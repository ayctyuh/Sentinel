from typing import Any, Optional, List, Dict, Tuple, Callable, Union

r"""Defines the interface between the kernel and the UI.

It contains:
* the UI dispatcher notification codes (ui_notification_t)
* convenience functions for UI services
* structures which hold information about the lines (disassembly, structures, enums) generated by the kernel
* functions to interact with the user (dialog boxes)
* some string and conversion functions. 


    
"""

class Choose:
    r"""
    Chooser wrapper class.
    
    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    
    """
    ALL_CHANGED: int  # 1
    ALREADY_EXISTS: int  # -3
    CHCOL_DEC: int  # 196608
    CHCOL_DEFHIDDEN: int  # 1048576
    CHCOL_DRAGHINT: int  # 2097152
    CHCOL_EA: int  # 262144
    CHCOL_FNAME: int  # 327680
    CHCOL_FORMAT: int  # 458752
    CHCOL_HEX: int  # 131072
    CHCOL_INODENAME: int  # 4194304
    CHCOL_PATH: int  # 65536
    CHCOL_PLAIN: int  # 0
    CH_ATTRS: int  # 32
    CH_BUILTIN_MASK: int  # 33030144
    CH_BUILTIN_SHIFT: int  # 19
    CH_CAN_DEL: int  # 512
    CH_CAN_EDIT: int  # 1024
    CH_CAN_INS: int  # 256
    CH_CAN_REFRESH: int  # 2048
    CH_FORCE_DEFAULT: int  # 128
    CH_HAS_DIFF: int  # 268435456
    CH_HAS_DIRTREE: int  # 33554432
    CH_MODAL: int  # 1
    CH_MULTI: int  # 4
    CH_NOBTNS: int  # 16
    CH_NOIDB: int  # 64
    CH_NO_STATUS_BAR: int  # 65536
    CH_QFLT: int  # 4096
    CH_QFTYP_DEFAULT: int  # 0
    CH_QFTYP_FUZZY: int  # 32768
    CH_QFTYP_MASK: int  # 57344
    CH_QFTYP_NORMAL: int  # 8192
    CH_QFTYP_REGEX: int  # 24576
    CH_QFTYP_SHIFT: int  # 13
    CH_QFTYP_WHOLE_WORDS: int  # 16384
    CH_RENAME_IS_EDIT: int  # 262144
    CH_RESTORE: int  # 131072
    EMPTY_CHOOSER: int  # -2
    NOTHING_CHANGED: int  # 0
    NO_ATTR: int  # -4
    NO_SELECTION: int  # -1
    SELECTION_CHANGED: int  # 2
    def Activate(self) -> Any:
        r"""Activates a visible chooser"""
        ...
    def AddCommand(self, caption: Any, flags: Any = 4, menu_index: Any = -1, icon: Any = -1, emb: Any = None, shortcut: Any = None) -> Any:
        ...
    def Close(self) -> Any:
        r"""Closes the chooser"""
        ...
    def Embedded(self, create_chobj: Any = False) -> Any:
        r"""
        Creates an embedded chooser (as opposed to Show())
        :returns: Returns 0 on success or NO_ATTR
        
        """
        ...
    def GetEmbSelection(self) -> Any:
        r"""
        Deprecated. For embedded choosers, the selection is
        available through 'Form.EmbeddedChooserControl.selection'
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def OnClose(self) -> Any:
        r"""
        The chooser window is closed.
        
        """
        ...
    def OnDeleteLine(self, sel: Any) -> Any:
        r"""
        User deleted an element
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnEditLine(self, sel: Any) -> Any:
        r"""
        User asked to edit an element.
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnGetDirTree(self) -> Any:
        r"""
        Get the dirtree_t that will be used to present a tree-like
        structure to the user (see CH_HAS_DIRTREE)
        
        :returns: the dirtree_t, or None
        
        """
        ...
    def OnGetEA(self, n: Any) -> Any:
        r"""
        Get the address of an element
        
        When this function returns valid addresses:
          * If any column has the `CHCOL_FNAME` flag, rows will
            be colored according to the attributes of the functions
            who own those addresses (extern, library function,
            Lumina, ... - similar to what the "Functions" widget does)
          * When a selection is present and the user presses `<Enter>`
            (`<Shift+Enter>` if the chooser is modal), IDA will jump
            to that address (through jumpto())
        :param n: element number (0-based)
        :returns: the effective address, ida_idaapi.BADADDR if the element has no address
        
        """
        ...
    def OnGetIcon(self, n: Any) -> Any:
        r"""
        Get an icon to associate with the first cell of an element
        
        :param n: index of the element
        :returns: an icon ID
        
        """
        ...
    def OnGetLine(self, n: Any) -> Any:
        r"""
        Get data for an element
        
        This callback is mandatory
        
        :param n: the index to fetch data for
        :returns: a list of strings
        
        """
        ...
    def OnGetLineAttr(self, n: Any) -> Any:
        r"""
        Get attributes for an element
        
        :param n: index of the element
        :returns: a tuple (color, flags)
        
        """
        ...
    def OnGetSize(self) -> Any:
        r"""
        Get the number of elements in the chooser.
        
        This callback is mandatory
        
        :returns: the number of elements
        
        """
        ...
    def OnIndexToDiffpos(self, n: Any) -> Any:
        r"""
        Map an element index to a diffpos_t
        
        This callback is mandatory if CH_HAS_DIFF is specified
        
        :param n: index of the element
        :returns: the diffpos
        
        """
        ...
    def OnIndexToInode(self, n: Any) -> Any:
        r"""
        Map an element index to a dirtree_t inode
        
        This callback is mandatory if CH_HAS_DIRTREE is specified
        
        :param n: index of the element
        :returns: the inode number
        
        """
        ...
    def OnInit(self) -> Any:
        r"""
        Initialize the chooser and populate it.
        
        This callback is optional
        
        """
        ...
    def OnInsertLine(self, sel: Any) -> Any:
        r"""
        User asked to insert an element
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnLazyLoadDir(self, path: Any) -> Any:
        r"""
        Callback for lazy-loaded, dirtree-based choosers;
        the function will be called when a folder is expanded and it has
        not been loaded before. The implementation should use the
        given dirtree's link() or mkdir() methods to add the folder contents.
        
        :param path: an absolute dirtree path to the directory that is being expanded
        :returns: success
        
        """
        ...
    def OnPopup(self, widget: Any, popup_handle: Any) -> Any:
        ...
    def OnRefresh(self, sel: Any) -> Any:
        r"""
        The chooser needs to be refreshed.
        It returns the new positions of the selected items.
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnSelectLine(self, sel: Any) -> Any:
        r"""
        User pressed the enter key, or double-clicked a selection
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnSelectionChange(self, sel: Any) -> Any:
        r"""
        Selection changed
        
        :param sel: the new selection
        
        """
        ...
    def Refresh(self) -> Any:
        r"""Causes the refresh callback to trigger"""
        ...
    def Show(self, modal: Any = False) -> Any:
        r"""
        Activates or creates a chooser window
        :param modal: Display as modal dialog
        :returns: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any, cols: Any, flags: Any = 0, popup_names: Any = None, icon: Any = -1, x1: Any = -1, y1: Any = -1, x2: Any = -1, y2: Any = -1, deflt: Any = None, embedded: Any = False, width: Any = None, height: Any = None, forbidden_cb: Any = 0, flags2: Any = 0) -> Any:
        r"""
        Constructs a chooser window.
        :param title: The chooser title
        :param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        :param flags: One of CH_XXXX constants
        :param flags2: One of CH2_XXXX constants
        :param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        :param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        :param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        :param x1: The default location (for txt-version)
        :param y1: The default location (for txt-version)
        :param x2: The default location (for txt-version)
        :param y2: The default location (for txt-version)
        :param embedded: Create as embedded chooser
        :param width: Embedded chooser width
        :param height: Embedded chooser height
        :param forbidden_cb: Explicitly forbidden callbacks
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust_last_item(self, n: Any) -> Any:
        r"""
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        :param n: line number of the remaining select item
        :returns: list of selected lines numbers (one element or empty)
        
        """
        ...

class CustomIDAMemo(View_Hooks):
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class Form:
    FT_ADDR: str  # $
    FT_ASCII: str  # A
    FT_BIN: str  # Y
    FT_BUTTON: str  # B
    FT_CHAR: str  # H
    FT_CHKGRP: str  # C
    FT_CHKGRP2: str  # c
    FT_COLOR: str  # K
    FT_DEC: str  # D
    FT_DIR: str  # F
    FT_DROPDOWN_LIST: str  # b
    FT_ECHOOSER: str  # E
    FT_FILE: str  # f
    FT_FORMCHG: str  # %/
    FT_HEX: str  # N
    FT_HTML_LABEL: str  # h
    FT_IDENT: str  # I
    FT_INT64: str  # l
    FT_MULTI_LINE_TEXT: str  # t
    FT_OCT: str  # O
    FT_RADGRP: str  # R
    FT_RADGRP2: str  # r
    FT_RAWHEX: str  # M
    FT_SEG: str  # S
    FT_SHEX: str  # n
    FT_TYPE: str  # T
    FT_UINT64: str  # L
    def Add(self, name: Any, ctrl: Any, mkattr: Any = True) -> Any:
        r"""
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.
        
        :param name: Control name
        :param ctrl: Control object
        :param mkattr: Create control name / control object as a form attribute
        
        """
        ...
    def AddControls(self, controls: Any, mkattr: Any = True) -> Any:
        r"""
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        :param controls: The control dictionary
        
        """
        ...
    def ButtonInput(self, handler: Any, code: Any = '', swidth: Any = '', hlp: Any = None) -> Any:
        r"""
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        
        """
        ...
    def ChkGroupControl(self, children_names: Any, value: Any = 0, secondary: Any = False) -> Any:
        r"""
        Checkbox group control class.
        It holds a set of checkbox controls
        
        """
        ...
    def ChkGroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Checkbox group item control
        
        """
        ...
    def Close(self, close_normally: Any) -> Any:
        r"""
        Close the form
        :param close_normally: 1: form is closed normally as if the user pressed Enter. 0: form is closed abnormally as if the user pressed Esc
        :returns: None
        
        """
        ...
    def ColorInput(self, value: Any = 0) -> Any:
        r"""
        Color button input control
        
        """
        ...
    def Compile(self) -> Any:
        r"""
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements
        
        :returns: It will raise an exception on failure. Otherwise the return value is ignored
        
        """
        ...
    def CompileEx(self, form: Any) -> Any:
        r"""
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().
        
        The form controls are wrapped inside curly braces: {ControlName}.
        
        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
        
        :param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        
        """
        ...
    def Compiled(self) -> Any:
        r"""
        Checks if the form has already been compiled
        
        :returns: Boolean
        
        """
        ...
    def Control(self) -> Any:
        ...
    def ControlToFieldTypeIdAndSize(self, ctrl: Any) -> Any:
        r"""
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        
        """
        ...
    def DirInput(self, width: Any = 512, swidth: Any = 80, hlp: Any = None, value: Any = None) -> Any:
        r"""
        Directory browsing control
        
        """
        ...
    def DropdownListControl(self, items: Any = ..., readonly: Any = True, selval: Any = 0, width: Any = 50, swidth: Any = 50, hlp: Any = None) -> Any:
        r"""
        Dropdown control
        This control allows manipulating a dropdown control
        
        """
        ...
    def EmbeddedChooserControl(self, chooser: Any = None, swidth: Any = 40, hlp: Any = None) -> Any:
        r"""
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        
        """
        ...
    def EnableField(self, ctrl: Any, enable: Any) -> Any:
        r"""
        Enable or disable an input field
        :returns: False - no such control
        
        """
        ...
    def Execute(self) -> Any:
        r"""
        Displays a modal dialog containing the compiled form.
        :returns: 1 - ok ; 0 - cancel
        
        """
        ...
    def FileInput(self, width: Any = 512, swidth: Any = 80, save: Any = False, open: Any = False, hlp: Any = None, value: Any = None) -> Any:
        r"""
        File Open/Save input control
        
        """
        ...
    def FindControlById(self, id: Any) -> Any:
        r"""
        Finds a control instance given its id
        
        """
        ...
    def FormChangeCb(self, handler: Any) -> Any:
        r"""
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...
        
        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
        
        
        """
        ...
    def Free(self) -> Any:
        r"""
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        
        """
        ...
    def GetControlValue(self, ctrl: Any) -> Any:
        r"""
        Returns the control's value depending on its type
        :param ctrl: Form control instance
        :returns: color button, radio controls: integer
        :returns: file/dir input, string input and string label: string
        :returns: embedded chooser control (0-based indices of selected items): integer list
        :returns: for multilinetext control: textctrl_info_t
        :returns: dropdown list controls: string (when editable) or index (when readonly)
        :returns: None: on failure
        
        """
        ...
    def GetFocusedField(self) -> Any:
        r"""
        Get currently focused input field.
        :returns: None if no field is selected otherwise the control ID
        
        """
        ...
    def GroupControl(self, children_names: Any, tag: Any, value: Any = 0) -> Any:
        r"""
        Base class for group controls
        
        """
        ...
    def GroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Base class for group control items
        
        """
        ...
    def InputControl(self, tp: Any, width: Any, swidth: Any, hlp: Any = None, is_relative_offset: Any = False) -> Any:
        r"""
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        
        """
        ...
    def LabelControl(self, tp: Any) -> Any:
        r"""
        Base class for static label control
        
        """
        ...
    def MoveField(self, ctrl: Any, x: Any, y: Any, w: Any, h: Any) -> Any:
        r"""
        Move/resize an input field
        
        :returns: False - no such fiel
        
        """
        ...
    def MultiLineTextControl(self, text: Any = '', flags: Any = 0, tabsize: Any = 0, width: Any = 50, swidth: Any = 50, hlp: Any = None) -> Any:
        r"""
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        
        """
        ...
    def NumericArgument(self, tp: Any, value: Any, i64: Any = None) -> Any:
        r"""
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        :param tp: One of Form.FT_XXX
        
        """
        ...
    def NumericInput(self, tp: Any = None, value: Any = 0, width: Any = 50, swidth: Any = 10, hlp: Any = None, is_relative_offset: Any = False, i64: Any = None) -> Any:
        r"""
        A composite class serving as a base numeric input control class
        
        """
        ...
    def NumericLabel(self, value: Any, tp: Any = None) -> Any:
        r"""
        Numeric label control
        
        """
        ...
    def Open(self) -> Any:
        r"""
        Opens a widget containing the compiled form.
        
        """
        ...
    def RadGroupControl(self, children_names: Any, value: Any = 0, secondary: Any = False) -> Any:
        r"""
        Radiobox group control class.
        It holds a set of radiobox controls
        
        """
        ...
    def RadGroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Radiobox group item control
        
        """
        ...
    def RefreshField(self, ctrl: Any) -> Any:
        r"""
        Refresh a field
        :returns: False - no such control
        
        """
        ...
    def SetControlValue(self, ctrl: Any, value: Any) -> Any:
        r"""
        Set the control's value depending on its type
        :param ctrl: Form control instance
        :param value: embedded chooser: a 0-base indices list to select embedded chooser items
        :param value: multilinetext: a textctrl_info_t
        :param value: dropdown list: an integer designating the selection index if readonly
                                     a string designating the edit control value if not readonly
        :returns: Boolean true on success
        
        """
        ...
    def SetFocusedField(self, ctrl: Any) -> Any:
        r"""
        Set currently focused input field
        :returns: False - no such control
        
        """
        ...
    def ShowField(self, ctrl: Any, show: Any) -> Any:
        r"""
        Show or hide an input field
        :returns: False - no such control
        
        """
        ...
    def StringArgument(self, size: Any = None, value: Any = None) -> Any:
        r"""
        Argument representing a character buffer
        
        """
        ...
    def StringInput(self, tp: Any = None, width: Any = 1024, swidth: Any = 40, hlp: Any = None, value: Any = None, size: Any = None) -> Any:
        r"""
        Base string input control class.
        This class also constructs a StringArgument
        
        """
        ...
    def StringLabel(self, value: Any, tp: Any = None, size: Any = 1024) -> Any:
        r"""
        String label control
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, name: Any) -> Any:
        r"""Returns a control object by name"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, form: Any, controls: Any) -> Any:
        r"""
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).
        
        :param form: The form string
        :param controls: A dictionary containing the control name as a _key_ and control object as _value_
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def create_string_buffer(self, value: Any, size: Any = None) -> Any:
        ...
    def fieldtype_to_ctype(self, tp: Any, i64: Any = False) -> Any:
        r"""
        Factory method returning a ctype class corresponding to the field type string
        
        """
        ...

class IDAViewWrapper(CustomIDAMemo, View_Hooks):
    r"""
    Deprecated. Use View_Hooks instead.
    
    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    
    """
    def Bind(self) -> Any:
        ...
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def Unbind(self) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class PluginForm:
    r"""
    PluginForm class.
    
    This form can be used to host additional controls. Please check the PyQt example.
    
    """
    VALID_CAPSULE_NAME: bytes  # b'$valid$'
    WCLS_CLOSE_LATER: int  # 8
    WCLS_DELETE_LATER: int  # 8
    WCLS_DONT_SAVE_SIZE: int  # 4
    WCLS_NO_CONTEXT: int  # 2
    WCLS_SAVE: int  # 1
    WOPN_CENTERED: int  # 32
    WOPN_CREATE_ONLY: dict  # {}
    WOPN_DP_BEFORE: int  # 2097152
    WOPN_DP_BOTTOM: int  # 524288
    WOPN_DP_FLOATING: int  # 8388608
    WOPN_DP_INSIDE: int  # 1048576
    WOPN_DP_INSIDE_BEFORE: int  # 3145728
    WOPN_DP_LEFT: int  # 65536
    WOPN_DP_RIGHT: int  # 262144
    WOPN_DP_SZHINT: int  # 16777216
    WOPN_DP_TAB: int  # 4194304
    WOPN_DP_TAB_BEFORE: int  # 6291456
    WOPN_DP_TOP: int  # 131072
    WOPN_MDI: int  # 1
    WOPN_MENU: int  # 16
    WOPN_ONTOP: int  # 8
    WOPN_PERSIST: int  # 64
    WOPN_RESTORE: int  # 4
    WOPN_TAB: int  # 2
    def Close(self, options: Any) -> Any:
        r"""
        Closes the form.
        
        :param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
        
        :returns: None
        
        """
        ...
    def FormToPyQtWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def FormToPySideWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Use this method to convert a TWidget* to a QWidget to be used by PySide
        
        :param ctx: Context. Reference to a module that already imported QtWidgets module
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def OnClose(self, form: Any) -> Any:
        r"""
        Called when the plugin form is closed
        
        :returns: None
        
        """
        ...
    def OnCreate(self, form: Any) -> Any:
        r"""
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.
        
        :returns: None
        
        """
        ...
    def QtWidgetToTWidget(self, w: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a QWidget to a TWidget* to be used by IDA
        
        :param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        
        """
        ...
    def Show(self, caption: Any, options: Any = 0) -> Any:
        r"""
        Creates the form if not was not created or brings to front if it was already created
        
        :param caption: The form caption
        :param options: One of PluginForm.WOPN_ constants
        
        """
        ...
    def TWidgetToPyQtWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def TWidgetToPySideWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Use this method to convert a TWidget* to a QWidget to be used by PySide
        
        :param ctx: Context. Reference to a module that already imported QtWidgets module
        
        """
        ...
    def TWidgetToQtPythonWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        r"""
                
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class UI_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __real_database_closed(self) -> None:
        r"""The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
                  
        :returns: void
        """
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def create_desktop_widget(self, title: str, cfg: jobj_wrapper_t) -> Any:
        r"""create a widget, to be placed in the widget tree (at desktop-creation time.) 
                  
        :param title: (const char *)
        :param cfg: (const jobj_t *)
        :returns: TWidget * the created widget, or null
        """
        ...
    def current_widget_changed(self, widget: TWidget, prev_widget: TWidget) -> None:
        r"""The currently-active TWidget changed. 
                  
        :param widget: (TWidget *)
        :param prev_widget: (TWidget *)
        :returns: void
        """
        ...
    def database_closed(self, args: Any) -> Any:
        r"""The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
                  
        :returns: void
        """
        ...
    def database_inited(self, is_new_database: int, idc_script: str) -> None:
        r"""database initialization has completed. the kernel is about to run idc scripts 
                  
        :param is_new_database: (int)
        :param idc_script: (const char *) - may be nullptr
        :returns: void See also ui_initing_database. This event is called for both new and old databases.
        """
        ...
    def debugger_menu_change(self, enable: bool) -> None:
        r"""debugger menu modification detected 
                  
        :param enable: (bool) true: debugger menu has been added, or a different debugger has been selected false: debugger menu will be removed (user switched to "No debugger")
        :returns: void
        """
        ...
    def desktop_applied(self, name: str, from_idb: bool, type: int) -> None:
        r"""a desktop has been applied 
                  
        :param name: (const char *) the desktop name
        :param from_idb: (bool) the desktop was stored in the IDB (false if it comes from the registry)
        :param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)
        """
        ...
    def destroying_plugmod(self, plugmod: plugmod_t, entry: plugin_t) -> None:
        r"""The plugin object is about to be destroyed 
                  
        :param plugmod: (const plugmod_t *)
        :param entry: (const plugin_t *)
        """
        ...
    def destroying_procmod(self, procmod: procmod_t) -> None:
        r"""The processor module is about to be destroyed 
                  
        :param procmod: (const procmod_t *)
        """
        ...
    def finish_populating_widget_popup(self, widget: TWidget, popup_handle: TPopupMenu, ctx: action_ctx_base_t = None) -> None:
        r"""IDA is about to be done populating the context menu for a widget. This is your chance to attach_action_to_popup().
        
        :param widget: (TWidget *)
        :param popup_handle: (TPopupMenu *)
        :param ctx: (const action_activation_ctx_t *)
        :returns: void
        """
        ...
    def get_chooser_item_attrs(self, chooser: chooser_base_t, n: size_t, attrs: chooser_item_attrs_t) -> None:
        r"""get item-specific attributes for a chooser. This callback is generated only after enable_chooser_attrs() 
                  
        :param chooser: (const chooser_base_t *)
        :param n: (::size_t)
        :param attrs: (chooser_item_attrs_t *)
        :returns: void
        """
        ...
    def get_custom_viewer_hint(self, viewer: TWidget, place: place_t) -> Any:
        r"""ui wants to display a hint for a viewer (idaview or custom). Every subscriber is supposed to append the hint lines to HINT and increment IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT is possible but not recommended. If the REG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the source-level debugger-generated hints. The following keywords might appear at the beginning of the returned hints: HIGHLIGHT text
         where text will be highlighted CAPTION caption
         caption for the hint widget 
                  
        :param viewer: (TWidget*) viewer
        :param place: (place_t *) current position in the viewer
        :returns: 0: continue collecting hints with other subscribers
        :returns: 1: stop collecting hints
        """
        ...
    def get_ea_hint(self, ea: ida_idaapi.ea_t) -> Any:
        r"""ui wants to display a simple hint for an address. Use this event to generate a custom hint See also more generic ui_get_item_hint 
                  
        :param ea: (::ea_t)
        :returns: true if generated a hint
        """
        ...
    def get_item_hint(self, ea: ida_idaapi.ea_t, max_lines: int) -> Any:
        r"""ui wants to display multiline hint for an item. See also more generic ui_get_custom_viewer_hint 
                  
        :param ea: (ea_t) or item id like a structure or enum member
        :param max_lines: (int) maximal number of lines
        :returns: true if generated a hint
        """
        ...
    def get_lines_rendering_info(self, out: lines_rendering_output_t, widget: TWidget, info: lines_rendering_input_t) -> None:
        r"""get lines rendering information 
                  
        :param out: (lines_rendering_output_t *)
        :param widget: (const TWidget *)
        :param info: (const lines_rendering_input_t *)
        :returns: void
        """
        ...
    def get_widget_config(self, widget: TWidget, cfg: jobj_t) -> Any:
        r"""retrieve the widget configuration (it will be passed back at ui_create_desktop_widget-, and ui_set_widget_config-time) 
                  
        :param widget: (const TWidget *)
        :param cfg: (jobj_t *)
        :returns: void
        """
        ...
    def hook(self) -> bool:
        ...
    def idcstart(self) -> None:
        r"""Start of IDC engine work. 
                  
        :returns: void
        """
        ...
    def idcstop(self) -> None:
        r"""Stop of IDC engine work. 
                  
        :returns: void
        """
        ...
    def initing_database(self) -> None:
        r"""database initialization has started. 
                  
        :returns: void See also ui_database_inited. This event is called for both new and old databases.
        """
        ...
    def plugin_loaded(self, plugin_info: plugin_info_t) -> None:
        r"""The plugin was loaded in memory. 
                  
        :param plugin_info: (const plugin_info_t *)
        """
        ...
    def plugin_unloading(self, plugin_info: plugin_info_t) -> None:
        r"""The plugin is about to be unloaded 
                  
        :param plugin_info: (const plugin_info_t *)
        """
        ...
    def populating_widget_popup(self, widget: TWidget, popup_handle: TPopupMenu, ctx: action_ctx_base_t = None) -> None:
        r"""IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
        Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)
        
        :param widget: (TWidget *)
        :param popup_handle: (TPopupMenu *)
        :param ctx: (const action_activation_ctx_t *)
        :returns: void
        """
        ...
    def postprocess_action(self) -> None:
        r"""an ida ui action has been handled
        
        """
        ...
    def preprocess_action(self, name: str) -> int:
        r"""ida ui is about to handle a user action. 
                  
        :param name: (const char *) ui action name. these names can be looked up in ida[tg]ui.cfg
        :returns: 0: ok
        :returns: nonzero: a plugin has handled the command
        """
        ...
    def range(self) -> None:
        r"""The disassembly range has been changed ( idainfo::min_ea ... idainfo::max_ea). UI should redraw the scrollbars. See also: ui_lock_range_refresh 
                  
        :returns: void
        """
        ...
    def ready_to_run(self) -> None:
        r"""all UI elements have been initialized. Automatic plugins may hook to this event to perform their tasks. 
                  
        :returns: void
        """
        ...
    def resume(self) -> None:
        r"""Resume the suspended graphical interface. Only the text version. Interface should respond to it 
                  
        :returns: void
        """
        ...
    def saved(self, path: str) -> None:
        r"""The kernel has saved the database. This callback just informs the interface. Note that at the time this notification is sent, the internal paths are not updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path. 
                  
        :param path: (const char *) the database path
        :returns: void
        """
        ...
    def saving(self) -> None:
        r"""The kernel is flushing its buffers to the disk. The user interface should save its state. Parameters: none Returns: none 
                  
        """
        ...
    def screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None:
        r"""The "current address" changed 
                  
        :param ea: (ea_t)
        :param prev_ea: (ea_t)
        :returns: void
        """
        ...
    def set_widget_config(self, widget: TWidget, cfg: jobj_wrapper_t) -> None:
        r"""set the widget configuration 
                  
        :param widget: (const TWidget *)
        :param cfg: (const jobj_t *)
        :returns: void
        """
        ...
    def suspend(self) -> None:
        r"""Suspend graphical interface. Only the text version. Interface should respond to it. 
                  
        :returns: void
        """
        ...
    def unhook(self) -> bool:
        ...
    def updated_actions(self) -> None:
        r"""IDA is done updating actions. 
                  
        :returns: void
        """
        ...
    def updating_actions(self, ctx: action_ctx_base_t) -> None:
        r"""IDA is about to update all actions. If your plugin needs to perform expensive operations more than once (e.g., once per action it registers), you should do them only once, right away. 
                  
        :param ctx: (action_update_ctx_t *)
        :returns: void
        """
        ...
    def widget_closing(self, widget: TWidget) -> None:
        r"""TWidget is about to close. This event precedes ui_widget_invisible. Use this to perform some possible actions relevant to the lifecycle of this widget 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...
    def widget_invisible(self, widget: TWidget) -> None:
        r"""TWidget is being closed. Use this event to destroy the window controls 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...
    def widget_visible(self, widget: TWidget) -> None:
        r"""TWidget is displayed on the screen. Use this event to populate the window with controls 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...

class View_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: TWidget) -> None:
        r"""A view is activated 
                  
        :param view: (TWidget *)
        """
        ...
    def view_click(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""Click event 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_close(self, view: TWidget) -> None:
        r"""View closed 
                  
        :param view: (TWidget *)
        """
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: TWidget) -> None:
        r"""Cursor position changed 
                  
        :param view: (TWidget *)
        """
        ...
    def view_dblclick(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""Double click event 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_deactivated(self, view: TWidget) -> None:
        r"""A view is deactivated 
                  
        :param view: (TWidget *)
        """
        ...
    def view_keydown(self, view: TWidget, key: int, state: view_event_state_t) -> None:
        r"""Key down event 
                  
        :param view: (TWidget *)
        :param key: (int)
        :param state: (::view_event_state_t)
        """
        ...
    def view_loc_changed(self, view: TWidget, now: lochist_entry_t, was: lochist_entry_t) -> None:
        r"""The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
                  
        :param view: (TWidget *)
        :param now: (const lochist_entry_t *)
        :param was: (const lochist_entry_t *)
        """
        ...
    def view_mouse_moved(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""The mouse moved on the view 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_mouse_over(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_switched(self, view: TWidget, rt: tcc_renderer_type_t) -> None:
        r"""A view's renderer has changed. 
                  
        :param view: (TWidget *)
        :param rt: (tcc_renderer_type_t)
        """
        ...

class action_ctx_base_cur_sel_t:
    @property
    def to(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reset(self) -> None:
        ...

class action_ctx_base_t:
    @property
    def action(self) -> Any: ...
    @property
    def chooser(self) -> Any: ...
    @property
    def chooser_selection(self) -> Any: ...
    @property
    def cur_ea(self) -> Any: ...
    @property
    def cur_extracted_ea(self) -> Any: ...
    @property
    def cur_fchunk(self) -> Any: ...
    @property
    def cur_flags(self) -> Any: ...
    @property
    def cur_func(self) -> Any: ...
    @property
    def cur_seg(self) -> Any: ...
    @property
    def cur_sel(self) -> Any: ...
    @property
    def cur_value(self) -> Any: ...
    @property
    def dirtree_selection(self) -> Any: ...
    @property
    def focus(self) -> Any: ...
    @property
    def form(self) -> Any: ...
    @property
    def form_title(self) -> Any: ...
    @property
    def form_type(self) -> Any: ...
    @property
    def graph(self) -> Any: ...
    @property
    def graph_selection(self) -> Any: ...
    @property
    def hovered(self) -> Any: ...
    @property
    def regname(self) -> Any: ...
    @property
    def type_ref(self) -> Any: ...
    @property
    def widget(self) -> Any: ...
    @property
    def widget_title(self) -> Any: ...
    @property
    def widget_type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def has_flag(self, flag: int) -> bool:
        r"""Check if the given flag is set.
        
        """
        ...
    def reset(self) -> None:
        r"""Invalidate all context info.
        
        """
        ...

class action_desc_t:
    @property
    def cb(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def owner(self) -> Any: ...
    @property
    def shortcut(self) -> Any: ...
    @property
    def tooltip(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, name: str, label: str, handler: Any, shortcut: str = None, tooltip: str = None, icon: int = -1, flags: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class action_handler_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def activate(self, ctx: Any) -> Any:
        r"""Activate an action. This function implements the core behavior of an action. It is called when the action is triggered, from a menu, from a popup menu, from the toolbar, or programmatically. 
                
        :returns: non-zero: all IDA windows will be refreshed
        """
        ...
    def update(self, ctx: Any) -> Any:
        r"""Update an action. This is called when the context of the UI changed, and we need to let the action update some of its properties if needed (label, icon, ...)
        In addition, this lets IDA know whether the action is enabled, and when it should be queried for availability again.
        Note: This callback is not meant to change anything in the application's state, except by calling one (or many) of the "update_action_*()" functions on this very action. 
                
        """
        ...

class addon_info_t:
    @property
    def cb(self) -> Any: ...
    @property
    def custom_data(self) -> Any: ...
    @property
    def custom_size(self) -> Any: ...
    @property
    def freeform(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def producer(self) -> Any: ...
    @property
    def url(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class chooser_base_t:
    NSTDPOPUPS: int  # 4
    POPUP_DEL: int  # 1
    POPUP_EDIT: int  # 2
    POPUP_INS: int  # 0
    POPUP_REFRESH: int  # 3
    @property
    def columns(self) -> Any: ...
    @property
    def deflt_col(self) -> Any: ...
    @property
    def header(self) -> Any: ...
    @property
    def height(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def popup_names(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    @property
    def widths(self) -> Any: ...
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    @property
    def y0(self) -> Any: ...
    @property
    def y1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def ask_item_attrs(self) -> bool:
        r"""should chooser generate ui_get_chooser_item_attrs events?
        
        """
        ...
    def can_del(self) -> bool:
        ...
    def can_edit(self) -> bool:
        ...
    def can_filter(self) -> bool:
        ...
    def can_ins(self) -> bool:
        r"""is an operation allowed?
        
        """
        ...
    def can_refresh(self) -> bool:
        ...
    def can_sort(self) -> bool:
        ...
    def get_builtin_number(self) -> uint:
        r"""get number of the built-in chooser
        
        """
        ...
    def get_count(self) -> int:
        r"""get the number of elements in the chooser
        
        """
        ...
    def get_ea(self, arg2: size_t) -> ida_idaapi.ea_t:
        r"""get the address of an element. When this function returns valid addresses: * If any column has the `CHCOL_FNAME` flag, rows will be colored according to the attributes of the functions who own those addresses (extern, library function, Lumina, ... - similar to what the "Functions" widget does) * When a selection is present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is modal), IDA will jump to that address (through jumpto()) 
                
        :returns: the effective address, BADADDR if the element has no address
        """
        ...
    def get_quick_filter_initial_mode(self) -> int:
        ...
    def get_row(self, n: int) -> Any:
        r"""Get data & attributes for a row in a chooser.
        
        :param n: The row number
        :returns: a tuple (list-of-strings, icon-id, row-attributes)
        """
        ...
    def has_diff_capability(self) -> bool:
        ...
    def has_dirtree(self) -> bool:
        ...
    def has_inode_to_index(self) -> bool:
        ...
    def has_widget_lifecycle(self) -> bool:
        r"""should chooser object be deleted when the widget gets destroyed?
        
        """
        ...
    def is_dirtree_persisted(self) -> bool:
        ...
    def is_force_default(self) -> bool:
        r"""should selection of the already opened non-modal chooser be changed?
        
        """
        ...
    def is_lazy_loaded(self) -> bool:
        ...
    def is_modal(self) -> bool:
        r"""is choose modal?
        
        """
        ...
    def is_multi(self) -> bool:
        r"""is multi-selection allowed?
        
        """
        ...
    def is_quick_filter_visible_initially(self) -> bool:
        ...
    def is_same(self, other: chooser_base_t) -> bool:
        r"""do the current and the given objects hold the same data?
        
        """
        ...
    def is_status_bar_hidden(self) -> bool:
        ...
    def popup_allowed(self, stdact_idx: int) -> bool:
        r"""is a standard action allowed?
        
        """
        ...
    def should_rename_trigger_edit(self) -> bool:
        ...
    def should_restore_geometry(self) -> bool:
        ...

class chooser_item_attrs_t:
    @property
    def color(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, other: chooser_item_attrs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reset(self) -> None:
        ...

class chooser_row_info_t:
    @property
    def attrs(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def texts(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, other: chooser_row_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, other: chooser_row_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class chooser_row_info_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: chooser_row_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> chooser_row_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: chooser_row_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: chooser_row_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: chooser_row_info_t) -> bool:
        ...
    def append(self, x: chooser_row_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> chooser_row_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: chooser_row_info_vec_t) -> None:
        ...
    def extract(self) -> chooser_row_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: chooser_row_info_t) -> bool:
        ...
    def inject(self, s: chooser_row_info_t, len: size_t) -> None:
        ...
    def insert(self, it: chooser_row_info_t, x: chooser_row_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> chooser_row_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: chooser_row_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class chooser_stdact_desc_t:
    @property
    def icon(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def tooltip(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _label: str = None, _tooltip: str = None, _icon: int = -1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def ucb(self, arg0: action_ctx_base_t) -> action_state_t:
        r"""the update callback, see action_handler_t::update() When the update callback is called from the chooser UI engine, it can be sure that ctx.source.chooser is a valid pointer to chooser_base_t and that there are selected items for the Delete and Edit actions. 
                
        """
        ...

class cli_t:
    r"""
    cli_t wrapper class.
    
    This class allows you to implement your own command line interface handlers.
    
    """
    def OnExecuteLine(self, line: Any) -> Any:
        r"""
        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
        
        This callback is mandatory.
        
        :param line: typed line(s)
        :returns: Boolean: True-executed line, False-ask for more lines
        
        """
        ...
    def OnFindCompletions(self, line: Any, x: Any) -> Any:
        r"""
        The user pressed Tab. Return a list of completions
        
        This callback is optional.
        
        :param line: the current line (string)
        :param x: the index where the cursor is (int)
        
        :returns: None if no completion could be generated, otherwise a tuple:
            (completions : Sequence[str], hints : Sequence[str], docs: Sequence[str],
              match_start: int, match_end: int)
        
        """
        ...
    def OnKeydown(self, line: Any, x: Any, sellen: Any, vkey: Any, shift: Any) -> Any:
        r"""
        A keyboard key has been pressed
        This is a generic callback and the CLI is free to do whatever it wants.
        
        This callback is optional.
        
        :param line: current input line
        :param x: current x coordinate of the cursor
        :param sellen: current selection length (usually 0)
        :param vkey: virtual key code. if the key has been handled, it should be returned as zero
        :param shift: shift state
        
        :returns: None - Nothing was changed
        :returns: tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
        :returns: It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
        
        """
        ...
    def __del__(self) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def register(self, flags: Any = 0, sname: Any = None, lname: Any = None, hint: Any = None) -> Any:
        r"""
        Registers the CLI.
        
        :param flags: Feature bits. No bits are defined yet, must be 0
        :param sname: Short name (displayed on the button)
        :param lname: Long name (displayed in the menu)
        :param hint:  Hint for the input line
        
        :returns: Boolean: True-Success, False-Failed
        
        """
        ...
    def unregister(self) -> Any:
        r"""
        Unregisters the CLI (if it was registered)
        
        """
        ...

class disabled_script_timeout_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __enter__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __exit__(self, type: Any, value: Any, tb: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class disasm_line_t:
    @property
    def at(self) -> Any: ...
    @property
    def bg_color(self) -> Any: ...
    @property
    def is_default(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def prefix_color(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class disasm_text_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> disasm_line_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: disasm_line_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: disasm_line_t) -> None:
        ...
    def at(self, _idx: size_t) -> disasm_line_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: disasm_text_t) -> None:
        ...
    def extract(self) -> disasm_line_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: disasm_line_t, len: size_t) -> None:
        ...
    def insert(self, it: disasm_line_t, x: disasm_line_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> disasm_line_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: disasm_text_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class idaplace_t(place_t):
    @property
    def ea(self) -> Any: ...
    @property
    def lnnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class input_event_keyboard_data_t:
    @property
    def key(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_mouse_data_t:
    @property
    def button(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_shortcut_data_t:
    @property
    def action_name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_t:
    @property
    def cb(self) -> Any: ...
    @property
    def keyboard(self) -> Any: ...
    @property
    def kind(self) -> Any: ...
    @property
    def modifiers(self) -> Any: ...
    @property
    def mouse(self) -> Any: ...
    @property
    def shortcut(self) -> Any: ...
    @property
    def source(self) -> Any: ...
    @property
    def target(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_source_QEvent(self) -> Any:
        ...
    def get_target_QWidget(self) -> Any:
        ...

class jobj_wrapper_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def get_dict(self) -> dict:
        r"""Retrieve the contents of this object, as a dict
        
        :returns: a dict containing all kvp's in this object
        """
        ...

class line_rendering_output_entries_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_rendering_output_entries_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_rendering_output_entries_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: line_rendering_output_entry_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: line_rendering_output_entry_t) -> bool:
        ...
    def append(self, x: line_rendering_output_entry_t) -> None:
        ...
    def at(self, _idx: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: line_rendering_output_entries_refs_t) -> None:
        ...
    def extract(self) -> line_rendering_output_entry_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: line_rendering_output_entry_t) -> bool:
        ...
    def inject(self, s: line_rendering_output_entry_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: line_rendering_output_entry_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, e: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: line_rendering_output_entries_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class line_rendering_output_entry_t:
    @property
    def bg_color(self) -> Any: ...
    @property
    def cpx(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def nchars(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_rendering_output_entry_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_rendering_output_entry_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_bg_color_direct(self) -> bool:
        ...
    def is_bg_color_empty(self) -> bool:
        ...
    def is_bg_color_key(self) -> bool:
        ...

class line_section_t:
    @property
    def length(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_section_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_section_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: cpidx_t) -> bool:
        ...
    def is_closed(self) -> bool:
        ...
    def is_open(self) -> bool:
        ...
    def valid(self) -> bool:
        ...

class linearray_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _ud: void) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def beginning(self) -> bool:
        r"""Are we at the beginning?
        
        """
        ...
    def copy_from(self, src: linearray_t) -> None:
        r"""Copy information from one linearray to another. Only linearray objects with compatible 'ud' fields can be copied. 
                
        """
        ...
    def down(self) -> str:
        r"""Get the next line going downwards. 'at' for the retrieved line is correct BEFORE calling this function. 
                
        """
        ...
    def ending(self) -> bool:
        ...
    def get_bg_color(self) -> bgcolor_t:
        r"""Get current background color. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_dlnnum(self) -> int:
        r"""Get default line number. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_linecnt(self) -> int:
        r"""Get number of lines for the current place. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_pfx_color(self) -> bgcolor_t:
        r"""Get current prefix color. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_place(self) -> place_t:
        r"""Get the current place. If called before down(), then returns place of line which will be returned by down(). If called after up(), then returns place if line returned by up(). 
                
        """
        ...
    def set_max_lines(self, n: int) -> None:
        r"""Set max number of lines to generate for a place. 0 means to use the default value, MAX_ITEM_LINES from ida.cfg 
                
        """
        ...
    def set_place(self, new_at: place_t) -> int:
        r"""Position the array. This function must be called before calling any other member functions. 
                
        :param new_at: new position of the array. linearray will make a clone of this object.
        :returns: the delta of lines that the linearray_t had to adjust the place by. 
        For example, if the place_t has a lnnum of 5, but it turns out, upon generating lines, 
        that the number of lines for that particular place is only 2, then 3 will be returned.
        """
        ...
    def set_userdata(self, userd: void) -> None:
        r"""Change the user data.
        
        """
        ...
    def up(self) -> str:
        r"""Get the next line going upwards. 'at' for the retrieved line is correct AFTER calling this function. 
                
        """
        ...
    def userdata(self) -> None:
        r"""Get pointer to user data.
        
        """
        ...

class lines_rendering_input_t:
    @property
    def cb(self) -> Any: ...
    @property
    def sections_lines(self) -> Any: ...
    @property
    def sync_group(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lines_rendering_output_t:
    @property
    def entries(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lines_rendering_output_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: lines_rendering_output_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def swap(self, r: lines_rendering_output_t) -> None:
        ...

class listing_location_t:
    @property
    def cb(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    @property
    def tagged_sections(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class place_t:
    @property
    def lnnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class quick_widget_commands_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, callback: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def add(self, caption: Any, flags: Any, menu_index: Any, icon: Any, emb: Any, shortcut: Any) -> Any:
        ...
    def populate_popup(self, widget: Any, popup: Any) -> Any:
        ...

class renderer_pos_info_t:
    @property
    def cx(self) -> Any: ...
    @property
    def cy(self) -> Any: ...
    @property
    def node(self) -> Any: ...
    @property
    def sx(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: renderer_pos_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: renderer_pos_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class section_lines_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: section_lines_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: section_lines_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: twinline_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: twinline_t) -> bool:
        ...
    def append(self, x: twinline_t) -> None:
        ...
    def at(self, _idx: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: section_lines_refs_t) -> None:
        ...
    def extract(self) -> twinline_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: twinline_t) -> bool:
        ...
    def inject(self, s: twinline_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: twinline_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: section_lines_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class sections_lines_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sections_lines_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> section_lines_refs_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sections_lines_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: section_lines_refs_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: section_lines_refs_t) -> bool:
        ...
    def append(self, x: section_lines_refs_t) -> None:
        ...
    def at(self, _idx: size_t) -> section_lines_refs_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sections_lines_refs_t) -> None:
        ...
    def extract(self) -> section_lines_refs_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: section_lines_refs_t) -> bool:
        ...
    def inject(self, s: section_lines_refs_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: section_lines_refs_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> section_lines_refs_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sections_lines_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class simplecustviewer_t:
    r"""The base class for implementing simple custom viewers"""
    def AddLine(self, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Adds a colored line to the view
        :returns: Boolean
        
        """
        ...
    def ClearLines(self) -> Any:
        r"""Clears all the lines"""
        ...
    def Close(self) -> Any:
        r"""
        Destroys the view.
        One has to call Create() afterwards.
        Show() can be called and it will call Create() internally.
        :returns: Boolean
        
        """
        ...
    def Count(self) -> Any:
        r"""Returns the number of lines in the view"""
        ...
    def Create(self, title: Any) -> Any:
        r"""
        Creates the custom view. This should be the first method called after instantiation
        
        :param title: The title of the view
        :returns: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                 In this case better close existing windows
        
        """
        ...
    def DelLine(self, lineno: Any) -> Any:
        r"""
        Deletes an existing line
        :returns: Boolean
        
        """
        ...
    def EditLine(self, lineno: Any, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Edits an existing line.
        :returns: Boolean
        
        """
        ...
    def GetCurrentLine(self, mouse: Any = 0, notags: Any = 0) -> Any:
        r"""
        Returns the current line.
        :param mouse: Current line at mouse pos
        :param notags: If True then tag_remove() will be called before returning the line
        :returns: Returns the current line (colored or uncolored) or None on failure
        
        """
        ...
    def GetCurrentWord(self, mouse: Any = 0) -> Any:
        r"""
        Returns the current word
        :param mouse: Use mouse position or cursor position
        :returns: None if failed or a String containing the current word at mouse or cursor
        
        """
        ...
    def GetLine(self, lineno: Any) -> Any:
        r"""
        Returns a line
        :param lineno: The line number
        :returns: a tuple (colored_line, fgcolor, bgcolor), or None
        
        """
        ...
    def GetLineNo(self, mouse: Any = 0) -> Any:
        r"""Calls GetPos() and returns the current line number or -1 on failure"""
        ...
    def GetPos(self, mouse: Any = 0) -> Any:
        r"""
        Returns the current cursor or mouse position.
        :param mouse: return mouse position
        :returns: Returns a tuple (lineno, x, y)
        
        """
        ...
    def GetSelection(self) -> Any:
        r"""
        Returns the selected range or None
        :returns: tuple(x1, y1, x2, y2), or None if no selection
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def InsertLine(self, lineno: Any, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Inserts a line in the given position
        :returns: Boolean
        
        """
        ...
    def IsFocused(self) -> Any:
        r"""Returns True if the current view is the focused view"""
        ...
    def Jump(self, lineno: Any, x: Any = 0, y: Any = 0) -> Any:
        ...
    def OnPopup(self, form: Any, popup_handle: Any) -> Any:
        r"""
        Context menu popup is about to be shown. Create items dynamically if you wish
        :returns: Boolean. True if you handled the event
        
        """
        ...
    def PatchLine(self, lineno: Any, offs: Any, value: Any) -> Any:
        r"""Patches an existing line character at the given offset. This is a low level function. You must know what you're doing"""
        ...
    def Refresh(self) -> Any:
        ...
    def RefreshCurrent(self) -> Any:
        r"""Refreshes the current line only"""
        ...
    def Show(self) -> Any:
        r"""
        Shows an already created view. It the view was closed, then it will call Create() for you
        :returns: Boolean
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class simpleline_place_t(place_t):
    @property
    def lnnum(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class simpleline_t:
    @property
    def bgcolor(self) -> Any: ...
    @property
    def color(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class strarray_t:
    @property
    def code(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class sync_source_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, _o: sync_source_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, _o: sync_source_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_register(self) -> str:
        ...
    def get_widget(self) -> TWidget:
        ...
    def is_register(self) -> bool:
        ...
    def is_widget(self) -> bool:
        ...

class sync_source_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sync_source_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> sync_source_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sync_source_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: sync_source_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: sync_source_t) -> bool:
        ...
    def append(self, x: sync_source_t) -> None:
        ...
    def at(self, _idx: size_t) -> sync_source_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sync_source_vec_t) -> None:
        ...
    def extract(self) -> sync_source_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: sync_source_t) -> bool:
        ...
    def inject(self, s: sync_source_t, len: size_t) -> None:
        ...
    def insert(self, it: sync_source_t, x: sync_source_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, x: sync_source_t) -> None:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sync_source_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class synced_group_t(sync_source_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sync_source_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> sync_source_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sync_source_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: sync_source_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: sync_source_t) -> bool:
        ...
    def append(self, x: sync_source_t) -> None:
        ...
    def at(self, _idx: size_t) -> sync_source_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sync_source_vec_t) -> None:
        ...
    def extract(self) -> sync_source_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, ss: sync_source_t) -> bool:
        ...
    def has_register(self, r: str) -> bool:
        ...
    def has_widget(self, v: TWidget) -> bool:
        ...
    def inject(self, s: sync_source_t, len: size_t) -> None:
        ...
    def insert(self, it: sync_source_t, x: sync_source_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, x: sync_source_t) -> None:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sync_source_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tagged_line_section_t(line_section_t):
    @property
    def length(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: cpidx_t) -> bool:
        ...
    def is_closed(self) -> bool:
        ...
    def is_open(self) -> bool:
        ...
    def substr(self, _in: str, end: tagged_line_section_t = None) -> bool:
        ...
    def valid(self) -> bool:
        ...
    def valid_in(self, _in: str) -> bool:
        ...

class tagged_line_section_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tagged_line_section_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tagged_line_section_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: tagged_line_section_t) -> bool:
        ...
    def append(self, x: tagged_line_section_t) -> None:
        ...
    def at(self, _idx: size_t) -> tagged_line_section_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tagged_line_section_vec_t) -> None:
        ...
    def extract(self) -> tagged_line_section_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: tagged_line_section_t) -> bool:
        ...
    def inject(self, s: tagged_line_section_t, len: size_t) -> None:
        ...
    def insert(self, it: tagged_line_section_t, x: tagged_line_section_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tagged_line_section_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tagged_line_section_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tagged_line_sections_t(tagged_line_section_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tagged_line_section_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tagged_line_section_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: tagged_line_section_t) -> bool:
        ...
    def append(self, x: tagged_line_section_t) -> None:
        ...
    def at(self, _idx: size_t) -> tagged_line_section_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tagged_line_section_vec_t) -> None:
        ...
    def extract(self) -> tagged_line_section_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def first(self, tag: color_t) -> tagged_line_section_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: tagged_line_section_t) -> bool:
        ...
    def inject(self, s: tagged_line_section_t, len: size_t) -> None:
        ...
    def insert(self, it: tagged_line_section_t, x: tagged_line_section_t) -> iterator:
        ...
    def nearest_after(self, range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def nearest_at(self, x: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def nearest_before(self, range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tagged_line_section_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def sections_at(self, out: tagged_line_sections_t, x: cpidx_t, tag: color_t = 0) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tagged_line_section_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class text_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> twinline_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: twinline_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: twinline_t) -> None:
        ...
    def at(self, _idx: size_t) -> twinline_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: text_t) -> None:
        ...
    def extract(self) -> twinline_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: twinline_t, len: size_t) -> None:
        ...
    def insert(self, it: twinline_t, x: twinline_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> twinline_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: text_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class textctrl_info_t:
    r"""Class representing textctrl_info_t"""
    TXTF_ACCEPTTABS: int  # 2
    TXTF_AUTOINDENT: int  # 1
    TXTF_FIXEDFONT: int  # 32
    TXTF_MODIFIED: int  # 16
    TXTF_READONLY: int  # 4
    TXTF_SELECTED: int  # 8
    @property
    def clink(self) -> Any: ...
    @property
    def clink_ptr(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def tabsize(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __del__(self) -> Any:
        r"""Delete the link upon object destruction (only if not static)"""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __get_flags__(self) -> Any:
        r"""Returns the flags value"""
        ...
    def __get_tabsize__(self) -> Any:
        r"""Returns the tabsize value"""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, text: Any = '', flags: Any = 0, tabsize: Any = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __set_flags__(self, flags: Any) -> Any:
        r"""Sets the flags value"""
        ...
    def __set_tabsize__(self, tabsize: Any) -> Any:
        r"""Sets the tabsize value"""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def assign(self, other: Any) -> Any:
        r"""Copies the contents of 'other' to 'self'"""
        ...
    def copy(self) -> Any:
        r"""Returns a new copy of this class"""
        ...

class tiplace_t(place_t):
    @property
    def cursor(self) -> Any: ...
    @property
    def lnnum(self) -> Any: ...
    @property
    def ordinal(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def calc_udm_offset(self, ud: void, p_udmidx: ssize_t = None, p_bitoff: int = None) -> uint64:
        r"""for structs: calculate the offset that corresponds to the tiplace. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param p_udmidx: place to return the index of the current udt member, if any. if there is no member at the current offset, return -1
        :param p_bitoff: place to return the bit offset of the item from the beginning of the bit bucket if there no bitfields, return -1
        :returns: the current offset or uint64(-1)
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def fill_type_ref(self, out: til_type_ref_t, ud: void) -> bool:
        r"""fill the type information for use in actions 
                
        :param out: pointer to storage
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def get_kind(self, ud: void) -> type_t:
        r"""get the kind of type this place represents 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def is_footer(self) -> bool:
        ...
    def is_header(self) -> bool:
        ...
    def is_index(self) -> bool:
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def reset(self) -> None:
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def set_footer(self) -> None:
        ...
    def set_header(self) -> None:
        ...
    def set_index_by_offset(self, ud: void, offset: uint64) -> None:
        r"""for structs: calculate the index that corresponds to the offset and set it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param offset: offset of udt member
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def valid_ord(self) -> bool:
        ...

class twinline_t:
    @property
    def at(self) -> Any: ...
    @property
    def bg_color(self) -> Any: ...
    @property
    def is_default(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def prefix_color(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class twinpos_t:
    @property
    def at(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, t: place_t = None, x0: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def place(self, view: Any) -> Any:
        ...
    def place_as_idaplace_t(self) -> Any:
        ...
    def place_as_simpleline_place_t(self) -> Any:
        ...
    def place_as_tiplace_t(self) -> Any:
        ...

class ui_requests_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class view_mouse_event_location_t:
    @property
    def ea(self) -> Any: ...
    @property
    def item(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class view_mouse_event_t:
    @property
    def button(self) -> Any: ...
    @property
    def location(self) -> Any: ...
    @property
    def renderer_pos(self) -> Any: ...
    @property
    def rtype(self) -> Any: ...
    @property
    def state(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

def TWidget__from_ptrval__(ptrval: size_t) -> TWidget:
    ...

def activate_widget(widget: TWidget, take_focus: bool) -> None:
    r"""Activate widget (only gui version) (ui_activate_widget). 
            
    :param widget: existing widget to display
    :param take_focus: give focus to given widget
    """
    ...

def add_hotkey(hotkey: Any, callable: Any) -> Any:
    r"""Associates a function call with a hotkey.
    Callable 'callable' will be called each time the hotkey is pressed
    
    :param hotkey: The hotkey
    :param callable: Callable
    
    :returns: Context object on success or None on failure.
    """
    ...

def add_idc_hotkey(hotkey: str, idcfunc: str) -> int:
    r"""Add hotkey for IDC function (ui_add_idckey). 
            
    :param hotkey: hotkey name
    :param idcfunc: IDC function name
    :returns: IDC hotkey error codes
    """
    ...

def add_spaces(s: str, len: size_t) -> str:
    r"""Add space characters to the colored string so that its length will be at least 'len' characters. Don't trim the string if it is longer than 'len'. 
            
    :param len: the desired length of the string
    :returns: pointer to the end of input string
    """
    ...

def addon_count() -> int:
    r"""Get number of installed addons.
    
    """
    ...

def analyzer_options() -> None:
    r"""Allow the user to set analyzer options. (show a dialog box) (ui_analyzer_options)
    
    """
    ...

def ask_addr(defval: ida_idaapi.ea_t, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input an address
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the address entered by the user, or None if the dialog was canceled
    """
    ...

def ask_buttons(args: Any) -> int:
    r"""Display a dialog box and get choice from maximum three possibilities (ui_ask_buttons). 
            
    :param Yes: text for the first button
    :param No: text for the second button
    :param Cancel: text for the third button
    :param deflt: default choice: one of Button IDs
    :param format: printf-style format string for question. It may have some prefixes, see below.
    :returns: one of Button IDs specifying the selected button (Esc key returns Cancel/3rd button value)
    """
    ...

def ask_file(args: Any) -> char:
    ...

def ask_for_feedback(args: Any) -> None:
    r"""Show a message box asking to send the input file to [support@hex-rays.com](mailto:support@hex-rays.com). 
            
    :param format: the reason why the input file is bad
    """
    ...

def ask_form(args: Any) -> Any:
    r"""Display a dialog box and wait for the user. If the form contains the "BUTTON NO <title>" keyword, then the return values are the same as in the ask_yn() function (Button IDs) 
            
    :param form: dialog box as a string. see ask_form()/open_form()
    :returns: 0: no memory to display or form syntax error (a warning is displayed in this case). the user pressed the 'No' button (if the form has it) or the user cancelled the dialog otherwise. all variables retain their original values.
    :returns: 1: ok, all input fields are filled and validated.
    :returns: -1: the form has the 'No' button and the user cancelled the dialog
    """
    ...

def ask_ident(defval: str, prompt: str) -> bool:
    r"""Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are usually forbidden. 
            
    :returns: false if the user cancelled the dialog, otherwise returns true.
    """
    ...

def ask_ident2(args: Any) -> bool:
    r"""Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are permitted. 
            
    :param str: qstring to fill. Can contain the default value. Cannot be nullptr.
    :param format: printf() style format string with the question
    :returns: false if the user cancelled the dialog, otherwise returns true.
    """
    ...

def ask_long(defval: int, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input a number
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the number entered by the user, or None if the dialog was canceled
    """
    ...

def ask_seg(defval: int, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input an segment name.
    This function allows to enter segment register names, segment base
    paragraphs, segment names to denote a segment.
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the selector of the segment entered by the user, or None if the dialog was canceled
    """
    ...

def ask_str(defval: Any, hist: Any, prompt: Any) -> Any:
    r"""Asks for a long text
    
    :param defval: The default value
    :param hist:   history id
    :param prompt: The prompt value
    :returns: None or the entered string
    """
    ...

def ask_text(max_size: int, defval: str, prompt: str) -> Any:
    r"""Asks for a long text
    
    :param max_size: Maximum text length, 0 for unlimited
    :param defval: The default value
    :param prompt: The prompt value
    :returns: None or the entered string
    """
    ...

def ask_yn(args: Any) -> int:
    r"""Display a dialog box and get choice from "Yes", "No", "Cancel". 
            
    :param deflt: default choice: one of Button IDs
    :param format: The question in printf() style format
    :returns: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.
    """
    ...

def atoea(str: str) -> uint64:
    r"""Convert a number in C notation to an address. decimal: 1234 
    octal: 0123 
    hexadecimal: 0xabcd 
    binary: 0b00101010 
            
    :param str: the string to parse
    """
    ...

def attach_action_to_menu(menupath: str, name: str, flags: int = 0) -> bool:
    r"""Attach a previously-registered action to the menu (ui_attach_action_to_menu). 
            
    :param menupath: path to the menu item after or before which the insertion will take place. 
    
    * Example: Debug/StartProcess
    * Whitespace, punctuation are ignored.
    * It is allowed to specify only the prefix of the menu item.
    * Comparison is case insensitive.
    * menupath may start with the following prefixes:
    * [S] - modify the main menu of the structure window
    * [E] - modify the main menu of the enum window
    :param name: the action name
    :param flags: a combination of Set menu flags, to determine menu item position
    :returns: success
    """
    ...

def attach_action_to_popup(widget: TWidget, popup_handle: TPopupMenu, name: str, popuppath: str = None, flags: int = 0) -> bool:
    r"""Insert a previously-registered action into the widget's popup menu (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and 'permanent'. 
            
    :param widget: target widget
    :param popup_handle: target popup menu
    * if non-nullptr, the action is added to this popup menu invocation (i.e., 'single-shot')
    * if nullptr, the action is added to a list of actions that should always be present in context menus for this widget (i.e., 'permanent'.)
    :param name: action name
    :param popuppath: can be nullptr
    :param flags: a combination of SETMENU_ flags (see Set menu flags)
    :returns: success
    """
    ...

def attach_action_to_toolbar(toolbar_name: str, name: str) -> bool:
    r"""Attach an action to an existing toolbar (ui_attach_action_to_toolbar). 
            
    :param toolbar_name: the name of the toolbar
    :param name: the action name
    :returns: success
    """
    ...

def attach_dynamic_action_to_popup(unused: Any, popup_handle: Any, desc: Any, popuppath: Any = None, flags: Any = 0) -> Any:
    r"""Create & insert an action into the widget's popup menu
    (::ui_attach_dynamic_action_to_popup).
    Note: The action description in the 'desc' parameter is modified by
          this call so you should prepare a new description for each call.
    For example:
        desc = ida_kernwin.action_desc_t(None, 'Dynamic popup action', Handler())
        ida_kernwin.attach_dynamic_action_to_popup(form, popup, desc)
    
    :param unused:       deprecated; should be None
    :param popup_handle: target popup
    :param desc:         action description of type action_desc_t
    :param popuppath:    can be None
    :param flags:        a combination of SETMENU_ constants
    :returns: success
    """
    ...

def banner(wait: int) -> bool:
    r"""Show a banner dialog box (ui_banner). 
            
    :param wait: time to wait before closing
    :returns: 1: ok
    :returns: 0: esc was pressed
    """
    ...

def beep(beep_type: beep_t = 0) -> None:
    r"""Issue a beeping sound (ui_beep). 
            
    :param beep_type: beep_t
    """
    ...

def call_nav_colorizer(colorizer: Any, ea: ida_idaapi.ea_t, nbytes: int) -> Any:
    r"""To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    
    :param colorizer: the Python colorizer to call
    :param ea: the address to colorize
    :param nbytes: the size of the range to colorize
    """
    ...

def cancel_exec_request(req_id: int) -> bool:
    r"""Try to cancel an asynchronous exec request (::ui_cancel_exec_request). 
            
    :param req_id: request id
    :returns: true: successfully canceled
    :returns: false: request has already been processed.
    """
    ...

def cancel_thread_exec_requests(tid: __qthread_t) -> int:
    r"""Try to cancel asynchronous exec requests created by the specified thread. 
            
    :param tid: thread id
    :returns: number of the canceled requests.
    """
    ...

def choose_activate(_self: Any) -> None:
    ...

def choose_choose(_self: Any) -> Any:
    ...

def choose_close(_self: Any) -> None:
    ...

def choose_create_embedded_chobj(_self: Any) -> Any:
    ...

def choose_entry(title: str) -> ida_idaapi.ea_t:
    r"""Choose an entry point (ui_choose, chtype_entry). 
            
    :param title: chooser title
    :returns: ea of selected entry point, BADADDR if none selected
    """
    ...

def choose_enum(out: tinfo_t, title: str, default_ord: int) -> bool:
    r"""Choose an enum (ui_choose, chtype_enum). 
            
    :param out: the selected enum type
    :param title: chooser title
    :param default_ord: ordinal of enum to select by default
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_enum_by_value(out: tinfo_t, title: str, default_ord: int, value: uint64, nbytes: int) -> uchar:
    r"""Choose an enum, restricted by value & size (ui_choose, chtype_enum_by_value_and_size). If the given value cannot be found initially, this function will ask if the user would like to import a standard enum. 
            
    :param out: the selected enum type
    :param title: chooser title
    :param default_ord: ordinal of enum to select by default
    :param value: value to search for
    :param nbytes: size of value
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_find(title: str) -> Any:
    r"""Retrieve the chooser object by title
    
    :param title: the chooser title
    :returns: the chooser, or None
    """
    ...

def choose_func(title: str, default_ea: ida_idaapi.ea_t) -> func_t:
    r"""Choose a function (ui_choose, chtype_func). 
            
    :param title: chooser title
    :param default_ea: ea of function to select by default
    :returns: pointer to function that was selected, nullptr if none selected
    """
    ...

def choose_get_widget(_self: Any) -> TWidget:
    ...

def choose_idasgn() -> Any:
    r"""Opens the signature chooser
    
    :returns: None or the selected signature name
    """
    ...

def choose_name(title: str) -> ida_idaapi.ea_t:
    r"""Choose a name (ui_choose, chtype_name). 
            
    :param title: chooser title
    :returns: ea of selected name, BADADDR if none selected
    """
    ...

def choose_refresh(_self: Any) -> None:
    ...

def choose_segm(title: str, default_ea: ida_idaapi.ea_t) -> segment_t:
    r"""Choose a segment (ui_choose, chtype_segm). 
            
    :param title: chooser title
    :param default_ea: ea of segment to select by default
    :returns: pointer to segment that was selected, nullptr if none selected
    """
    ...

def choose_srcp(title: str) -> sreg_range_t:
    r"""Choose a segment register change point (ui_choose, chtype_srcp). 
            
    :param title: chooser title
    :returns: pointer to segment register range of selected change point, nullptr if none selected
    """
    ...

def choose_stkvar_xref(pfn: func_t, srkvar_tid: tid_t) -> ida_idaapi.ea_t:
    r"""Choose an xref to a stack variable (ui_choose, chtype_name). 
            
    :param pfn: function
    :param srkvar_tid: frame variable TID
    :returns: ea of the selected xref, BADADDR if none selected
    """
    ...

def choose_struct(out: tinfo_t, title: str) -> bool:
    r"""Choose a structure (ui_choose, chtype_struct). 
            
    :param out: the selected structure type
    :param title: chooser title
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_til() -> str:
    r"""Choose a type library (ui_choose, chtype_idatil). 
            
    :returns: true: 'buf' was filled with the name of the selected til
    :returns: false: otherwise
    """
    ...

def choose_xref(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Choose an xref to an address (ui_choose, chtype_xref). 
            
    :param to: referenced address
    :returns: ea of selected xref, BADADDR if none selected
    """
    ...

def clear_refresh_request(mask: uint64) -> None:
    ...

def close_chooser(title: str) -> bool:
    r"""Close a non-modal chooser (ui_close_chooser). 
            
    :param title: window title of chooser to close
    :returns: success
    """
    ...

def close_widget(widget: TWidget, options: int) -> None:
    r"""Close widget (ui_close_widget, only gui version). 
            
    :param widget: pointer to the widget to close
    :param options: Form close flags
    """
    ...

def clr_cancelled() -> None:
    r"""Clear "Cancelled" flag (ui_clr_cancelled)
    
    """
    ...

def create_code_viewer(custview: TWidget, flags: int = 0, parent: TWidget = None) -> TWidget:
    r"""Create a code viewer (ui_create_code_viewer). A code viewer contains on the left side a widget representing the line numbers, and on the right side, the child widget passed as parameter. It will inherit its title from the child widget.
    
    :param custview: the custom view to be added
    :param flags: Code viewer flags
    :param parent: widget to contain the new code viewer
    """
    ...

def create_empty_widget(title: str, icon: int = -1) -> TWidget:
    r"""Create an empty widget, serving as a container for custom user widgets 
            
    """
    ...

def create_menu(name: str, label: str, menupath: str = None) -> bool:
    r"""Create a menu with the given name, label and optional position, either in the menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information about where the menu should be positioned. First, IDA will try and resolve the corresponding menu by its name. If such an existing menu is found and is present in the menubar, then the new menu will be inserted in the menubar before it. Otherwise, IDA will try to resolve 'menupath' as it would for attach_action_to_menu() and, if found, add the new menu like so: 
         The new 'My menu' submenu will appear in the 'Comments' submenu
         before the 'Enter comment..." command
         "My menu", "Edit/Comments/Enter comment...");
    
    
         The new 'My menu' submenu will appear at the end of the
         'Comments' submenu.
         "My menu", "Edit/Comments/");
    
    
            
    :param name: name of menu (must be unique)
    :param label: label of menu
    :param menupath: where should the menu be inserted
    :returns: success
    """
    ...

def create_toolbar(name: str, label: str, before: str = None, flags: int = 0) -> bool:
    r"""Create a toolbar with the given name, label and optional position 
            
    :param name: name of toolbar (must be unique)
    :param label: label of toolbar
    :param before: if non-nullptr, the toolbar before which the new toolbar will be inserted
    :param flags: a combination of create toolbar flags, to determine toolbar position
    :returns: success
    """
    ...

def custom_viewer_jump(v: TWidget, loc: lochist_entry_t, flags: int = 0) -> bool:
    r"""Append 'loc' to the viewer's history, and cause the viewer to display it. 
            
    :param v: (TWidget *)
    :param loc: (const lochist_entry_t &)
    :param flags: (uint32) or'ed combination of CVNF_* values
    :returns: success
    """
    ...

def del_hotkey(ctx: Any) -> Any:
    r"""Deletes a previously registered function hotkey
    
    :param ctx: Hotkey context previously returned by add_hotkey()
    
    :returns: Boolean.
    """
    ...

def del_idc_hotkey(hotkey: str) -> bool:
    ...

def delete_menu(name: str) -> bool:
    r"""Delete an existing menu 
            
    :param name: name of menu
    :returns: success
    """
    ...

def delete_toolbar(name: str) -> bool:
    r"""Delete an existing toolbar 
            
    :param name: name of toolbar
    :returns: success
    """
    ...

def detach_action_from_menu(menupath: str, name: str) -> bool:
    r"""Detach an action from the menu (ui_detach_action_from_menu). 
            
    :param menupath: path to the menu item
    :param name: the action name
    :returns: success
    """
    ...

def detach_action_from_popup(widget: TWidget, name: str) -> bool:
    r"""Remove a previously-registered action, from the list of 'permanent' context menu actions for this widget (ui_detach_action_from_popup). This only makes sense if the action has been added to 'widget's list of permanent popup actions by calling attach_action_to_popup in 'permanent' mode. 
            
    :param widget: target widget
    :param name: action name
    """
    ...

def detach_action_from_toolbar(toolbar_name: str, name: str) -> bool:
    r"""Detach an action from the toolbar (ui_detach_action_from_toolbar). 
            
    :param toolbar_name: the name of the toolbar
    :param name: the action name
    :returns: success
    """
    ...

def display_copyright_warning() -> bool:
    r"""Display copyright warning (ui_copywarn). 
            
    :returns: yes/no
    """
    ...

def display_widget(widget: TWidget, options: int, dest_ctrl: str = None) -> None:
    r"""Display a widget, dock it if not done before 
            
    :param widget: widget to display
    :param options: Widget open flags
    :param dest_ctrl: where to dock: if nullptr or invalid then use the active docker if there is not create a new tab relative to current active tab
    """
    ...

def ea2str(ea: ida_idaapi.ea_t) -> str:
    r"""Convert linear address to UTF-8 string.
    
    """
    ...

def ea_viewer_history_push_and_jump(v: TWidget, ea: ida_idaapi.ea_t, x: int, y: int, lnnum: int) -> bool:
    r"""Push current location in the history and jump to the given location (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and also in other synchronized views. 
            
    :param v: ea viewer
    :param ea: jump destination
    :param x: coords on screen
    :param y: coords on screen
    :param lnnum: desired line number of given address
    """
    ...

def enable_chooser_item_attrs(chooser_caption: str, enable: bool) -> bool:
    r"""Enable item-specific attributes for chooser items (ui_enable_chooser_item_attrs). For example: color list items differently depending on a criterium. 
    If enabled, the chooser will generate ui_get_chooser_item_attrs 
    events that can be intercepted by a plugin to modify the item attributes. 
    This event is generated only in the GUI version of IDA. 
    Specifying CH_ATTRS bit at the chooser creation time has the same effect. 
            
    :returns: success
    """
    ...

def error(message: Any) -> Any:
    r"""Display a fatal message in a message box and quit IDA
    
    :param format: message to print
    """
    ...

def execute_sync(callable: Any, reqf: Any) -> Any:
    r"""Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    :param callable: A python callable object, must return an integer value
    :param reqf: one of MFF_ flags
    :returns: -1 or the return value of the callable
    """
    ...

def execute_ui_requests(callable_list: Any) -> Any:
    r"""Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    NOTE: A callable should return True if it wants to be called more than once.
    
    :param callable_list: A list of python callable objects.
    :returns: Boolean. False if the list contains a non callable item
    """
    ...

def find_widget(caption: str) -> TWidget:
    r"""Find widget with the specified caption (only gui version) (ui_find_widget). NB: this callback works only with the tabbed widgets! 
            
    :param caption: title of tab, or window title if widget is not tabbed
    :returns: pointer to the TWidget, nullptr if none is found
    """
    ...

def formchgcbfa_close(p_fa: size_t, close_normally: int) -> None:
    ...

def formchgcbfa_enable_field(p_fa: size_t, fid: int, enable: bool) -> bool:
    ...

def formchgcbfa_get_field_value(p_fa: size_t, fid: int, ft: int, sz: size_t) -> Any:
    ...

def formchgcbfa_get_focused_field(p_fa: size_t) -> int:
    ...

def formchgcbfa_move_field(p_fa: size_t, fid: int, x: int, y: int, w: int, h: int) -> bool:
    ...

def formchgcbfa_refresh_field(p_fa: size_t, fid: int) -> None:
    ...

def formchgcbfa_set_field_value(p_fa: size_t, fid: int, ft: int, py_val: Any) -> bool:
    ...

def formchgcbfa_set_focused_field(p_fa: size_t, fid: int) -> bool:
    ...

def formchgcbfa_show_field(p_fa: size_t, fid: int, show: bool) -> bool:
    ...

def free_custom_icon(icon_id: Any) -> Any:
    r"""Frees an icon loaded with load_custom_icon()
    
    :param icon_id: The ID of the icon to free
    """
    ...

def gen_disasm_text(text: disasm_text_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, truncate_lines: bool) -> None:
    r"""Generate disassembly text for a range. 
            
    :param text: result
    :param ea1: start address
    :param ea2: end address
    :param truncate_lines: (on idainfo::margin)
    """
    ...

def get_action_checkable(name: str) -> bool:
    r"""Get an action's checkability (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_checked(name: str) -> bool:
    r"""Get an action's checked state (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_icon(name: str) -> int:
    r"""Get an action's icon (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_label(name: str) -> str:
    r"""Get an action's label (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_shortcut(name: str) -> str:
    r"""Get an action's shortcut (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_state(name: str) -> action_state_t:
    r"""Get an action's state (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_tooltip(name: str) -> str:
    r"""Get an action's tooltip (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_visibility(name: str) -> bool:
    r"""Get an action's visibility (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_active_modal_widget() -> TWidget:
    r"""Get the current, active modal TWidget instance. Note that in this context, the "wait dialog" is not considered: this function will return nullptr even if it is currently shown. 
            
    :returns: TWidget * the active modal widget, or nullptr
    """
    ...

def get_addon_info(id: str, info: addon_info_t) -> bool:
    r"""Get info about a registered addon with a given product code. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    :returns: false if not found
    """
    ...

def get_addon_info_idx(index: int, info: addon_info_t) -> bool:
    r"""Get info about a registered addon with specific index. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    :returns: false if index is out of range
    """
    ...

def get_chooser_data(title: str, n: int) -> List[str]:
    r"""Get the text corresponding to the index N in the chooser data.
    Use -1 to get the header.
    
    :param title: The chooser title
    :returns: a list of strings, or None
    """
    ...

def get_chooser_obj(chooser_caption: str) -> None:
    r"""Get the underlying object of the specified chooser (ui_get_chooser_obj).
    This attemps to find the choser by its title and, if found, returns the result of calling its chooser_base_t::get_chooser_obj() method.
    
    :returns: the object that was used to create the chooser
    """
    ...

def get_chooser_rows(out: chooser_row_info_vec_t, chooser_caption: str, what: size_t) -> bool:
    r"""Get the chooser contents corresponding to the rows indicated by "what". 
            
    :param out: A vector of chooser_row_info_t, one entry per returned row.
    :param chooser_caption: The caption that identifies the desired chooser.
    :param what: Either one of the GCRF_ flags, or a row index.
    :returns: Success.
    """
    ...

def get_curline() -> str:
    r"""Get current line from the disassemble window (ui_get_curline). 
            
    :returns: cptr current line with the color codes (use tag_remove() to remove the color codes)
    """
    ...

def get_current_viewer() -> TWidget:
    r"""Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)
    
    """
    ...

def get_current_widget() -> TWidget:
    r"""Get a pointer to the current widget (ui_get_current_widget).
    
    """
    ...

def get_cursor() -> Any:
    r"""Get the cursor position on the screen (ui_get_cursor). 
            
    :returns: true: pointers are filled
    :returns: false: no disassembly window open
    """
    ...

def get_custom_viewer_curline(custom_viewer: TWidget, mouse: bool) -> str:
    r"""Get current line of custom viewer (ui_get_custom_viewer_curline). The returned line contains color codes
    See also the more powerful get_custom_viewer_location()
    
    :param custom_viewer: view
    :param mouse: mouse position (otherwise cursor position)
    :returns: pointer to contents of current line
    """
    ...

def get_custom_viewer_location(args: Any) -> bool:
    r"""Get information about the current location in a listing
    
    This function has the following signatures:
    
        1. get_custom_viewer_location(out_entry: ida_moves.lochist_entry_t, widget: TWidget, mouse: bool=False) -> bool
        2. get_custom_viewer_location(out_entry: ida_kernwin.listing_location_t, widget: TWidget, flags: int=0) -> bool
    
    The 2nd form is a superset of the 1st, and retrieves
    the text (and tags) of the text.
    """
    ...

def get_custom_viewer_place(custom_viewer: TWidget, mouse: bool) -> Any:
    r"""Get current place in a custom viewer (ui_get_curplace).
    See also the more complete get_custom_viewer_location()
    
    :param custom_viewer: view
    :param mouse: mouse position (otherwise cursor position)
    """
    ...

def get_custom_viewer_place_xcoord(custom_viewer: TWidget, pline: place_t, pitem: place_t) -> int:
    r"""Get the X position of the item, in the line 
            
    :param custom_viewer: the widget
    :param pline: a place corresponding to the line
    :param pitem: a place corresponding to the item
    :returns: -1: if 'pitem' is not included in the line
    :returns: -2: if 'pitem' points at the entire line
    :returns: >=: 0 for the X coordinate within the pline, where pitem points
    """
    ...

def get_ea_viewer_history_info(nback: int, nfwd: int, v: TWidget) -> bool:
    r"""Get information about what's in the history (ui_ea_viewer_history_info). 
            
    :param nback: number of available back steps
    :param nfwd: number of available forward steps
    :param v: ea viewer
    :returns: false: if the given ea viewer does not exist
    :returns: true: otherwise
    """
    ...

def get_hexdump_ea(hexdump_num: int) -> ida_idaapi.ea_t:
    r"""Get the current address in a hex view. 
            
    :param hexdump_num: number of hexview window
    """
    ...

def get_highlight(v: Any, flags: Any = 0) -> Any:
    r"""Returns the currently highlighted identifier and flags
    
    :param v: The UI widget to operate on
    :param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
    :returns: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.
    """
    ...

def get_icon_id_by_name(icon_name: str) -> int:
    r"""Retrieve the id of the icon by name (ui_get_icon_id_by_name). 
            
    :param icon_name: full name of the icon
    :returns: icon id
    """
    ...

def get_kernel_version() -> str:
    r"""Get IDA kernel version (in a string like "5.1").
    
    """
    ...

def get_key_code(keyname: str) -> ushort:
    r"""Get keyboard key code by its name (ui_get_key_code)
    
    """
    ...

def get_last_widget(args: Any) -> TWidget:
    r"""Get last ida viewer (idaview or custom viewer) (ui_get_last_widget) 
            
    :param mask: an OR'ed set of IWID_* to limit the search to
    :returns: the viewer, if found
    """
    ...

def get_navband_ea(pixel: int) -> ida_idaapi.ea_t:
    r"""Translate the pixel position on the navigation band, into an address.
    
    """
    ...

def get_navband_pixel(ea: Any) -> Any:
    r"""Maps an address, onto a pixel coordinate within the navigation band
    
    :param ea: The address to map
    :returns: a list [pixel, is_vertical]
    """
    ...

def get_opnum() -> int:
    r"""Get current operand number, -1 means no operand (ui_get_opnum)
    
    """
    ...

def get_output_curline(mouse: bool) -> str:
    r"""Get current line of output window (ui_get_output_curline). 
            
    :param mouse: current for mouse pointer?
    :returns: false if output contains no text
    """
    ...

def get_output_cursor() -> Any:
    r"""Get coordinates of the output window's cursor (ui_get_output_cursor). 
            
    :returns: false: the output window has been destroyed.
    :returns: true: pointers are filled
    """
    ...

def get_output_selected_text() -> str:
    r"""Returns selected text from output window (ui_get_output_selected_text). 
            
    :returns: true if there is a selection
    """
    ...

def get_place_class(out_flags: int, out_sdk_version: int, id: int) -> place_t:
    r"""Get information about a previously-registered place_t class. See also register_place_class(). 
            
    :param out_flags: output flags (can be nullptr)
    :param out_sdk_version: sdk version the place was created with (can be nullptr)
    :param id: place class ID
    :returns: the place_t template, or nullptr if not found
    """
    ...

def get_place_class_id(name: str) -> int:
    r"""Get the place class ID for the place that has been registered as 'name'. 
            
    :param name: the class name
    :returns: the place class ID, or -1 if not found
    """
    ...

def get_place_class_template(id: int) -> place_t:
    r"""See get_place_class()
    
    """
    ...

def get_registered_actions() -> List[str]:
    r"""Get a list with the names of all currently-registered actions.
    
    :returns: the list of action names
    """
    ...

def get_screen_ea() -> ida_idaapi.ea_t:
    r"""Get the address at the screen cursor (ui_screenea)
    
    """
    ...

def get_synced_group(w: TWidget) -> synced_group_t:
    r"""Get the group of widgets/registers this view is synchronized with 
            
    :param w: the widget
    :returns: the group of widgets/registers, or nullptr
    """
    ...

def get_tab_size(path: str) -> int:
    r"""Get the size of a tab in spaces (ui_get_tab_size). 
            
    :param path: the path of the source view for which the tab size is requested.
    * if nullptr, the default size is returned.
    """
    ...

def get_user_input_event(out: input_event_t) -> bool:
    r"""Get the current user input event (mouse button press, key press, ...) It is sometimes desirable to be able to tell when a certain situation happens (e.g., 'view_curpos' gets triggered); this function exists to provide that context (GUI version only) 
            
    :param out: the input event data
    :returns: false if we are not currently processing a user input event
    """
    ...

def get_user_strlist_options(out: strwinsetup_t) -> None:
    ...

def get_view_renderer_type(v: TWidget) -> tcc_renderer_type_t:
    r"""Get the type of renderer currently in use in the given view (ui_get_renderer_type)
    
    """
    ...

def get_viewer_place_type(viewer: TWidget) -> tcc_place_type_t:
    r"""Get the type of place_t instances a viewer uses & creates (ui_get_viewer_place_type).
    
    """
    ...

def get_viewer_user_data(viewer: TWidget) -> None:
    r"""Get the user data from a custom viewer (ui_get_viewer_user_data)
    
    """
    ...

def get_widget_title(widget: TWidget) -> str:
    r"""Get the TWidget's title (ui_get_widget_title).
    
    """
    ...

def get_widget_type(widget: TWidget) -> twidget_type_t:
    r"""Get the type of the TWidget * (ui_get_widget_type).
    
    """
    ...

def get_window_id(name: str = None) -> None:
    r"""Get the system-specific window ID (GUI version only) 
            
    :param name: name of the window (nullptr means the main IDA window)
    :returns: the low-level window ID
    """
    ...

def hide_wait_box() -> None:
    r"""Hide the "Please wait dialog box".
    
    """
    ...

def info(args: Any) -> ssize_t:
    ...

def install_command_interpreter(py_obj: Any) -> int:
    r"""Install command line interpreter (ui_install_cli)
    
    """
    ...

def internal_register_place_class(tmplate: place_t, flags: int, owner: plugin_t, sdk_version: int) -> int:
    ...

def is_action_enabled(s: action_state_t) -> bool:
    r"""Check if the given action state is one of AST_ENABLE*.
    
    """
    ...

def is_chooser_widget(t: twidget_type_t) -> bool:
    r"""Does the given widget type specify a chooser widget?
    
    """
    ...

def is_ida_library(path: char = None, pathsize: size_t = 0, handle: void = None) -> bool:
    ...

def is_idaq() -> Any:
    r"""Returns True or False depending if IDAPython is hosted by IDAQ"""
    ...

def is_idaview(v: TWidget) -> bool:
    r"""Is the given custom view an idaview? (ui_is_idaview)
    
    """
    ...

def is_msg_inited() -> bool:
    r"""Can we use msg() functions?
    
    """
    ...

def is_place_class_ea_capable(id: int) -> bool:
    r"""See get_place_class()
    
    """
    ...

def is_refresh_requested(mask: uint64) -> bool:
    r"""Get a refresh request state 
            
    :param mask: Window refresh flags
    :returns: the state (set or cleared)
    """
    ...

def is_tif_cursor_footer(c: tif_cursor_t) -> bool:
    ...

def is_tif_cursor_header(c: tif_cursor_t) -> bool:
    ...

def is_tif_cursor_index(c: tif_cursor_t) -> bool:
    ...

def jumpto(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
        1. jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    # 0: jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
    
    Jump to the specified address (ui_jumpto). 
            
    :returns: success
    
    # 1: jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    Set cursor position in custom ida viewer. 
            
    :returns: success
    
    """
    ...

def l_compare2(t1: place_t, t2: place_t, ud: void) -> int:
    ...

def l_equals(t1: place_t, t2: place_t, ud: void) -> bool:
    ...

def load_custom_icon(file_name: Any = None, data: Any = None, format: Any = None) -> Any:
    r"""Load an icon from a file (ui_load_custom_icon_file). Also see load_custom_icon(const void *, unsigned int, const char *) 
            
    :param file_name: path to file
    :returns: icon id
    """
    ...

def load_dbg_dbginfo(args: Any) -> bool:
    r"""Load debugging information from a file. 
            
    :param path: path to file
    :param li: loader input. if nullptr, check DBG_NAME_KEY
    :param base: loading address
    :param verbose: dump status to message window
    """
    ...

def lookup_key_code(key: int, shift: int, is_qt: bool) -> ushort:
    r"""Get shortcut code previously created by ui_get_key_code. 
            
    :param key: key constant
    :param shift: modifiers
    :param is_qt: are we using gui version?
    """
    ...

def msg(message: Any) -> Any:
    r"""Display a message in the message window
    
    :param message: message to print
    """
    ...

def msg_clear() -> None:
    r"""Clear the "Output" window.
    
    """
    ...

def msg_get_lines(count: int = -1) -> Any:
    r"""Retrieve the last 'count' lines from the output window, in reverse order (from most recent, to least recent) 
            
    :param count: The number of lines to retrieve. -1 means: all
    """
    ...

def msg_save(path: str) -> bool:
    r"""Save the "Output" window contents into a file 
            
    :param path: The path of the file to save the contents into. An empty path means that the user will be prompted for the destination and, if the file already exists, the user will be asked to confirm before overriding its contents. Upon return, 'path' will contain the path that the user chose.
    :returns: success
    """
    ...

def nomem(args: Any) -> None:
    ...

def open_bookmarks_window(w: TWidget) -> TWidget:
    r"""Open the bookmarks window (ui_open_builtin). 
            
    :param w: The widget for which the bookmarks will open. For example, this can be an IDAView, or Enums view, etc.
    :returns: pointer to resulting window
    """
    ...

def open_bpts_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the breakpoints window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_calls_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the function calls window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_disasm_window(window_title: str, ranges: rangevec_t = None) -> TWidget:
    r"""Open a disassembly view (ui_open_builtin). 
            
    :param window_title: title of view to open
    :param ranges: if != nullptr, then display a flow chart with the specified ranges
    :returns: pointer to resulting window
    """
    ...

def open_exports_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the exports window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_form(args: Any) -> Any:
    r"""Display a dockable modeless dialog box and return a handle to it. The modeless form can be closed in the following ways:
    * by pressing the small 'x' in the window title
    * by calling form_actions_t::close() from the form callback (form_actions_t)
    
    
    
    :param form: dialog box as a string. see ask_form()/open_form()
    :param flags: Widget open flags
    :returns: handle to the form or nullptr. the handle can be used with TWidget functions: close_widget()/activate_widget()/etc
    """
    ...

def open_frame_window(pfn: func_t, offset: int) -> TWidget:
    r"""Open the frame window for the given function (ui_open_builtin). 
            
    :param pfn: function to analyze
    :param offset: offset where the cursor is placed
    :returns: pointer to resulting window if 'pfn' is a valid function and the window was displayed, 
     nullptr otherwise
    """
    ...

def open_funcs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the 'Functions' window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_hexdump_window(window_title: str) -> TWidget:
    r"""Open a hexdump view (ui_open_builtin). 
            
    :param window_title: title of view to open
    :returns: pointer to resulting window
    """
    ...

def open_imports_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the exports window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_loctypes_window(ordinal: int, cursor: tif_cursor_t = None) -> TWidget:
    r"""Open the local types window (ui_open_builtin2). 
            
    :param ordinal: ordinal of type to select by default
    :param cursor: cursor to the type member
    :returns: pointer to resulting window
    """
    ...

def open_modules_window() -> TWidget:
    r"""Open the modules window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_names_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the names window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_navband_window(ea: ida_idaapi.ea_t, zoom: int) -> TWidget:
    r"""Open the navigation band window (ui_open_builtin). 
            
    :param ea: sets the address of the navband arrow
    :param zoom: sets the navband zoom level
    :returns: pointer to resulting window
    """
    ...

def open_notepad_window() -> TWidget:
    r"""Open the notepad window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_problems_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the problems window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_segments_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the segments window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_segregs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the segment registers window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_selectors_window() -> TWidget:
    r"""Open the selectors window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_signatures_window() -> TWidget:
    r"""Open the signatures window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_stack_window() -> TWidget:
    r"""Open the call stack window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_strings_window(args: Any) -> TWidget:
    r"""Open the 'Strings' window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :param selstart: only display strings that occur within this range
    :param selend: only display strings that occur within this range
    :returns: pointer to resulting window
    """
    ...

def open_threads_window() -> TWidget:
    r"""Open the threads window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_til_view_window(tif: tinfo_t, cursor: tif_cursor_t = None) -> TWidget:
    r"""Open the sub-til window (ui_open_builtin2). 
            
    :param tif: tif to open
    :param cursor: cursor to the type member
    :returns: pointer to resulting window
    """
    ...

def open_tils_window() -> TWidget:
    r"""Open the type libraries window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_trace_window() -> TWidget:
    r"""Open the tracing window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_url(url: str) -> None:
    r"""Open the given url (ui_open_url)
    
    """
    ...

def open_xrefs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the cross references window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def parse_tagged_line_sections(out: tagged_line_sections_t, line: str) -> bool:
    r"""Collect tagged sections in a color-tagged line (produced by `place_t::generate`)
    
    :param out: sections storage
    :param line: input line
    :returns: success
    """
    ...

def place_t_as_idaplace_t(p: place_t) -> idaplace_t:
    ...

def place_t_as_simpleline_place_t(p: place_t) -> simpleline_place_t:
    ...

def place_t_as_tiplace_t(p: place_t) -> tiplace_t:
    ...

def plgform_close(py_link: Any, options: int) -> None:
    ...

def plgform_get_widget(py_link: Any) -> TWidget:
    ...

def plgform_new() -> Any:
    ...

def plgform_show(args: Any) -> bool:
    ...

def process_ui_action(name: str, flags: int = 0) -> Any:
    r"""Invokes an IDA UI action by name
    
    :param name:  action name
    :param flags: reserved
    :returns: Boolean
    """
    ...

def prompt_function_prototype(out_tif: tinfo_t, pfn: func_t, tif: tinfo_t, name: str) -> str:
    r"""Open function prototype editor to edit function type and create new type. Allows to change the function prototype either in the "old" one-liner mode or in the new multi-line editor, which supports shortcuts, etc. Note: changes will not apply! It is the caller's job to apply the resulting out_tif. Parameters: 
            
    :param out_tif: - (tinfo_t *) tif for created type
    :param pfn: - (func_t *) editing function
    :param tif: - (tinfo_t *) current function type
    :param name: - (const char *) function name
    :returns: true if new type created successfully
    """
    ...

def py_chooser_base_t_get_row(chobj: chooser_base_t, n: size_t) -> Any:
    ...

def py_get_ask_form() -> int:
    ...

def py_get_open_form() -> int:
    ...

def py_load_custom_icon_data(data: Any, format: str) -> int:
    ...

def py_load_custom_icon_fn(filename: str) -> int:
    ...

def py_register_compiled_form(py_form: Any) -> None:
    ...

def py_unregister_compiled_form(py_form: Any) -> None:
    ...

def pyidag_bind(_self: Any) -> bool:
    ...

def pyidag_unbind(_self: Any) -> bool:
    ...

def pyscv_add_line(py_this: Any, py_sl: Any) -> bool:
    ...

def pyscv_clear_lines(py_this: Any) -> Any:
    ...

def pyscv_close(py_this: Any) -> None:
    ...

def pyscv_count(py_this: Any) -> int:
    ...

def pyscv_del_line(py_this: Any, nline: size_t) -> bool:
    ...

def pyscv_edit_line(py_this: Any, nline: size_t, py_sl: Any) -> bool:
    ...

def pyscv_get_current_line(py_this: Any, mouse: bool, notags: bool) -> Any:
    ...

def pyscv_get_current_word(py_this: Any, mouse: bool) -> Any:
    ...

def pyscv_get_line(py_this: Any, nline: size_t) -> Any:
    ...

def pyscv_get_pos(py_this: Any, mouse: bool) -> Any:
    ...

def pyscv_get_selection(py_this: Any) -> Any:
    ...

def pyscv_get_widget(py_this: Any) -> TWidget:
    ...

def pyscv_init(py_link: Any, title: str) -> Any:
    ...

def pyscv_insert_line(py_this: Any, nline: size_t, py_sl: Any) -> bool:
    ...

def pyscv_is_focused(py_this: Any) -> bool:
    ...

def pyscv_jumpto(py_this: Any, ln: size_t, x: int, y: int) -> bool:
    ...

def pyscv_patch_line(py_this: Any, nline: size_t, offs: size_t, value: int) -> bool:
    ...

def pyscv_refresh(py_this: Any) -> bool:
    ...

def pyscv_show(py_this: Any) -> bool:
    ...

def qcleanline(args: Any) -> str:
    r"""Performs some cleanup operations to a line. 
            
    :param buf: string to modify
    :param cmt_char: character that denotes the start of a comment:
    * the entire text is removed if the line begins with this character (ignoring leading spaces)
    * all text after (and including) this character is removed if flag CLNL_FINDCMT is set
    :param flags: a combination of line cleanup flags. defaults to CLNL_TRIM
    :returns: length of line
    """
    ...

def read_range_selection(v: TWidget) -> Any:
    r"""Get the address range for the selected range boundaries, this is the convenient function for read_selection() 
            
    :param v: view, nullptr means the last active window containing addresses
    :returns: 0: no range is selected
    :returns: 1: ok, start ea and end ea are filled
    """
    ...

def read_selection(v: Any, p1: Any, p2: Any) -> Any:
    r"""Read the user selection, and store its information in p1 (from) and p2 (to).
    
    This can be used as follows:
    
    
    >>> p1 = ida_kernwin.twinpos_t()
    p2 = ida_kernwin.twinpos_t()
    view = ida_kernwin.get_current_viewer()
    ida_kernwin.read_selection(view, p1, p2)
    
    
    At that point, p1 and p2 hold information for the selection.
    But, the 'at' property of p1 and p2 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p1.place(view)
    place1 = p2.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    :param v: The view to retrieve the selection for.
    :param p1: Storage for the "from" part of the selection.
    :param p2: Storage for the "to" part of the selection.
    :returns: a bool value indicating success.
    """
    ...

def refresh_chooser(title: str) -> bool:
    r"""Mark a non-modal custom chooser for a refresh (ui_refresh_chooser). 
            
    :param title: title of chooser
    :returns: success
    """
    ...

def refresh_choosers() -> None:
    ...

def refresh_custom_viewer(custom_viewer: TWidget) -> None:
    r"""Refresh custom ida viewer (ui_refresh_custom_viewer)
    
    """
    ...

def refresh_idaview() -> None:
    r"""Refresh marked windows (ui_refreshmarked)
    
    """
    ...

def refresh_idaview_anyway() -> None:
    r"""Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please consider request_refresh() instead 
            
    """
    ...

def refresh_navband(force: bool) -> None:
    r"""Refresh navigation band if changed (ui_refresh_navband). 
            
    :param force: refresh regardless
    """
    ...

def register_action(desc: action_desc_t) -> bool:
    r"""Create a new action (ui_register_action). After an action has been created, it is possible to attach it to menu items (attach_action_to_menu()), or to popup menus (attach_action_to_popup()).
    Because the actions will need to call the handler's activate() and update() methods at any time, you shouldn't build your action handler on the stack.
    Please see the SDK's "ht_view" plugin for an example how to register actions. 
            
    :param desc: action to register
    :returns: success
    """
    ...

def register_addon(info: addon_info_t) -> int:
    r"""Register an add-on. Show its info in the About box. For plugins, should be called from init() function (repeated calls with the same product code overwrite previous entries) returns: index of the add-on in the list, or -1 on error 
            
    """
    ...

def register_and_attach_to_menu(menupath: str, name: str, label: str, shortcut: str, flags: int, handler: action_handler_t, owner: void, action_desc_t_flags: int) -> bool:
    r"""Helper.
    You are not encouraged to use this, as it mixes flags for both register_action(), and attach_action_to_menu().
    The only reason for its existence is to make it simpler to port existing plugins to the new actions API. 
            
    """
    ...

def register_timer(interval: Any, callback: Any) -> Any:
    r"""Register a timer
    
    :param interval: Interval in milliseconds
    :param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    :returns: None or a timer object
    """
    ...

def remove_command_interpreter(cli_idx: int) -> None:
    r"""Remove command line interpreter (ui_install_cli)
    
    """
    ...

def repaint_custom_viewer(custom_viewer: TWidget) -> None:
    r"""Repaint the given widget immediately (ui_repaint_qwidget)
    
    """
    ...

def replace_wait_box(args: Any) -> None:
    r"""Replace the label of "Please wait dialog box".
    
    """
    ...

def request_refresh(mask: uint64, cnd: bool = True) -> None:
    r"""Request a refresh of a builtin window. 
            
    :param mask: Window refresh flags
    :param cnd: set if true or clear flag otherwise
    """
    ...

def restore_database_snapshot(snapshot: Any, callback: Any, userdata: Any) -> bool:
    r"""Restore a database snapshot.
    
    Note: This call is asynchronous. When it is completed, the callback will be triggered.
    
    :param snapshot: the snapshot object
    :param callback: a callback function
    :param userdata: payload to pass to the callback
    :returns: success
    """
    ...

def set_cancelled() -> None:
    r"""Set "Cancelled" flag (ui_set_cancelled)
    
    """
    ...

def set_code_viewer_handler(code_viewer: TWidget, handler_id: custom_viewer_handler_id_t, handler_or_data: void) -> None:
    r"""Set a handler for a code viewer event (ui_set_custom_viewer_handler). 
            
    :param code_viewer: the code viewer
    :param handler_id: one of CDVH_ in custom_viewer_handler_id_t
    :param handler_or_data: can be a handler or data. see examples in Functions: custom viewer handlers
    :returns: old value of the handler or data
    """
    ...

def set_code_viewer_is_source(code_viewer: TWidget) -> bool:
    r"""Specify that the given code viewer is used to display source code (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_line_handlers(code_viewer: TWidget, click_handler: code_viewer_lines_click_t, popup_handler: code_viewer_lines_click_t, dblclick_handler: code_viewer_lines_click_t, drawicon_handler: code_viewer_lines_icon_t, linenum_handler: code_viewer_lines_linenum_t) -> None:
    r"""Set handlers for code viewer line events. Any of these handlers may be nullptr 
            
    """
    ...

def set_code_viewer_lines_alignment(code_viewer: TWidget, align: int) -> bool:
    r"""Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_lines_icon_margin(code_viewer: TWidget, margin: int) -> bool:
    r"""Set space allowed for icons in the margin of a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_lines_radix(code_viewer: TWidget, radix: int) -> bool:
    r"""Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_user_data(code_viewer: TWidget, ud: void) -> bool:
    r"""Set the user data on a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_custom_viewer_qt_aware(custom_viewer: TWidget) -> bool:
    r"""Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)
    
    """
    ...

def set_dock_pos(src_ctrl: Any, dest_ctrl: Any, orient: Any, left: Any = 0, top: Any = 0, right: Any = 0, bottom: Any = 0) -> Any:
    r"""Sets the dock orientation of a window relatively to another window.
    
    Use the left, top, right, bottom parameters if DP_FLOATING is used,
    or if you want to specify the width of docked windows.
    
    :param src_ctrl: Source docking control
    :param dest_ctrl: Destination docking control
    :param orient: One of DP_XXXX constants
    :returns: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window
    """
    ...

def set_execute_sync_availability(tid: __qthread_t, availability: execute_sync_availability_t) -> execute_sync_availability_t:
    r"""Set the availability of the execute_sync functionality for the given thread
    Setting it to `esa_unavailable` will cause the existing requests for this thread to be cancelled. Setting it to `esa_release` will clear the status for this thread, and should be issued right before a call to `qthread_free` is issued.
    
    :param tid: thread id
    :param availability: the availability
    :returns: the previous availability
    """
    ...

def set_highlight(viewer: TWidget, str: str, flags: int) -> bool:
    r"""Set the highlighted identifier in the viewer (ui_set_highlight). 
            
    :param viewer: the viewer
    :param str: the text to match, or nullptr to remove current
    :param flags: combination of HIF_... bits (see set_highlight flags)
    :returns: false if an error occurred
    """
    ...

def set_nav_colorizer(callback: Any) -> Any:
    r"""Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = ida_kernwin.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = ida_kernwin.set_nav_colorizer(my_colorizer)
    
    :param callback: the new colorizer
    """
    ...

def set_view_renderer_type(v: TWidget, rt: tcc_renderer_type_t) -> None:
    r"""Set the type of renderer to use in a view (ui_set_renderer_type)
    
    """
    ...

def show_wait_box(message: str) -> None:
    r"""Display a dialog box with "Please wait...". The behavior of the dialog box can be configured with well-known 
    tokens, that should be placed at the start of the format string: 
     "NODELAY\n": the dialog will show immediately, instead of 
     appearing after usual grace threshold 
     "HIDECANCEL\n": the cancel button won't be added to the dialog box 
     and user_cancelled() will always return false (but 
     can be called to refresh UI) 
     Using "HIDECANCEL" implies "NODELAY" 
    Plugins must call hide_wait_box() to close the dialog box, otherwise 
    the user interface will remain disabled. 
     Note that, if the wait dialog is already visible, show_wait_box() will 
     1) push the currently-displayed text on a stack 
     2) display the new text 
    Then, when hide_wait_box() is called, if that stack isn't empty its top 
    label will be popped and restored in the wait dialog. 
    This implies that a plugin should call hide_wait_box() exactly as many 
    times as it called show_wait_box(), or the wait dialog might remain 
    visible and block the UI. 
    Also, in case the plugin knows the wait dialog is currently displayed, 
    alternatively it can call replace_wait_box(), to replace the text of the
    dialog without pushing the currently-displayed text on the stack. 
            
    """
    ...

def str2ea(args: Any) -> uint64:
    r"""Convert string to linear address. Tries to interpret the string as: 
    1) "current IP" keyword if supported by assembler (e.g. "$" in x86) 
    2) segment:offset expression, where "segment" may be a name or a fixed segment register (e.g. cs, ds) 
    3) just segment name/register (translated to segment's start address) 
    4) a name in the database (or debug name during debugging) 
    5) hexadecimal value without prefix or suffix 
    6) +delta or -delta, where numerical 'delta' is added to or subtracted from 'screen_ea' 
    7) register name (only during debugging) 
    8) if all else fails, try to evaluate 'str' as an IDC expression
    
    :param str: string to parse
    :param screen_ea: the current address in the disassembly/pseudocode view
    :returns: success
    """
    ...

def str2ea_ex(args: Any) -> uint64:
    r"""Same as str2ea() but possibly with some steps skipped. 
            
    :param out: the buffer to put the result
    :param str: string to parse
    :param screen_ea: the current address in the disassembly/pseudocode view
    :param flags: see String to address conversion flags
    :returns: success
    """
    ...

def str2user(str: Any) -> Any:
    r"""Insert C-style escape characters to string
    
    :param str: the input string
    :returns: new string with escape characters inserted, or None
    """
    ...

def strarray(array: strarray_t, array_size: size_t, code: int) -> str:
    r"""Find a line with the specified code in the strarray_t array. If the last element of the array has code==0 then it is considered as the default entry. 
    If no default entry exists and the code is not found, strarray() returns "". 
            
    """
    ...

def sync_sources(what: sync_source_t, _with: sync_source_t, sync: bool) -> bool:
    r"""[Un]synchronize sources 
            
    :returns: success
    """
    ...

def take_database_snapshot(snapshot: Any) -> Any:
    r"""Take a database snapshot.
    
    :param snapshot: the snapshot object
    :returns: a tuple (success, error-message)
    """
    ...

def textctrl_info_t_assign(_self: Any, other: Any) -> bool:
    ...

def textctrl_info_t_create() -> Any:
    ...

def textctrl_info_t_destroy(py_obj: Any) -> bool:
    ...

def textctrl_info_t_get_clink(_self: Any) -> textctrl_info_t:
    ...

def textctrl_info_t_get_clink_ptr(_self: Any) -> Any:
    ...

def textctrl_info_t_get_flags(_self: Any) -> int:
    ...

def textctrl_info_t_get_tabsize(_self: Any) -> int:
    ...

def textctrl_info_t_get_text(_self: Any) -> str:
    ...

def textctrl_info_t_set_flags(_self: Any, flags: int) -> bool:
    ...

def textctrl_info_t_set_tabsize(_self: Any, tabsize: int) -> bool:
    ...

def textctrl_info_t_set_text(_self: Any, s: str) -> bool:
    ...

def ui_load_new_file(temp_file: str, filename: str, pli: linput_t, neflags: ushort, ploaders: load_info_t) -> bool:
    r"""Display a load file dialog and load file (ui_load_file). 
            
    :param temp_file: name of the file with the extracted archive member.
    :param filename: the name of input file as is, library or archive name
    :param pli: loader input source, may be changed to point to temp_file
    :param neflags: combination of NEF_... bits (see Load file flags)
    :param ploaders: list of loaders which accept file, may be changed for loaders of temp_file
    :returns: true: file was successfully loaded
    :returns: false: otherwise
    """
    ...

def ui_run_debugger(dbgopts: str, exename: str, argc: int, argv: Any) -> bool:
    r"""Load a debugger plugin and run the specified program (ui_run_dbg). 
            
    :param dbgopts: value of the -r command line switch
    :param exename: name of the file to run
    :param argc: number of arguments for the executable
    :param argv: argument vector
    :returns: success
    """
    ...

def unmark_selection() -> None:
    r"""Unmark selection (ui_unmarksel)
    
    """
    ...

def unregister_action(name: str) -> bool:
    r"""Delete a previously-registered action (ui_unregister_action). 
            
    :param name: name of action
    :returns: success
    """
    ...

def unregister_timer(timer_obj: Any) -> Any:
    r"""Unregister a timer
    
    NOTE: After the timer has been deleted, the timer_obj will become invalid.
    
    :param timer_obj: a timer object previously returned by a register_timer()
    :returns: Boolean
    """
    ...

def update_action_checkable(name: str, checkable: bool) -> bool:
    r"""Update an action's checkability (ui_update_action_attr). 
            
    :param name: action name
    :param checkable: new checkability
    :returns: success
    """
    ...

def update_action_checked(name: str, checked: bool) -> bool:
    r"""Update an action's checked state (ui_update_action_attr). 
            
    :param name: action name
    :param checked: new checked state
    :returns: success
    """
    ...

def update_action_icon(name: str, icon: int) -> bool:
    r"""Update an action's icon (ui_update_action_attr). 
            
    :param name: action name
    :param icon: new icon id
    :returns: success
    """
    ...

def update_action_label(name: str, label: str) -> bool:
    r"""Update an action's label (ui_update_action_attr). 
            
    :param name: action name
    :param label: new label
    :returns: success
    """
    ...

def update_action_shortcut(name: str, shortcut: str) -> bool:
    r"""Update an action's shortcut (ui_update_action_attr). 
            
    :param name: action name
    :param shortcut: new shortcut
    :returns: success
    """
    ...

def update_action_state(name: str, state: action_state_t) -> bool:
    r"""Update an action's state (ui_update_action_attr). 
            
    :param name: action name
    :param state: new state
    :returns: success
    """
    ...

def update_action_tooltip(name: str, tooltip: str) -> bool:
    r"""Update an action's tooltip (ui_update_action_attr). 
            
    :param name: action name
    :param tooltip: new tooltip
    :returns: success
    """
    ...

def update_action_visibility(name: str, visible: bool) -> bool:
    r"""Update an action's visibility (ui_update_action_attr). 
            
    :param name: action name
    :param visible: new visibility
    :returns: success
    """
    ...

def user_cancelled() -> bool:
    r"""Test the cancellation flag (ui_test_cancelled). 
            
    :returns: true: Cancelled, a message is displayed
    :returns: false: Not cancelled
    """
    ...

def warning(message: Any) -> Any:
    r"""Display a message in a warning message box
    
    :param message: message to print
    """
    ...

AA_CHECKABLE: int  # 6
AA_CHECKED: int  # 7
AA_ICON: int  # 4
AA_LABEL: int  # 1
AA_NONE: int  # 0
AA_SHORTCUT: int  # 2
AA_STATE: int  # 5
AA_TOOLTIP: int  # 3
AA_VISIBILITY: int  # 8
ACF_HAS_FIELD_DIRTREE_SELECTION: int  # 4
ACF_HAS_SELECTION: int  # 1
ACF_HAS_SOURCE: int  # 8
ACF_HAS_TYPE_REF: int  # 16
ACF_XTRN_EA: int  # 2
ADF_CHECKABLE: int  # 64
ADF_CHECKED: int  # 128
ADF_GLOBAL: int  # 16
ADF_NO_HIGHLIGHT: int  # 32
ADF_NO_UNDO: int  # 2
ADF_OT_MASK: int  # 12
ADF_OT_PLUGIN: int  # 0
ADF_OT_PLUGMOD: int  # 4
ADF_OT_PROCMOD: int  # 8
ADF_OWN_HANDLER: int  # 1
AHF_VERSION: int  # 1
AHF_VERSION_MASK: int  # 255
ASKBTN_BTN1: int  # 1
ASKBTN_BTN2: int  # 0
ASKBTN_BTN3: int  # -1
ASKBTN_CANCEL: int  # -1
ASKBTN_NO: int  # 0
ASKBTN_YES: int  # 1
AST_DISABLE: int  # 7
AST_DISABLE_ALWAYS: int  # 4
AST_DISABLE_FOR_IDB: int  # 5
AST_DISABLE_FOR_WIDGET: int  # 6
AST_ENABLE: int  # 3
AST_ENABLE_ALWAYS: int  # 0
AST_ENABLE_FOR_IDB: int  # 1
AST_ENABLE_FOR_WIDGET: int  # 2
BWN_ADDRWATCH: int  # 45
BWN_BOOKMARKS: int  # 57
BWN_BPTS: int  # 13
BWN_CALLS: int  # 11
BWN_CALLS_CALLEES: int  # 48
BWN_CALLS_CALLERS: int  # 47
BWN_CALL_STACK: int  # 17
BWN_CHOOSER: int  # 35
BWN_CLI: int  # 31
BWN_CMDPALCSR: int  # 41
BWN_CMDPALWIN: int  # 42
BWN_CPUREGS: int  # 38
BWN_CUSTVIEW: int  # 44
BWN_CV_LINE_INFOS: int  # 51
BWN_DISASM: int  # 27
BWN_DISASMS: int  # 27
BWN_DISASM_ARROWS: int  # 50
BWN_EXPORTS: int  # 0
BWN_FRAME: int  # 25
BWN_FUNCS: int  # 3
BWN_HEXVIEW: int  # 28
BWN_IMPORTS: int  # 1
BWN_LOCALS: int  # 33
BWN_LOCTYPS: int  # 10
BWN_MDVIEWCSR: int  # 49
BWN_MICROCODE: int  # 61
BWN_MODULES: int  # 15
BWN_NAMES: int  # 2
BWN_NAVBAND: int  # 26
BWN_NOTEPAD: int  # 29
BWN_OUTPUT: int  # 30
BWN_PROBS: int  # 12
BWN_PSEUDOCODE: int  # 46
BWN_SCRIPTS_CSR: int  # 56
BWN_SEARCH: int  # 19
BWN_SEGREGS: int  # 6
BWN_SEGS: int  # 5
BWN_SELS: int  # 7
BWN_SHORTCUTCSR: int  # 36
BWN_SHORTCUTWIN: int  # 37
BWN_SIGNS: int  # 8
BWN_SNIPPETS: int  # 43
BWN_SNIPPETS_CSR: int  # 55
BWN_SO_OFFSETS: int  # 40
BWN_SO_STRUCTS: int  # 39
BWN_SRCPTHMAP_CSR: int  # 52
BWN_SRCPTHUND_CSR: int  # 53
BWN_STKVIEW: int  # 34
BWN_STRINGS: int  # 4
BWN_THREADS: int  # 14
BWN_TICSR: int  # 10
BWN_TILIST: int  # 58
BWN_TILS: int  # 9
BWN_TILVIEW: int  # 10
BWN_TIL_VIEW: int  # 59
BWN_TRACE: int  # 16
BWN_TYPE_EDITOR: int  # 60
BWN_UNDOHIST: int  # 54
BWN_UNKNOWN: int  # -1
BWN_WATCH: int  # 32
BWN_XREFS: int  # 18
BWN_XREF_TREE: int  # 62
CB_CANCEL: int  # -7
CB_CLOSE: int  # -3
CB_DESTROYING: int  # -5
CB_INIT: int  # -1
CB_INVISIBLE: int  # -4
CB_NO: int  # -6
CB_YES: int  # -2
CDVF_LINEICONS: int  # 2
CDVF_NOLINES: int  # 1
CDVF_STATUSBAR: int  # 4
CDVH_LINES_ALIGNMENT: int  # 1009
CDVH_LINES_CLICK: int  # 1002
CDVH_LINES_DBLCLICK: int  # 1003
CDVH_LINES_DRAWICON: int  # 1005
CDVH_LINES_ICONMARGIN: int  # 1007
CDVH_LINES_LINENUM: int  # 1006
CDVH_LINES_POPUP: int  # 1004
CDVH_LINES_RADIX: int  # 1008
CDVH_SRCVIEW: int  # 1001
CDVH_USERDATA: int  # 1000
CH2_HAS_INODE2INDEX: int  # 2
CH2_LAZY_LOADED: int  # 1
CHCOL_DEC: int  # 196608
CHCOL_DEFHIDDEN: int  # 1048576
CHCOL_DRAGHINT: int  # 2097152
CHCOL_EA: int  # 262144
CHCOL_FNAME: int  # 327680
CHCOL_FORMAT: int  # 458752
CHCOL_HEX: int  # 131072
CHCOL_INODENAME: int  # 4194304
CHCOL_PATH: int  # 65536
CHCOL_PLAIN: int  # 0
CHITEM_BOLD: int  # 1
CHITEM_GRAY: int  # 16
CHITEM_ITALIC: int  # 2
CHITEM_STRIKE: int  # 8
CHITEM_UNDER: int  # 4
CHOOSER_MENU_EDIT: int  # 0
CHOOSER_MENU_JUMP: int  # 1
CHOOSER_MENU_SEARCH: int  # 2
CHOOSER_MULTI_SELECTION: int  # 2
CHOOSER_NOMAINMENU: str  # NOMAINMENU

CHOOSER_NOSTATUSBAR: str  # NOSTATUSBAR

CHOOSER_NO_SELECTION: int  # 1
CHOOSER_POPUP_MENU: int  # 4
CH_ATTRS: int  # 32
CH_BUILTIN_MASK: int  # 33030144
CH_BUILTIN_SHIFT: int  # 19
CH_CAN_DEL: int  # 512
CH_CAN_EDIT: int  # 1024
CH_CAN_INS: int  # 256
CH_CAN_REFRESH: int  # 2048
CH_FORCE_DEFAULT: int  # 128
CH_HAS_DIFF: int  # 268435456
CH_HAS_DIRTREE: int  # 33554432
CH_KEEP: int  # 2
CH_MODAL: int  # 1
CH_MULTI: int  # 4
CH_MULTI_EDIT: int  # 8
CH_NOBTNS: int  # 16
CH_NOIDB: int  # 64
CH_NON_PERSISTED_TREE: int  # -2147483648
CH_NO_FILTER: int  # 1073741824
CH_NO_SORT: int  # 536870912
CH_NO_STATUS_BAR: int  # 65536
CH_QFLT: int  # 4096
CH_QFTYP_DEFAULT: int  # 0
CH_QFTYP_FUZZY: int  # 32768
CH_QFTYP_MASK: int  # 57344
CH_QFTYP_NORMAL: int  # 8192
CH_QFTYP_REGEX: int  # 24576
CH_QFTYP_SHIFT: int  # 13
CH_QFTYP_WHOLE_WORDS: int  # 16384
CH_RENAME_IS_EDIT: int  # 262144
CH_RESTORE: int  # 131072
CH_TM_FOLDERS_ONLY: int  # 67108864
CH_TM_FULL_TREE: int  # 134217728
CH_TM_MASK: int  # 201326592
CH_TM_NO_TREE: int  # 0
CH_TM_SHIFT: int  # 26
CH_UNUSED: int  # 64
CK_EXTRA1: int  # 82
CK_EXTRA10: int  # 91
CK_EXTRA11: int  # 92
CK_EXTRA12: int  # 93
CK_EXTRA13: int  # 94
CK_EXTRA14: int  # 95
CK_EXTRA15: int  # 96
CK_EXTRA16: int  # 97
CK_EXTRA2: int  # 83
CK_EXTRA3: int  # 84
CK_EXTRA4: int  # 85
CK_EXTRA5: int  # 86
CK_EXTRA6: int  # 87
CK_EXTRA7: int  # 88
CK_EXTRA8: int  # 89
CK_EXTRA9: int  # 90
CK_TRACE: int  # 80
CK_TRACE_OVL: int  # 81
CLNL_FINDCMT: int  # 4
CLNL_LTRIM: int  # 2
CLNL_RTRIM: int  # 1
CLNL_TRIM: int  # 3
CREATETB_ADV: int  # 1
CVH_CLICK: int  # 6
CVH_CLOSE: int  # 5
CVH_CURPOS: int  # 4
CVH_DBLCLICK: int  # 3
CVH_HELP: int  # 8
CVH_KEYDOWN: int  # 1
CVH_MOUSEMOVE: int  # 9
CVH_POPUP: int  # 2
CVH_QT_AWARE: int  # 7
CVH_USERDATA: int  # 0
CVLF_USE_MOUSE: int  # 1
CVNF_ACT: int  # 4
CVNF_JUMP: int  # 2
CVNF_LAZY: int  # 1
DEFAULT_PLACE_LNNUM: int  # -1
DP_BEFORE: int  # 32
DP_BOTTOM: int  # 8
DP_FLOATING: int  # 128
DP_INSIDE: int  # 16
DP_LEFT: int  # 1
DP_RIGHT: int  # 4
DP_SZHINT: int  # 256
DP_TAB: int  # 64
DP_TOP: int  # 2
GCRF_ALL: int  # 9223372036854775811
GCRF_CURRENT: int  # 9223372036854775810
GCRF_HEADER: int  # 9223372036854775808
GCRF_HIGH_BIT: int  # 9223372036854775808
GCRF_SELECTION: int  # 9223372036854775809
HIF_IDENTIFIER: int  # 1
HIF_LOCKED: int  # 4
HIF_NOCASE: int  # 8
HIF_REGISTER: int  # 2
HIF_SLOT_0: int  # 134217728
HIF_SLOT_1: int  # 402653184
HIF_SLOT_2: int  # 671088640
HIF_SLOT_3: int  # 939524096
HIF_SLOT_4: int  # 1207959552
HIF_SLOT_5: int  # 1476395008
HIF_SLOT_6: int  # 1744830464
HIF_SLOT_7: int  # 2013265920
HIF_SLOT_SHIFT: int  # 28
HIF_USE_SLOT: int  # 134217728
HIST_CMD: int  # 7
HIST_CMT: int  # 2
HIST_DIR: int  # 8
HIST_FILE: int  # 5
HIST_IDENT: int  # 4
HIST_IDENT2: int  # 9
HIST_SEG: int  # 1
HIST_SRCH: int  # 3
HIST_TYPE: int  # 6
IDALIB_API_MAGIC: int  # 8339911660797952
IDA_DEBUG_ACCESSIBILITY: int  # 524288
IDA_DEBUG_ALREADY: int  # 8192
IDA_DEBUG_ALWAYS: int  # -1
IDA_DEBUG_APPCALL: int  # 131072
IDA_DEBUG_CHECKMEM: int  # 256
IDA_DEBUG_CONFIG: int  # 128
IDA_DEBUG_DBGINFO: int  # 4194304
IDA_DEBUG_DEBUGGER: int  # 65536
IDA_DEBUG_DEMANGLE: int  # 1024
IDA_DEBUG_DREFS: int  # 1
IDA_DEBUG_FLIRT: int  # 4
IDA_DEBUG_IDP: int  # 8
IDA_DEBUG_IDS: int  # 64
IDA_DEBUG_INTERNET: int  # 1048576
IDA_DEBUG_LDR: int  # 16
IDA_DEBUG_LICENSE: int  # 512
IDA_DEBUG_LUMINA: int  # 8388608
IDA_DEBUG_NETWORK: int  # 1048576
IDA_DEBUG_NOTIFY: int  # 32768
IDA_DEBUG_OFFSET: int  # 2
IDA_DEBUG_PLUGIN: int  # 32
IDA_DEBUG_QUEUE: int  # 2048
IDA_DEBUG_RANGECB: int  # 134217728
IDA_DEBUG_REGEX: int  # 33554432
IDA_DEBUG_ROLLBACK: int  # 4096
IDA_DEBUG_SIMPLEX: int  # 2097152
IDA_DEBUG_SRCDBG: int  # 262144
IDA_DEBUG_SUBPROC: int  # 67108864
IDA_DEBUG_THEMES: int  # 16777216
IDA_DEBUG_TIL: int  # 16384
IDCHK_ARG: int  # -1
IDCHK_KEY: int  # -2
IDCHK_MAX: int  # -3
IDCHK_OK: int  # 0
IK_ADD: int  # 107
IK_APPS: int  # 93
IK_BACK: int  # 8
IK_BROWSER_BACK: int  # 166
IK_BROWSER_FAVORITES: int  # 171
IK_BROWSER_FORWARD: int  # 167
IK_BROWSER_HOME: int  # 172
IK_BROWSER_REFRESH: int  # 168
IK_BROWSER_SEARCH: int  # 170
IK_BROWSER_STOP: int  # 169
IK_CANCEL: int  # 3
IK_CAPITAL: int  # 20
IK_CLEAR: int  # 12
IK_CONTROL: int  # 17
IK_DECIMAL: int  # 110
IK_DELETE: int  # 46
IK_DIVIDE: int  # 111
IK_DOWN: int  # 40
IK_END: int  # 35
IK_ESCAPE: int  # 27
IK_EXECUTE: int  # 43
IK_F1: int  # 112
IK_F10: int  # 121
IK_F11: int  # 122
IK_F12: int  # 123
IK_F13: int  # 124
IK_F14: int  # 125
IK_F15: int  # 126
IK_F16: int  # 127
IK_F17: int  # 128
IK_F18: int  # 129
IK_F19: int  # 130
IK_F2: int  # 113
IK_F20: int  # 131
IK_F21: int  # 132
IK_F22: int  # 133
IK_F23: int  # 134
IK_F24: int  # 135
IK_F3: int  # 114
IK_F4: int  # 115
IK_F5: int  # 116
IK_F6: int  # 117
IK_F7: int  # 118
IK_F8: int  # 119
IK_F9: int  # 120
IK_HELP: int  # 47
IK_HOME: int  # 36
IK_INSERT: int  # 45
IK_KANA: int  # 21
IK_LAUNCH_APP1: int  # 182
IK_LAUNCH_APP2: int  # 183
IK_LAUNCH_MAIL: int  # 180
IK_LAUNCH_MEDIA_SELECT: int  # 181
IK_LCONTROL: int  # 162
IK_LEFT: int  # 37
IK_LMENU: int  # 164
IK_LSHIFT: int  # 160
IK_LWIN: int  # 91
IK_MEDIA_NEXT_TRACK: int  # 176
IK_MEDIA_PLAY_PAUSE: int  # 179
IK_MEDIA_PREV_TRACK: int  # 177
IK_MEDIA_STOP: int  # 178
IK_MENU: int  # 18
IK_MODECHANGE: int  # 31
IK_MULTIPLY: int  # 106
IK_NEXT: int  # 34
IK_NUMLOCK: int  # 144
IK_NUMPAD0: int  # 96
IK_NUMPAD1: int  # 97
IK_NUMPAD2: int  # 98
IK_NUMPAD3: int  # 99
IK_NUMPAD4: int  # 100
IK_NUMPAD5: int  # 101
IK_NUMPAD6: int  # 102
IK_NUMPAD7: int  # 103
IK_NUMPAD8: int  # 104
IK_NUMPAD9: int  # 105
IK_OEM_1: int  # 186
IK_OEM_102: int  # 226
IK_OEM_2: int  # 191
IK_OEM_3: int  # 192
IK_OEM_4: int  # 219
IK_OEM_5: int  # 220
IK_OEM_6: int  # 221
IK_OEM_7: int  # 222
IK_OEM_CLEAR: int  # 254
IK_OEM_COMMA: int  # 188
IK_OEM_FJ_MASSHOU: int  # 147
IK_OEM_FJ_TOUROKU: int  # 148
IK_OEM_MINUS: int  # 189
IK_OEM_PERIOD: int  # 190
IK_OEM_PLUS: int  # 187
IK_PAUSE: int  # 19
IK_PLAY: int  # 250
IK_PRINT: int  # 42
IK_PRIOR: int  # 33
IK_RCONTROL: int  # 163
IK_RETURN: int  # 13
IK_RIGHT: int  # 39
IK_RMENU: int  # 165
IK_RSHIFT: int  # 161
IK_RWIN: int  # 92
IK_SCROLL: int  # 145
IK_SELECT: int  # 41
IK_SEPARATOR: int  # 108
IK_SHIFT: int  # 16
IK_SLEEP: int  # 95
IK_SNAPSHOT: int  # 44
IK_SPACE: int  # 32
IK_SUBTRACT: int  # 109
IK_TAB: int  # 9
IK_UP: int  # 38
IK_VOLUME_DOWN: int  # 174
IK_VOLUME_MUTE: int  # 173
IK_VOLUME_UP: int  # 175
IK_ZOOM: int  # 251
IWID_ADDRWATCH: int  # 35184372088832
IWID_ALL: int  # 18446744073709551615
IWID_ANY_LISTING: int  # 288318337518141440
IWID_BOOKMARKS: int  # 144115188075855872
IWID_BPTS: int  # 8192
IWID_CALLS: int  # 2048
IWID_CALLS_CALLEES: int  # 281474976710656
IWID_CALLS_CALLERS: int  # 140737488355328
IWID_CALL_STACK: int  # 131072
IWID_CHOOSER: int  # 34359738368
IWID_CLI: int  # 2147483648
IWID_CMDPALCSR: int  # 2199023255552
IWID_CMDPALWIN: int  # 4398046511104
IWID_CPUREGS: int  # 274877906944
IWID_CUSTVIEW: int  # 17592186044416
IWID_CV_LINE_INFOS: int  # 2251799813685248
IWID_DISASM: int  # 134217728
IWID_DISASMS: int  # 134217728
IWID_DISASM_ARROWS: int  # 1125899906842624
IWID_EA_LISTING: int  # 70369146830848
IWID_EXPORTS: int  # 1
IWID_FRAME: int  # 33554432
IWID_FUNCS: int  # 8
IWID_HEXVIEW: int  # 268435456
IWID_IMPORTS: int  # 2
IWID_LOCALS: int  # 8589934592
IWID_LOCTYPS: int  # 1024
IWID_MDVIEWCSR: int  # 562949953421312
IWID_MODULES: int  # 32768
IWID_NAMES: int  # 4
IWID_NAVBAND: int  # 67108864
IWID_NOTEPAD: int  # 536870912
IWID_OUTPUT: int  # 1073741824
IWID_PROBS: int  # 4096
IWID_PSEUDOCODE: int  # 70368744177664
IWID_SCRIPTS_CSR: int  # 72057594037927936
IWID_SEARCH: int  # 524288
IWID_SEGREGS: int  # 64
IWID_SEGS: int  # 32
IWID_SELS: int  # 128
IWID_SHORTCUTCSR: int  # 68719476736
IWID_SHORTCUTWIN: int  # 137438953472
IWID_SIGNS: int  # 256
IWID_SNIPPETS: int  # 8796093022208
IWID_SNIPPETS_CSR: int  # 36028797018963968
IWID_SO_OFFSETS: int  # 1099511627776
IWID_SO_STRUCTS: int  # 549755813888
IWID_SRCPTHMAP_CSR: int  # 4503599627370496
IWID_SRCPTHUND_CSR: int  # 9007199254740992
IWID_STKVIEW: int  # 17179869184
IWID_STRINGS: int  # 16
IWID_THREADS: int  # 16384
IWID_TICSR: int  # 1024
IWID_TILIST: int  # 288230376151711744
IWID_TILS: int  # 512
IWID_TILVIEW: int  # 1024
IWID_TIL_VIEW: int  # 576460752303423488
IWID_TRACE: int  # 65536
IWID_TYPE_EDITOR: int  # 1152921504606846976
IWID_UNDOHIST: int  # 18014398509481984
IWID_WATCH: int  # 4294967296
IWID_XREFS: int  # 262144
IWID_XREF_TREE: int  # 4611686018427387904
LECVT_CANCELED: int  # -1
LECVT_ERROR: int  # 0
LECVT_OK: int  # 1
LECVT_WITHIN_LISTING: int  # 1
LROEF_CPS_RANGE: int  # 1
LROEF_FULL_LINE: int  # 0
LROEF_MASK: int  # 16777215
MAX_SPACES_ADDED: int  # 524288
MFF_FAST: int  # 0
MFF_NOWAIT: int  # 4
MFF_READ: int  # 1
MFF_WRITE: int  # 2
PCF_EA_CAPABLE: int  # 1
PCF_MAKEPLACE_ALLOCATES: int  # 2
REG_HINTS_MARKER: str  # 
REG_HINTS_MARKER_LEN: int  # 2
RENADDR_HR: int  # 1
RENADDR_IDA: int  # 0
S2EAOPT_NOCALC: int  # 1
SETMENU_APP: int  # 1
SETMENU_ENSURE_SEP: int  # 8
SETMENU_FIRST: int  # 2
SETMENU_IF_ENABLED: int  # 4
SETMENU_INS: int  # 0
SETMENU_POSMASK: int  # 3
SRCDBG_HINTS_MARKER: str  # ~
SRCDBG_HINTS_MARKER_LEN: int  # 2
SVF_COPY_LINES: int  # 0
SVF_LINES_BYPTR: int  # 1
SWIG_PYTHON_LEGACY_BOOL: int  # 1
TCCPT_IDAPLACE: int  # 3
TCCPT_INVALID: int  # 0
TCCPT_PLACE: int  # 1
TCCPT_SIMPLELINE_PLACE: int  # 2
TCCPT_TIPLACE: int  # 4
TCCRT_FLAT: int  # 1
TCCRT_GRAPH: int  # 2
TCCRT_INVALID: int  # 0
TCCRT_PROXIMITY: int  # 3
UIJMP_ACTIVATE: int  # 1
UIJMP_ANYVIEW: int  # 0
UIJMP_DONTPUSH: int  # 2
UIJMP_IDAVIEW: int  # 4
UIJMP_IDAVIEW_NEW: int  # 8
UIJMP_VIEWMASK: int  # 12
VES_ALT: int  # 2
VES_CTRL: int  # 4
VES_META: int  # 128
VES_MOUSE_LEFT: int  # 8
VES_MOUSE_MIDDLE: int  # 32
VES_MOUSE_RIGHT: int  # 16
VES_SHIFT: int  # 1
VME_LEFT_BUTTON: int  # 1
VME_MID_BUTTON: int  # 3
VME_RIGHT_BUTTON: int  # 2
VME_UNKNOWN: int  # 0
WCLS_CLOSE_LATER: int  # 8
WCLS_DELETE_LATER: int  # 8
WCLS_DONT_SAVE_SIZE: int  # 4
WCLS_NO_CONTEXT: int  # 2
WCLS_SAVE: int  # 1
WOPN_CLOSED_BY_ESC: int  # 128
WOPN_DP_BEFORE: int  # 2097152
WOPN_DP_BOTTOM: int  # 524288
WOPN_DP_FLOATING: int  # 8388608
WOPN_DP_INSIDE: int  # 1048576
WOPN_DP_INSIDE_BEFORE: int  # 3145728
WOPN_DP_LEFT: int  # 65536
WOPN_DP_MASK: int  # 268369920
WOPN_DP_RIGHT: int  # 262144
WOPN_DP_SHIFT: int  # 16
WOPN_DP_SZHINT: int  # 16777216
WOPN_DP_TAB: int  # 4194304
WOPN_DP_TAB_BEFORE: int  # 6291456
WOPN_DP_TOP: int  # 131072
WOPN_NOT_CLOSED_BY_ESC: int  # 256
WOPN_PERSIST: int  # 64
WOPN_RESTORE: int  # 4
annotations: _Feature  # _Feature((3, 7, 0, 'beta', 1), None, 16777216)
beep_default: int  # 0
chtype_entry: int  # 2
chtype_enum: int  # 12
chtype_enum_by_value_and_size: int  # 13
chtype_func: int  # 6
chtype_generic: int  # 0
chtype_idasgn: int  # 1
chtype_idatil: int  # 9
chtype_name: int  # 3
chtype_segm: int  # 7
chtype_srcp: int  # 10
chtype_stkvar_xref: int  # 4
chtype_strpath: int  # 8
chtype_struct: int  # 11
chtype_xref: int  # 5
ctypes: module
cvar: swigvarlink  # (errorexit, batch, debug, IDALIB_API_MAGIC)
ida_ida: _module_wrapper_t
ida_idaapi: module
ida_pro: module
iek_key_press: int  # 2
iek_key_release: int  # 3
iek_mouse_button_press: int  # 4
iek_mouse_button_release: int  # 5
iek_mouse_wheel: int  # 6
iek_shortcut: int  # 1
iek_unknown: int  # 0
mbox_error: int  # 3
mbox_feedback: int  # 5
mbox_filestruct: int  # 8
mbox_hide: int  # 10
mbox_info: int  # 1
mbox_internal: int  # 0
mbox_nomem: int  # 4
mbox_readerror: int  # 6
mbox_replace: int  # 11
mbox_wait: int  # 9
mbox_warning: int  # 2
mbox_writeerror: int  # 7
msg_activated: int  # 0
msg_click: int  # 2
msg_closed: int  # 4
msg_dblclick: int  # 3
msg_deactivated: int  # 1
msg_keydown: int  # 5
nat_auto: int  # 9
nat_cod: int  # 2
nat_cur: int  # 8
nat_dat: int  # 3
nat_err: int  # 6
nat_ext: int  # 5
nat_fun: int  # 1
nat_gap: int  # 7
nat_hlo: int  # 11
nat_last: int  # 12
nat_lib: int  # 0
nat_lum: int  # 10
nat_und: int  # 4
sys: module  # <module 'sys' (built-in)>
types: module
view_activated: int  # 0
view_click: int  # 3
view_close: int  # 7
view_created: int  # 6
view_curpos: int  # 5
view_dblclick: int  # 4
view_deactivated: int  # 1
view_keydown: int  # 2
view_loc_changed: int  # 10
view_mouse_moved: int  # 11
view_mouse_over: int  # 9
view_switched: int  # 8
weakref: module