from typing import Any, Optional, List, Dict, Tuple, Callable, Union

class Appcall__:
    APPCALL_DEBEV: int  # 2
    APPCALL_MANUAL: int  # 1
    APPCALL_TIMEOUT: int  # 4
    @property
    def Consts(self) -> Any: ...
    def UTF16(self, s: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattr__(self, name_or_ea: Any) -> Any:
        r"""Allows you to call functions as if they were member functions (by returning a callable object)"""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""
        Use self[func_name] syntax if the function name contains invalid characters for an attribute name
        See __getattr___
        
        """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def array(self, type_name: Any) -> Any:
        r"""Defines an array type. Later you need to pack() / unpack()"""
        ...
    def buffer(self, str: Any = None, size: Any = 0, fill: Any = '\x00') -> Any:
        r"""
        Creates a string buffer. The returned value (r) will be a byref object.
        Use r.value to get the contents and r.size to get the buffer's size
        
        """
        ...
    def byref(self, val: Any) -> Any:
        r"""
        Method to create references to immutable objects
        Currently we support references to int/strings
        Objects need not be passed by reference (this will be done automatically)
        
        """
        ...
    def cleanup_appcall(self, tid: Any = 0) -> Any:
        r"""Cleanup after manual appcall. 
                
        :param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
        :returns: eOk if successful, otherwise an error code
        """
        ...
    def cstr(self, val: Any) -> Any:
        ...
    def get_appcall_options(self) -> Any:
        r"""Return the global Appcall options"""
        ...
    def int64(self, v: Any) -> Any:
        r"""Whenever a 64bit number is needed use this method to construct an object"""
        ...
    def obj(self, kwds: Any) -> Any:
        r"""Returns an empty object or objects with attributes as passed via its keywords arguments"""
        ...
    def proto(self, name_or_ea: Any, proto_or_tinfo: Any, flags: Any = None) -> Any:
        r"""
        Allows you to instantiate an appcall (callable object) with the desired prototype
        :param name_or_ea: The name of the function (will be resolved with LocByName())
        :param proto_or_tinfo: function prototype as a string or type of the function as tinfo_t object
        :returns: a callbable Appcall instance with the given prototypes and flags, or
                  an exception if the prototype could not be parsed or the address is not resolvable.
        
        """
        ...
    def set_appcall_options(self, opt: Any) -> Any:
        r"""Method to change the Appcall options globally (not per Appcall)"""
        ...
    def typedobj(self, typedecl_or_tinfo: Any, ea: Any = None) -> Any:
        r"""
        Returns an appcall object for a type (can be given as tinfo_t object or
        as a string declaration)
        One can then use retrieve() member method
        :param ea: Optional parameter that later can be used to retrieve the type
        :returns: Appcall object or raises ValueError exception
        
        """
        ...
    def unicode(self, s: Any) -> Any:
        ...
    def valueof(self, name: Any, default: Any = 0) -> Any:
        r"""
        If the name could not be resolved then the default value will be returned
        
        :returns: the numeric value of a given name string.
        
        """
        ...

class Appcall_array__:
    r"""This class is used with Appcall.array() method"""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, tp: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def pack(self, L: Any) -> Any:
        r"""Packs a list or tuple into a byref buffer"""
        ...
    def try_to_convert_to_list(self, obj: Any) -> Any:
        r"""Is this object a list? We check for the existance of attribute zero and attribute self.size-1"""
        ...
    def unpack(self, buf: Any, as_list: Any = True) -> Any:
        r"""Unpacks an array back into a list or an object"""
        ...

class Appcall_callable__:
    r"""
    Helper class to issue appcalls using a natural syntax:
      appcall.FunctionNameInTheDatabase(arguments, ....)
    or
      appcall["Function@8"](arguments, ...)
    or
      f8 = appcall["Function@8"]
      f8(arg1, arg2, ...)
    or
      o = appcall.obj()
      i = byref(5)
      appcall.funcname(arg1, i, "hello", o)
    
    """
    @property
    def ea(self) -> Any: ...
    @property
    def fields(self) -> Any: ...
    @property
    def options(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def tif(self) -> Any: ...
    @property
    def timeout(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __call__(self, args: Any) -> Any:
        r"""Make object callable. We redirect execution to idaapi.appcall()"""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, ea: Any, tinfo_or_typestr: Any = None, fields: Any = None) -> Any:
        r"""Initializes an appcall with a given function ea"""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def retrieve(self, src: Any = None, flags: Any = 0) -> Any:
        r"""
        Unpacks a typed object from the database if an ea is given or from a string if a string was passed
        :param src: the address of the object or a string
        :returns: Returns a tuple of boolean and object or error number (Bool, Error | Object).
        
        """
        ...
    def store(self, obj: Any, dest_ea: Any = None, base_ea: Any = 0, flags: Any = 0) -> Any:
        r"""
        Packs an object into a given ea if provided or into a string if no address was passed.
        :param obj: The object to pack
        :param dest_ea: If packing to idb this will be the store location
        :param base_ea: If packing to a buffer, this will be the base that will be used to relocate the pointers
        
        :returns: Tuple(Boolean, packed_string or error code) if packing to a string
        :returns: a return code is returned (0 indicating success) if packing to the database
        
        """
        ...

class Appcall_consts__:
    r"""
    Helper class used by Appcall.Consts attribute
    It is used to retrieve constants via attribute access
    
    """
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattr__(self, attr: Any) -> Any:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, default: Any = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class BasicBlock:
    r"""Basic block class. It is returned by the Flowchart class"""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, id: Any, bb: Any, fc: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def preds(self) -> Any:
        r"""
        Iterates the predecessors list
        
        """
        ...
    def succs(self) -> Any:
        r"""
        Iterates the successors list
        
        """
        ...

class Choose:
    r"""
    Chooser wrapper class.
    
    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    
    """
    ALL_CHANGED: int  # 1
    ALREADY_EXISTS: int  # -3
    CHCOL_DEC: int  # 196608
    CHCOL_DEFHIDDEN: int  # 1048576
    CHCOL_DRAGHINT: int  # 2097152
    CHCOL_EA: int  # 262144
    CHCOL_FNAME: int  # 327680
    CHCOL_FORMAT: int  # 458752
    CHCOL_HEX: int  # 131072
    CHCOL_INODENAME: int  # 4194304
    CHCOL_PATH: int  # 65536
    CHCOL_PLAIN: int  # 0
    CH_ATTRS: int  # 32
    CH_BUILTIN_MASK: int  # 33030144
    CH_BUILTIN_SHIFT: int  # 19
    CH_CAN_DEL: int  # 512
    CH_CAN_EDIT: int  # 1024
    CH_CAN_INS: int  # 256
    CH_CAN_REFRESH: int  # 2048
    CH_FORCE_DEFAULT: int  # 128
    CH_HAS_DIFF: int  # 268435456
    CH_HAS_DIRTREE: int  # 33554432
    CH_MODAL: int  # 1
    CH_MULTI: int  # 4
    CH_NOBTNS: int  # 16
    CH_NOIDB: int  # 64
    CH_NO_STATUS_BAR: int  # 65536
    CH_QFLT: int  # 4096
    CH_QFTYP_DEFAULT: int  # 0
    CH_QFTYP_FUZZY: int  # 32768
    CH_QFTYP_MASK: int  # 57344
    CH_QFTYP_NORMAL: int  # 8192
    CH_QFTYP_REGEX: int  # 24576
    CH_QFTYP_SHIFT: int  # 13
    CH_QFTYP_WHOLE_WORDS: int  # 16384
    CH_RENAME_IS_EDIT: int  # 262144
    CH_RESTORE: int  # 131072
    EMPTY_CHOOSER: int  # -2
    NOTHING_CHANGED: int  # 0
    NO_ATTR: int  # -4
    NO_SELECTION: int  # -1
    SELECTION_CHANGED: int  # 2
    def Activate(self) -> Any:
        r"""Activates a visible chooser"""
        ...
    def AddCommand(self, caption: Any, flags: Any = 4, menu_index: Any = -1, icon: Any = -1, emb: Any = None, shortcut: Any = None) -> Any:
        ...
    def Close(self) -> Any:
        r"""Closes the chooser"""
        ...
    def Embedded(self, create_chobj: Any = False) -> Any:
        r"""
        Creates an embedded chooser (as opposed to Show())
        :returns: Returns 0 on success or NO_ATTR
        
        """
        ...
    def GetEmbSelection(self) -> Any:
        r"""
        Deprecated. For embedded choosers, the selection is
        available through 'Form.EmbeddedChooserControl.selection'
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def OnClose(self) -> Any:
        r"""
        The chooser window is closed.
        
        """
        ...
    def OnDeleteLine(self, sel: Any) -> Any:
        r"""
        User deleted an element
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnEditLine(self, sel: Any) -> Any:
        r"""
        User asked to edit an element.
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnGetDirTree(self) -> Any:
        r"""
        Get the dirtree_t that will be used to present a tree-like
        structure to the user (see CH_HAS_DIRTREE)
        
        :returns: the dirtree_t, or None
        
        """
        ...
    def OnGetEA(self, n: Any) -> Any:
        r"""
        Get the address of an element
        
        When this function returns valid addresses:
          * If any column has the `CHCOL_FNAME` flag, rows will
            be colored according to the attributes of the functions
            who own those addresses (extern, library function,
            Lumina, ... - similar to what the "Functions" widget does)
          * When a selection is present and the user presses `<Enter>`
            (`<Shift+Enter>` if the chooser is modal), IDA will jump
            to that address (through jumpto())
        :param n: element number (0-based)
        :returns: the effective address, ida_idaapi.BADADDR if the element has no address
        
        """
        ...
    def OnGetIcon(self, n: Any) -> Any:
        r"""
        Get an icon to associate with the first cell of an element
        
        :param n: index of the element
        :returns: an icon ID
        
        """
        ...
    def OnGetLine(self, n: Any) -> Any:
        r"""
        Get data for an element
        
        This callback is mandatory
        
        :param n: the index to fetch data for
        :returns: a list of strings
        
        """
        ...
    def OnGetLineAttr(self, n: Any) -> Any:
        r"""
        Get attributes for an element
        
        :param n: index of the element
        :returns: a tuple (color, flags)
        
        """
        ...
    def OnGetSize(self) -> Any:
        r"""
        Get the number of elements in the chooser.
        
        This callback is mandatory
        
        :returns: the number of elements
        
        """
        ...
    def OnIndexToDiffpos(self, n: Any) -> Any:
        r"""
        Map an element index to a diffpos_t
        
        This callback is mandatory if CH_HAS_DIFF is specified
        
        :param n: index of the element
        :returns: the diffpos
        
        """
        ...
    def OnIndexToInode(self, n: Any) -> Any:
        r"""
        Map an element index to a dirtree_t inode
        
        This callback is mandatory if CH_HAS_DIRTREE is specified
        
        :param n: index of the element
        :returns: the inode number
        
        """
        ...
    def OnInit(self) -> Any:
        r"""
        Initialize the chooser and populate it.
        
        This callback is optional
        
        """
        ...
    def OnInsertLine(self, sel: Any) -> Any:
        r"""
        User asked to insert an element
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnLazyLoadDir(self, path: Any) -> Any:
        r"""
        Callback for lazy-loaded, dirtree-based choosers;
        the function will be called when a folder is expanded and it has
        not been loaded before. The implementation should use the
        given dirtree's link() or mkdir() methods to add the folder contents.
        
        :param path: an absolute dirtree path to the directory that is being expanded
        :returns: success
        
        """
        ...
    def OnPopup(self, widget: Any, popup_handle: Any) -> Any:
        ...
    def OnRefresh(self, sel: Any) -> Any:
        r"""
        The chooser needs to be refreshed.
        It returns the new positions of the selected items.
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnSelectLine(self, sel: Any) -> Any:
        r"""
        User pressed the enter key, or double-clicked a selection
        
        :param sel: the current selection
        :returns: a tuple (changed, selection)
        
        """
        ...
    def OnSelectionChange(self, sel: Any) -> Any:
        r"""
        Selection changed
        
        :param sel: the new selection
        
        """
        ...
    def Refresh(self) -> Any:
        r"""Causes the refresh callback to trigger"""
        ...
    def Show(self, modal: Any = False) -> Any:
        r"""
        Activates or creates a chooser window
        :param modal: Display as modal dialog
        :returns: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any, cols: Any, flags: Any = 0, popup_names: Any = None, icon: Any = -1, x1: Any = -1, y1: Any = -1, x2: Any = -1, y2: Any = -1, deflt: Any = None, embedded: Any = False, width: Any = None, height: Any = None, forbidden_cb: Any = 0, flags2: Any = 0) -> Any:
        r"""
        Constructs a chooser window.
        :param title: The chooser title
        :param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        :param flags: One of CH_XXXX constants
        :param flags2: One of CH2_XXXX constants
        :param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        :param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        :param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        :param x1: The default location (for txt-version)
        :param y1: The default location (for txt-version)
        :param x2: The default location (for txt-version)
        :param y2: The default location (for txt-version)
        :param embedded: Create as embedded chooser
        :param width: Embedded chooser width
        :param height: Embedded chooser height
        :param forbidden_cb: Explicitly forbidden callbacks
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust_last_item(self, n: Any) -> Any:
        r"""
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        :param n: line number of the remaining select item
        :returns: list of selected lines numbers (one element or empty)
        
        """
        ...

class CustomIDAMemo(View_Hooks):
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class DBG_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dbg_bpt(self, tid: thid_t, bptea: ida_idaapi.ea_t) -> int:
        r"""A user defined breakpoint was reached. 
                  
        :param tid: (thid_t)
        :param bptea: (::ea_t)
        """
        ...
    def dbg_bpt_changed(self, bptev_code: int, bpt: bpt_t) -> None:
        r"""Breakpoint has been changed. 
                  
        :param bptev_code: (int) Breakpoint modification events
        :param bpt: (bpt_t *)
        """
        ...
    def dbg_exception(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exc_code: int, exc_can_cont: bool, exc_ea: ida_idaapi.ea_t, exc_info: str) -> int:
        ...
    def dbg_finished_loading_bpts(self) -> None:
        r"""Finished loading breakpoint info from idb.
        
        """
        ...
    def dbg_information(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, info: str) -> None:
        ...
    def dbg_library_load(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None:
        ...
    def dbg_library_unload(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, info: str) -> None:
        ...
    def dbg_process_attach(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None:
        ...
    def dbg_process_detach(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None:
        ...
    def dbg_process_exit(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exit_code: int) -> None:
        ...
    def dbg_process_start(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, modinfo_name: str, modinfo_base: ida_idaapi.ea_t, modinfo_size: asize_t) -> None:
        ...
    def dbg_request_error(self, failed_command: int, failed_dbg_notification: int) -> None:
        r"""An error occurred during the processing of a request. 
                  
        :param failed_command: (ui_notification_t)
        :param failed_dbg_notification: (dbg_notification_t)
        """
        ...
    def dbg_run_to(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None:
        ...
    def dbg_started_loading_bpts(self) -> None:
        r"""Started loading breakpoint info from idb.
        
        """
        ...
    def dbg_step_into(self) -> None:
        ...
    def dbg_step_over(self) -> None:
        ...
    def dbg_step_until_ret(self) -> None:
        ...
    def dbg_suspend_process(self) -> None:
        r"""The process is now suspended. 
                  
        """
        ...
    def dbg_thread_exit(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t, exit_code: int) -> None:
        ...
    def dbg_thread_start(self, pid: pid_t, tid: thid_t, ea: ida_idaapi.ea_t) -> None:
        ...
    def dbg_trace(self, tid: thid_t, ip: ida_idaapi.ea_t) -> int:
        r"""A step occurred (one instruction was executed). This event notification is only generated if step tracing is enabled. 
                  
        :param tid: (thid_t) thread ID
        :param ip: (::ea_t) current instruction pointer. usually points after the executed instruction
        :returns: 1: do not log this trace event
        :returns: 0: log it
        """
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...

class DecompilationFailure(Exception):
    args: getset_descriptor  # <attribute 'args' of 'BaseException' objects>
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setstate__(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def add_note(self, object: Any) -> Any:
        r"""Exception.add_note(note) --
            add a note to the exception
        """
        ...
    def with_traceback(self, object: Any) -> Any:
        r"""Exception.with_traceback(tb) --
            set self.__traceback__ to tb and return self.
        """
        ...

class FlowChart:
    r"""
    Flowchart class used to determine basic blocks.
    Check ex_gdl_qflow_chart.py for sample usage.
    
    """
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: Any) -> Any:
        r"""
        Returns a basic block
        
        :returns: BasicBlock
        
        """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, f: Any = None, bounds: Any = None, flags: Any = 0) -> Any:
        r"""
        Constructor
        :param f: A func_t type, use get_func(ea) to get a reference
        :param bounds: A tuple of the form (start, end). Used if "f" is None
        :param flags: one of the FC_xxxx flags.
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def refresh(self) -> Any:
        r"""Refreshes the flow chart"""
        ...

class Form:
    FT_ADDR: str  # $
    FT_ASCII: str  # A
    FT_BIN: str  # Y
    FT_BUTTON: str  # B
    FT_CHAR: str  # H
    FT_CHKGRP: str  # C
    FT_CHKGRP2: str  # c
    FT_COLOR: str  # K
    FT_DEC: str  # D
    FT_DIR: str  # F
    FT_DROPDOWN_LIST: str  # b
    FT_ECHOOSER: str  # E
    FT_FILE: str  # f
    FT_FORMCHG: str  # %/
    FT_HEX: str  # N
    FT_HTML_LABEL: str  # h
    FT_IDENT: str  # I
    FT_INT64: str  # l
    FT_MULTI_LINE_TEXT: str  # t
    FT_OCT: str  # O
    FT_RADGRP: str  # R
    FT_RADGRP2: str  # r
    FT_RAWHEX: str  # M
    FT_SEG: str  # S
    FT_SHEX: str  # n
    FT_TYPE: str  # T
    FT_UINT64: str  # L
    def Add(self, name: Any, ctrl: Any, mkattr: Any = True) -> Any:
        r"""
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.
        
        :param name: Control name
        :param ctrl: Control object
        :param mkattr: Create control name / control object as a form attribute
        
        """
        ...
    def AddControls(self, controls: Any, mkattr: Any = True) -> Any:
        r"""
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        :param controls: The control dictionary
        
        """
        ...
    def ButtonInput(self, handler: Any, code: Any = '', swidth: Any = '', hlp: Any = None) -> Any:
        r"""
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        
        """
        ...
    def ChkGroupControl(self, children_names: Any, value: Any = 0, secondary: Any = False) -> Any:
        r"""
        Checkbox group control class.
        It holds a set of checkbox controls
        
        """
        ...
    def ChkGroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Checkbox group item control
        
        """
        ...
    def Close(self, close_normally: Any) -> Any:
        r"""
        Close the form
        :param close_normally: 1: form is closed normally as if the user pressed Enter. 0: form is closed abnormally as if the user pressed Esc
        :returns: None
        
        """
        ...
    def ColorInput(self, value: Any = 0) -> Any:
        r"""
        Color button input control
        
        """
        ...
    def Compile(self) -> Any:
        r"""
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements
        
        :returns: It will raise an exception on failure. Otherwise the return value is ignored
        
        """
        ...
    def CompileEx(self, form: Any) -> Any:
        r"""
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().
        
        The form controls are wrapped inside curly braces: {ControlName}.
        
        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)
        
        :param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        
        """
        ...
    def Compiled(self) -> Any:
        r"""
        Checks if the form has already been compiled
        
        :returns: Boolean
        
        """
        ...
    def Control(self) -> Any:
        ...
    def ControlToFieldTypeIdAndSize(self, ctrl: Any) -> Any:
        r"""
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        
        """
        ...
    def DirInput(self, width: Any = 512, swidth: Any = 80, hlp: Any = None, value: Any = None) -> Any:
        r"""
        Directory browsing control
        
        """
        ...
    def DropdownListControl(self, items: Any = ..., readonly: Any = True, selval: Any = 0, width: Any = 50, swidth: Any = 50, hlp: Any = None) -> Any:
        r"""
        Dropdown control
        This control allows manipulating a dropdown control
        
        """
        ...
    def EmbeddedChooserControl(self, chooser: Any = None, swidth: Any = 40, hlp: Any = None) -> Any:
        r"""
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        
        """
        ...
    def EnableField(self, ctrl: Any, enable: Any) -> Any:
        r"""
        Enable or disable an input field
        :returns: False - no such control
        
        """
        ...
    def Execute(self) -> Any:
        r"""
        Displays a modal dialog containing the compiled form.
        :returns: 1 - ok ; 0 - cancel
        
        """
        ...
    def FileInput(self, width: Any = 512, swidth: Any = 80, save: Any = False, open: Any = False, hlp: Any = None, value: Any = None) -> Any:
        r"""
        File Open/Save input control
        
        """
        ...
    def FindControlById(self, id: Any) -> Any:
        r"""
        Finds a control instance given its id
        
        """
        ...
    def FormChangeCb(self, handler: Any) -> Any:
        r"""
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...
        
        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)
        
        
        """
        ...
    def Free(self) -> Any:
        r"""
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        
        """
        ...
    def GetControlValue(self, ctrl: Any) -> Any:
        r"""
        Returns the control's value depending on its type
        :param ctrl: Form control instance
        :returns: color button, radio controls: integer
        :returns: file/dir input, string input and string label: string
        :returns: embedded chooser control (0-based indices of selected items): integer list
        :returns: for multilinetext control: textctrl_info_t
        :returns: dropdown list controls: string (when editable) or index (when readonly)
        :returns: None: on failure
        
        """
        ...
    def GetFocusedField(self) -> Any:
        r"""
        Get currently focused input field.
        :returns: None if no field is selected otherwise the control ID
        
        """
        ...
    def GroupControl(self, children_names: Any, tag: Any, value: Any = 0) -> Any:
        r"""
        Base class for group controls
        
        """
        ...
    def GroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Base class for group control items
        
        """
        ...
    def InputControl(self, tp: Any, width: Any, swidth: Any, hlp: Any = None, is_relative_offset: Any = False) -> Any:
        r"""
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        
        """
        ...
    def LabelControl(self, tp: Any) -> Any:
        r"""
        Base class for static label control
        
        """
        ...
    def MoveField(self, ctrl: Any, x: Any, y: Any, w: Any, h: Any) -> Any:
        r"""
        Move/resize an input field
        
        :returns: False - no such fiel
        
        """
        ...
    def MultiLineTextControl(self, text: Any = '', flags: Any = 0, tabsize: Any = 0, width: Any = 50, swidth: Any = 50, hlp: Any = None) -> Any:
        r"""
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        
        """
        ...
    def NumericArgument(self, tp: Any, value: Any, i64: Any = None) -> Any:
        r"""
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        :param tp: One of Form.FT_XXX
        
        """
        ...
    def NumericInput(self, tp: Any = None, value: Any = 0, width: Any = 50, swidth: Any = 10, hlp: Any = None, is_relative_offset: Any = False, i64: Any = None) -> Any:
        r"""
        A composite class serving as a base numeric input control class
        
        """
        ...
    def NumericLabel(self, value: Any, tp: Any = None) -> Any:
        r"""
        Numeric label control
        
        """
        ...
    def Open(self) -> Any:
        r"""
        Opens a widget containing the compiled form.
        
        """
        ...
    def RadGroupControl(self, children_names: Any, value: Any = 0, secondary: Any = False) -> Any:
        r"""
        Radiobox group control class.
        It holds a set of radiobox controls
        
        """
        ...
    def RadGroupItemControl(self, tag: Any, parent: Any) -> Any:
        r"""
        Radiobox group item control
        
        """
        ...
    def RefreshField(self, ctrl: Any) -> Any:
        r"""
        Refresh a field
        :returns: False - no such control
        
        """
        ...
    def SetControlValue(self, ctrl: Any, value: Any) -> Any:
        r"""
        Set the control's value depending on its type
        :param ctrl: Form control instance
        :param value: embedded chooser: a 0-base indices list to select embedded chooser items
        :param value: multilinetext: a textctrl_info_t
        :param value: dropdown list: an integer designating the selection index if readonly
                                     a string designating the edit control value if not readonly
        :returns: Boolean true on success
        
        """
        ...
    def SetFocusedField(self, ctrl: Any) -> Any:
        r"""
        Set currently focused input field
        :returns: False - no such control
        
        """
        ...
    def ShowField(self, ctrl: Any, show: Any) -> Any:
        r"""
        Show or hide an input field
        :returns: False - no such control
        
        """
        ...
    def StringArgument(self, size: Any = None, value: Any = None) -> Any:
        r"""
        Argument representing a character buffer
        
        """
        ...
    def StringInput(self, tp: Any = None, width: Any = 1024, swidth: Any = 40, hlp: Any = None, value: Any = None, size: Any = None) -> Any:
        r"""
        Base string input control class.
        This class also constructs a StringArgument
        
        """
        ...
    def StringLabel(self, value: Any, tp: Any = None, size: Any = 1024) -> Any:
        r"""
        String label control
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, name: Any) -> Any:
        r"""Returns a control object by name"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, form: Any, controls: Any) -> Any:
        r"""
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).
        
        :param form: The form string
        :param controls: A dictionary containing the control name as a _key_ and control object as _value_
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def create_string_buffer(self, value: Any, size: Any = None) -> Any:
        ...
    def fieldtype_to_ctype(self, tp: Any, i64: Any = False) -> Any:
        r"""
        Factory method returning a ctype class corresponding to the field type string
        
        """
        ...

class GraphViewer(CustomIDAMemo, View_Hooks):
    def AddCommand(self, title: Any, shortcut: Any) -> Any:
        ...
    def AddEdge(self, src_node: Any, dest_node: Any) -> Any:
        r"""Creates an edge between two given node ids"""
        ...
    def AddNode(self, obj: Any) -> Any:
        r"""Creates a node associated with the given object and returns the node id"""
        ...
    def Clear(self) -> Any:
        r"""Clears all the nodes and edges"""
        ...
    def Close(self) -> Any:
        r"""
        Closes the graph.
        It is possible to call Show() again (which will recreate the graph)
        
        """
        ...
    def Count(self) -> Any:
        r"""Returns the node count"""
        ...
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def OnCommand(self, cmd_id: Any) -> Any:
        ...
    def OnPopup(self, widget: Any, popup_handle: Any) -> Any:
        ...
    def OnRefresh(self) -> Any:
        r"""
        Event called when the graph is refreshed or first created.
        From this event you are supposed to create nodes and edges.
        This callback is mandatory.
        
        NOTE: ***It is important to clear previous nodes before adding nodes.***
        
        :returns: Returning True tells the graph viewer to use the items. Otherwise old items will be used.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def Select(self, node_id: Any) -> Any:
        r"""Selects a node on the graph"""
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def Show(self) -> Any:
        r"""
        Shows an existing graph or creates a new one
        
        :returns: Boolean
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""Returns a reference to the object associated with this node id"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any, close_open: Any = False) -> Any:
        r"""
        Constructs the GraphView object.
        Please do not remove or rename the private fields
        
        :param title: The title of the graph window
        :param close_open: Should it attempt to close an existing graph (with same title) before creating this graph?
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class Hexrays_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin_inlining(self, cdg: codegen_t, decomp_flags: int) -> int:
        r"""Starting to inline outlined functions. 
                  
        :param cdg: (codegen_t *)
        :param decomp_flags: (int)
        :returns: Microcode error code This is an opportunity to inline other ranges.
        """
        ...
    def build_callinfo(self, blk: mblock_t, type: tinfo_t) -> Any:
        r"""Analyzing a call instruction. 
                  
        :param blk: (mblock_t *) blk->tail is the call.
        :param type: (tinfo_t *) buffer for the output type.
        """
        ...
    def callinfo_built(self, blk: mblock_t) -> int:
        r"""A call instruction has been anallyzed. 
                  
        :param blk: (mblock_t *) blk->tail is the call.
        """
        ...
    def calls_done(self, mba: mba_t) -> int:
        r"""All calls have been analyzed. 
                  
        :param mba: (mba_t *) This event is generated immediately after analyzing all calls, before any optimizitions, call unmerging and block merging.
        """
        ...
    def close_pseudocode(self, vu: vdui_t) -> int:
        r"""Pseudocode view is being closed. 
                  
        :param vu: (vdui_t *)
        """
        ...
    def cmt_changed(self, cfunc: cfunc_t, loc: treeloc_t, cmt: str) -> int:
        r"""Comment got changed. 
                  
        :param cfunc: (cfunc_t *)
        :param loc: (const treeloc_t *)
        :param cmt: (const char *)
        """
        ...
    def collect_warnings(self, cfunc: cfunc_t) -> int:
        r"""Collect warning messages from plugins. These warnings will be displayed at the function header, after the user-defined comments. 
                  
        :param cfunc: (cfunc_t *)
        """
        ...
    def combine(self, blk: mblock_t, insn: minsn_t) -> int:
        r"""Trying to combine instructions of basic block. 
                  
        :param blk: (mblock_t *)
        :param insn: (minsn_t *) Should return: 1 if combined the current instruction with a preceding one -1 if the instruction should not be combined 0 else
        """
        ...
    def create_hint(self, vu: vdui_t) -> Any:
        r"""Create a hint for the current item. 
                  
        :param vu: (vdui_t *)
        :returns: 0: continue collecting hints with other subscribers
        :returns: 1: stop collecting hints
        """
        ...
    def curpos(self, vu: vdui_t) -> int:
        r"""Current cursor position has been changed. (for example, by left-clicking or using keyboard)
        
                  
        :param vu: (vdui_t *)
        """
        ...
    def double_click(self, vu: vdui_t, shift_state: int) -> int:
        r"""Mouse double click. 
                  
        :param vu: (vdui_t *)
        :param shift_state: (int) Should return: 1 if the event has been handled
        """
        ...
    def flowchart(self, fc: qflow_chart_t, mba: mba_t, reachable_blocks: bitset_t, decomp_flags: int) -> int:
        r"""Flowchart has been generated. 
                  
        :param fc: (qflow_chart_t *)
        :param mba: (mba_t *)
        :param reachable_blocks: (bitset_t *)
        :param decomp_flags: (int)
        :returns: Microcode error code
        """
        ...
    def func_printed(self, cfunc: cfunc_t) -> int:
        r"""Function text has been generated. Plugins may modify the text in cfunc_t::sv. However, it is too late to modify the ctree or microcode. The text uses regular color codes (see lines.hpp) COLOR_ADDR is used to store pointers to ctree items. 
                  
        :param cfunc: (cfunc_t *)
        """
        ...
    def glbopt(self, mba: mba_t) -> int:
        r"""Global optimization has been finished. If microcode is modified, MERR_LOOP must be returned. It will cause a complete restart of the optimization. 
                  
        :param mba: (mba_t *)
        :returns: Microcode error code
        """
        ...
    def hook(self) -> bool:
        ...
    def inlined_func(self, cdg: codegen_t, blk: int, mbr: mba_ranges_t, i1: int, i2: int) -> int:
        r"""A set of ranges got inlined. 
                  
        :param cdg: (codegen_t *)
        :param blk: (int) the block containing call/jump to inline
        :param mbr: (mba_ranges_t *) the range to inline
        :param i1: (int) blknum of the first inlined block
        :param i2: (int) blknum of the last inlined block (excluded)
        """
        ...
    def inlining_func(self, cdg: codegen_t, blk: int, mbr: mba_ranges_t) -> int:
        r"""A set of ranges is going to be inlined. 
                  
        :param cdg: (codegen_t *)
        :param blk: (int) the block containing call/jump to inline
        :param mbr: (mba_ranges_t *) the range to inline
        """
        ...
    def interr(self, errcode: int) -> int:
        r"""Internal error has occurred. 
                  
        :param errcode: (int )
        """
        ...
    def keyboard(self, vu: vdui_t, key_code: int, shift_state: int) -> int:
        r"""Keyboard has been hit. 
                  
        :param vu: (vdui_t *)
        :param key_code: (int) VK_...
        :param shift_state: (int) Should return: 1 if the event has been handled
        """
        ...
    def locopt(self, mba: mba_t) -> int:
        r"""Basic block level optimization has been finished. 
                  
        :param mba: (mba_t *)
        :returns: Microcode error code
        """
        ...
    def lvar_cmt_changed(self, vu: vdui_t, v: lvar_t, cmt: str) -> int:
        r"""Local variable comment got changed. 
                  
        :param vu: (vdui_t *)
        :param v: (lvar_t *)
        :param cmt: (const char *) Please note that it is possible to read/write user settings for lvars directly from the idb.
        """
        ...
    def lvar_mapping_changed(self, vu: vdui_t, frm: lvar_t, to: lvar_t) -> int:
        r"""Local variable mapping got changed. 
                  
        :param vu: (vdui_t *)
        :param to: (lvar_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.
        """
        ...
    def lvar_name_changed(self, vu: vdui_t, v: lvar_t, name: str, is_user_name: bool) -> int:
        r"""Local variable got renamed. 
                  
        :param vu: (vdui_t *)
        :param v: (lvar_t *)
        :param name: (const char *)
        :param is_user_name: (bool) Please note that it is possible to read/write user settings for lvars directly from the idb.
        """
        ...
    def lvar_type_changed(self, vu: vdui_t, v: lvar_t, tinfo: tinfo_t) -> int:
        r"""Local variable type got changed. 
                  
        :param vu: (vdui_t *)
        :param v: (lvar_t *)
        :param tinfo: (const tinfo_t *) Please note that it is possible to read/write user settings for lvars directly from the idb.
        """
        ...
    def maturity(self, cfunc: cfunc_t, new_maturity: ctree_maturity_t) -> int:
        r"""Ctree maturity level is being changed. 
                  
        :param cfunc: (cfunc_t *)
        :param new_maturity: (ctree_maturity_t)
        """
        ...
    def mba_maturity(self, mba: mba_t, reqmat: mba_maturity_t) -> int:
        r"""Maturity level of an MBA was changed. 
                  
        :param mba: (mba_t *)
        :param reqmat: (mba_maturity_t) requested maturity level
        :returns: Microcode error code
        """
        ...
    def microcode(self, mba: mba_t) -> int:
        r"""Microcode has been generated. 
                  
        :param mba: (mba_t *)
        :returns: Microcode error code
        """
        ...
    def open_pseudocode(self, vu: vdui_t) -> int:
        r"""New pseudocode view has been opened. 
                  
        :param vu: (vdui_t *)
        """
        ...
    def populating_popup(self, widget: TWidget, popup_handle: TPopupMenu, vu: vdui_t) -> int:
        r"""Populating popup menu. We can add menu items now. 
                  
        :param widget: (TWidget *)
        :param popup_handle: (TPopupMenu *)
        :param vu: (vdui_t *)
        """
        ...
    def pre_structural(self, ct: control_graph_t, cfunc: cfunc_t, g: simple_graph_t) -> int:
        r"""Structure analysis is starting. 
                  
        :param ct: (control_graph_t *) in/out: control graph
        :param cfunc: (cfunc_t *) in: the current function
        :param g: (const simple_graph_t *) in: control flow graph
        :returns: Microcode error code; MERR_BLOCK means that the analysis has been performed by a plugin
        """
        ...
    def prealloc(self, mba: mba_t) -> int:
        r"""Local variables: preallocation step begins. 
                  
        :param mba: (mba_t *) This event may occur several times. Should return: 1 if modified microcode Negative values are Microcode error code
        """
        ...
    def preoptimized(self, mba: mba_t) -> int:
        r"""Microcode has been preoptimized. 
                  
        :param mba: (mba_t *)
        :returns: Microcode error code
        """
        ...
    def print_func(self, cfunc: cfunc_t, vp: vc_printer_t) -> int:
        r"""Printing ctree and generating text. 
                  
        :param cfunc: (cfunc_t *)
        :param vp: (vc_printer_t *) Returns: 1 if text has been generated by the plugin It is forbidden to modify ctree at this event.
        """
        ...
    def prolog(self, mba: mba_t, fc: qflow_chart_t, reachable_blocks: bitset_t, decomp_flags: int) -> int:
        r"""Prolog analysis has been finished. 
                  
        :param mba: (mba_t *)
        :param fc: (qflow_chart_t *)
        :param reachable_blocks: (const bitset_t *)
        :param decomp_flags: (int)
        :returns: Microcode error code This event is generated for each inlined range as well.
        """
        ...
    def refresh_pseudocode(self, vu: vdui_t) -> int:
        r"""Existing pseudocode text has been refreshed. Adding/removing pseudocode lines is forbidden in this event. 
                  
        :param vu: (vdui_t *) See also hxe_text_ready, which happens earlier
        """
        ...
    def resolve_stkaddrs(self, mba: mba_t) -> int:
        r"""The optimizer is about to resolve stack addresses. 
                  
        :param mba: (mba_t *)
        """
        ...
    def right_click(self, vu: vdui_t) -> int:
        r"""Mouse right click. Use hxe_populating_popup instead, in case you want to add items in the popup menu. 
                  
        :param vu: (vdui_t *)
        """
        ...
    def stkpnts(self, mba: mba_t, _sps: stkpnts_t) -> int:
        r"""SP change points have been calculated. 
                  
        :param mba: (mba_t *)
        :returns: Microcode error code This event is generated for each inlined range as well.
        """
        ...
    def structural(self, ct: control_graph_t) -> int:
        r"""Structural analysis has been finished. 
                  
        :param ct: (control_graph_t *)
        """
        ...
    def switch_pseudocode(self, vu: vdui_t) -> int:
        r"""Existing pseudocode view has been reloaded with a new function. Its text has not been refreshed yet, only cfunc and mba pointers are ready. 
                  
        :param vu: (vdui_t *)
        """
        ...
    def text_ready(self, vu: vdui_t) -> int:
        r"""Decompiled text is ready. 
                  
        :param vu: (vdui_t *) This event can be used to modify the output text (sv). Obsolete. Please use hxe_func_printed instead.
        """
        ...
    def unhook(self) -> bool:
        ...

class IDAPython_displayhook:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def displayhook(self, item: Any) -> Any:
        ...
    def displayhook_format(self, item: Any) -> Any:
        ...
    def format_item(self, num_printer: Any, storage: Any, item: Any) -> Any:
        ...
    def format_seq(self, num_printer: Any, storage: Any, item: Any, opn: Any, cls: Any) -> Any:
        ...

class IDAViewWrapper(CustomIDAMemo, View_Hooks):
    r"""
    Deprecated. Use View_Hooks instead.
    
    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    
    """
    def Bind(self) -> Any:
        ...
    def CreateGroups(self, groups_infos: Any) -> Any:
        r"""
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.
        
        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }
        
        :param groups_infos: A list of objects that describe those groups.
        :returns: A [<int>, <int>, ...] list of group nodes, or None (failure).
        
        """
        ...
    def DelNodesInfos(self, nodes: Any) -> Any:
        r"""
        Delete the properties for the given node(s).
        
        :param nodes: A list of node IDs
        
        """
        ...
    def DeleteGroups(self, groups: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to delete the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param new_current: A node to focus on after the groups have been deleted
        :returns: True on success, False otherwise.
        
        """
        ...
    def GetCurrentRendererType(self) -> Any:
        ...
    def GetNodeInfo(self, args: Any) -> Any:
        r"""
        Get the properties for the given node.
        
        :param ni: A node_info_t instance
        :param node: The index of the node.
        :returns: success
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def GetWidgetAsGraphViewer(self) -> Any:
        r"""
        Return the graph_viewer_t underlying this view.
        
        :returns: The graph_viewer_t underlying this view, or None.
        
        """
        ...
    def Refresh(self) -> Any:
        r"""
        Refreshes the view. This causes the OnRefresh() to be called
        
        """
        ...
    def SetCurrentRendererType(self, rtype: Any) -> Any:
        r"""
        Set the current view's renderer.
        
        :param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        
        """
        ...
    def SetGroupsVisibility(self, groups: Any, expand: Any, new_current: Any = -1) -> Any:
        r"""
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.
        
        :param groups: A list of group node numbers.
        :param expand: True to expand the group, False otherwise.
        :param new_current: A node to focus on after the groups have been expanded/collapsed.
        :returns: True on success, False otherwise.
        
        """
        ...
    def SetNodeInfo(self, node_index: Any, node_info: Any, flags: Any) -> Any:
        r"""
        Set the properties for the given node.
        
        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)
        
        :param node_index: The node index.
        :param node_info: An idaapi.node_info_t instance.
        :param flags: An OR'ed value of NIF_* values.
        
        """
        ...
    def SetNodesInfos(self, values: Any) -> Any:
        r"""
        Set the properties for the given nodes.
        
        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})
        
        :param values: A dictionary of 'int -> node_info_t' objects.
        
        """
        ...
    def Unbind(self) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, title: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: Any) -> Any:
        ...
    def view_click(self, view: Any, ve: Any) -> Any:
        ...
    def view_close(self, view: Any, args: Any) -> Any:
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: Any, args: Any) -> Any:
        ...
    def view_dblclick(self, view: Any, ve: Any) -> Any:
        ...
    def view_deactivated(self, view: Any) -> Any:
        ...
    def view_keydown(self, view: Any, key: Any, state: Any) -> Any:
        ...
    def view_loc_changed(self, view: Any, now: Any, was: Any) -> Any:
        ...
    def view_mouse_moved(self, view: Any, ve: Any) -> Any:
        ...
    def view_mouse_over(self, view: Any, ve: Any) -> Any:
        ...
    def view_switched(self, view: Any, rt: Any) -> Any:
        ...

class IDB_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def adding_segm(self, s: segment_t) -> None:
        r"""A segment is being created. 
                  
        :param s: (segment_t *)
        """
        ...
    def allsegs_moved(self, info: segm_move_infos_t) -> None:
        r"""Program rebasing is complete. This event is generated after series of segm_moved events 
                  
        :param info: (segm_move_infos_t *)
        """
        ...
    def auto_empty(self) -> None:
        r"""Info: all analysis queues are empty. This callback is called once when the initial analysis is finished. If the queue is not empty upon the return from this callback, it will be called later again. 
                  
        """
        ...
    def auto_empty_finally(self) -> None:
        r"""Info: all analysis queues are empty definitively. This callback is called only once. 
                  
        """
        ...
    def bookmark_changed(self, index: int, pos: lochist_entry_t, desc: str, operation: int) -> None:
        r"""Boomarked position changed. 
                  
        :param index: (uint32)
        :param pos: (::const lochist_entry_t *)
        :param desc: (::const char *)
        :param operation: (int) 0-added, 1-updated, 2-deleted if desc==nullptr, then the bookmark was deleted.
        """
        ...
    def byte_patched(self, ea: ida_idaapi.ea_t, old_value: int) -> None:
        r"""A byte has been patched. 
                  
        :param ea: (::ea_t)
        :param old_value: (uint32)
        """
        ...
    def callee_addr_changed(self, ea: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None:
        r"""Callee address has been updated by the user. 
                  
        :param ea: (::ea_t)
        :param callee: (::ea_t)
        """
        ...
    def changing_cmt(self, ea: ida_idaapi.ea_t, repeatable_cmt: bool, newcmt: str) -> None:
        r"""An item comment is to be changed. 
                  
        :param ea: (::ea_t)
        :param repeatable_cmt: (bool)
        :param newcmt: (const char *)
        """
        ...
    def changing_op_ti(self, ea: ida_idaapi.ea_t, n: int, new_type: type_t, new_fnames: p_list) -> None:
        r"""An operand typestring (c/c++ prototype) is to be changed. 
                  
        :param ea: (::ea_t)
        :param n: (int)
        :param new_type: (const type_t *)
        :param new_fnames: (const p_list *)
        """
        ...
    def changing_op_type(self, ea: ida_idaapi.ea_t, n: int, opinfo: opinfo_t) -> None:
        r"""An operand type (offset, hex, etc...) is to be changed. 
                  
        :param ea: (::ea_t)
        :param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
        :param opinfo: (const opinfo_t *) additional operand info
        """
        ...
    def changing_range_cmt(self, kind: range_kind_t, a: range_t, cmt: str, repeatable: bool) -> None:
        r"""Range comment is to be changed. 
                  
        :param kind: (range_kind_t)
        :param a: (const range_t *)
        :param cmt: (const char *)
        :param repeatable: (bool)
        """
        ...
    def changing_segm_class(self, s: segment_t) -> None:
        r"""Segment class is being changed. 
                  
        :param s: (segment_t *)
        """
        ...
    def changing_segm_end(self, s: segment_t, new_end: ida_idaapi.ea_t, segmod_flags: int) -> None:
        r"""Segment end address is to be changed. 
                  
        :param s: (segment_t *)
        :param new_end: (::ea_t)
        :param segmod_flags: (int)
        """
        ...
    def changing_segm_name(self, s: segment_t, oldname: str) -> None:
        r"""Segment name is being changed. 
                  
        :param s: (segment_t *)
        :param oldname: (const char *)
        """
        ...
    def changing_segm_start(self, s: segment_t, new_start: ida_idaapi.ea_t, segmod_flags: int) -> None:
        r"""Segment start address is to be changed. 
                  
        :param s: (segment_t *)
        :param new_start: (::ea_t)
        :param segmod_flags: (int)
        """
        ...
    def changing_ti(self, ea: ida_idaapi.ea_t, new_type: type_t, new_fnames: p_list) -> None:
        r"""An item typestring (c/c++ prototype) is to be changed. 
                  
        :param ea: (::ea_t)
        :param new_type: (const type_t *)
        :param new_fnames: (const p_list *)
        """
        ...
    def closebase(self) -> None:
        r"""The database will be closed now.
        
        """
        ...
    def cmt_changed(self, ea: ida_idaapi.ea_t, repeatable_cmt: bool) -> None:
        r"""An item comment has been changed. 
                  
        :param ea: (::ea_t)
        :param repeatable_cmt: (bool)
        """
        ...
    def compiler_changed(self, adjust_inf_fields: bool) -> None:
        r"""The kernel has changed the compiler information. ( idainfo::cc structure; get_abi_name) 
                  
        :param adjust_inf_fields: (::bool) may change inf fields?
        """
        ...
    def deleting_func(self, pfn: func_t) -> None:
        r"""The kernel is about to delete a function. 
                  
        :param pfn: (func_t *)
        """
        ...
    def deleting_func_tail(self, pfn: func_t, tail: range_t) -> None:
        r"""A function tail chunk is to be removed. 
                  
        :param pfn: (func_t *)
        :param tail: (const range_t *)
        """
        ...
    def deleting_segm(self, start_ea: ida_idaapi.ea_t) -> None:
        r"""A segment is to be deleted. 
                  
        :param start_ea: (::ea_t)
        """
        ...
    def deleting_tryblks(self, range: range_t) -> None:
        r"""About to delete tryblk information in given range 
                  
        :param range: (const range_t *)
        """
        ...
    def destroyed_items(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, will_disable_range: bool) -> None:
        r"""Instructions/data have been destroyed in [ea1,ea2). 
                  
        :param ea1: (::ea_t)
        :param ea2: (::ea_t)
        :param will_disable_range: (bool)
        """
        ...
    def determined_main(self, main: ida_idaapi.ea_t) -> None:
        r"""The main() function has been determined. 
                  
        :param main: (::ea_t) address of the main() function
        """
        ...
    def dirtree_link(self, dt: dirtree_t, path: str, link: bool) -> None:
        r"""Dirtree: an item has been linked/unlinked. 
                  
        :param dt: (dirtree_t *)
        :param path: (::const char *)
        :param link: (::bool)
        """
        ...
    def dirtree_mkdir(self, dt: dirtree_t, path: str) -> None:
        r"""Dirtree: a directory has been created. 
                  
        :param dt: (dirtree_t *)
        :param path: (::const char *)
        """
        ...
    def dirtree_move(self, dt: dirtree_t, _from: str, to: str) -> None:
        r"""Dirtree: a directory or item has been moved. 
                  
        :param dt: (dirtree_t *)
        :param to: (::const char *)
        """
        ...
    def dirtree_rank(self, dt: dirtree_t, path: str, rank: size_t) -> None:
        r"""Dirtree: a directory or item rank has been changed. 
                  
        :param dt: (dirtree_t *)
        :param path: (::const char *)
        :param rank: (::size_t)
        """
        ...
    def dirtree_rmdir(self, dt: dirtree_t, path: str) -> None:
        r"""Dirtree: a directory has been deleted. 
                  
        :param dt: (dirtree_t *)
        :param path: (::const char *)
        """
        ...
    def dirtree_rminode(self, dt: dirtree_t, inode: inode_t) -> None:
        r"""Dirtree: an inode became unavailable. 
                  
        :param dt: (dirtree_t *)
        :param inode: (inode_t)
        """
        ...
    def dirtree_segm_moved(self, dt: dirtree_t) -> None:
        r"""Dirtree: inodes were changed due to a segment movement or a program rebasing 
                  
        :param dt: (dirtree_t *)
        """
        ...
    def extlang_changed(self, kind: int, el: extlang_t, idx: int) -> None:
        r"""The list of extlangs or the default extlang was changed. 
                  
        :param kind: (int) 0: extlang installed 1: extlang removed 2: default extlang changed
        :param el: (extlang_t *) pointer to the extlang affected
        :param idx: (int) extlang index
        """
        ...
    def extra_cmt_changed(self, ea: ida_idaapi.ea_t, line_idx: int, cmt: str) -> None:
        r"""An extra comment has been changed. 
                  
        :param ea: (::ea_t)
        :param line_idx: (int)
        :param cmt: (const char *)
        """
        ...
    def flow_chart_created(self, fc: qflow_chart_t) -> None:
        r"""Gui has retrieved a function flow chart. Plugins may modify the flow chart in this callback. 
                  
        :param fc: (qflow_chart_t *)
        """
        ...
    def frame_created(self, func_ea: ida_idaapi.ea_t) -> None:
        r"""A function frame has been created. 
                  
        :param func_ea: (::ea_t) idb_event::frame_deleted
        """
        ...
    def frame_deleted(self, pfn: func_t) -> None:
        r"""The kernel has deleted a function frame. 
                  
        :param pfn: (func_t *) idb_event::frame_created
        """
        ...
    def frame_expanded(self, func_ea: ida_idaapi.ea_t, udm_tid: tid_t, delta: adiff_t) -> None:
        r"""A frame type has been expanded/shrank. 
                  
        :param func_ea: (::ea_t)
        :param udm_tid: (tid_t) the gap was added/removed before this member
        :param delta: (::adiff_t) number of added/removed bytes
        """
        ...
    def frame_udm_changed(self, func_ea: ida_idaapi.ea_t, udm_tid: tid_t, udmold: udm_t, udmnew: udm_t) -> None:
        r"""Frame member has been changed. 
                  
        :param func_ea: (::ea_t)
        :param udm_tid: (tid_t)
        :param udmold: (::const udm_t *)
        :param udmnew: (::const udm_t *)
        """
        ...
    def frame_udm_created(self, func_ea: ida_idaapi.ea_t, udm: udm_t) -> None:
        r"""Frame member has been added. 
                  
        :param func_ea: (::ea_t)
        :param udm: (::const udm_t *)
        """
        ...
    def frame_udm_deleted(self, func_ea: ida_idaapi.ea_t, udm_tid: tid_t, udm: udm_t) -> None:
        r"""Frame member has been deleted. 
                  
        :param func_ea: (::ea_t)
        :param udm_tid: (tid_t)
        :param udm: (::const udm_t *)
        """
        ...
    def frame_udm_renamed(self, func_ea: ida_idaapi.ea_t, udm: udm_t, oldname: str) -> None:
        r"""Frame member has been renamed. 
                  
        :param func_ea: (::ea_t)
        :param udm: (::const udm_t *)
        :param oldname: (::const char *)
        """
        ...
    def func_added(self, pfn: func_t) -> None:
        r"""The kernel has added a function. 
                  
        :param pfn: (func_t *)
        """
        ...
    def func_deleted(self, func_ea: ida_idaapi.ea_t) -> None:
        r"""A function has been deleted. 
                  
        :param func_ea: (::ea_t)
        """
        ...
    def func_noret_changed(self, pfn: func_t) -> None:
        r"""FUNC_NORET bit has been changed. 
                  
        :param pfn: (func_t *)
        """
        ...
    def func_tail_appended(self, pfn: func_t, tail: func_t) -> None:
        r"""A function tail chunk has been appended. 
                  
        :param pfn: (func_t *)
        :param tail: (func_t *)
        """
        ...
    def func_tail_deleted(self, pfn: func_t, tail_ea: ida_idaapi.ea_t) -> None:
        r"""A function tail chunk has been removed. 
                  
        :param pfn: (func_t *)
        :param tail_ea: (::ea_t)
        """
        ...
    def func_updated(self, pfn: func_t) -> None:
        r"""The kernel has updated a function. 
                  
        :param pfn: (func_t *)
        """
        ...
    def hook(self) -> bool:
        ...
    def idasgn_loaded(self, short_sig_name: str) -> None:
        r"""FLIRT signature has been loaded for normal processing (not for recognition of startup sequences). 
                  
        :param short_sig_name: (const char *)
        """
        ...
    def idasgn_matched_ea(self, ea: ida_idaapi.ea_t, name: str, lib_name: str) -> None:
        r"""A FLIRT match has been found 
                  
        :param ea: (::ea_t) the matching address
        :param name: (::const char *) the matched name
        :param lib_name: (::const char *) library name extracted from signature file
        """
        ...
    def item_color_changed(self, ea: ida_idaapi.ea_t, color: bgcolor_t) -> None:
        r"""An item color has been changed. 
                  
        :param ea: (::ea_t)
        :param color: (bgcolor_t) if color==DEFCOLOR, the the color is deleted.
        """
        ...
    def kernel_config_loaded(self, pass_number: int) -> None:
        r"""This event is issued when ida.cfg is parsed. 
                  
        :param pass_number: (int)
        """
        ...
    def loader_finished(self, li: linput_t, neflags: uint16, filetypename: str) -> None:
        r"""External file loader finished its work. Use this event to augment the existing loader functionality. 
                  
        :param li: (linput_t *)
        :param neflags: (uint16) Load file flags
        :param filetypename: (const char *)
        """
        ...
    def local_type_renamed(self, ordinal: int, oldname: str, newname: str) -> None:
        r"""Local type has been renamed 
                  
        :param ordinal: (uint32) 0 means ordinal is unknown
        :param oldname: (const char *) nullptr means name is unknown
        :param newname: (const char *) nullptr means name is unknown
        """
        ...
    def local_types_changed(self, ltc: local_type_change_t, ordinal: int, name: str) -> None:
        r"""Local types have been changed 
                  
        :param ltc: (local_type_change_t)
        :param ordinal: (uint32) 0 means ordinal is unknown
        :param name: (const char *) nullptr means name is unknown
        """
        ...
    def lt_edm_changed(self, enumname: str, edm_tid: tid_t, edmold: edm_t, edmnew: edm_t) -> None:
        r"""local type enum member has been changed 
                  
        :param enumname: (::const char *)
        :param edm_tid: (tid_t)
        :param edmold: (::const edm_t *)
        :param edmnew: (::const edm_t *)
        """
        ...
    def lt_edm_created(self, enumname: str, edm: edm_t) -> None:
        r"""local type enum member has been added 
                  
        :param enumname: (::const char *)
        :param edm: (::const edm_t *)
        """
        ...
    def lt_edm_deleted(self, enumname: str, edm_tid: tid_t, edm: edm_t) -> None:
        r"""local type enum member has been deleted 
                  
        :param enumname: (::const char *)
        :param edm_tid: (tid_t)
        :param edm: (::const edm_t *)
        """
        ...
    def lt_edm_renamed(self, enumname: str, edm: edm_t, oldname: str) -> None:
        r"""local type enum member has been renamed 
                  
        :param enumname: (::const char *)
        :param edm: (::const edm_t *)
        :param oldname: (::const char *)
        """
        ...
    def lt_udm_changed(self, udtname: str, udm_tid: tid_t, udmold: udm_t, udmnew: udm_t) -> None:
        r"""local type udt member has been changed 
                  
        :param udtname: (::const char *)
        :param udm_tid: (tid_t)
        :param udmold: (::const udm_t *)
        :param udmnew: (::const udm_t *)
        """
        ...
    def lt_udm_created(self, udtname: str, udm: udm_t) -> None:
        r"""local type udt member has been added 
                  
        :param udtname: (::const char *)
        :param udm: (::const udm_t *)
        """
        ...
    def lt_udm_deleted(self, udtname: str, udm_tid: tid_t, udm: udm_t) -> None:
        r"""local type udt member has been deleted 
                  
        :param udtname: (::const char *)
        :param udm_tid: (tid_t)
        :param udm: (::const udm_t *)
        """
        ...
    def lt_udm_renamed(self, udtname: str, udm: udm_t, oldname: str) -> None:
        r"""local type udt member has been renamed 
                  
        :param udtname: (::const char *)
        :param udm: (::const udm_t *)
        :param oldname: (::const char *)
        """
        ...
    def lt_udt_expanded(self, udtname: str, udm_tid: tid_t, delta: adiff_t) -> None:
        r"""A structure type has been expanded/shrank. 
                  
        :param udtname: (::const char *)
        :param udm_tid: (tid_t) the gap was added/removed before this member
        :param delta: (::adiff_t) number of added/removed bytes
        """
        ...
    def make_code(self, insn: insn_t) -> None:
        r"""An instruction is being created. 
                  
        :param insn: (const insn_t*)
        """
        ...
    def make_data(self, ea: ida_idaapi.ea_t, flags: flags64_t, tid: tid_t, len: asize_t) -> None:
        r"""A data item is being created. 
                  
        :param ea: (::ea_t)
        :param flags: (flags64_t)
        :param tid: (tid_t)
        :param len: (::asize_t)
        """
        ...
    def op_ti_changed(self, ea: ida_idaapi.ea_t, n: int, type: type_t, fnames: p_list) -> None:
        r"""An operand typestring (c/c++ prototype) has been changed. 
                  
        :param ea: (::ea_t)
        :param n: (int)
        :param type: (const type_t *)
        :param fnames: (const p_list *)
        """
        ...
    def op_type_changed(self, ea: ida_idaapi.ea_t, n: int) -> None:
        r"""An operand type (offset, hex, etc...) has been set or deleted. 
                  
        :param ea: (::ea_t)
        :param n: (int) eventually or'ed with OPND_OUTER or OPND_ALL
        """
        ...
    def range_cmt_changed(self, kind: range_kind_t, a: range_t, cmt: str, repeatable: bool) -> None:
        r"""Range comment has been changed. 
                  
        :param kind: (range_kind_t)
        :param a: (const range_t *)
        :param cmt: (const char *)
        :param repeatable: (bool)
        """
        ...
    def renamed(self, ea: ida_idaapi.ea_t, new_name: str, local_name: bool, old_name: str) -> None:
        r"""The kernel has renamed a byte. See also the rename event 
                  
        :param ea: (::ea_t)
        :param new_name: (const char *) can be nullptr
        :param local_name: (bool)
        :param old_name: (const char *) can be nullptr
        """
        ...
    def savebase(self) -> None:
        r"""The database is being saved.
        
        """
        ...
    def segm_added(self, s: segment_t) -> None:
        r"""A new segment has been created. 
                  
        :param s: (segment_t *) See also adding_segm
        """
        ...
    def segm_attrs_updated(self, s: segment_t) -> None:
        r"""Segment attributes has been changed. 
                  
        :param s: (segment_t *) This event is generated for secondary segment attributes (examples: color, permissions, etc)
        """
        ...
    def segm_class_changed(self, s: segment_t, sclass: str) -> None:
        r"""Segment class has been changed. 
                  
        :param s: (segment_t *)
        :param sclass: (const char *)
        """
        ...
    def segm_deleted(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, flags: int) -> None:
        r"""A segment has been deleted. 
                  
        :param start_ea: (::ea_t)
        :param end_ea: (::ea_t)
        :param flags: (int)
        """
        ...
    def segm_end_changed(self, s: segment_t, oldend: ida_idaapi.ea_t) -> None:
        r"""Segment end address has been changed. 
                  
        :param s: (segment_t *)
        :param oldend: (::ea_t)
        """
        ...
    def segm_moved(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t, changed_netmap: bool) -> None:
        r"""Segment has been moved. 
                  
        :param to: (::ea_t)
        :param size: (::asize_t)
        :param changed_netmap: (bool) See also idb_event::allsegs_moved
        """
        ...
    def segm_name_changed(self, s: segment_t, name: str) -> None:
        r"""Segment name has been changed. 
                  
        :param s: (segment_t *)
        :param name: (const char *)
        """
        ...
    def segm_start_changed(self, s: segment_t, oldstart: ida_idaapi.ea_t) -> None:
        r"""Segment start address has been changed. 
                  
        :param s: (segment_t *)
        :param oldstart: (::ea_t)
        """
        ...
    def set_func_end(self, pfn: func_t, new_end: ida_idaapi.ea_t) -> None:
        r"""Function chunk end address will be changed. 
                  
        :param pfn: (func_t *)
        :param new_end: (::ea_t)
        """
        ...
    def set_func_start(self, pfn: func_t, new_start: ida_idaapi.ea_t) -> None:
        r"""Function chunk start address will be changed. 
                  
        :param pfn: (func_t *)
        :param new_start: (::ea_t)
        """
        ...
    def sgr_changed(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int, value: sel_t, old_value: sel_t, tag: uchar) -> None:
        r"""The kernel has changed a segment register value. 
                  
        :param start_ea: (::ea_t)
        :param end_ea: (::ea_t)
        :param regnum: (int)
        :param value: (::sel_t)
        :param old_value: (::sel_t)
        :param tag: (uchar) Segment register range tags
        """
        ...
    def sgr_deleted(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regnum: int) -> None:
        r"""The kernel has deleted a segment register value. 
                  
        :param start_ea: (::ea_t)
        :param end_ea: (::ea_t)
        :param regnum: (int)
        """
        ...
    def stkpnts_changed(self, pfn: func_t) -> None:
        r"""Stack change points have been modified. 
                  
        :param pfn: (func_t *)
        """
        ...
    def tail_owner_changed(self, tail: func_t, owner_func: ida_idaapi.ea_t, old_owner: ida_idaapi.ea_t) -> None:
        r"""A tail chunk owner has been changed. 
                  
        :param tail: (func_t *)
        :param owner_func: (::ea_t)
        :param old_owner: (::ea_t)
        """
        ...
    def thunk_func_created(self, pfn: func_t) -> None:
        r"""A thunk bit has been set for a function. 
                  
        :param pfn: (func_t *)
        """
        ...
    def ti_changed(self, ea: ida_idaapi.ea_t, type: type_t, fnames: p_list) -> None:
        r"""An item typestring (c/c++ prototype) has been changed. 
                  
        :param ea: (::ea_t)
        :param type: (const type_t *)
        :param fnames: (const p_list *)
        """
        ...
    def tryblks_updated(self, tbv: tryblks_t) -> None:
        r"""Updated tryblk information 
                  
        :param tbv: (const ::tryblks_t *)
        """
        ...
    def unhook(self) -> bool:
        ...
    def updating_tryblks(self, tbv: tryblks_t) -> None:
        r"""About to update tryblk information 
                  
        :param tbv: (const ::tryblks_t *)
        """
        ...
    def upgraded(self, _from: int) -> None:
        r"""The database has been upgraded and the receiver can upgrade its info as well 
                  
        """
        ...

class IDP_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def ev_add_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: cref_t) -> int:
        r"""A code reference is being created. 
                  
        :param to: (::ea_t)
        :param type: (cref_t)
        :returns: <0: cancel cref creation
        :returns: 0: not implemented or continue
        """
        ...
    def ev_add_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: dref_t) -> int:
        r"""A data reference is being created. 
                  
        :param to: (::ea_t)
        :param type: (dref_t)
        :returns: <0: cancel dref creation
        :returns: 0: not implemented or continue
        """
        ...
    def ev_adjust_argloc(self, argloc: argloc_t, optional_type: tinfo_t, size: int) -> int:
        r"""Adjust argloc according to its type/size and platform endianess 
                  
        :param argloc: (argloc_t *), inout
        :param size: (int) 'size' makes no sense if type != nullptr (type->get_size() should be used instead)
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error
        """
        ...
    def ev_adjust_libfunc_ea(self, sig: idasgn_t, libfun: libfunc_t, ea: ea_t) -> int:
        r"""Called when a signature module has been matched against bytes in the database. This is used to compute the offset at which a particular module's libfunc should be applied. 
                  
        :param sig: (const idasgn_t *)
        :param libfun: (const libfunc_t *)
        :param ea: (::ea_t *)
        :returns: 1: the ea_t pointed to by the third argument was modified.
        :returns: <=0: not modified. use default algorithm.
        """
        ...
    def ev_adjust_refinfo(self, ri: refinfo_t, ea: ida_idaapi.ea_t, n: int, fd: fixup_data_t) -> int:
        r"""Called from apply_fixup before converting operand to reference. Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) 
                  
        :param ri: (refinfo_t *)
        :param ea: (::ea_t) instruction address
        :param n: (int) operand number
        :param fd: (const fixup_data_t *)
        :returns: <0: do not create an offset
        :returns: 0: not implemented or refinfo adjusted
        """
        ...
    def ev_ana_insn(self, out: insn_t) -> bool:
        r"""Analyze one instruction and fill 'out' structure. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. insn_t::ea contains address of instruction to analyze. 
                  
        :param out: (insn_t *)
        :returns: length of the instruction in bytes, 0 if instruction can't be decoded.
        :returns: 0: if instruction can't be decoded.
        """
        ...
    def ev_analyze_prolog(self, ea: ida_idaapi.ea_t) -> int:
        r"""Analyzes function prolog, epilog, and updates purge, and function attributes 
                  
        :param ea: (::ea_t) start of function
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_arch_changed(self) -> int:
        r"""The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. 
                  
        :returns: 1: if success
        :returns: 0: not implemented or failed
        """
        ...
    def ev_arg_addrs_ready(self, caller: ida_idaapi.ea_t, n: int, tif: tinfo_t, addrs: ea_t) -> int:
        r"""Argument address info is ready. 
                  
        :param caller: (::ea_t)
        :param n: (int) number of formal arguments
        :param tif: (tinfo_t *) call prototype
        :param addrs: (::ea_t *) argument intilization addresses
        :returns: <0: do not save into idb; other values mean "ok to save"
        """
        ...
    def ev_asm_installed(self, asmnum: int) -> int:
        r"""After setting a new assembler 
                  
        :param asmnum: (int) See also ev_newasm
        """
        ...
    def ev_assemble(self, ea: ida_idaapi.ea_t, cs: ida_idaapi.ea_t, ip: ida_idaapi.ea_t, use32: bool, line: str) -> Any:
        r"""Assemble an instruction. (display a warning if an error is found). 
                  
        :param ea: (::ea_t) linear address of instruction
        :param cs: (::ea_t) cs of instruction
        :param ip: (::ea_t) ip of instruction
        :param use32: (bool) is 32bit segment?
        :param line: (const char *) line to assemble
        :returns: size of the instruction in bytes
        """
        ...
    def ev_auto_queue_empty(self, type: atype_t) -> int:
        r"""One analysis queue is empty. 
                  
        :param type: (atype_t)
        :returns: void: see also idb_event::auto_empty_finally
        """
        ...
    def ev_calc_arglocs(self, fti: func_type_data_t) -> int:
        r"""Calculate function argument locations. This callback should fill retloc, all arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions. 
                  
        :param fti: (func_type_data_t *) points to the func type info
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error
        """
        ...
    def ev_calc_cdecl_purged_bytes(self, ea: ida_idaapi.ea_t) -> int:
        r"""Calculate number of purged bytes after call. 
                  
        :param ea: (::ea_t) address of the call instruction
        :returns: number of purged bytes (usually add sp, N)
        """
        ...
    def ev_calc_next_eas(self, res: eavec_t, insn: insn_t, over: bool) -> int:
        r"""Calculate list of addresses the instruction in 'insn' may pass control to. This callback is required for source level debugging. 
                  
        :param res: (eavec_t *), out: array for the results.
        :param insn: (const insn_t*) the instruction
        :param over: (bool) calculate for step over (ignore call targets)
        :returns: <0: incalculable (indirect jumps, for example)
        :returns: >=0: number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true)
        """
        ...
    def ev_calc_purged_bytes(self, p_purged_bytes: int, fti: func_type_data_t) -> int:
        r"""Calculate number of purged bytes by the given function type. 
                  
        :param p_purged_bytes: (int *) ptr to output
        :param fti: (const func_type_data_t *) func type details
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_calc_retloc(self, retloc: argloc_t, rettype: tinfo_t, cc: callcnv_t) -> int:
        r"""Calculate return value location. 
                  
        :param retloc: (argloc_t *)
        :param rettype: (const tinfo_t *)
        :param cc: (::callcnv_t)
        :returns: 0: not implemented
        :returns: 1: ok,
        :returns: -1: error
        """
        ...
    def ev_calc_spdelta(self, spdelta: sval_t, insn: insn_t) -> int:
        r"""Calculate amount of change to sp for the given insn. This event is required to decompile code snippets. 
                  
        :param spdelta: (sval_t *)
        :param insn: (const insn_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_calc_step_over(self, target: ea_t, ip: ida_idaapi.ea_t) -> int:
        r"""Calculate the address of the instruction which will be executed after "step over". The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return BADADDR. 
                  
        :param target: (::ea_t *) pointer to the answer
        :param ip: (::ea_t) instruction address
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_calc_switch_cases(self, casevec: casevec_t, targets: eavec_t, insn_ea: ida_idaapi.ea_t, si: switch_info_t) -> int:
        r"""Calculate case values and targets for a custom jump table. 
                  
        :param casevec: (::casevec_t *) vector of case values (may be nullptr)
        :param targets: (eavec_t *) corresponding target addresses (my be nullptr)
        :param insn_ea: (::ea_t) address of the 'indirect jump' instruction
        :param si: (switch_info_t *) switch information
        :returns: 1: ok
        :returns: <=0: failed
        """
        ...
    def ev_calc_varglocs(self, ftd: func_type_data_t, aux_regs: regobjs_t, aux_stkargs: relobj_t, nfixed: int) -> int:
        r"""Calculate locations of the arguments that correspond to '...'. 
                  
        :param ftd: (func_type_data_t *), inout: info about all arguments (including varargs)
        :param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be nullptr
        :param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be nullptr
        :param nfixed: (int) number of fixed arguments
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs
        """
        ...
    def ev_calcrel(self) -> int:
        r"""Reserved.
        
        """
        ...
    def ev_can_have_type(self, op: op_t) -> int:
        r"""Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. see bytes.hpp for information about types and flags) 
                  
        :param op: (const op_t *)
        :returns: 0: unknown
        :returns: <0: no
        :returns: 1: yes
        """
        ...
    def ev_clean_tbit(self, ea: ida_idaapi.ea_t, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Clear the TF bit after an insn like pushf stored it in memory. 
                  
        :param ea: (::ea_t) instruction address
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 1: ok
        :returns: 0: failed
        """
        ...
    def ev_cmp_operands(self, op1: op_t, op2: op_t) -> int:
        r"""Compare instruction operands 
                  
        :param op1: (const op_t*)
        :param op2: (const op_t*)
        :returns: 1: equal
        :returns: -1: not equal
        :returns: 0: not implemented
        """
        ...
    def ev_coagulate(self, start_ea: ida_idaapi.ea_t) -> int:
        r"""Try to define some unexplored bytes. This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. 
                  
        :param start_ea: (::ea_t)
        :returns: number of converted bytes
        """
        ...
    def ev_coagulate_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, may_define: bool, code_ea: ea_t) -> int:
        r"""Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) 
                  
        :param to: (::ea_t)
        :param may_define: (bool)
        :param code_ea: (::ea_t *)
        :returns: <0: failed dref analysis, >0 done dref analysis
        :returns: 0: not implemented or continue
        """
        ...
    def ev_create_flat_group(self, image_base: ida_idaapi.ea_t, bitness: int, dataseg_sel: sel_t) -> int:
        r"""Create special segment representing the flat group. 
                  
        :param image_base: (::ea_t)
        :param bitness: (int)
        :param dataseg_sel: (::sel_t) return value is ignored
        """
        ...
    def ev_create_func_frame(self, pfn: func_t) -> int:
        r"""Create a function frame for a newly created function Set up frame size, its attributes etc 
                  
        :param pfn: (func_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_create_merge_handlers(self, md: merge_data_t) -> int:
        r"""Create merge handlers, if needed 
                  
        :param md: (merge_data_t *) This event is generated immediately after opening idbs.
        :returns: must be 0
        """
        ...
    def ev_create_switch_xrefs(self, jumpea: ida_idaapi.ea_t, si: switch_info_t) -> int:
        r"""Create xrefs for a custom jump table. 
                  
        :param jumpea: (::ea_t) address of the jump insn
        :param si: (const switch_info_t *) switch information
        :returns: must return 1 Must be implemented if module uses custom jump tables, SWI_CUSTOM
        """
        ...
    def ev_creating_segm(self, seg: segment_t) -> int:
        r"""A new segment is about to be created. 
                  
        :param seg: (segment_t *)
        :returns: 1: ok
        :returns: <0: segment should not be created
        """
        ...
    def ev_cvt64_hashval(self, node: nodeidx_t, tag: uchar, name: str, data: uchar) -> int:
        r"""perform 32-64 conversion for a hash value 
                  
        :param node: (::nodeidx_t)
        :param tag: (uchar)
        :param name: (const ::char *)
        :param data: (const uchar *)
        :returns: 0: nothing was done
        :returns: 1: converted successfully
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_cvt64_supval(self, node: nodeidx_t, tag: uchar, idx: nodeidx_t, data: uchar) -> int:
        r"""perform 32-64 conversion for a netnode array element 
                  
        :param node: (::nodeidx_t)
        :param tag: (uchar)
        :param idx: (::nodeidx_t)
        :param data: (const uchar *)
        :returns: 0: nothing was done
        :returns: 1: converted successfully
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_decorate_name(self, name: str, mangle: bool, cc: int, optional_type: tinfo_t) -> Any:
        r"""Decorate/undecorate a C symbol name. 
                  
        :param name: (const char *) name of symbol
        :param mangle: (bool) true-mangle, false-unmangle
        :param cc: (::callcnv_t) calling convention
        :returns: 1: if success
        :returns: 0: not implemented or failed
        """
        ...
    def ev_del_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> int:
        r"""A code reference is being deleted. 
                  
        :param to: (::ea_t)
        :param expand: (bool)
        :returns: <0: cancel cref deletion
        :returns: 0: not implemented or continue
        """
        ...
    def ev_del_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> int:
        r"""A data reference is being deleted. 
                  
        :param to: (::ea_t)
        :returns: <0: cancel dref deletion
        :returns: 0: not implemented or continue
        """
        ...
    def ev_delay_slot_insn(self, ea: ida_idaapi.ea_t, bexec: bool, fexec: bool) -> Any:
        r"""Get delay slot instruction 
                  
        :param ea: (::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
        :param bexec: (bool *) execute slot if jumping, initially set to 'true'
        :param fexec: (bool *) execute slot if not jumping, initally set to 'true'
        :returns: 1: positive answer
        :returns: <=0: ordinary insn
        """
        ...
    def ev_demangle_name(self, name: str, disable_mask: int, demreq: int) -> Any:
        r"""Demangle a C++ (or another language) name into a user-readable string. This event is called by demangle_name() 
                  
        :param name: (const char *) mangled name
        :param disable_mask: (uint32) flags to inhibit parts of output or compiler info/other (see MNG_)
        :param demreq: (demreq_type_t) operation to perform
        :returns: 1: if success
        :returns: 0: not implemented
        """
        ...
    def ev_emu_insn(self, insn: insn_t) -> bool:
        r"""Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. Upon entrance to this function, all information about the instruction is in 'insn' structure. 
                  
        :param insn: (const insn_t *)
        :returns: 1: ok
        :returns: -1: the kernel will delete the instruction
        """
        ...
    def ev_endbinary(self, ok: bool) -> int:
        r"""IDA has loaded a binary file. 
                  
        :param ok: (bool) file loaded successfully?
        """
        ...
    def ev_ending_undo(self, action_name: str, is_undo: bool) -> int:
        r"""Ended undoing/redoing an action 
                  
        :param action_name: (const char *) action that we finished undoing/redoing. is not nullptr.
        :param is_undo: (bool) true if performing undo, false if performing redo
        """
        ...
    def ev_equal_reglocs(self, a1: argloc_t, a2: argloc_t) -> int:
        r"""Are 2 register arglocs the same?. We need this callback for the pc module. 
                  
        :param a1: (argloc_t *)
        :param a2: (argloc_t *)
        :returns: 1: yes
        :returns: -1: no
        :returns: 0: not implemented
        """
        ...
    def ev_extract_address(self, out_ea: ea_t, screen_ea: ida_idaapi.ea_t, string: str, position: size_t) -> int:
        r"""Extract address from a string. 
                  
        :param out_ea: (ea_t *), out
        :param screen_ea: (ea_t)
        :param string: (const char *)
        :param position: (size_t)
        :returns: 1: ok
        :returns: 0: kernel should use the standard algorithm
        :returns: -1: error
        """
        ...
    def ev_find_op_value(self, pinsn: insn_t, opn: int) -> Any:
        r"""Find operand value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                  
        :param pinsn: (const insn_t *) instruction
        :param opn: (int) operand index
        :returns: 1: if implemented, and value was found
        :returns: 0: not implemented, -1 decoding failed, or no value found
        """
        ...
    def ev_find_reg_value(self, pinsn: insn_t, reg: int) -> Any:
        r"""Find register value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                  
        :param pinsn: (const insn_t *) instruction
        :param reg: (int) register index
        :returns: 1: if implemented, and value was found
        :returns: 0: not implemented, -1 decoding failed, or no value found
        """
        ...
    def ev_func_bounds(self, possible_return_code: int, pfn: func_t, max_func_end_ea: ida_idaapi.ea_t) -> int:
        r"""find_func_bounds() finished its work. The module may fine tune the function bounds 
                  
        :param possible_return_code: (int *), in/out
        :param pfn: (func_t *)
        :param max_func_end_ea: (::ea_t) (from the kernel's point of view)
        :returns: void: 
        """
        ...
    def ev_gen_asm_or_lst(self, starting: bool, fp: FILE, is_asm: bool, flags: int, outline: html_line_cb_t) -> int:
        r"""Callback: generating asm or lst file. The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output 
                  
        :param starting: (bool) beginning listing generation
        :param fp: (FILE *) output file
        :param is_asm: (bool) true:assembler, false:listing
        :param flags: (int) flags passed to gen_file()
        :param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines
        :returns: void: 
        """
        ...
    def ev_gen_map_file(self, nlines: int, fp: FILE) -> int:
        r"""Generate map file. If not implemented the kernel itself will create the map file. 
                  
        :param nlines: (int *) number of lines in map file (-1 means write error)
        :param fp: (FILE *) output file
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: write error
        """
        ...
    def ev_gen_regvar_def(self, outctx: outctx_t, v: regvar_t) -> int:
        r"""Generate register variable definition line. 
                  
        :param outctx: (outctx_t *)
        :param v: (regvar_t *)
        :returns: >0: ok, generated the definition text
        :returns: 0: not implemented
        """
        ...
    def ev_gen_src_file_lnnum(self, outctx: outctx_t, file: str, lnnum: size_t) -> int:
        r"""Callback: generate analog of: 
             #line  123
            
        
        
                  
        :param outctx: (outctx_t *) output context
        :param file: (const char *) source file (may be nullptr)
        :param lnnum: (size_t) line number
        :returns: 1: directive has been generated
        :returns: 0: not implemented
        """
        ...
    def ev_gen_stkvar_def(self, outctx: outctx_t, stkvar: udm_t, v: int, tid: tid_t) -> int:
        r"""Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte 
                  
        :param outctx: (outctx_t *)
        :param stkvar: (const udm_t *)
        :param v: (sval_t)
        :param tid: (tid_t) stkvar TID
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_get_abi_info(self, comp: comp_t) -> int:
        r"""Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore 
                  
        :param comp: (comp_t) - compiler ID
        :returns: 0: not implemented
        :returns: 1: ok
        """
        ...
    def ev_get_autocmt(self, insn: insn_t) -> Any:
        r"""Callback: get dynamic auto comment. Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. 
                  
        :param insn: (const insn_t*) the instruction
        :returns: 1: new comment has been generated
        :returns: 0: callback has not been handled. the buffer must not be changed in this case
        """
        ...
    def ev_get_bg_color(self, color: bgcolor_t, ea: ida_idaapi.ea_t) -> int:
        r"""Get item background color. Plugins can hook this callback to color disassembly lines dynamically 
                  
        :param color: (bgcolor_t *), out
        :param ea: (::ea_t)
        :returns: 0: not implemented
        :returns: 1: color set
        """
        ...
    def ev_get_cc_regs(self, regs: callregs_t, cc: callcnv_t) -> int:
        r"""Get register allocation convention for given calling convention 
                  
        :param regs: (callregs_t *), out
        :param cc: (::callcnv_t)
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_get_code16_mode(self, ea: ida_idaapi.ea_t) -> int:
        r"""Get ISA 16-bit mode 
                  
        :param ea: (ea_t) address to get the ISA mode
        :returns: 1: 16-bit mode
        :returns: 0: not implemented or 32-bit mode
        """
        ...
    def ev_get_dbr_opnum(self, opnum: int, insn: insn_t) -> int:
        r"""Get the number of the operand to be displayed in the debugger reference view (text mode). 
                  
        :param opnum: (int *) operand number (out, -1 means no such operand)
        :param insn: (const insn_t*) the instruction
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_get_default_enum_size(self) -> int:
        r"""Get default enum size. Not generated anymore. inf_get_cc_size_e() is used instead 
                  
        """
        ...
    def ev_get_frame_retsize(self, frsize: int, pfn: func_t) -> int:
        r"""Get size of function return address in bytes If this event is not implemented, the kernel will assume
        * 8 bytes for 64-bit function
        * 4 bytes for 32-bit function
        * 2 bytes otherwise
        
        
        
        :param frsize: (int *) frame size (out)
        :param pfn: (const func_t *), can't be nullptr
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_get_macro_insn_head(self, head: ea_t, ip: ida_idaapi.ea_t) -> int:
        r"""Calculate the start of a macro instruction. This notification is called if IP points to the middle of an instruction 
                  
        :param head: (::ea_t *), out: answer, BADADDR means normal instruction
        :param ip: (::ea_t) instruction address
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_get_operand_string(self, insn: insn_t, opnum: int) -> Any:
        r"""Request text string for operand (cli, java, ...). 
                  
        :param insn: (const insn_t*) the instruction
        :param opnum: (int) operand number, -1 means any string operand
        :returns: 0: no string (or empty string)
        :returns: >0: original string length without terminating zero
        """
        ...
    def ev_get_procmod(self) -> int:
        r"""Get pointer to the processor module object. All processor modules must implement this. The pointer is returned as size_t. 
                  
        """
        ...
    def ev_get_reg_accesses(self, accvec: reg_accesses_t, insn: insn_t, flags: int) -> int:
        r"""Get info about the registers that are used/changed by an instruction. 
                  
        :param accvec: (reg_accesses_t*) out: info about accessed registers
        :param insn: (const insn_t *) instruction in question
        :param flags: (int) reserved, must be 0
        :returns: -1: if accvec is nullptr
        :returns: 1: found the requested access (and filled accvec)
        :returns: 0: not implemented
        """
        ...
    def ev_get_reg_info(self, main_regname: char, bitrange: bitrange_t, regname: str) -> int:
        r"""Get register information by its name. example: "ah" returns:
        * main_regname="eax"
        * bitrange_t = { offset==8, nbits==8 }
        
        
        This callback may be unimplemented if the register names are all present in processor_t::reg_names and they all have the same size 
                  
        :param main_regname: (const char **), out
        :param bitrange: (bitrange_t *), out: position and size of the value within 'main_regname' (empty bitrange == whole register)
        :param regname: (const char *)
        :returns: 1: ok
        :returns: -1: failed (not found)
        :returns: 0: unimplemented
        """
        ...
    def ev_get_reg_name(self, reg: int, width: size_t, reghi: int) -> Any:
        r"""Generate text representation of a register. Most processor modules do not need to implement this callback. It is useful only if processor_t::reg_names[reg] does not provide the correct register name. 
                  
        :param reg: (int) internal register number as defined in the processor module
        :param width: (size_t) register width in bytes
        :param reghi: (int) if not -1 then this function will return the register pair
        :returns: -1: if error
        :returns: strlen(buf): if success
        """
        ...
    def ev_get_simd_types(self, out: simd_info_vec_t, simd_attrs: simd_info_t, argloc: argloc_t, create_tifs: bool) -> int:
        r"""Get SIMD-related types according to given attributes ant/or argument location 
                  
        :param out: (::simd_info_vec_t *)
        :param simd_attrs: (const simd_info_t *), may be nullptr
        :param argloc: (const argloc_t *), may be nullptr
        :param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
        :returns: number: of found types
        :returns: -1: error If name==nullptr, initialize all SIMD types
        """
        ...
    def ev_get_stkarg_area_info(self, out: stkarg_area_info_t, cc: callcnv_t) -> int:
        r"""Get some metrics of the stack argument area. 
                  
        :param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
        :param cc: (::callcnv_t) calling convention
        :returns: 1: if success
        :returns: 0: not implemented
        """
        ...
    def ev_get_stkvar_scale_factor(self) -> int:
        r"""Should stack variable references be multiplied by a coefficient before being used in the stack frame?. Currently used by TMS320C55 because the references into the stack should be multiplied by 2 
                  
        :returns: scaling factor
        :returns: 0: not implemented
        """
        ...
    def ev_getreg(self, regval: uval_t, regnum: int) -> int:
        r"""IBM PC only internal request, should never be used for other purpose Get register value by internal index 
                  
        :param regval: (uval_t *), out
        :param regnum: (int)
        :returns: 1: ok
        :returns: 0: not implemented
        :returns: -1: failed (undefined value or bad regnum)
        """
        ...
    def ev_init(self, idp_modname: str) -> int:
        r"""The IDP module is just loaded. 
                  
        :param idp_modname: (const char *) processor module name
        :returns: <0: on failure
        """
        ...
    def ev_insn_reads_tbit(self, insn: insn_t, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Check if insn will read the TF bit. 
                  
        :param insn: (const insn_t*) the instruction
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 2: yes, will generate 'step' exception
        :returns: 1: yes, will store the TF bit in memory
        :returns: 0: no
        """
        ...
    def ev_is_addr_insn(self, type: int, insn: insn_t) -> int:
        r"""Does the instruction calculate some address using an immediate operand? e.g. in PC such operand may be o_displ: 'lea eax, [esi+4]' 
                  
        :param type: (int *) pointer to the returned instruction type:
        * 0 the "add" instruction (the immediate operand is a relative value)
        * 1 the "move" instruction (the immediate operand is an absolute value)
        * 2 the "sub" instruction (the immediate operand is a relative value)
        :param insn: (const insn_t *) instruction
        :returns: >0 the operand number+1
        :returns: 0: not implemented
        """
        ...
    def ev_is_align_insn(self, ea: ida_idaapi.ea_t) -> int:
        r"""Is the instruction created only for alignment purposes?. Do not directly call this function, use is_align_insn() 
                  
        :param ea: (ea_t) - instruction address
        :returns: number: of bytes in the instruction
        """
        ...
    def ev_is_alloca_probe(self, ea: ida_idaapi.ea_t) -> int:
        r"""Does the function at 'ea' behave as __alloca_probe? 
                  
        :param ea: (::ea_t)
        :returns: 1: yes
        :returns: 0: no
        """
        ...
    def ev_is_basic_block_end(self, insn: insn_t, call_insn_stops_block: bool) -> int:
        r"""Is the current instruction end of a basic block?. This function should be defined for processors with delayed jump slots. 
                  
        :param insn: (const insn_t*) the instruction
        :param call_insn_stops_block: (bool)
        :returns: 0: unknown
        :returns: <0: no
        :returns: 1: yes
        """
        ...
    def ev_is_call_insn(self, insn: insn_t) -> int:
        r"""Is the instruction a "call"? 
                  
        :param insn: (const insn_t *) instruction
        :returns: 0: unknown
        :returns: <0: no
        :returns: 1: yes
        """
        ...
    def ev_is_cond_insn(self, insn: insn_t) -> int:
        r"""Is conditional instruction? 
                  
        :param insn: (const insn_t *) instruction address
        :returns: 1: yes
        :returns: -1: no
        :returns: 0: not implemented or not instruction
        """
        ...
    def ev_is_control_flow_guard(self, p_reg: int, insn: insn_t) -> int:
        r"""Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) 
                  
        :param p_reg: (int *) indirect register number, may be -1
        :param insn: (const insn_t *) call/jump instruction
        :returns: -1: no thunk detected
        :returns: 1: indirect call
        :returns: 2: security check routine call (NOP)
        :returns: 3: return thunk
        :returns: 0: not implemented
        """
        ...
    def ev_is_far_jump(self, icode: int) -> int:
        r"""is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types 
                  
        :param icode: (int)
        :returns: 0: not implemented
        :returns: 1: yes
        :returns: -1: no
        """
        ...
    def ev_is_indirect_jump(self, insn: insn_t) -> int:
        r"""Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all jump types jumps, please define this callback. 
                  
        :param insn: (const insn_t*) the instruction
        :returns: 0: use CF_JUMP
        :returns: 1: no
        :returns: 2: yes
        """
        ...
    def ev_is_insn_table_jump(self) -> int:
        r"""Reserved.
        
        """
        ...
    def ev_is_jump_func(self, pfn: func_t, jump_target: ea_t, func_pointer: ea_t) -> int:
        r"""Is the function a trivial "jump" function?. 
                  
        :param pfn: (func_t *)
        :param jump_target: (::ea_t *)
        :param func_pointer: (::ea_t *)
        :returns: <0: no
        :returns: 0: don't know
        :returns: 1: yes, see 'jump_target' and 'func_pointer'
        """
        ...
    def ev_is_ret_insn(self, insn: insn_t, flags: uchar) -> int:
        r"""Is the instruction a "return"? 
                  
        :param insn: (const insn_t *) instruction
        :param flags: (uchar), combination of IRI_... flags (see above)
        :returns: 0: unknown
        :returns: <0: no
        :returns: 1: yes
        """
        ...
    def ev_is_sane_insn(self, insn: insn_t, no_crefs: int) -> int:
        r"""Is the instruction sane for the current file type?. 
                  
        :param insn: (const insn_t*) the instruction
        :param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason.
        :returns: >=0: ok
        :returns: <0: no, the instruction isn't likely to appear in the program
        """
        ...
    def ev_is_sp_based(self, mode: int, insn: insn_t, op: op_t) -> int:
        r"""Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. Implement this event only if some stack references use frame pointer instead of stack pointer. 
                  
        :param mode: (int *) out, combination of SP/FP operand flags
        :param insn: (const insn_t *)
        :param op: (const op_t *)
        :returns: 0: not implemented
        :returns: 1: ok
        """
        ...
    def ev_is_switch(self, si: switch_info_t, insn: insn_t) -> int:
        r"""Find 'switch' idiom or override processor module's decision. It will be called for instructions marked with CF_JUMP. 
                  
        :param si: (switch_info_t *), out
        :param insn: (const insn_t *) instruction possibly belonging to a switch
        :returns: 1: switch is found, 'si' is filled. IDA will create the switch using the filled 'si'
        :returns: -1: no switch found. This value forbids switch creation by the processor module
        :returns: 0: not implemented
        """
        ...
    def ev_last_cb_before_loader(self) -> int:
        ...
    def ev_loader(self) -> int:
        r"""This code and higher ones are reserved for the loaders. The arguments and the return values are defined by the loaders 
                  
        """
        ...
    def ev_lower_func_type(self, argnums: intvec_t, fti: func_type_data_t) -> int:
        r"""Get function arguments which should be converted to pointers when lowering function prototype. The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. 
                  
        :param argnums: (intvec_t *), out - numbers of arguments to be converted to pointers in acsending order
        :param fti: (func_type_data_t *), inout func type details
        :returns: 0: not implemented
        :returns: 1: argnums was filled
        :returns: 2: argnums was filled and made substantial changes to fti argnums[0] can contain a special negative value indicating that the return value should be passed as a hidden 'retstr' argument: -1 this argument is passed as the first one and the function returns a pointer to the argument, -2 this argument is passed as the last one and the function returns a pointer to the argument, -3 this argument is passed as the first one and the function returns 'void'.
        """
        ...
    def ev_max_ptr_size(self) -> int:
        r"""Get maximal size of a pointer in bytes. 
                  
        :returns: max possible size of a pointer
        """
        ...
    def ev_may_be_func(self, insn: insn_t, state: int) -> int:
        r"""Can a function start here? 
                  
        :param insn: (const insn_t*) the instruction
        :param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
        :returns: probability 1..100
        """
        ...
    def ev_may_show_sreg(self, current_ea: ida_idaapi.ea_t) -> int:
        r"""The kernel wants to display the segment registers in the messages window. 
                  
        :param current_ea: (::ea_t)
        :returns: <0: if the kernel should not show the segment registers. (assuming that the module has done it)
        :returns: 0: not implemented
        """
        ...
    def ev_moving_segm(self, seg: segment_t, to: ida_idaapi.ea_t, flags: int) -> int:
        r"""May the kernel move the segment? 
                  
        :param seg: (segment_t *) segment to move
        :param to: (::ea_t) new segment start address
        :param flags: (int) combination of Move segment flags
        :returns: 0: yes
        :returns: <0: the kernel should stop
        """
        ...
    def ev_newasm(self, asmnum: int) -> int:
        r"""Before setting a new assembler. 
                  
        :param asmnum: (int) See also ev_asm_installed
        """
        ...
    def ev_newbinary(self, filename: char, fileoff: qoff64_t, basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: uint64) -> int:
        r"""IDA is about to load a binary file. 
                  
        :param filename: (char *) binary file name
        :param fileoff: (qoff64_t) offset in the file
        :param basepara: (::ea_t) base loading paragraph
        :param binoff: (::ea_t) loader offset
        :param nbytes: (::uint64) number of bytes to load
        """
        ...
    def ev_newfile(self, fname: char) -> int:
        r"""A new file has been loaded. 
                  
        :param fname: (char *) input file name
        """
        ...
    def ev_newprc(self, pnum: int, keep_cfg: bool) -> int:
        r"""Before changing processor type. 
                  
        :param pnum: (int) processor number in the array of processor names
        :param keep_cfg: (bool) true: do not modify kernel configuration
        :returns: 1: ok
        :returns: <0: prohibit
        """
        ...
    def ev_next_exec_insn(self, target: ea_t, ea: ida_idaapi.ea_t, tid: int, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Get next address to be executed This function must return the next address to be executed. If the instruction following the current one is executed, then it must return BADADDR Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. 
                  
        :param target: (::ea_t *), out: pointer to the answer
        :param ea: (::ea_t) instruction address
        :param tid: (int) current therad id
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_oldfile(self, fname: char) -> int:
        r"""An old file has been loaded. 
                  
        :param fname: (char *) input file name
        """
        ...
    def ev_out_assumes(self, outctx: outctx_t) -> int:
        r"""Function to produce assume directives when segment register value changes. 
                  
        :param outctx: (outctx_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_out_data(self, outctx: outctx_t, analyze_only: bool) -> int:
        r"""Generate text representation of data items This function may change the database and create cross-references if analyze_only is set 
                  
        :param outctx: (outctx_t *)
        :param analyze_only: (bool)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_out_footer(self, outctx: outctx_t) -> int:
        r"""Function to produce end of disassembled text 
                  
        :param outctx: (outctx_t *)
        :returns: void: 
        """
        ...
    def ev_out_header(self, outctx: outctx_t) -> int:
        r"""Function to produce start of disassembled text 
                  
        :param outctx: (outctx_t *)
        :returns: void: 
        """
        ...
    def ev_out_insn(self, outctx: outctx_t) -> bool:
        r"""Generate text representation of an instruction in 'ctx.insn' outctx_t provides functions to output the generated text. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. 
                  
        :param outctx: (outctx_t *)
        :returns: void: 
        """
        ...
    def ev_out_label(self, outctx: outctx_t, colored_name: str) -> int:
        r"""The kernel is going to generate an instruction label line or a function header. 
                  
        :param outctx: (outctx_t *)
        :param colored_name: (const char *)
        :returns: <0: if the kernel should not generate the label
        :returns: 0: not implemented or continue
        """
        ...
    def ev_out_mnem(self, outctx: outctx_t) -> int:
        r"""Generate instruction mnemonics. This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. 
                  
        :param outctx: (outctx_t *)
        :returns: 1: if appended the mnemonics
        :returns: 0: not implemented
        """
        ...
    def ev_out_operand(self, outctx: outctx_t, op: op_t) -> bool:
        r"""Generate text representation of an instruction operand outctx_t provides functions to output the generated text. All these actions should be performed only by emu_insn() function. 
                  
        :param outctx: (outctx_t *)
        :param op: (const op_t *)
        :returns: 1: ok
        :returns: -1: operand is hidden
        """
        ...
    def ev_out_segend(self, outctx: outctx_t, seg: segment_t) -> int:
        r"""Function to produce end of segment 
                  
        :param outctx: (outctx_t *)
        :param seg: (segment_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_out_segstart(self, outctx: outctx_t, seg: segment_t) -> int:
        r"""Function to produce start of segment 
                  
        :param outctx: (outctx_t *)
        :param seg: (segment_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_out_special_item(self, outctx: outctx_t, segtype: uchar) -> int:
        r"""Generate text representation of an item in a special segment i.e. absolute symbols, externs, communal definitions etc 
                  
        :param outctx: (outctx_t *)
        :param segtype: (uchar)
        :returns: 1: ok
        :returns: 0: not implemented
        :returns: -1: overflow
        """
        ...
    def ev_privrange_changed(self, old_privrange: range_t, delta: adiff_t) -> int:
        r"""Privrange interval has been moved to a new location. Most common actions to be done by module in this case: fix indices of netnodes used by module 
                  
        :param old_privrange: (const range_t *) - old privrange interval
        :param delta: (::adiff_t)
        :returns: 0: Ok
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_realcvt(self, m: void, e: fpvalue_t, swt: uint16) -> int:
        r"""Floating point -> IEEE conversion 
                  
        :param m: (void *) ptr to processor-specific floating point value
        :param e: (fpvalue_t *) IDA representation of a floating point value
        :param swt: (uint16) operation (see realcvt() in ieee.h)
        :returns: 0: not implemented
        """
        ...
    def ev_rename(self, ea: ida_idaapi.ea_t, new_name: str) -> int:
        r"""The kernel is going to rename a byte. 
                  
        :param ea: (::ea_t)
        :param new_name: (const char *)
        :returns: <0: if the kernel should not rename it.
        :returns: 2: to inhibit the notification. I.e., the kernel should not rename, but 'set_name()' should return 'true'. also see renamed the return value is ignored when kernel is going to delete name
        """
        ...
    def ev_replaying_undo(self, action_name: str, vec: undo_records_t, is_undo: bool) -> int:
        r"""Replaying an undo/redo buffer 
                  
        :param action_name: (const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers.
        :param vec: (const undo_records_t *)
        :param is_undo: (bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo
        """
        ...
    def ev_set_code16_mode(self, ea: ida_idaapi.ea_t, code16: bool) -> int:
        r"""Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode 
                  
        :param ea: (ea_t) address to set new ISA mode
        :param code16: (bool) true for 16-bit mode, false for 32-bit mode
        """
        ...
    def ev_set_idp_options(self, keyword: str, value_type: int, value: void, idb_loaded: bool) -> int:
        r"""Set IDP-specific configuration option Also see set_options_t in config.hpp 
                  
        :param keyword: (const char *)
        :param value_type: (int)
        :param value: (const void *)
        :param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been generated
        :returns: 1: ok
        :returns: 0: not implemented
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_set_proc_options(self, options: str, confidence: int) -> int:
        r"""Called if the user specified an option string in the command line: -p<processor name>:<options>. Can be used for setting a processor subtype. Also called if option string is passed to set_processor_type() and IDC's SetProcessorType(). 
                  
        :param options: (const char *)
        :param confidence: (int) 0: loader's suggestion 1: user's decision
        :returns: <0: if bad option string
        """
        ...
    def ev_setup_til(self) -> int:
        r"""Setup default type libraries. (called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. 
                  
        :returns: void: 
        """
        ...
    def ev_str2reg(self, regname: str) -> int:
        r"""Convert a register name to a register number. The register number is the register index in the processor_t::reg_names array Most processor modules do not need to implement this callback It is useful only if processor_t::reg_names[reg] does not provide the correct register names 
                  
        :param regname: (const char *)
        :returns: register: number + 1
        :returns: 0: not implemented or could not be decoded
        """
        ...
    def ev_term(self) -> int:
        r"""The IDP module is being unloaded.
        
        """
        ...
    def ev_treat_hindering_item(self, hindering_item_ea: ida_idaapi.ea_t, new_item_flags: flags64_t, new_item_ea: ida_idaapi.ea_t, new_item_length: asize_t) -> int:
        r"""An item hinders creation of another item. 
                  
        :param hindering_item_ea: (::ea_t)
        :param new_item_flags: (flags64_t) (0 for code)
        :param new_item_ea: (::ea_t)
        :param new_item_length: (::asize_t)
        :returns: 0: no reaction
        :returns: !=0: the kernel may delete the hindering item
        """
        ...
    def ev_undefine(self, ea: ida_idaapi.ea_t) -> int:
        r"""An item in the database (insn or data) is being deleted. 
                  
        :param ea: (ea_t)
        :returns: 1: do not delete srranges at the item end
        :returns: 0: srranges can be deleted
        """
        ...
    def ev_update_call_stack(self, stack: call_stack_t, tid: int, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Calculate the call stack trace for the given thread. This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. 
                  
        :param stack: (call_stack_t *) result
        :param tid: (int) thread id
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 1: ok
        :returns: -1: failed
        :returns: 0: unimplemented
        """
        ...
    def ev_use_arg_types(self, ea: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> int:
        r"""Use information about callee arguments. 
                  
        :param ea: (::ea_t) address of the call instruction
        :param fti: (func_type_data_t *) info about function type
        :param rargs: (funcargvec_t *) array of register arguments
        :returns: 1: (and removes handled arguments from fti and rargs)
        :returns: 0: not implemented
        """
        ...
    def ev_use_regarg_type(self, ea: ida_idaapi.ea_t, rargs: funcargvec_t) -> Any:
        r"""Use information about register argument. 
                  
        :param ea: (::ea_t) address of the instruction
        :param rargs: (const funcargvec_t *) vector of register arguments (including regs extracted from scattered arguments)
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_use_stkarg_type(self, ea: ida_idaapi.ea_t, arg: funcarg_t) -> int:
        r"""Use information about a stack argument. 
                  
        :param ea: (::ea_t) address of the push instruction which pushes the function argument into the stack
        :param arg: (const funcarg_t *) argument info
        :returns: 1: ok
        :returns: <=0: failed, the kernel will create a comment with the argument name or type for the instruction
        """
        ...
    def ev_validate_flirt_func(self, start_ea: ida_idaapi.ea_t, funcname: str) -> int:
        r"""Flirt has recognized a library function. This callback can be used by a plugin or proc module to intercept it and validate such a function. 
                  
        :param start_ea: (::ea_t)
        :param funcname: (const char *)
        :returns: -1: do not create a function,
        :returns: 0: function is validated
        """
        ...
    def ev_verify_noreturn(self, pfn: func_t) -> int:
        r"""The kernel wants to set 'noreturn' flags for a function. 
                  
        :param pfn: (func_t *)
        :returns: 0: ok. any other value: do not set 'noreturn' flag
        """
        ...
    def ev_verify_sp(self, pfn: func_t) -> int:
        r"""All function instructions have been analyzed. Now the processor module can analyze the stack pointer for the whole function 
                  
        :param pfn: (func_t *)
        :returns: 0: ok
        :returns: <0: bad stack pointer
        """
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...

class NearestName:
    r"""
    Utility class to help find the nearest name in a given ea/name dictionary
    
    """
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: Any) -> Any:
        r"""Returns the tupple (ea, name, index)"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, ea_names: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def find(self, ea: Any) -> Any:
        r"""
        Returns a tupple (ea, name, pos) that is the nearest to the passed ea
        If no name is matched then None is returned
        
        """
        ...
    def update(self, ea_names: Any) -> Any:
        r"""Updates the ea/names map"""
        ...

class PluginForm:
    r"""
    PluginForm class.
    
    This form can be used to host additional controls. Please check the PyQt example.
    
    """
    VALID_CAPSULE_NAME: bytes  # b'$valid$'
    WCLS_CLOSE_LATER: int  # 8
    WCLS_DELETE_LATER: int  # 8
    WCLS_DONT_SAVE_SIZE: int  # 4
    WCLS_NO_CONTEXT: int  # 2
    WCLS_SAVE: int  # 1
    WOPN_CENTERED: int  # 32
    WOPN_CREATE_ONLY: dict  # {}
    WOPN_DP_BEFORE: int  # 2097152
    WOPN_DP_BOTTOM: int  # 524288
    WOPN_DP_FLOATING: int  # 8388608
    WOPN_DP_INSIDE: int  # 1048576
    WOPN_DP_INSIDE_BEFORE: int  # 3145728
    WOPN_DP_LEFT: int  # 65536
    WOPN_DP_RIGHT: int  # 262144
    WOPN_DP_SZHINT: int  # 16777216
    WOPN_DP_TAB: int  # 4194304
    WOPN_DP_TAB_BEFORE: int  # 6291456
    WOPN_DP_TOP: int  # 131072
    WOPN_MDI: int  # 1
    WOPN_MENU: int  # 16
    WOPN_ONTOP: int  # 8
    WOPN_PERSIST: int  # 64
    WOPN_RESTORE: int  # 4
    WOPN_TAB: int  # 2
    def Close(self, options: Any) -> Any:
        r"""
        Closes the form.
        
        :param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)
        
        :returns: None
        
        """
        ...
    def FormToPyQtWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def FormToPySideWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Use this method to convert a TWidget* to a QWidget to be used by PySide
        
        :param ctx: Context. Reference to a module that already imported QtWidgets module
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def OnClose(self, form: Any) -> Any:
        r"""
        Called when the plugin form is closed
        
        :returns: None
        
        """
        ...
    def OnCreate(self, form: Any) -> Any:
        r"""
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.
        
        :returns: None
        
        """
        ...
    def QtWidgetToTWidget(self, w: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a QWidget to a TWidget* to be used by IDA
        
        :param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        
        """
        ...
    def Show(self, caption: Any, options: Any = 0) -> Any:
        r"""
        Creates the form if not was not created or brings to front if it was already created
        
        :param caption: The form caption
        :param options: One of PluginForm.WOPN_ constants
        
        """
        ...
    def TWidgetToPyQtWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def TWidgetToPySideWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Use this method to convert a TWidget* to a QWidget to be used by PySide
        
        :param ctx: Context. Reference to a module that already imported QtWidgets module
        
        """
        ...
    def TWidgetToQtPythonWidget(self, tw: Any, ctx: Any = ...) -> Any:
        r"""
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        
        """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        r"""
                
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class PyIdc_cvt_int64__(pyidc_cvt_helper__):
    r"""Helper class for explicitly representing VT_INT64 values"""
    @property
    def value(self) -> Any: ...
    def __add__(self, other: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __div__(self, other: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, v: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __mul__(self, other: Any) -> Any:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __radd__(self, other: Any) -> Any:
        ...
    def __rdiv__(self, other: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __rmul__(self, other: Any) -> Any:
        ...
    def __rsub__(self, other: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __sub__(self, other: Any) -> Any:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class PyIdc_cvt_refclass__(pyidc_cvt_helper__):
    r"""Helper class for representing references to immutable objects"""
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, v: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def cstr(self) -> Any:
        r"""Returns the string as a C string (up to the zero termination)"""
        ...

class TPointDouble:
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: TPointDouble) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: TPointDouble) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, r: TPointDouble) -> None:
        ...
    def negate(self) -> None:
        ...
    def sub(self, r: TPointDouble) -> None:
        ...

class UI_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __real_database_closed(self) -> None:
        r"""The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
                  
        :returns: void
        """
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def create_desktop_widget(self, title: str, cfg: jobj_wrapper_t) -> Any:
        r"""create a widget, to be placed in the widget tree (at desktop-creation time.) 
                  
        :param title: (const char *)
        :param cfg: (const jobj_t *)
        :returns: TWidget * the created widget, or null
        """
        ...
    def current_widget_changed(self, widget: TWidget, prev_widget: TWidget) -> None:
        r"""The currently-active TWidget changed. 
                  
        :param widget: (TWidget *)
        :param prev_widget: (TWidget *)
        :returns: void
        """
        ...
    def database_closed(self, args: Any) -> Any:
        r"""The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
                  
        :returns: void
        """
        ...
    def database_inited(self, is_new_database: int, idc_script: str) -> None:
        r"""database initialization has completed. the kernel is about to run idc scripts 
                  
        :param is_new_database: (int)
        :param idc_script: (const char *) - may be nullptr
        :returns: void See also ui_initing_database. This event is called for both new and old databases.
        """
        ...
    def debugger_menu_change(self, enable: bool) -> None:
        r"""debugger menu modification detected 
                  
        :param enable: (bool) true: debugger menu has been added, or a different debugger has been selected false: debugger menu will be removed (user switched to "No debugger")
        :returns: void
        """
        ...
    def desktop_applied(self, name: str, from_idb: bool, type: int) -> None:
        r"""a desktop has been applied 
                  
        :param name: (const char *) the desktop name
        :param from_idb: (bool) the desktop was stored in the IDB (false if it comes from the registry)
        :param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)
        """
        ...
    def destroying_plugmod(self, plugmod: plugmod_t, entry: plugin_t) -> None:
        r"""The plugin object is about to be destroyed 
                  
        :param plugmod: (const plugmod_t *)
        :param entry: (const plugin_t *)
        """
        ...
    def destroying_procmod(self, procmod: procmod_t) -> None:
        r"""The processor module is about to be destroyed 
                  
        :param procmod: (const procmod_t *)
        """
        ...
    def finish_populating_widget_popup(self, widget: TWidget, popup_handle: TPopupMenu, ctx: action_ctx_base_t = None) -> None:
        r"""IDA is about to be done populating the context menu for a widget. This is your chance to attach_action_to_popup().
        
        :param widget: (TWidget *)
        :param popup_handle: (TPopupMenu *)
        :param ctx: (const action_activation_ctx_t *)
        :returns: void
        """
        ...
    def get_chooser_item_attrs(self, chooser: chooser_base_t, n: size_t, attrs: chooser_item_attrs_t) -> None:
        r"""get item-specific attributes for a chooser. This callback is generated only after enable_chooser_attrs() 
                  
        :param chooser: (const chooser_base_t *)
        :param n: (::size_t)
        :param attrs: (chooser_item_attrs_t *)
        :returns: void
        """
        ...
    def get_custom_viewer_hint(self, viewer: TWidget, place: place_t) -> Any:
        r"""ui wants to display a hint for a viewer (idaview or custom). Every subscriber is supposed to append the hint lines to HINT and increment IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT is possible but not recommended. If the REG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the source-level debugger-generated hints. The following keywords might appear at the beginning of the returned hints: HIGHLIGHT text
         where text will be highlighted CAPTION caption
         caption for the hint widget 
                  
        :param viewer: (TWidget*) viewer
        :param place: (place_t *) current position in the viewer
        :returns: 0: continue collecting hints with other subscribers
        :returns: 1: stop collecting hints
        """
        ...
    def get_ea_hint(self, ea: ida_idaapi.ea_t) -> Any:
        r"""ui wants to display a simple hint for an address. Use this event to generate a custom hint See also more generic ui_get_item_hint 
                  
        :param ea: (::ea_t)
        :returns: true if generated a hint
        """
        ...
    def get_item_hint(self, ea: ida_idaapi.ea_t, max_lines: int) -> Any:
        r"""ui wants to display multiline hint for an item. See also more generic ui_get_custom_viewer_hint 
                  
        :param ea: (ea_t) or item id like a structure or enum member
        :param max_lines: (int) maximal number of lines
        :returns: true if generated a hint
        """
        ...
    def get_lines_rendering_info(self, out: lines_rendering_output_t, widget: TWidget, info: lines_rendering_input_t) -> None:
        r"""get lines rendering information 
                  
        :param out: (lines_rendering_output_t *)
        :param widget: (const TWidget *)
        :param info: (const lines_rendering_input_t *)
        :returns: void
        """
        ...
    def get_widget_config(self, widget: TWidget, cfg: jobj_t) -> Any:
        r"""retrieve the widget configuration (it will be passed back at ui_create_desktop_widget-, and ui_set_widget_config-time) 
                  
        :param widget: (const TWidget *)
        :param cfg: (jobj_t *)
        :returns: void
        """
        ...
    def hook(self) -> bool:
        ...
    def idcstart(self) -> None:
        r"""Start of IDC engine work. 
                  
        :returns: void
        """
        ...
    def idcstop(self) -> None:
        r"""Stop of IDC engine work. 
                  
        :returns: void
        """
        ...
    def initing_database(self) -> None:
        r"""database initialization has started. 
                  
        :returns: void See also ui_database_inited. This event is called for both new and old databases.
        """
        ...
    def plugin_loaded(self, plugin_info: plugin_info_t) -> None:
        r"""The plugin was loaded in memory. 
                  
        :param plugin_info: (const plugin_info_t *)
        """
        ...
    def plugin_unloading(self, plugin_info: plugin_info_t) -> None:
        r"""The plugin is about to be unloaded 
                  
        :param plugin_info: (const plugin_info_t *)
        """
        ...
    def populating_widget_popup(self, widget: TWidget, popup_handle: TPopupMenu, ctx: action_ctx_base_t = None) -> None:
        r"""IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
        Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)
        
        :param widget: (TWidget *)
        :param popup_handle: (TPopupMenu *)
        :param ctx: (const action_activation_ctx_t *)
        :returns: void
        """
        ...
    def postprocess_action(self) -> None:
        r"""an ida ui action has been handled
        
        """
        ...
    def preprocess_action(self, name: str) -> int:
        r"""ida ui is about to handle a user action. 
                  
        :param name: (const char *) ui action name. these names can be looked up in ida[tg]ui.cfg
        :returns: 0: ok
        :returns: nonzero: a plugin has handled the command
        """
        ...
    def range(self) -> None:
        r"""The disassembly range has been changed ( idainfo::min_ea ... idainfo::max_ea). UI should redraw the scrollbars. See also: ui_lock_range_refresh 
                  
        :returns: void
        """
        ...
    def ready_to_run(self) -> None:
        r"""all UI elements have been initialized. Automatic plugins may hook to this event to perform their tasks. 
                  
        :returns: void
        """
        ...
    def resume(self) -> None:
        r"""Resume the suspended graphical interface. Only the text version. Interface should respond to it 
                  
        :returns: void
        """
        ...
    def saved(self, path: str) -> None:
        r"""The kernel has saved the database. This callback just informs the interface. Note that at the time this notification is sent, the internal paths are not updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path. 
                  
        :param path: (const char *) the database path
        :returns: void
        """
        ...
    def saving(self) -> None:
        r"""The kernel is flushing its buffers to the disk. The user interface should save its state. Parameters: none Returns: none 
                  
        """
        ...
    def screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t) -> None:
        r"""The "current address" changed 
                  
        :param ea: (ea_t)
        :param prev_ea: (ea_t)
        :returns: void
        """
        ...
    def set_widget_config(self, widget: TWidget, cfg: jobj_wrapper_t) -> None:
        r"""set the widget configuration 
                  
        :param widget: (const TWidget *)
        :param cfg: (const jobj_t *)
        :returns: void
        """
        ...
    def suspend(self) -> None:
        r"""Suspend graphical interface. Only the text version. Interface should respond to it. 
                  
        :returns: void
        """
        ...
    def unhook(self) -> bool:
        ...
    def updated_actions(self) -> None:
        r"""IDA is done updating actions. 
                  
        :returns: void
        """
        ...
    def updating_actions(self, ctx: action_ctx_base_t) -> None:
        r"""IDA is about to update all actions. If your plugin needs to perform expensive operations more than once (e.g., once per action it registers), you should do them only once, right away. 
                  
        :param ctx: (action_update_ctx_t *)
        :returns: void
        """
        ...
    def widget_closing(self, widget: TWidget) -> None:
        r"""TWidget is about to close. This event precedes ui_widget_invisible. Use this to perform some possible actions relevant to the lifecycle of this widget 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...
    def widget_invisible(self, widget: TWidget) -> None:
        r"""TWidget is being closed. Use this event to destroy the window controls 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...
    def widget_visible(self, widget: TWidget) -> None:
        r"""TWidget is displayed on the screen. Use this event to populate the window with controls 
                  
        :param widget: (TWidget *)
        :returns: void
        """
        ...

class View_Hooks:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int = 0, _hkcb_flags: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def hook(self) -> bool:
        ...
    def unhook(self) -> bool:
        ...
    def view_activated(self, view: TWidget) -> None:
        r"""A view is activated 
                  
        :param view: (TWidget *)
        """
        ...
    def view_click(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""Click event 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_close(self, view: TWidget) -> None:
        r"""View closed 
                  
        :param view: (TWidget *)
        """
        ...
    def view_created(self, view: TWidget) -> None:
        r"""A view is being created. 
                  
        :param view: (TWidget *)
        """
        ...
    def view_curpos(self, view: TWidget) -> None:
        r"""Cursor position changed 
                  
        :param view: (TWidget *)
        """
        ...
    def view_dblclick(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""Double click event 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_deactivated(self, view: TWidget) -> None:
        r"""A view is deactivated 
                  
        :param view: (TWidget *)
        """
        ...
    def view_keydown(self, view: TWidget, key: int, state: view_event_state_t) -> None:
        r"""Key down event 
                  
        :param view: (TWidget *)
        :param key: (int)
        :param state: (::view_event_state_t)
        """
        ...
    def view_loc_changed(self, view: TWidget, now: lochist_entry_t, was: lochist_entry_t) -> None:
        r"""The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
                  
        :param view: (TWidget *)
        :param now: (const lochist_entry_t *)
        :param was: (const lochist_entry_t *)
        """
        ...
    def view_mouse_moved(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""The mouse moved on the view 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_mouse_over(self, view: TWidget, event: view_mouse_event_t) -> None:
        r"""The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
                  
        :param view: (TWidget *)
        :param event: (const view_mouse_event_t *)
        """
        ...
    def view_switched(self, view: TWidget, rt: tcc_renderer_type_t) -> None:
        r"""A view's renderer has changed. 
                  
        :param view: (TWidget *)
        :param rt: (tcc_renderer_type_t)
        """
        ...

class abstract_graph_t(gdl_graph_t):
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_tree_layout(self) -> bool:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class action_ctx_base_cur_sel_t:
    @property
    def to(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reset(self) -> None:
        ...

class action_ctx_base_t:
    @property
    def action(self) -> Any: ...
    @property
    def chooser(self) -> Any: ...
    @property
    def chooser_selection(self) -> Any: ...
    @property
    def cur_ea(self) -> Any: ...
    @property
    def cur_extracted_ea(self) -> Any: ...
    @property
    def cur_fchunk(self) -> Any: ...
    @property
    def cur_flags(self) -> Any: ...
    @property
    def cur_func(self) -> Any: ...
    @property
    def cur_seg(self) -> Any: ...
    @property
    def cur_sel(self) -> Any: ...
    @property
    def cur_value(self) -> Any: ...
    @property
    def dirtree_selection(self) -> Any: ...
    @property
    def focus(self) -> Any: ...
    @property
    def form(self) -> Any: ...
    @property
    def form_title(self) -> Any: ...
    @property
    def form_type(self) -> Any: ...
    @property
    def graph(self) -> Any: ...
    @property
    def graph_selection(self) -> Any: ...
    @property
    def hovered(self) -> Any: ...
    @property
    def regname(self) -> Any: ...
    @property
    def type_ref(self) -> Any: ...
    @property
    def widget(self) -> Any: ...
    @property
    def widget_title(self) -> Any: ...
    @property
    def widget_type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def has_flag(self, flag: int) -> bool:
        r"""Check if the given flag is set.
        
        """
        ...
    def reset(self) -> None:
        r"""Invalidate all context info.
        
        """
        ...

class action_desc_t:
    @property
    def cb(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def owner(self) -> Any: ...
    @property
    def shortcut(self) -> Any: ...
    @property
    def tooltip(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, name: str, label: str, handler: Any, shortcut: str = None, tooltip: str = None, icon: int = -1, flags: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class action_handler_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def activate(self, ctx: Any) -> Any:
        r"""Activate an action. This function implements the core behavior of an action. It is called when the action is triggered, from a menu, from a popup menu, from the toolbar, or programmatically. 
                
        :returns: non-zero: all IDA windows will be refreshed
        """
        ...
    def update(self, ctx: Any) -> Any:
        r"""Update an action. This is called when the context of the UI changed, and we need to let the action update some of its properties if needed (label, icon, ...)
        In addition, this lets IDA know whether the action is enabled, and when it should be queried for availability again.
        Note: This callback is not meant to change anything in the application's state, except by calling one (or many) of the "update_action_*()" functions on this very action. 
                
        """
        ...

class addon_info_t:
    @property
    def cb(self) -> Any: ...
    @property
    def custom_data(self) -> Any: ...
    @property
    def custom_size(self) -> Any: ...
    @property
    def freeform(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def producer(self) -> Any: ...
    @property
    def url(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class adiff_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: adiff_t) -> None:
        ...
    def cast(self) -> adiff_t:
        ...
    def frompointer(self, t: adiff_t) -> adiff_pointer:
        ...
    def value(self) -> adiff_t:
        ...

class aloc_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_location(self, v: argloc_t, off: int, size: int) -> int:
        ...

class argloc_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: argloc_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: argloc_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: argloc_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: argloc_t) -> bool:
        ...
    def __lt__(self, r: argloc_t) -> bool:
        ...
    def __ne__(self, r: argloc_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def advance(self, delta: int) -> bool:
        r"""Move the location to point 'delta' bytes further.
        
        """
        ...
    def align_reg_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set register offset to align it to the upper part of _SLOTSIZE.
        
        """
        ...
    def align_stkoff_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set stack offset to align to the upper part of _SLOTSIZE.
        
        """
        ...
    def atype(self) -> argloc_type_t:
        r"""Get type (Argument location types)
        
        """
        ...
    def calc_offset(self) -> int:
        r"""Calculate offset that can be used to compare 2 similar arglocs.
        
        """
        ...
    def compare(self, r: argloc_t) -> int:
        ...
    def consume_rrel(self, p: rrel_t) -> None:
        r"""Set register-relative location - can't be nullptr.
        
        """
        ...
    def consume_scattered(self, p: scattered_aloc_t) -> None:
        r"""Set distributed argument location.
        
        """
        ...
    def get_biggest(self) -> biggest_t:
        r"""Get largest element in internal union.
        
        """
        ...
    def get_custom(self) -> None:
        r"""Get custom argloc info. Use if atype() == ALOC_CUSTOM 
                
        """
        ...
    def get_ea(self) -> ida_idaapi.ea_t:
        r"""Get the global address. Use when atype() == ALOC_STATIC 
                
        """
        ...
    def get_reginfo(self) -> int:
        r"""Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def get_rrel(self) -> rrel_t:
        r"""Get register-relative info. Use when atype() == ALOC_RREL 
                
        """
        ...
    def has_reg(self) -> bool:
        r"""TRUE if argloc has a register part.
        
        """
        ...
    def has_stkoff(self) -> bool:
        r"""TRUE if argloc has a stack part.
        
        """
        ...
    def in_stack(self) -> bool:
        r"""TRUE if argloc is in stack entirely.
        
        """
        ...
    def is_badloc(self) -> bool:
        r"""See ALOC_NONE.
        
        """
        ...
    def is_custom(self) -> bool:
        r"""See ALOC_CUSTOM.
        
        """
        ...
    def is_ea(self) -> bool:
        r"""See ALOC_STATIC.
        
        """
        ...
    def is_fragmented(self) -> bool:
        r"""is_scattered() || is_reg2()
        
        """
        ...
    def is_mixed_scattered(self) -> bool:
        r"""mixed scattered: consists of register and stack parts
        
        """
        ...
    def is_reg(self) -> bool:
        r"""is_reg1() || is_reg2()
        
        """
        ...
    def is_reg1(self) -> bool:
        r"""See ALOC_REG1.
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""See ALOC_REG2.
        
        """
        ...
    def is_rrel(self) -> bool:
        r"""See ALOC_RREL.
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""See ALOC_DIST.
        
        """
        ...
    def is_stkoff(self) -> bool:
        r"""See ALOC_STACK.
        
        """
        ...
    def reg1(self) -> int:
        r"""Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def reg2(self) -> int:
        r"""Get info for the second register. Use when atype() == ALOC_REG2 
                
        """
        ...
    def regoff(self) -> int:
        r"""Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
                
        """
        ...
    def scattered(self) -> scattered_aloc_t:
        r"""Get scattered argument info. Use when atype() == ALOC_DIST 
                
        """
        ...
    def set_badloc(self) -> None:
        r"""Set to invalid location.
        
        """
        ...
    def set_ea(self, _ea: ida_idaapi.ea_t) -> None:
        r"""Set static ea location.
        
        """
        ...
    def set_reg1(self, reg: int, off: int = 0) -> None:
        r"""Set register location.
        
        """
        ...
    def set_reg2(self, _reg1: int, _reg2: int) -> None:
        r"""Set secondary register location.
        
        """
        ...
    def set_stkoff(self, off: int) -> None:
        r"""Set stack offset location.
        
        """
        ...
    def stkoff(self) -> int:
        r"""Get the stack offset. Use if atype() == ALOC_STACK 
                
        """
        ...
    def swap(self, r: argloc_t) -> None:
        r"""Assign this == r and r == this.
        
        """
        ...

class argpart_t(argloc_t):
    @property
    def off(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: argloc_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: argloc_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: argloc_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: argloc_t) -> bool:
        ...
    def __lt__(self, r: argpart_t) -> bool:
        ...
    def __ne__(self, r: argloc_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def advance(self, delta: int) -> bool:
        r"""Move the location to point 'delta' bytes further.
        
        """
        ...
    def align_reg_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set register offset to align it to the upper part of _SLOTSIZE.
        
        """
        ...
    def align_stkoff_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set stack offset to align to the upper part of _SLOTSIZE.
        
        """
        ...
    def atype(self) -> argloc_type_t:
        r"""Get type (Argument location types)
        
        """
        ...
    def bad_offset(self) -> bool:
        r"""Does this argpart have a valid offset?
        
        """
        ...
    def bad_size(self) -> bool:
        r"""Does this argpart have a valid size?
        
        """
        ...
    def calc_offset(self) -> int:
        r"""Calculate offset that can be used to compare 2 similar arglocs.
        
        """
        ...
    def compare(self, r: argloc_t) -> int:
        ...
    def consume_rrel(self, p: rrel_t) -> None:
        r"""Set register-relative location - can't be nullptr.
        
        """
        ...
    def consume_scattered(self, p: scattered_aloc_t) -> None:
        r"""Set distributed argument location.
        
        """
        ...
    def get_biggest(self) -> biggest_t:
        r"""Get largest element in internal union.
        
        """
        ...
    def get_custom(self) -> None:
        r"""Get custom argloc info. Use if atype() == ALOC_CUSTOM 
                
        """
        ...
    def get_ea(self) -> ida_idaapi.ea_t:
        r"""Get the global address. Use when atype() == ALOC_STATIC 
                
        """
        ...
    def get_reginfo(self) -> int:
        r"""Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def get_rrel(self) -> rrel_t:
        r"""Get register-relative info. Use when atype() == ALOC_RREL 
                
        """
        ...
    def has_reg(self) -> bool:
        r"""TRUE if argloc has a register part.
        
        """
        ...
    def has_stkoff(self) -> bool:
        r"""TRUE if argloc has a stack part.
        
        """
        ...
    def in_stack(self) -> bool:
        r"""TRUE if argloc is in stack entirely.
        
        """
        ...
    def is_badloc(self) -> bool:
        r"""See ALOC_NONE.
        
        """
        ...
    def is_custom(self) -> bool:
        r"""See ALOC_CUSTOM.
        
        """
        ...
    def is_ea(self) -> bool:
        r"""See ALOC_STATIC.
        
        """
        ...
    def is_fragmented(self) -> bool:
        r"""is_scattered() || is_reg2()
        
        """
        ...
    def is_mixed_scattered(self) -> bool:
        r"""mixed scattered: consists of register and stack parts
        
        """
        ...
    def is_reg(self) -> bool:
        r"""is_reg1() || is_reg2()
        
        """
        ...
    def is_reg1(self) -> bool:
        r"""See ALOC_REG1.
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""See ALOC_REG2.
        
        """
        ...
    def is_rrel(self) -> bool:
        r"""See ALOC_RREL.
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""See ALOC_DIST.
        
        """
        ...
    def is_stkoff(self) -> bool:
        r"""See ALOC_STACK.
        
        """
        ...
    def reg1(self) -> int:
        r"""Get the register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def reg2(self) -> int:
        r"""Get info for the second register. Use when atype() == ALOC_REG2 
                
        """
        ...
    def regoff(self) -> int:
        r"""Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
                
        """
        ...
    def scattered(self) -> scattered_aloc_t:
        r"""Get scattered argument info. Use when atype() == ALOC_DIST 
                
        """
        ...
    def set_badloc(self) -> None:
        r"""Set to invalid location.
        
        """
        ...
    def set_ea(self, _ea: ida_idaapi.ea_t) -> None:
        r"""Set static ea location.
        
        """
        ...
    def set_reg1(self, reg: int, off: int = 0) -> None:
        r"""Set register location.
        
        """
        ...
    def set_reg2(self, _reg1: int, _reg2: int) -> None:
        r"""Set secondary register location.
        
        """
        ...
    def set_stkoff(self, off: int) -> None:
        r"""Set stack offset location.
        
        """
        ...
    def stkoff(self) -> int:
        r"""Get the stack offset. Use if atype() == ALOC_STACK 
                
        """
        ...
    def swap(self, r: argpart_t) -> None:
        r"""Assign this = r and r = this.
        
        """
        ...

class argpartvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: argpartvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> argpart_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: argpartvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: argpart_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: argpart_t) -> bool:
        ...
    def append(self, x: argpart_t) -> None:
        ...
    def at(self, _idx: size_t) -> argpart_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: argpartvec_t) -> None:
        ...
    def extract(self) -> argpart_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: argpart_t) -> bool:
        ...
    def inject(self, s: argpart_t, len: size_t) -> None:
        ...
    def insert(self, it: argpart_t, x: argpart_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> argpart_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: argpartvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class argtinfo_helper_t:
    @property
    def reserved(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def has_delay_slot(self, arg0: ida_idaapi.ea_t) -> bool:
        r"""The call instruction with a delay slot?.
        
        """
        ...
    def is_stkarg_load(self, insn: insn_t, src: int, dst: int) -> bool:
        r"""Is the current insn a stkarg load?. if yes:
        * src: index of the source operand in insn_t::ops
        * dst: index of the destination operand in insn_t::ops insn_t::ops[dst].addr is expected to have the stack offset 
        
        
                
        """
        ...
    def set_op_tinfo(self, insn: insn_t, x: op_t, tif: tinfo_t, name: str) -> bool:
        r"""Set the operand type as specified.
        
        """
        ...
    def use_arg_tinfos(self, caller: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> None:
        r"""This function is to be called by the processor module in response to ev_use_arg_types. 
                
        """
        ...

class array_of_bitsets:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: array_of_bitsets) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> bitset_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: array_of_bitsets) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: bitset_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: bitset_t) -> bool:
        ...
    def append(self, x: bitset_t) -> None:
        ...
    def at(self, _idx: size_t) -> bitset_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: array_of_bitsets) -> None:
        ...
    def extract(self) -> bitset_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: bitset_t) -> bool:
        ...
    def inject(self, s: bitset_t, len: size_t) -> None:
        ...
    def insert(self, it: bitset_t, x: bitset_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> bitset_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: array_of_bitsets) -> None:
        ...
    def truncate(self) -> None:
        ...

class array_of_ivlsets:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: array_of_ivlsets) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ivlset_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: array_of_ivlsets) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ivlset_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: ivlset_t) -> bool:
        ...
    def append(self, x: ivlset_t) -> None:
        ...
    def at(self, _idx: size_t) -> ivlset_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: array_of_ivlsets) -> None:
        ...
    def extract(self) -> ivlset_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: ivlset_t) -> bool:
        ...
    def inject(self, s: ivlset_t, len: size_t) -> None:
        ...
    def insert(self, it: ivlset_t, x: ivlset_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ivlset_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: array_of_ivlsets) -> None:
        ...
    def truncate(self) -> None:
        ...

class array_of_node_bitset_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class array_of_rangesets:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: array_of_rangesets) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> rangeset_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: array_of_rangesets) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: rangeset_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: rangeset_t) -> bool:
        ...
    def append(self, x: rangeset_t) -> None:
        ...
    def at(self, _idx: size_t) -> rangeset_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: array_of_rangesets) -> None:
        ...
    def extract(self) -> rangeset_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: rangeset_t) -> bool:
        ...
    def inject(self, s: rangeset_t, len: size_t) -> None:
        ...
    def insert(self, it: rangeset_t, x: rangeset_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> rangeset_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: array_of_rangesets) -> None:
        ...
    def truncate(self) -> None:
        ...

class array_parameters_t:
    @property
    def alignment(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def lineitems(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _f: int = 1, _l: int = 0, _a: int = -1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_default(self) -> bool:
        ...

class array_type_data_t:
    @property
    def base(self) -> Any: ...
    @property
    def elem_type(self) -> Any: ...
    @property
    def nelems(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, b: size_t = 0, n: size_t = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def swap(self, r: array_type_data_t) -> None:
        r"""set this = r and r = this
        
        """
        ...

class asize_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: asize_t) -> None:
        ...
    def cast(self) -> int:
        ...
    def frompointer(self, t: asize_t) -> asize_pointer:
        ...
    def value(self) -> int:
        ...

class asm_t:
    @property
    def a_align(self) -> Any: ...
    @property
    def a_ascii(self) -> Any: ...
    @property
    def a_band(self) -> Any: ...
    @property
    def a_bnot(self) -> Any: ...
    @property
    def a_bor(self) -> Any: ...
    @property
    def a_bss(self) -> Any: ...
    @property
    def a_byte(self) -> Any: ...
    @property
    def a_comdef(self) -> Any: ...
    @property
    def a_curip(self) -> Any: ...
    @property
    def a_double(self) -> Any: ...
    @property
    def a_dups(self) -> Any: ...
    @property
    def a_dword(self) -> Any: ...
    @property
    def a_equ(self) -> Any: ...
    @property
    def a_extrn(self) -> Any: ...
    @property
    def a_float(self) -> Any: ...
    @property
    def a_include_fmt(self) -> Any: ...
    @property
    def a_mod(self) -> Any: ...
    @property
    def a_oword(self) -> Any: ...
    @property
    def a_packreal(self) -> Any: ...
    @property
    def a_public(self) -> Any: ...
    @property
    def a_qword(self) -> Any: ...
    @property
    def a_rva(self) -> Any: ...
    @property
    def a_seg(self) -> Any: ...
    @property
    def a_shl(self) -> Any: ...
    @property
    def a_shr(self) -> Any: ...
    @property
    def a_sizeof_fmt(self) -> Any: ...
    @property
    def a_tbyte(self) -> Any: ...
    @property
    def a_vstruc_fmt(self) -> Any: ...
    @property
    def a_weak(self) -> Any: ...
    @property
    def a_word(self) -> Any: ...
    @property
    def a_xor(self) -> Any: ...
    @property
    def a_yword(self) -> Any: ...
    @property
    def a_zword(self) -> Any: ...
    @property
    def accsep(self) -> Any: ...
    @property
    def ascsep(self) -> Any: ...
    @property
    def cmnt(self) -> Any: ...
    @property
    def cmnt2(self) -> Any: ...
    @property
    def end(self) -> Any: ...
    @property
    def esccodes(self) -> Any: ...
    @property
    def flag(self) -> Any: ...
    @property
    def flag2(self) -> Any: ...
    @property
    def header(self) -> Any: ...
    @property
    def help(self) -> Any: ...
    @property
    def high16(self) -> Any: ...
    @property
    def high8(self) -> Any: ...
    @property
    def lbrace(self) -> Any: ...
    @property
    def low16(self) -> Any: ...
    @property
    def low8(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def origin(self) -> Any: ...
    @property
    def rbrace(self) -> Any: ...
    @property
    def uflag(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class auto_display_t:
    @property
    def ea(self) -> Any: ...
    @property
    def state(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class bit_bound_t:
    @property
    def nbits(self) -> Any: ...
    @property
    def sbits(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, n: int = 0, s: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class bitfield_type_data_t:
    @property
    def is_unsigned(self) -> Any: ...
    @property
    def nbytes(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __init__(self, _nbytes: uchar = 0, _width: uchar = 0, _is_unsigned: bool = False) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __lt__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __ne__(self, r: bitfield_type_data_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: bitfield_type_data_t) -> int:
        ...
    def is_valid_bitfield(self) -> bool:
        ...
    def swap(self, r: bitfield_type_data_t) -> None:
        ...

class bitrange_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bitrange_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bitrange_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bitrange_t) -> bool:
        ...
    def __init__(self, bit_ofs: uint16 = 0, size_in_bits: uint16 = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: bitrange_t) -> bool:
        ...
    def __lt__(self, r: bitrange_t) -> bool:
        ...
    def __ne__(self, r: bitrange_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_mask(self, subrange: bitrange_t) -> bool:
        r"""Apply mask to a bitrange 
                
        :param subrange: range *inside* the main bitrange to keep After this operation the main bitrange will be truncated to have only the bits that are specified by subrange. Example: [off=8,nbits=4], subrange[off=1,nbits=2] => [off=9,nbits=2]
        :returns: success
        """
        ...
    def bitoff(self) -> uint:
        r"""Get offset of 1st bit.
        
        """
        ...
    def bitsize(self) -> uint:
        r"""Get size of the value in bits.
        
        """
        ...
    def bytesize(self) -> uint:
        r"""Size of the value in bytes.
        
        """
        ...
    def compare(self, r: bitrange_t) -> int:
        ...
    def create_union(self, r: bitrange_t) -> None:
        r"""Create union of 2 ranges including the hole between them.
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the bitrange empty?
        
        """
        ...
    def extract(self, src: void, is_mf: bool) -> bool:
        ...
    def has_common(self, r: bitrange_t) -> bool:
        r"""Does have common bits with another bitrange?
        
        """
        ...
    def init(self, bit_ofs: uint16, size_in_bits: uint16) -> None:
        r"""Initialize offset and size to given values.
        
        """
        ...
    def inject(self, dst: void, src: bytevec_t, is_mf: bool) -> bool:
        ...
    def intersect(self, r: bitrange_t) -> None:
        r"""Intersect two ranges.
        
        """
        ...
    def mask64(self) -> uint64:
        r"""Convert to mask of 64 bits.
        
        """
        ...
    def reset(self) -> None:
        r"""Make the bitrange empty.
        
        """
        ...
    def shift_down(self, cnt: uint) -> None:
        r"""Shift range down (left)
        
        """
        ...
    def shift_up(self, cnt: uint) -> None:
        r"""Shift range up (right)
        
        """
        ...
    def sub(self, r: bitrange_t) -> bool:
        r"""Subtract a bitrange.
        
        """
        ...

class bitset_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bitset_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bitset_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bitset_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, r: bitset_t) -> bool:
        ...
    def __len__(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def __lt__(self, r: bitset_t) -> bool:
        ...
    def __ne__(self, r: bitset_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(bit: int) -> bool
            1. add(bit: int, width: int) -> bool
            2. add(ml: const bitset_t &) -> bool
        
        # 0: add(bit: int) -> bool
        
        
        # 1: add(bit: int, width: int) -> bool
        
        
        # 2: add(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def back(self) -> int:
        ...
    def begin(self) -> iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: bitset_t) -> int:
        ...
    def copy(self, m: bitset_t) -> bitset_t:
        ...
    def count(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def cut_at(self, maxbit: int) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> iterator:
        ...
    def fill_with_ones(self, maxbit: int) -> None:
        ...
    def front(self) -> int:
        ...
    def has(self, bit: int) -> bool:
        ...
    def has_all(self, bit: int, width: int) -> bool:
        ...
    def has_any(self, bit: int, width: int) -> bool:
        ...
    def has_common(self, ml: bitset_t) -> bool:
        ...
    def inc(self, p: iterator, n: int = 1) -> None:
        ...
    def includes(self, ml: bitset_t) -> bool:
        ...
    def intersect(self, ml: bitset_t) -> bool:
        ...
    def is_subset_of(self, ml: bitset_t) -> bool:
        ...
    def itat(self, n: int) -> iterator:
        ...
    def itv(self, it: iterator) -> int:
        ...
    def last(self) -> int:
        ...
    def shift_down(self, shift: int) -> None:
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(bit: int) -> bool
            1. sub(bit: int, width: int) -> bool
            2. sub(ml: const bitset_t &) -> bool
        
        # 0: sub(bit: int) -> bool
        
        
        # 1: sub(bit: int, width: int) -> bool
        
        
        # 2: sub(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def swap(self, r: bitset_t) -> None:
        ...

class block_chains_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: block_chains_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: block_chains_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class block_chains_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dstr(self) -> str:
        ...
    def get_chain(self, args: Any) -> chain_t:
        r"""This function has the following signatures:
        
            0. get_chain(k: const voff_t &, width: int=1) -> const chain_t *
            1. get_chain(k: const voff_t &, width: int=1) -> chain_t *
            2. get_chain(ch: const chain_t &) -> const chain_t *
            3. get_chain(ch: const chain_t &) -> chain_t *
        
        # 0: get_chain(k: const voff_t &, width: int=1) -> const chain_t *
        
        Get chain for the specified value offset. 
                
        
        # 1: get_chain(k: const voff_t &, width: int=1) -> chain_t *
        
        
        # 2: get_chain(ch: const chain_t &) -> const chain_t *
        
        Get chain similar to the specified chain 
                
        
        # 3: get_chain(ch: const chain_t &) -> chain_t *
        
        
        """
        ...
    def get_reg_chain(self, reg: mreg_t, width: int = 1) -> chain_t:
        r"""Get chain for the specified register 
                
        :param reg: register number
        :param width: size of register in bytes
        """
        ...
    def get_stk_chain(self, off: int, width: int = 1) -> chain_t:
        r"""Get chain for the specified stack offset 
                
        :param off: stack offset
        :param width: size of stack value in bytes
        """
        ...

class block_chains_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> block_chains_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: block_chains_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: block_chains_t) -> None:
        ...
    def at(self, _idx: size_t) -> block_chains_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: block_chains_vec_t) -> None:
        ...
    def extract(self) -> block_chains_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: block_chains_t, len: size_t) -> None:
        ...
    def insert(self, it: block_chains_t, x: block_chains_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> block_chains_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: block_chains_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class bookmarks_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""
        Get the n-th bookmark for the widget.
        
        """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, w: Any) -> Any:
        r"""
        Build an object suitable for iterating bookmarks
        associated with the specified widget.
        
        Note: all ea_t-based widgets (e.g., "IDA View-*",
        "Pseudocode-*", "Hex View-*", ...) share a common storage,
        so bookmarks can be re-used interchangeably between them
        
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""
        Iterate on bookmarks present for the widget.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> Any:
        r"""
        Get the number of bookmarks for the widget.
        
        """
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def erase(self, e: lochist_entry_t, index: int, ud: void) -> bool:
        ...
    def find_index(self, e: lochist_entry_t, ud: void) -> int:
        ...
    def get(self, out: lochist_entry_t, _index: int, ud: void) -> Any:
        ...
    def get_desc(self, e: lochist_entry_t, index: int, ud: void) -> str:
        ...
    def get_dirtree_id(self, e: lochist_entry_t, ud: void) -> dirtree_id_t:
        ...
    def mark(self, e: lochist_entry_t, index: int, title: str, desc: str, ud: void) -> int:
        ...
    def size(self, e: lochist_entry_t, ud: void) -> int:
        ...

class bool_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: bool) -> None:
        ...
    def cast(self) -> bool:
        ...
    def frompointer(self, t: bool) -> bool_pointer:
        ...
    def value(self) -> bool:
        ...

class boolvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: boolvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> bool:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: boolvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: bool) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: bool) -> bool:
        ...
    def append(self, args: Any) -> bool:
        ...
    def at(self, i: size_t) -> bool:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: boolvec_t) -> None:
        ...
    def extract(self) -> bool:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: bool) -> bool:
        ...
    def inject(self, s: bool, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: bool) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> bool:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: boolvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class boundaries_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: boundaries_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: boundaries_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class boundaries_t:
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: cinsn_t) -> rangeset_t:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def keytype(self, args: Any) -> Any:
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, args: Any) -> Any:
        ...

class bpt_location_t:
    @property
    def index(self) -> Any: ...
    @property
    def info(self) -> Any: ...
    @property
    def loctype(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bpt_location_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bpt_location_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bpt_location_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: bpt_location_t) -> bool:
        ...
    def __lt__(self, r: bpt_location_t) -> bool:
        ...
    def __ne__(self, r: bpt_location_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: bpt_location_t) -> int:
        r"""Lexically compare two breakpoint locations. Bpt locations are first compared based on type (i.e. BPLT_ABS < BPLT_REL). BPLT_ABS locations are compared based on their ea values. For all other location types, locations are first compared based on their string (path/filename/symbol), then their offset/lineno. 
                
        """
        ...
    def ea(self) -> ida_idaapi.ea_t:
        r"""Get address (BPLT_ABS)
        
        """
        ...
    def is_empty_path(self) -> bool:
        r"""No path/filename specified? (BPLT_REL, BPLT_SRC)
        
        """
        ...
    def lineno(self) -> int:
        r"""Get line number (BPLT_SRC)
        
        """
        ...
    def offset(self) -> int:
        r"""Get offset (BPLT_REL, BPLT_SYM)
        
        """
        ...
    def path(self) -> str:
        r"""Get path/filename (BPLT_REL, BPLT_SRC)
        
        """
        ...
    def set_abs_bpt(self, a: ida_idaapi.ea_t) -> None:
        r"""Specify an absolute address location.
        
        """
        ...
    def set_rel_bpt(self, mod: str, _offset: int) -> None:
        r"""Specify a relative address location.
        
        """
        ...
    def set_src_bpt(self, fn: str, _lineno: int) -> None:
        r"""Specify a source level location.
        
        """
        ...
    def set_sym_bpt(self, _symbol: str, _offset: int = 0) -> None:
        r"""Specify a symbolic location.
        
        """
        ...
    def symbol(self) -> str:
        r"""Get symbol name (BPLT_SYM)
        
        """
        ...
    def type(self) -> bpt_loctype_t:
        r"""Get bpt type.
        
        """
        ...

class bpt_t:
    @property
    def bptid(self) -> Any: ...
    @property
    def cb(self) -> Any: ...
    @property
    def cndidx(self) -> Any: ...
    @property
    def condition(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def elang(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    @property
    def pass_count(self) -> Any: ...
    @property
    def pid(self) -> Any: ...
    @property
    def props(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def badbpt(self) -> bool:
        r"""Failed to write bpt to process memory?
        
        """
        ...
    def enabled(self) -> bool:
        r"""Is breakpoint enabled?
        
        """
        ...
    def get_cnd_elang_idx(self) -> int:
        ...
    def get_size(self) -> int:
        r"""Get bpt size.
        
        """
        ...
    def is_absbpt(self) -> bool:
        r"""Is absolute address breakpoint?
        
        """
        ...
    def is_active(self) -> bool:
        r"""Written completely to process?
        
        """
        ...
    def is_compiled(self) -> bool:
        r"""Condition has been compiled? 
                
        """
        ...
    def is_hwbpt(self) -> bool:
        r"""Is hardware breakpoint?
        
        """
        ...
    def is_inactive(self) -> bool:
        r"""Not written to process at all?
        
        """
        ...
    def is_low_level(self) -> bool:
        r"""Is bpt condition calculated at low level?
        
        """
        ...
    def is_page_bpt(self) -> bool:
        r"""Page breakpoint?
        
        """
        ...
    def is_partially_active(self) -> bool:
        r"""Written partially to process?
        
        """
        ...
    def is_relbpt(self) -> bool:
        r"""Is relative address breakpoint?
        
        """
        ...
    def is_srcbpt(self) -> bool:
        r"""Is source level breakpoint?
        
        """
        ...
    def is_symbpt(self) -> bool:
        r"""Is symbolic breakpoint?
        
        """
        ...
    def is_tracemodebpt(self) -> bool:
        r"""Does breakpoint trace anything?
        
        """
        ...
    def is_traceoffbpt(self) -> bool:
        r"""Is this a tracing breakpoint, and is tracing disabled?
        
        """
        ...
    def is_traceonbpt(self) -> bool:
        r"""Is this a tracing breakpoint, and is tracing enabled?
        
        """
        ...
    def listbpt(self) -> bool:
        r"""Include in the bpt list?
        
        """
        ...
    def set_abs_bpt(self, a: ida_idaapi.ea_t) -> None:
        r"""Set bpt location to an absolute address.
        
        """
        ...
    def set_rel_bpt(self, mod: str, o: int) -> None:
        r"""Set bpt location to a relative address.
        
        """
        ...
    def set_src_bpt(self, fn: str, lineno: int) -> None:
        r"""Set bpt location to a source line.
        
        """
        ...
    def set_sym_bpt(self, sym: str, o: int) -> None:
        r"""Set bpt location to a symbol.
        
        """
        ...
    def set_trace_action(self, enable: bool, trace_types: int) -> bool:
        r"""Configure tracing options.
        
        """
        ...

class bpt_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> bpt_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: bpt_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: bpt_t) -> None:
        ...
    def at(self, _idx: size_t) -> bpt_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: bpt_vec_t) -> None:
        ...
    def extract(self) -> bpt_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: bpt_t, len: size_t) -> None:
        ...
    def insert(self, it: bpt_t, x: bpt_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> bpt_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: bpt_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class bptaddr_t:
    @property
    def hea(self) -> Any: ...
    @property
    def kea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class bptaddrs_t:
    @property
    def bpt(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class call_stack_info_t:
    @property
    def callea(self) -> Any: ...
    @property
    def fp(self) -> Any: ...
    @property
    def funcea(self) -> Any: ...
    @property
    def funcok(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: call_stack_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: call_stack_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class call_stack_info_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: call_stack_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> call_stack_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: call_stack_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: call_stack_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: call_stack_info_t) -> bool:
        ...
    def append(self, x: call_stack_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> call_stack_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: call_stack_info_vec_t) -> None:
        ...
    def extract(self) -> call_stack_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: call_stack_info_t) -> bool:
        ...
    def inject(self, s: call_stack_info_t, len: size_t) -> None:
        ...
    def insert(self, it: call_stack_info_t, x: call_stack_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> call_stack_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: call_stack_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class call_stack_t(call_stack_info_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: call_stack_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> call_stack_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: call_stack_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: call_stack_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: call_stack_info_t) -> bool:
        ...
    def append(self, x: call_stack_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> call_stack_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: call_stack_info_vec_t) -> None:
        ...
    def extract(self) -> call_stack_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: call_stack_info_t) -> bool:
        ...
    def inject(self, s: call_stack_info_t, len: size_t) -> None:
        ...
    def insert(self, it: call_stack_info_t, x: call_stack_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> call_stack_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: call_stack_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class callregs_t:
    FPREGS: int  # 1
    GPREGS: int  # 0
    @property
    def fpregs(self) -> Any: ...
    @property
    def gpregs(self) -> Any: ...
    @property
    def nregs(self) -> Any: ...
    @property
    def policy(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append_registers(self, kind: reg_kind_t, first_reg: int, last_reg: int) -> None:
        ...
    def by_slots(self) -> bool:
        ...
    def init_regs(self, cc: callcnv_t) -> bool:
        r"""Init policy & registers for given CC.
        
        """
        ...
    def regcount(self, cc: callcnv_t) -> int:
        r"""Get max number of registers may be used in a function call.
        
        """
        ...
    def reginds(self, gp_ind: int, fp_ind: int, r: int) -> bool:
        r"""Get register indexes within GP/FP arrays. (-1 -> is not present in the corresponding array) 
                
        """
        ...
    def reset(self) -> None:
        r"""Set policy and registers to invalid values.
        
        """
        ...
    def set(self, _policy: argreg_policy_t, gprs: int, fprs: int) -> None:
        r"""Init policy & registers (arrays are -1-terminated)
        
        """
        ...
    def set_registers(self, kind: reg_kind_t, first_reg: int, last_reg: int) -> None:
        ...
    def swap(self, r: callregs_t) -> None:
        r"""swap two instances
        
        """
        ...

class cancellable_graph_t(gdl_graph_t):
    @property
    def cancelled(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class carg_t(cexpr_t, citem_t):
    op_to_typename: dict
    @property
    def a(self) -> Any: ...
    @property
    def cexpr(self) -> Any: ...
    @property
    def cinsn(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def exflags(self) -> Any: ...
    @property
    def formal_type(self) -> Any: ...
    @property
    def fpc(self) -> Any: ...
    @property
    def helper(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def insn(self) -> Any: ...
    @property
    def is_vararg(self) -> Any: ...
    @property
    def label_num(self) -> Any: ...
    @property
    def m(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def obj_ea(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    @property
    def operands(self) -> Any: ...
    @property
    def opname(self) -> Any: ...
    @property
    def ptrsize(self) -> Any: ...
    @property
    def refwidth(self) -> Any: ...
    @property
    def string(self) -> Any: ...
    @property
    def to_specific_type(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def v(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    @property
    def z(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: carg_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: carg_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: carg_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: carg_t) -> bool:
        ...
    def __lt__(self, r: carg_t) -> bool:
        ...
    def __ne__(self, r: carg_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cexpr_t) -> cexpr_t:
        ...
    def calc_type(self, recursive: bool) -> None:
        r"""Calculate the type of the expression. Use this function to calculate the expression type when a new expression is built 
                
        :param recursive: if true, types of all children expression will be calculated before calculating our type
        """
        ...
    def cleanup(self) -> None:
        r"""Cleanup the expression. This function properly deletes all children and sets the item type to cot_empty. 
                
        """
        ...
    def compare(self, r: carg_t) -> int:
        ...
    def consume_cexpr(self, e: cexpr_t) -> None:
        ...
    def contains_comma(self, times: int = 1) -> bool:
        r"""Does the expression contain a comma operator?
        
        """
        ...
    def contains_comma_or_insn_or_label(self, maxcommas: int = 1) -> bool:
        r"""Does the expression contain a comma operator or an embedded statement operator or a label?
        
        """
        ...
    def contains_expr(self, e: cexpr_t) -> bool:
        r"""Does the item contain an expression?
        
        """
        ...
    def contains_insn(self, times: int = 1) -> bool:
        r"""Does the expression contain an embedded statement operator?
        
        """
        ...
    def contains_insn_or_label(self) -> bool:
        r"""Does the expression contain an embedded statement operator or a label?
        
        """
        ...
    def contains_label(self) -> bool:
        r"""Does the item contain a label?
        
        """
        ...
    def contains_operator(self, needed_op: ctype_t, times: int = 1) -> bool:
        r"""Check if the expression contains the specified operator. 
                
        :param needed_op: operator code to search for
        :param times: how many times the operator code should be present
        :returns: true if the expression has at least TIMES children with NEEDED_OP
        """
        ...
    def cpadone(self) -> bool:
        r"""Pointer arithmetic correction done for this expression?
        
        """
        ...
    def dstr(self) -> str:
        ...
    def equal_effect(self, r: cexpr_t) -> bool:
        r"""Compare two expressions. This function tries to compare two expressions in an 'intelligent' manner. For example, it knows about commutitive operators and can ignore useless casts. 
                
        :param r: the expression to compare against the current expression
        :returns: true expressions can be considered equal
        """
        ...
    def find_closest_addr(self, _ea: ida_idaapi.ea_t) -> citem_t:
        ...
    def find_num_op(self) -> cexpr_t:
        r"""Find the operand with a numeric value.
        
        """
        ...
    def find_op(self, _op: ctype_t) -> cexpr_t:
        r"""Find the child with the specified operator.
        
        """
        ...
    def find_parent_of(self, item: citem_t) -> citem_t:
        r"""Find parent of the specified item. 
                
        :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
        :returns: nullptr if not found
        """
        ...
    def get_1num_op(self, o1: cexpr_t, o2: cexpr_t) -> bool:
        r"""Get pointers to operands. at last one operand should be a number o1 will be pointer to the number 
                
        """
        ...
    def get_const_value(self) -> bool:
        r"""Get expression value. 
                
        :returns: true if the expression is a number.
        """
        ...
    def get_high_nbit_bound(self) -> bit_bound_t:
        r"""Get max number of bits that can really be used by the expression. For example, x % 16 can yield only 4 non-zero bits, higher bits are zero 
                
        """
        ...
    def get_low_nbit_bound(self) -> int:
        r"""Get min number of bits that are certainly required to represent the expression. For example, constant 16 always uses 5 bits: 10000. 
                
        """
        ...
    def get_ptr_or_array(self) -> cexpr_t:
        r"""Find pointer or array child.
        
        """
        ...
    def get_type_sign(self) -> type_sign_t:
        r"""Get expression sign.
        
        """
        ...
    def get_v(self) -> var_ref_t:
        ...
    def has_side_effects(self) -> bool:
        r"""Check if the expression has side effects. Calls, pre/post inc/dec, and assignments have side effects. 
                
        """
        ...
    def is_call_arg_of(self, parent: citem_t) -> bool:
        r"""Is call argument? 
                
        :returns: true if our expression is a call argument of the specified parent expression.
        """
        ...
    def is_call_object_of(self, parent: citem_t) -> bool:
        r"""Is call object? 
                
        :returns: true if our expression is the call object of the specified parent expression.
        """
        ...
    def is_child_of(self, parent: citem_t) -> bool:
        r"""Verify if the specified item is our parent. 
                
        :param parent: possible parent item
        :returns: true if the specified item is our parent
        """
        ...
    def is_const_value(self, _v: uint64) -> bool:
        r"""Check if the expression is a number with the specified value.
        
        """
        ...
    def is_cstr(self) -> bool:
        ...
    def is_expr(self) -> bool:
        r"""Is an expression?
        
        """
        ...
    def is_fpop(self) -> bool:
        ...
    def is_jumpout(self) -> bool:
        ...
    def is_negative_const(self) -> bool:
        r"""Check if the expression is a negative number.
        
        """
        ...
    def is_nice_cond(self) -> bool:
        r"""Is nice condition?. Nice condition is a nice expression of the boolean type. 
                
        """
        ...
    def is_nice_expr(self) -> bool:
        r"""Is nice expression? Nice expressions do not contain comma operators, embedded statements, or labels. 
                
        """
        ...
    def is_non_negative_const(self) -> bool:
        r"""Check if the expression is a non-negative number.
        
        """
        ...
    def is_non_zero_const(self) -> bool:
        r"""Check if the expression is a non-zero number.
        
        """
        ...
    def is_odd_lvalue(self) -> bool:
        ...
    def is_type_signed(self) -> bool:
        r"""Is expression signed?
        
        """
        ...
    def is_type_unsigned(self) -> bool:
        r"""Is expression unsigned?
        
        """
        ...
    def is_undef_val(self) -> bool:
        ...
    def is_vftable(self) -> bool:
        ...
    def is_zero_const(self) -> bool:
        r"""Check if the expression is a zero.
        
        """
        ...
    def maybe_ptr(self) -> bool:
        r"""May the expression be a pointer?
        
        """
        ...
    def numval(self) -> uint64:
        r"""Get numeric value of the expression. This function can be called only on cot_num expressions! 
                
        """
        ...
    def print1(self, func: cfunc_t) -> None:
        r"""Print expression into one line. 
                
        :param func: parent function. This argument is used to find out the referenced variable names.
        """
        ...
    def put_number(self, args: Any) -> None:
        r"""Assign a number to the expression. 
                
        :param func: current function
        :param value: number value
        :param nbytes: size of the number in bytes
        :param sign: number sign
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def requires_lvalue(self, child: cexpr_t) -> bool:
        r"""Check if the expression requires an lvalue. 
                
        :param child: The function will check if this child of our expression must be an lvalue.
        :returns: true if child must be an lvalue.
        """
        ...
    def set_cpadone(self) -> None:
        ...
    def set_v(self, v: var_ref_t) -> None:
        ...
    def set_vftable(self) -> None:
        ...
    def swap(self, r: cexpr_t) -> None:
        ...
    def theother(self, what: cexpr_t) -> cexpr_t:
        r"""Get the other operand. This function returns the other operand (not the specified one) for binary expressions. 
                
        """
        ...

class carglist_t(qvector_carg_t):
    @property
    def flags(self) -> Any: ...
    @property
    def functype(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: carglist_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: carglist_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> carg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: carglist_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: carglist_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: carglist_t) -> bool:
        ...
    def __ne__(self, r: carglist_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: carg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: carg_t) -> bool:
        ...
    def append(self, args: Any) -> carg_t:
        ...
    def at(self, i: size_t) -> carg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: carglist_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_carg_t) -> None:
        ...
    def extract(self) -> carg_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: carg_t) -> bool:
        ...
    def inject(self, s: carg_t, len: size_t) -> None:
        ...
    def insert(self, it: carg_t, x: carg_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> carg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_carg_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class cases_and_targets_t:
    @property
    def cases(self) -> Any: ...
    @property
    def targets(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class casevec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: casevec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> qvector:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: casevec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: qvector) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: qvector) -> bool:
        ...
    def append(self, args: Any) -> qvector:
        ...
    def at(self, i: size_t) -> qvector:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: casevec_t) -> None:
        ...
    def extract(self) -> qvector:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: qvector) -> bool:
        ...
    def inject(self, s: qvector, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: qvector) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> qvector:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: casevec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class casm_t(uint64vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: casm_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: casm_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: casm_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: casm_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: casm_t) -> bool:
        ...
    def __ne__(self, r: casm_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: casm_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uint64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def one_insn(self) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uint64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class catch_t(try_handler_t, rangevec_t, rangevec_base_t):
    @property
    def disp(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    @property
    def obj(self) -> Any: ...
    @property
    def type_id(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class catchexpr_t:
    @property
    def fake_type(self) -> Any: ...
    @property
    def obj(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: catchexpr_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: catchexpr_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: catchexpr_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: catchexpr_t) -> bool:
        ...
    def __lt__(self, r: catchexpr_t) -> bool:
        ...
    def __ne__(self, r: catchexpr_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: catchexpr_t) -> int:
        ...
    def is_catch_all(self) -> bool:
        ...
    def swap(self, r: catchexpr_t) -> None:
        ...

class catchvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: catchvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> catch_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: catchvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: catch_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: catch_t) -> bool:
        ...
    def append(self, x: catch_t) -> None:
        ...
    def at(self, _idx: size_t) -> catch_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: catchvec_t) -> None:
        ...
    def extract(self) -> catch_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: catch_t) -> bool:
        ...
    def inject(self, s: catch_t, len: size_t) -> None:
        ...
    def insert(self, it: catch_t, x: catch_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> catch_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: catchvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class cblock_pos_t:
    @property
    def blk(self) -> Any: ...
    @property
    def p(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def insn(self) -> cinsn_t:
        ...
    def is_first_insn(self) -> bool:
        ...
    def prev_insn(self) -> cinsn_t:
        ...

class cblock_posvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> cblock_pos_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cblock_pos_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: cblock_pos_t) -> None:
        ...
    def at(self, _idx: size_t) -> cblock_pos_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: cblock_posvec_t) -> None:
        ...
    def extract(self) -> cblock_pos_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: cblock_pos_t, len: size_t) -> None:
        ...
    def insert(self, it: cblock_pos_t, x: cblock_pos_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> cblock_pos_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: cblock_posvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class cblock_t(cinsn_list_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cblock_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cblock_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> cinsn_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cblock_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: cblock_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: cblock_t) -> bool:
        ...
    def __ne__(self, r: cblock_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cinsn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, index: Any) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self) -> cinsn_list_t_iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: cblock_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> cinsn_list_t_iterator:
        ...
    def erase(self, p: cinsn_list_t_iterator) -> None:
        ...
    def find(self, item: Any) -> Any:
        ...
    def front(self) -> Any:
        ...
    def index(self, item: Any) -> Any:
        ...
    def insert(self, args: Any) -> cinsn_list_t_iterator:
        ...
    def pop_back(self) -> None:
        ...
    def pop_front(self) -> None:
        ...
    def push_back(self, args: Any) -> cinsn_t:
        ...
    def push_front(self, x: cinsn_t) -> None:
        ...
    def rbegin(self, args: Any) -> const_reverse_iterator:
        ...
    def remove(self, v: cinsn_t) -> bool:
        ...
    def rend(self, args: Any) -> const_reverse_iterator:
        ...
    def size(self) -> int:
        ...
    def splice(self, pos: iterator, other: cinsn_list_t, first: iterator, last: iterator) -> None:
        ...
    def swap(self, x: cinsn_list_t) -> None:
        ...

class ccase_t(cinsn_t, citem_t):
    op_to_typename: dict
    @property
    def casm(self) -> Any: ...
    @property
    def cblock(self) -> Any: ...
    @property
    def cdo(self) -> Any: ...
    @property
    def cexpr(self) -> Any: ...
    @property
    def cfor(self) -> Any: ...
    @property
    def cgoto(self) -> Any: ...
    @property
    def cif(self) -> Any: ...
    @property
    def cinsn(self) -> Any: ...
    @property
    def creturn(self) -> Any: ...
    @property
    def cswitch(self) -> Any: ...
    @property
    def cthrow(self) -> Any: ...
    @property
    def ctry(self) -> Any: ...
    @property
    def cwhile(self) -> Any: ...
    @property
    def details(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def label_num(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    @property
    def opname(self) -> Any: ...
    @property
    def to_specific_type(self) -> Any: ...
    @property
    def values(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ccase_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ccase_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ccase_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: ccase_t) -> bool:
        ...
    def __lt__(self, r: ccase_t) -> bool:
        ...
    def __ne__(self, r: ccase_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cinsn_t) -> cinsn_t:
        ...
    def cleanup(self) -> None:
        r"""Cleanup the statement. This function properly deletes all children and sets the item type to cit_empty. 
                
        """
        ...
    def collect_free_breaks(self, breaks: cinsnptrvec_t) -> bool:
        r"""Collect free `break` statements. This function finds all free `break` statements within the current statement. A `break` statement is free if it does not have a loop or switch parent that that is also within the current statement. 
                
        :param breaks: pointer to the variable where the vector of all found free `break` statements is returned. This argument can be nullptr.
        :returns: true if some free `break` statements have been found
        """
        ...
    def collect_free_continues(self, continues: cinsnptrvec_t) -> bool:
        r"""Collect free `continue` statements. This function finds all free `continue` statements within the current statement. A `continue` statement is free if it does not have a loop parent that that is also within the current statement. 
                
        :param continues: pointer to the variable where the vector of all found free `continue` statements is returned. This argument can be nullptr.
        :returns: true if some free `continue` statements have been found
        """
        ...
    def compare(self, r: ccase_t) -> int:
        ...
    def contains_expr(self, e: cexpr_t) -> bool:
        r"""Does the item contain an expression?
        
        """
        ...
    def contains_free_break(self) -> bool:
        r"""Check if the statement has free `break` statements.
        
        """
        ...
    def contains_free_continue(self) -> bool:
        r"""Check if the statement has free `continue` statements.
        
        """
        ...
    def contains_insn(self, type: ctype_t, times: int = 1) -> bool:
        r"""Check if the statement contains a statement of the specified type. 
                
        :param type: statement opcode to look for
        :param times: how many times TYPE should be present
        :returns: true if the statement has at least TIMES children with opcode == TYPE
        """
        ...
    def contains_label(self) -> bool:
        r"""Does the item contain a label?
        
        """
        ...
    def create_if(self, cnd: cexpr_t) -> cif_t:
        r"""Create a new if-statement. The current statement must be a block. The new statement will be appended to it. 
                
        :param cnd: if condition. It will be deleted after being copied.
        """
        ...
    def dstr(self) -> str:
        ...
    def find_closest_addr(self, _ea: ida_idaapi.ea_t) -> citem_t:
        ...
    def find_parent_of(self, item: citem_t) -> citem_t:
        r"""Find parent of the specified item. 
                
        :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
        :returns: nullptr if not found
        """
        ...
    def insn_is_epilog(self, insn: cinsn_t) -> bool:
        ...
    def is_epilog(self) -> Any:
        ...
    def is_expr(self) -> bool:
        r"""Is an expression?
        
        """
        ...
    def is_ordinary_flow(self) -> bool:
        r"""Check if the statement passes execution to the next statement. 
                
        :returns: false if the statement breaks the control flow (like goto, return, etc)
        """
        ...
    def new_insn(self, insn_ea: ida_idaapi.ea_t) -> cinsn_t:
        r"""Create a new statement. The current statement must be a block. The new statement will be appended to it. 
                
        :param insn_ea: statement address
        """
        ...
    def print1(self, func: cfunc_t) -> None:
        r"""Print the statement into one line. Currently this function is not available. 
                
        :param func: parent function. This argument is used to find out the referenced variable names.
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: cinsn_t) -> None:
        ...
    def value(self, i: int) -> uint64:
        ...
    def zero(self) -> None:
        r"""Overwrite with zeroes without cleaning memory or deleting children.
        
        """
        ...

class ccases_t(qvector_ccase_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ccases_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ccases_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ccase_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ccases_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: ccases_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: ccases_t) -> bool:
        ...
    def __ne__(self, r: ccases_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ccase_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: ccase_t) -> bool:
        ...
    def append(self, args: Any) -> ccase_t:
        ...
    def at(self, i: size_t) -> ccase_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: ccases_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_ccase_t) -> None:
        ...
    def extract(self) -> ccase_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: ccase_t) -> bool:
        ...
    def inject(self, s: ccase_t, len: size_t) -> None:
        ...
    def insert(self, it: ccase_t, x: ccase_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ccase_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_ccase_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ccatch_t(cblock_t, cinsn_list_t):
    @property
    def exprs(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ccatch_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ccatch_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> cinsn_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ccatch_t) -> bool:
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: ccatch_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: ccatch_t) -> bool:
        ...
    def __ne__(self, r: ccatch_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cinsn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, index: Any) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self) -> cinsn_list_t_iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: ccatch_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> cinsn_list_t_iterator:
        ...
    def erase(self, p: cinsn_list_t_iterator) -> None:
        ...
    def find(self, item: Any) -> Any:
        ...
    def front(self) -> Any:
        ...
    def index(self, item: Any) -> Any:
        ...
    def insert(self, args: Any) -> cinsn_list_t_iterator:
        ...
    def is_catch_all(self) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def pop_front(self) -> None:
        ...
    def push_back(self, args: Any) -> cinsn_t:
        ...
    def push_front(self, x: cinsn_t) -> None:
        ...
    def rbegin(self, args: Any) -> const_reverse_iterator:
        ...
    def remove(self, v: cinsn_t) -> bool:
        ...
    def rend(self, args: Any) -> const_reverse_iterator:
        ...
    def size(self) -> int:
        ...
    def splice(self, pos: iterator, other: cinsn_list_t, first: iterator, last: iterator) -> None:
        ...
    def swap(self, r: ccatch_t) -> None:
        ...

class cdg_insn_iterator_t:
    @property
    def dslot(self) -> Any: ...
    @property
    def dslot_insn(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def end(self) -> Any: ...
    @property
    def is_likely_dslot(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def severed_branch(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dslot_with_xrefs(self) -> bool:
        ...
    def has_dslot(self) -> bool:
        ...
    def is_severed_dslot(self) -> bool:
        ...
    def next(self, ins: insn_t) -> merror_t:
        ...
    def ok(self) -> bool:
        ...
    def start(self, rng: range_t) -> None:
        ...

class cdo_t(cloop_t, ceinsn_t):
    @property
    def body(self) -> Any: ...
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cdo_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cdo_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cdo_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cdo_t) -> bool:
        ...
    def __lt__(self, r: cdo_t) -> bool:
        ...
    def __ne__(self, r: cdo_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cloop_t) -> cloop_t:
        ...
    def cleanup(self) -> None:
        ...
    def compare(self, r: cdo_t) -> int:
        ...

class ceinsn_t:
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class cexpr_t(citem_t):
    op_to_typename: dict
    @property
    def a(self) -> Any: ...
    @property
    def cexpr(self) -> Any: ...
    @property
    def cinsn(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def exflags(self) -> Any: ...
    @property
    def fpc(self) -> Any: ...
    @property
    def helper(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def insn(self) -> Any: ...
    @property
    def label_num(self) -> Any: ...
    @property
    def m(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def obj_ea(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    @property
    def operands(self) -> Any: ...
    @property
    def opname(self) -> Any: ...
    @property
    def ptrsize(self) -> Any: ...
    @property
    def refwidth(self) -> Any: ...
    @property
    def string(self) -> Any: ...
    @property
    def to_specific_type(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def v(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    @property
    def z(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cexpr_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cexpr_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cexpr_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cexpr_t) -> bool:
        ...
    def __lt__(self, r: cexpr_t) -> bool:
        ...
    def __ne__(self, r: cexpr_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cexpr_t) -> cexpr_t:
        ...
    def calc_type(self, recursive: bool) -> None:
        r"""Calculate the type of the expression. Use this function to calculate the expression type when a new expression is built 
                
        :param recursive: if true, types of all children expression will be calculated before calculating our type
        """
        ...
    def cleanup(self) -> None:
        r"""Cleanup the expression. This function properly deletes all children and sets the item type to cot_empty. 
                
        """
        ...
    def compare(self, r: cexpr_t) -> int:
        ...
    def contains_comma(self, times: int = 1) -> bool:
        r"""Does the expression contain a comma operator?
        
        """
        ...
    def contains_comma_or_insn_or_label(self, maxcommas: int = 1) -> bool:
        r"""Does the expression contain a comma operator or an embedded statement operator or a label?
        
        """
        ...
    def contains_expr(self, e: cexpr_t) -> bool:
        r"""Does the item contain an expression?
        
        """
        ...
    def contains_insn(self, times: int = 1) -> bool:
        r"""Does the expression contain an embedded statement operator?
        
        """
        ...
    def contains_insn_or_label(self) -> bool:
        r"""Does the expression contain an embedded statement operator or a label?
        
        """
        ...
    def contains_label(self) -> bool:
        r"""Does the item contain a label?
        
        """
        ...
    def contains_operator(self, needed_op: ctype_t, times: int = 1) -> bool:
        r"""Check if the expression contains the specified operator. 
                
        :param needed_op: operator code to search for
        :param times: how many times the operator code should be present
        :returns: true if the expression has at least TIMES children with NEEDED_OP
        """
        ...
    def cpadone(self) -> bool:
        r"""Pointer arithmetic correction done for this expression?
        
        """
        ...
    def dstr(self) -> str:
        ...
    def equal_effect(self, r: cexpr_t) -> bool:
        r"""Compare two expressions. This function tries to compare two expressions in an 'intelligent' manner. For example, it knows about commutitive operators and can ignore useless casts. 
                
        :param r: the expression to compare against the current expression
        :returns: true expressions can be considered equal
        """
        ...
    def find_closest_addr(self, _ea: ida_idaapi.ea_t) -> citem_t:
        ...
    def find_num_op(self) -> cexpr_t:
        r"""Find the operand with a numeric value.
        
        """
        ...
    def find_op(self, _op: ctype_t) -> cexpr_t:
        r"""Find the child with the specified operator.
        
        """
        ...
    def find_parent_of(self, item: citem_t) -> citem_t:
        r"""Find parent of the specified item. 
                
        :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
        :returns: nullptr if not found
        """
        ...
    def get_1num_op(self, o1: cexpr_t, o2: cexpr_t) -> bool:
        r"""Get pointers to operands. at last one operand should be a number o1 will be pointer to the number 
                
        """
        ...
    def get_const_value(self) -> bool:
        r"""Get expression value. 
                
        :returns: true if the expression is a number.
        """
        ...
    def get_high_nbit_bound(self) -> bit_bound_t:
        r"""Get max number of bits that can really be used by the expression. For example, x % 16 can yield only 4 non-zero bits, higher bits are zero 
                
        """
        ...
    def get_low_nbit_bound(self) -> int:
        r"""Get min number of bits that are certainly required to represent the expression. For example, constant 16 always uses 5 bits: 10000. 
                
        """
        ...
    def get_ptr_or_array(self) -> cexpr_t:
        r"""Find pointer or array child.
        
        """
        ...
    def get_type_sign(self) -> type_sign_t:
        r"""Get expression sign.
        
        """
        ...
    def get_v(self) -> var_ref_t:
        ...
    def has_side_effects(self) -> bool:
        r"""Check if the expression has side effects. Calls, pre/post inc/dec, and assignments have side effects. 
                
        """
        ...
    def is_call_arg_of(self, parent: citem_t) -> bool:
        r"""Is call argument? 
                
        :returns: true if our expression is a call argument of the specified parent expression.
        """
        ...
    def is_call_object_of(self, parent: citem_t) -> bool:
        r"""Is call object? 
                
        :returns: true if our expression is the call object of the specified parent expression.
        """
        ...
    def is_child_of(self, parent: citem_t) -> bool:
        r"""Verify if the specified item is our parent. 
                
        :param parent: possible parent item
        :returns: true if the specified item is our parent
        """
        ...
    def is_const_value(self, _v: uint64) -> bool:
        r"""Check if the expression is a number with the specified value.
        
        """
        ...
    def is_cstr(self) -> bool:
        ...
    def is_expr(self) -> bool:
        r"""Is an expression?
        
        """
        ...
    def is_fpop(self) -> bool:
        ...
    def is_jumpout(self) -> bool:
        ...
    def is_negative_const(self) -> bool:
        r"""Check if the expression is a negative number.
        
        """
        ...
    def is_nice_cond(self) -> bool:
        r"""Is nice condition?. Nice condition is a nice expression of the boolean type. 
                
        """
        ...
    def is_nice_expr(self) -> bool:
        r"""Is nice expression? Nice expressions do not contain comma operators, embedded statements, or labels. 
                
        """
        ...
    def is_non_negative_const(self) -> bool:
        r"""Check if the expression is a non-negative number.
        
        """
        ...
    def is_non_zero_const(self) -> bool:
        r"""Check if the expression is a non-zero number.
        
        """
        ...
    def is_odd_lvalue(self) -> bool:
        ...
    def is_type_signed(self) -> bool:
        r"""Is expression signed?
        
        """
        ...
    def is_type_unsigned(self) -> bool:
        r"""Is expression unsigned?
        
        """
        ...
    def is_undef_val(self) -> bool:
        ...
    def is_vftable(self) -> bool:
        ...
    def is_zero_const(self) -> bool:
        r"""Check if the expression is a zero.
        
        """
        ...
    def maybe_ptr(self) -> bool:
        r"""May the expression be a pointer?
        
        """
        ...
    def numval(self) -> uint64:
        r"""Get numeric value of the expression. This function can be called only on cot_num expressions! 
                
        """
        ...
    def print1(self, func: cfunc_t) -> None:
        r"""Print expression into one line. 
                
        :param func: parent function. This argument is used to find out the referenced variable names.
        """
        ...
    def put_number(self, args: Any) -> None:
        r"""Assign a number to the expression. 
                
        :param func: current function
        :param value: number value
        :param nbytes: size of the number in bytes
        :param sign: number sign
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def requires_lvalue(self, child: cexpr_t) -> bool:
        r"""Check if the expression requires an lvalue. 
                
        :param child: The function will check if this child of our expression must be an lvalue.
        :returns: true if child must be an lvalue.
        """
        ...
    def set_cpadone(self) -> None:
        ...
    def set_v(self, v: var_ref_t) -> None:
        ...
    def set_vftable(self) -> None:
        ...
    def swap(self, r: cexpr_t) -> None:
        ...
    def theother(self, what: cexpr_t) -> cexpr_t:
        r"""Get the other operand. This function returns the other operand (not the specified one) for binary expressions. 
                
        """
        ...

class cfor_t(cloop_t, ceinsn_t):
    @property
    def body(self) -> Any: ...
    @property
    def expr(self) -> Any: ...
    @property
    def init(self) -> Any: ...
    @property
    def step(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cfor_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cfor_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cfor_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cfor_t) -> bool:
        ...
    def __lt__(self, r: cfor_t) -> bool:
        ...
    def __ne__(self, r: cfor_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cloop_t) -> cloop_t:
        ...
    def cleanup(self) -> None:
        ...
    def compare(self, r: cfor_t) -> int:
        ...

class cfunc_parentee_t(ctree_parentee_t, ctree_visitor_t):
    @property
    def bposvec(self) -> Any: ...
    @property
    def cv_flags(self) -> Any: ...
    @property
    def func(self) -> Any: ...
    @property
    def parents(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, f: cfunc_t, post: bool = False) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_to(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse ctree. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def apply_to_exprs(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse only expressions. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def calc_rvalue_type(self, target: tinfo_t, e: cexpr_t) -> bool:
        r"""Calculate rvalue type. This function tries to determine the type of the specified item based on its context. For example, if the current expression is the right side of an assignment operator, the type of its left side will be returned. This function can be used to determine the 'best' type of the specified expression. 
                
        :param target: 'best' type of the expression will be returned here
        :param e: expression to determine the desired type
        :returns: false if failed
        """
        ...
    def clr_prune(self) -> None:
        r"""Do not prune children. This is an internal function, no need to call it.
        
        """
        ...
    def clr_restart(self) -> None:
        r"""Do not restart. This is an internal function, no need to call it.
        
        """
        ...
    def is_postorder(self) -> bool:
        r"""Should the leave...() functions be called?
        
        """
        ...
    def leave_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def leave_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def maintain_parents(self) -> bool:
        r"""Should the parent information by maintained?
        
        """
        ...
    def must_prune(self) -> bool:
        r"""Should the traversal skip the children of the current item?
        
        """
        ...
    def must_restart(self) -> bool:
        r"""Should the traversal restart?
        
        """
        ...
    def only_insns(self) -> bool:
        r"""Should all expressions be automatically pruned?
        
        """
        ...
    def parent_expr(self) -> cexpr_t:
        r"""Get parent of the current item as an expression.
        
        """
        ...
    def parent_insn(self) -> cinsn_t:
        r"""Get parent of the current item as a statement.
        
        """
        ...
    def parent_item(self) -> citem_t:
        r"""Get parent of the current item as an item (statement or expression)
        
        """
        ...
    def prune_now(self) -> None:
        r"""Prune children. This function may be called by a visitor() to skip all children of the current item. 
                
        """
        ...
    def recalc_parent_types(self) -> bool:
        r"""Recalculate type of parent nodes. If a node type has been changed, the visitor must recalculate all parent types, otherwise the ctree becomes inconsistent. If during this recalculation a parent node is added/deleted, this function returns true. In this case the traversal must be stopped because the information about parent nodes is stale. 
                
        :returns: false-ok to continue the traversal, true-must stop.
        """
        ...
    def set_restart(self) -> None:
        r"""Restart the travesal. Meaningful only in apply_to_exprs()
        
        """
        ...
    def visit_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def visit_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...

class cfunc_t:
    @property
    def argidx(self) -> Any: ...
    @property
    def arguments(self) -> Any: ...
    @property
    def body(self) -> Any: ...
    @property
    def boundaries(self) -> Any: ...
    @property
    def eamap(self) -> Any: ...
    @property
    def entry_ea(self) -> Any: ...
    @property
    def hdrlines(self) -> Any: ...
    @property
    def lvars(self) -> Any: ...
    @property
    def maturity(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def numforms(self) -> Any: ...
    @property
    def pseudocode(self) -> Any: ...
    @property
    def refcnt(self) -> Any: ...
    @property
    def statebits(self) -> Any: ...
    @property
    def treeitems(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def user_cmts(self) -> Any: ...
    @property
    def user_iflags(self) -> Any: ...
    @property
    def user_labels(self) -> Any: ...
    @property
    def user_unions(self) -> Any: ...
    @property
    def warnings(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> str:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def build_c_tree(self) -> None:
        r"""Generate the function body. This function (re)generates the function body from the underlying microcode. 
                
        """
        ...
    def del_orphan_cmts(self) -> int:
        r"""Delete all orphan comments. The save_user_cmts() function must be called after this call. 
                
        """
        ...
    def find_item_coords(self, args: Any) -> Any:
        r"""This method has the following signatures:
        
            1. find_item_coords(item: citem_t) -> Tuple[int, int]
            2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool
        
        NOTE: The second form is retained for backward-compatibility,
        but we strongly recommend using the first.
        
        :param item: The item to find coordinates for in the pseudocode listing
        """
        ...
    def find_label(self, label: int) -> citem_t:
        r"""Find the label. 
                
        :returns: pointer to the ctree item with the specified label number.
        """
        ...
    def gather_derefs(self, ci: ctree_item_t, udm: udt_type_data_t = None) -> bool:
        ...
    def get_boundaries(self) -> boundaries_t:
        r"""Get pointer to map of instruction boundaries. This function initializes the boundary map if not done yet. 
                
        """
        ...
    def get_eamap(self) -> eamap_t:
        r"""Get pointer to ea->insn map. This function initializes eamap if not done yet. 
                
        """
        ...
    def get_func_type(self, type: tinfo_t) -> bool:
        r"""Get the function type. 
                
        :param type: variable where the function type is returned
        :returns: false if failure
        """
        ...
    def get_line_item(self, line: str, x: int, is_ctree_line: bool, phead: ctree_item_t, pitem: ctree_item_t, ptail: ctree_item_t) -> bool:
        r"""Get ctree item for the specified cursor position. 
                
        :param line: line of decompilation text (element of sv)
        :param x: x cursor coordinate in the line
        :param is_ctree_line: does the line belong to statement area? (if not, it is assumed to belong to the declaration area)
        :param phead: ptr to the first item on the line (used to attach block comments). May be nullptr
        :param pitem: ptr to the current item. May be nullptr
        :param ptail: ptr to the last item on the line (used to attach indented comments). May be nullptr
        :returns: false if failed to get the current item
        """
        ...
    def get_lvars(self) -> lvars_t:
        r"""Get vector of local variables. 
                
        :returns: pointer to the vector of local variables. If you modify this vector, the ctree must be regenerated in order to have correct cast operators. Use build_c_tree() for that. Removing lvars should be done carefully: all references in ctree and microcode must be corrected after that.
        """
        ...
    def get_pseudocode(self) -> strvec_t:
        r"""Get pointer to decompilation output: the pseudocode. This function generates pseudocode if not done yet. 
                
        """
        ...
    def get_stkoff_delta(self) -> int:
        r"""Get stack offset delta. The local variable stack offsets retrieved by v.location.stkoff() should be adjusted before being used as stack frame offsets in IDA. 
                
        :returns: the delta to apply. example: ida_stkoff = v.location.stkoff() - f->get_stkoff_delta()
        """
        ...
    def get_user_cmt(self, loc: treeloc_t, rt: cmt_retrieval_type_t) -> str:
        r"""Retrieve a user defined comment. 
                
        :param loc: ctree location
        :param rt: should already retrieved comments retrieved again?
        :returns: pointer to the comment string or nullptr
        """
        ...
    def get_user_iflags(self, loc: citem_locator_t) -> int:
        r"""Retrieve citem iflags. 
                
        :param loc: citem locator
        :returns: ctree item iflags bits or 0
        """
        ...
    def get_user_union_selection(self, ea: ida_idaapi.ea_t, path: intvec_t) -> bool:
        r"""Retrieve a user defined union field selection. 
                
        :param ea: address
        :param path: out: path describing the union selection.
        :returns: pointer to the path or nullptr
        """
        ...
    def get_warnings(self) -> hexwarns_t:
        r"""Get information about decompilation warnings. 
                
        :returns: reference to the vector of warnings
        """
        ...
    def has_orphan_cmts(self) -> bool:
        r"""Check if there are orphan comments.
        
        """
        ...
    def locked(self) -> bool:
        ...
    def print_dcl(self) -> None:
        r"""Print function prototype. 
                
        """
        ...
    def print_func(self, vp: vc_printer_t) -> None:
        r"""Print function text. 
                
        :param vp: printer helper class to receive the generated text.
        """
        ...
    def recalc_item_addresses(self) -> None:
        r"""Recalculate item adresses. This function may be required after shuffling ctree items. For example, when adding or removing statements of a block, or changing 'if' statements. 
                
        """
        ...
    def refresh_func_ctext(self) -> None:
        r"""Refresh ctext after a ctree modification. This function informs the decompiler that ctree (body) have been modified and ctext (sv) does not correspond to it anymore. It also refreshes the pseudocode windows if there is any. 
                
        """
        ...
    def release(self) -> None:
        ...
    def remove_unused_labels(self) -> None:
        r"""Remove unused labels. This function checks what labels are really used by the function and removes the unused ones. You must call it after deleting a goto statement. 
                
        """
        ...
    def save_user_cmts(self) -> None:
        r"""Save user-defined comments into the database.
        
        """
        ...
    def save_user_iflags(self) -> None:
        r"""Save user-defined iflags into the database.
        
        """
        ...
    def save_user_labels(self) -> None:
        r"""Save user-defined labels into the database.
        
        """
        ...
    def save_user_numforms(self) -> None:
        r"""Save user-defined number formats into the database.
        
        """
        ...
    def save_user_unions(self) -> None:
        r"""Save user-defined union field selections into the database.
        
        """
        ...
    def set_user_cmt(self, loc: treeloc_t, cmt: str) -> None:
        r"""Set a user defined comment. This function stores the specified comment in the cfunc_t structure. The save_user_cmts() function must be called after it. 
                
        :param loc: ctree location
        :param cmt: new comment. if empty or nullptr, then an existing comment is deleted.
        """
        ...
    def set_user_iflags(self, loc: citem_locator_t, iflags: int) -> None:
        r"""Set citem iflags. 
                
        :param loc: citem locator
        :param iflags: new iflags
        """
        ...
    def set_user_union_selection(self, ea: ida_idaapi.ea_t, path: intvec_t) -> None:
        r"""Set a union field selection. The save_user_unions() function must be called after calling this function. 
                
        :param ea: address
        :param path: in: path describing the union selection.
        """
        ...
    def verify(self, aul: allow_unused_labels_t, even_without_debugger: bool) -> None:
        r"""Verify the ctree. This function verifies the ctree. If the ctree is malformed, an internal error is generated. Use it to verify the ctree after your modifications. 
                
        :param aul: Are unused labels acceptable?
        :param even_without_debugger: if false and there is no debugger, the verification will be skipped
        """
        ...

class cfuncptr_t:
    @property
    def argidx(self) -> Any: ...
    @property
    def arguments(self) -> Any: ...
    @property
    def body(self) -> Any: ...
    @property
    def boundaries(self) -> Any: ...
    @property
    def eamap(self) -> Any: ...
    @property
    def entry_ea(self) -> Any: ...
    @property
    def hdrlines(self) -> Any: ...
    @property
    def lvars(self) -> Any: ...
    @property
    def maturity(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def numforms(self) -> Any: ...
    @property
    def pseudocode(self) -> Any: ...
    @property
    def refcnt(self) -> Any: ...
    @property
    def statebits(self) -> Any: ...
    @property
    def treeitems(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def user_cmts(self) -> Any: ...
    @property
    def user_iflags(self) -> Any: ...
    @property
    def user_labels(self) -> Any: ...
    @property
    def user_unions(self) -> Any: ...
    @property
    def warnings(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __deref__(self) -> cfunc_t:
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, other: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __ptrval__(self) -> int:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __ref__(self) -> cfunc_t:
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def build_c_tree(self) -> None:
        ...
    def del_orphan_cmts(self) -> int:
        ...
    def find_item_coords(self, args: Any) -> Any:
        r"""This method has the following signatures:
        
            1. find_item_coords(item: citem_t) -> Tuple[int, int]
            2. find_item_coords(item: citem_t, x: int_pointer, y: int_pointer) -> bool
        
        NOTE: The second form is retained for backward-compatibility,
        but we strongly recommend using the first.
        
        :param item: The item to find coordinates for in the pseudocode listing
        """
        ...
    def find_label(self, label: int) -> citem_t:
        ...
    def gather_derefs(self, ci: ctree_item_t, udm: udt_type_data_t = None) -> bool:
        ...
    def get_boundaries(self) -> boundaries_t:
        ...
    def get_eamap(self) -> eamap_t:
        ...
    def get_func_type(self, type: tinfo_t) -> bool:
        ...
    def get_line_item(self, line: str, x: int, is_ctree_line: bool, phead: ctree_item_t, pitem: ctree_item_t, ptail: ctree_item_t) -> bool:
        ...
    def get_lvars(self) -> lvars_t:
        ...
    def get_pseudocode(self) -> strvec_t:
        ...
    def get_stkoff_delta(self) -> int:
        ...
    def get_user_cmt(self, loc: treeloc_t, rt: cmt_retrieval_type_t) -> str:
        ...
    def get_user_iflags(self, loc: citem_locator_t) -> int:
        ...
    def get_user_union_selection(self, ea: ida_idaapi.ea_t, path: intvec_t) -> bool:
        ...
    def get_warnings(self) -> hexwarns_t:
        ...
    def has_orphan_cmts(self) -> bool:
        ...
    def locked(self) -> bool:
        ...
    def print_dcl(self) -> None:
        ...
    def print_func(self, vp: vc_printer_t) -> None:
        ...
    def recalc_item_addresses(self) -> None:
        ...
    def refresh_func_ctext(self) -> None:
        ...
    def release(self) -> None:
        ...
    def remove_unused_labels(self) -> None:
        ...
    def reset(self) -> None:
        ...
    def save_user_cmts(self) -> None:
        r"""Save user defined comments into the database. 
                
        """
        ...
    def save_user_iflags(self) -> None:
        r"""Save user defined citem iflags into the database. 
                
        """
        ...
    def save_user_labels(self) -> None:
        r"""Save user defined labels into the database. 
                
        """
        ...
    def save_user_numforms(self) -> None:
        r"""Save user defined number formats into the database. 
                
        """
        ...
    def save_user_unions(self) -> None:
        r"""Save user defined union field selections into the database. 
                
        """
        ...
    def set_user_cmt(self, loc: treeloc_t, cmt: str) -> None:
        ...
    def set_user_iflags(self, loc: citem_locator_t, iflags: int) -> None:
        ...
    def set_user_union_selection(self, ea: ida_idaapi.ea_t, path: intvec_t) -> None:
        ...
    def verify(self, aul: allow_unused_labels_t, even_without_debugger: bool) -> None:
        ...

class cgoto_t:
    @property
    def label_num(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cgoto_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cgoto_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cgoto_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cgoto_t) -> bool:
        ...
    def __lt__(self, r: cgoto_t) -> bool:
        ...
    def __ne__(self, r: cgoto_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: cgoto_t) -> int:
        ...

class chain_keeper_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _gc: graph_chains_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def back(self) -> block_chains_t:
        ...
    def for_all_chains(self, cv: chain_visitor_t, gca: int) -> int:
        ...
    def front(self) -> block_chains_t:
        ...

class chain_t(intvec_t):
    @property
    def flags(self) -> Any: ...
    @property
    def varnum(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: intvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: chain_t) -> bool:
        ...
    def __ne__(self, r: intvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def append_list(self, mba: mba_t, list: mlist_t) -> None:
        r"""Append the contents of the chain to the specified list of locations.
        
        """
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def clear_varnum(self) -> None:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def endoff(self) -> voff_t:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: intvec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def get_reg(self) -> mreg_t:
        ...
    def get_stkoff(self) -> int:
        ...
    def has(self, x: int) -> bool:
        ...
    def includes(self, r: chain_t) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def is_fake(self) -> bool:
        ...
    def is_inited(self) -> bool:
        ...
    def is_overlapped(self) -> bool:
        ...
    def is_passreg(self) -> bool:
        ...
    def is_reg(self) -> bool:
        ...
    def is_replaced(self) -> bool:
        ...
    def is_stkoff(self) -> bool:
        ...
    def is_term(self) -> bool:
        ...
    def key(self) -> voff_t:
        ...
    def overlap(self, r: chain_t) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def set_inited(self, b: bool) -> None:
        ...
    def set_overlapped(self, b: bool) -> None:
        ...
    def set_replaced(self, b: bool) -> None:
        ...
    def set_term(self, b: bool) -> None:
        ...
    def set_value(self, r: chain_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: intvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class chain_visitor_t:
    @property
    def parent(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_chain(self, nblock: int, ch: chain_t) -> int:
        ...

class channel_redir_t:
    @property
    def fd(self) -> Any: ...
    @property
    def file(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def length(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_append(self) -> bool:
        ...
    def is_input(self) -> bool:
        ...
    def is_output(self) -> bool:
        ...
    def is_quoted(self) -> bool:
        ...

class char_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: char) -> None:
        ...
    def cast(self) -> char:
        ...
    def frompointer(self, t: char) -> char_pointer:
        ...
    def value(self) -> char:
        ...

class choose_ioport_parser_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def parse(self, param: str, line: str) -> bool:
        r""":returns: true: and fill PARAM with a displayed string
        :returns: false: and empty PARAM to skip the current device
        :returns: false: and fill PARAM with an error message
        """
        ...

class chooser_base_t:
    NSTDPOPUPS: int  # 4
    POPUP_DEL: int  # 1
    POPUP_EDIT: int  # 2
    POPUP_INS: int  # 0
    POPUP_REFRESH: int  # 3
    @property
    def columns(self) -> Any: ...
    @property
    def deflt_col(self) -> Any: ...
    @property
    def header(self) -> Any: ...
    @property
    def height(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def popup_names(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    @property
    def widths(self) -> Any: ...
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    @property
    def y0(self) -> Any: ...
    @property
    def y1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def ask_item_attrs(self) -> bool:
        r"""should chooser generate ui_get_chooser_item_attrs events?
        
        """
        ...
    def can_del(self) -> bool:
        ...
    def can_edit(self) -> bool:
        ...
    def can_filter(self) -> bool:
        ...
    def can_ins(self) -> bool:
        r"""is an operation allowed?
        
        """
        ...
    def can_refresh(self) -> bool:
        ...
    def can_sort(self) -> bool:
        ...
    def get_builtin_number(self) -> uint:
        r"""get number of the built-in chooser
        
        """
        ...
    def get_count(self) -> int:
        r"""get the number of elements in the chooser
        
        """
        ...
    def get_ea(self, arg2: size_t) -> ida_idaapi.ea_t:
        r"""get the address of an element. When this function returns valid addresses: * If any column has the `CHCOL_FNAME` flag, rows will be colored according to the attributes of the functions who own those addresses (extern, library function, Lumina, ... - similar to what the "Functions" widget does) * When a selection is present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is modal), IDA will jump to that address (through jumpto()) 
                
        :returns: the effective address, BADADDR if the element has no address
        """
        ...
    def get_quick_filter_initial_mode(self) -> int:
        ...
    def get_row(self, n: int) -> Any:
        r"""Get data & attributes for a row in a chooser.
        
        :param n: The row number
        :returns: a tuple (list-of-strings, icon-id, row-attributes)
        """
        ...
    def has_diff_capability(self) -> bool:
        ...
    def has_dirtree(self) -> bool:
        ...
    def has_inode_to_index(self) -> bool:
        ...
    def has_widget_lifecycle(self) -> bool:
        r"""should chooser object be deleted when the widget gets destroyed?
        
        """
        ...
    def is_dirtree_persisted(self) -> bool:
        ...
    def is_force_default(self) -> bool:
        r"""should selection of the already opened non-modal chooser be changed?
        
        """
        ...
    def is_lazy_loaded(self) -> bool:
        ...
    def is_modal(self) -> bool:
        r"""is choose modal?
        
        """
        ...
    def is_multi(self) -> bool:
        r"""is multi-selection allowed?
        
        """
        ...
    def is_quick_filter_visible_initially(self) -> bool:
        ...
    def is_same(self, other: chooser_base_t) -> bool:
        r"""do the current and the given objects hold the same data?
        
        """
        ...
    def is_status_bar_hidden(self) -> bool:
        ...
    def popup_allowed(self, stdact_idx: int) -> bool:
        r"""is a standard action allowed?
        
        """
        ...
    def should_rename_trigger_edit(self) -> bool:
        ...
    def should_restore_geometry(self) -> bool:
        ...

class chooser_item_attrs_t:
    @property
    def color(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, other: chooser_item_attrs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reset(self) -> None:
        ...

class chooser_row_info_t:
    @property
    def attrs(self) -> Any: ...
    @property
    def icon(self) -> Any: ...
    @property
    def texts(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, other: chooser_row_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, other: chooser_row_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class chooser_row_info_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: chooser_row_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> chooser_row_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: chooser_row_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: chooser_row_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: chooser_row_info_t) -> bool:
        ...
    def append(self, x: chooser_row_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> chooser_row_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: chooser_row_info_vec_t) -> None:
        ...
    def extract(self) -> chooser_row_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: chooser_row_info_t) -> bool:
        ...
    def inject(self, s: chooser_row_info_t, len: size_t) -> None:
        ...
    def insert(self, it: chooser_row_info_t, x: chooser_row_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> chooser_row_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: chooser_row_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class chooser_stdact_desc_t:
    @property
    def icon(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def tooltip(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _label: str = None, _tooltip: str = None, _icon: int = -1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def ucb(self, arg0: action_ctx_base_t) -> action_state_t:
        r"""the update callback, see action_handler_t::update() When the update callback is called from the chooser UI engine, it can be sure that ctx.source.chooser is a valid pointer to chooser_base_t and that there are selected items for the Delete and Edit actions. 
                
        """
        ...

class cif_t(ceinsn_t):
    @property
    def expr(self) -> Any: ...
    @property
    def ielse(self) -> Any: ...
    @property
    def ithen(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cif_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cif_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cif_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cif_t) -> bool:
        ...
    def __lt__(self, r: cif_t) -> bool:
        ...
    def __ne__(self, r: cif_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cif_t) -> cif_t:
        ...
    def cleanup(self) -> None:
        ...
    def compare(self, r: cif_t) -> int:
        ...

class cinsn_list_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, x: cinsn_list_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> cinsn_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, x: cinsn_list_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cinsn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, index: Any) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self) -> cinsn_list_t_iterator:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> cinsn_list_t_iterator:
        ...
    def erase(self, p: cinsn_list_t_iterator) -> None:
        ...
    def find(self, item: Any) -> Any:
        ...
    def front(self) -> Any:
        ...
    def index(self, item: Any) -> Any:
        ...
    def insert(self, args: Any) -> cinsn_list_t_iterator:
        ...
    def pop_back(self) -> None:
        ...
    def pop_front(self) -> None:
        ...
    def push_back(self, args: Any) -> cinsn_t:
        ...
    def push_front(self, x: cinsn_t) -> None:
        ...
    def rbegin(self, args: Any) -> const_reverse_iterator:
        ...
    def remove(self, v: cinsn_t) -> bool:
        ...
    def rend(self, args: Any) -> const_reverse_iterator:
        ...
    def size(self) -> int:
        ...
    def splice(self, pos: iterator, other: cinsn_list_t, first: iterator, last: iterator) -> None:
        ...
    def swap(self, x: cinsn_list_t) -> None:
        ...

class cinsn_list_t_iterator:
    @property
    def cur(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, x: cinsn_list_t_iterator) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, x: cinsn_list_t_iterator) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next__(self) -> None:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def next(self) -> None:
        ...

class cinsn_t(citem_t):
    op_to_typename: dict
    @property
    def casm(self) -> Any: ...
    @property
    def cblock(self) -> Any: ...
    @property
    def cdo(self) -> Any: ...
    @property
    def cexpr(self) -> Any: ...
    @property
    def cfor(self) -> Any: ...
    @property
    def cgoto(self) -> Any: ...
    @property
    def cif(self) -> Any: ...
    @property
    def cinsn(self) -> Any: ...
    @property
    def creturn(self) -> Any: ...
    @property
    def cswitch(self) -> Any: ...
    @property
    def cthrow(self) -> Any: ...
    @property
    def ctry(self) -> Any: ...
    @property
    def cwhile(self) -> Any: ...
    @property
    def details(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def label_num(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    @property
    def opname(self) -> Any: ...
    @property
    def to_specific_type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cinsn_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cinsn_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cinsn_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cinsn_t) -> bool:
        ...
    def __lt__(self, r: cinsn_t) -> bool:
        ...
    def __ne__(self, r: cinsn_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cinsn_t) -> cinsn_t:
        ...
    def cleanup(self) -> None:
        r"""Cleanup the statement. This function properly deletes all children and sets the item type to cit_empty. 
                
        """
        ...
    def collect_free_breaks(self, breaks: cinsnptrvec_t) -> bool:
        r"""Collect free `break` statements. This function finds all free `break` statements within the current statement. A `break` statement is free if it does not have a loop or switch parent that that is also within the current statement. 
                
        :param breaks: pointer to the variable where the vector of all found free `break` statements is returned. This argument can be nullptr.
        :returns: true if some free `break` statements have been found
        """
        ...
    def collect_free_continues(self, continues: cinsnptrvec_t) -> bool:
        r"""Collect free `continue` statements. This function finds all free `continue` statements within the current statement. A `continue` statement is free if it does not have a loop parent that that is also within the current statement. 
                
        :param continues: pointer to the variable where the vector of all found free `continue` statements is returned. This argument can be nullptr.
        :returns: true if some free `continue` statements have been found
        """
        ...
    def compare(self, r: cinsn_t) -> int:
        ...
    def contains_expr(self, e: cexpr_t) -> bool:
        r"""Does the item contain an expression?
        
        """
        ...
    def contains_free_break(self) -> bool:
        r"""Check if the statement has free `break` statements.
        
        """
        ...
    def contains_free_continue(self) -> bool:
        r"""Check if the statement has free `continue` statements.
        
        """
        ...
    def contains_insn(self, type: ctype_t, times: int = 1) -> bool:
        r"""Check if the statement contains a statement of the specified type. 
                
        :param type: statement opcode to look for
        :param times: how many times TYPE should be present
        :returns: true if the statement has at least TIMES children with opcode == TYPE
        """
        ...
    def contains_label(self) -> bool:
        r"""Does the item contain a label?
        
        """
        ...
    def create_if(self, cnd: cexpr_t) -> cif_t:
        r"""Create a new if-statement. The current statement must be a block. The new statement will be appended to it. 
                
        :param cnd: if condition. It will be deleted after being copied.
        """
        ...
    def dstr(self) -> str:
        ...
    def find_closest_addr(self, _ea: ida_idaapi.ea_t) -> citem_t:
        ...
    def find_parent_of(self, item: citem_t) -> citem_t:
        r"""Find parent of the specified item. 
                
        :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
        :returns: nullptr if not found
        """
        ...
    def insn_is_epilog(self, insn: cinsn_t) -> bool:
        ...
    def is_epilog(self) -> Any:
        ...
    def is_expr(self) -> bool:
        r"""Is an expression?
        
        """
        ...
    def is_ordinary_flow(self) -> bool:
        r"""Check if the statement passes execution to the next statement. 
                
        :returns: false if the statement breaks the control flow (like goto, return, etc)
        """
        ...
    def new_insn(self, insn_ea: ida_idaapi.ea_t) -> cinsn_t:
        r"""Create a new statement. The current statement must be a block. The new statement will be appended to it. 
                
        :param insn_ea: statement address
        """
        ...
    def print1(self, func: cfunc_t) -> None:
        r"""Print the statement into one line. Currently this function is not available. 
                
        :param func: parent function. This argument is used to find out the referenced variable names.
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def swap(self, r: cinsn_t) -> None:
        ...
    def zero(self) -> None:
        r"""Overwrite with zeroes without cleaning memory or deleting children.
        
        """
        ...

class cinsnptrvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cinsnptrvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: cinsnptrvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cinsn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: cinsn_t) -> bool:
        ...
    def append(self, args: Any) -> Any:
        ...
    def at(self, i: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: cinsnptrvec_t) -> None:
        ...
    def extract(self) -> cinsn_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: cinsn_t) -> bool:
        ...
    def inject(self, s: cinsn_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: cinsn_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: cinsnptrvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class citem_cmt_t:
    @property
    def used(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def c_str(self) -> str:
        ...

class citem_locator_t:
    @property
    def ea(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: citem_locator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: citem_locator_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: citem_locator_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: citem_locator_t) -> bool:
        ...
    def __lt__(self, r: citem_locator_t) -> bool:
        ...
    def __ne__(self, r: citem_locator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: citem_locator_t) -> int:
        ...

class citem_t:
    @property
    def cexpr(self) -> Any: ...
    @property
    def cinsn(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def index(self) -> Any: ...
    @property
    def label_num(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def op(self) -> Any: ...
    @property
    def to_specific_type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, o: ctype_t = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains_expr(self, e: cexpr_t) -> bool:
        r"""Does the item contain an expression?
        
        """
        ...
    def contains_label(self) -> bool:
        r"""Does the item contain a label?
        
        """
        ...
    def find_closest_addr(self, _ea: ida_idaapi.ea_t) -> citem_t:
        ...
    def find_parent_of(self, item: citem_t) -> citem_t:
        r"""Find parent of the specified item. 
                
        :param item: Item to find the parent of. The search will be performed among the children of the item pointed by `this`.
        :returns: nullptr if not found
        """
        ...
    def is_expr(self) -> bool:
        r"""Is an expression?
        
        """
        ...
    def print1(self, func: cfunc_t) -> None:
        r"""Print item into one line. 
                
        :param func: parent function. This argument is used to find out the referenced variable names.
        :returns: length of the generated text.
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def swap(self, r: citem_t) -> None:
        r"""Swap two citem_t.
        
        """
        ...

class cli_t(pyidc_opaque_object_t):
    r"""
    cli_t wrapper class.
    
    This class allows you to implement your own command line interface handlers.
    
    """
    def OnExecuteLine(self, line: Any) -> Any:
        r"""
        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.
        
        This callback is mandatory.
        
        :param line: typed line(s)
        :returns: Boolean: True-executed line, False-ask for more lines
        
        """
        ...
    def OnFindCompletions(self, line: Any, x: Any) -> Any:
        r"""
        The user pressed Tab. Return a list of completions
        
        This callback is optional.
        
        :param line: the current line (string)
        :param x: the index where the cursor is (int)
        
        :returns: None if no completion could be generated, otherwise a tuple:
            (completions : Sequence[str], hints : Sequence[str], docs: Sequence[str],
              match_start: int, match_end: int)
        
        """
        ...
    def OnKeydown(self, line: Any, x: Any, sellen: Any, vkey: Any, shift: Any) -> Any:
        r"""
        A keyboard key has been pressed
        This is a generic callback and the CLI is free to do whatever it wants.
        
        This callback is optional.
        
        :param line: current input line
        :param x: current x coordinate of the cursor
        :param sellen: current selection length (usually 0)
        :param vkey: virtual key code. if the key has been handled, it should be returned as zero
        :param shift: shift state
        
        :returns: None - Nothing was changed
        :returns: tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
        :returns: It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
        
        """
        ...
    def __del__(self) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def register(self, flags: Any = 0, sname: Any = None, lname: Any = None, hint: Any = None) -> Any:
        r"""
        Registers the CLI.
        
        :param flags: Feature bits. No bits are defined yet, must be 0
        :param sname: Short name (displayed on the button)
        :param lname: Long name (displayed in the menu)
        :param hint:  Hint for the input line
        
        :returns: Boolean: True-Success, False-Failed
        
        """
        ...
    def unregister(self) -> Any:
        r"""
        Unregisters the CLI (if it was registered)
        
        """
        ...

class cloop_t(ceinsn_t):
    @property
    def body(self) -> Any: ...
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cloop_t) -> cloop_t:
        ...
    def cleanup(self) -> None:
        ...

class cnumber_t:
    @property
    def nf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cnumber_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cnumber_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cnumber_t) -> bool:
        ...
    def __init__(self, _opnum: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cnumber_t) -> bool:
        ...
    def __lt__(self, r: cnumber_t) -> bool:
        ...
    def __ne__(self, r: cnumber_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, v: uint64, nbytes: int, sign: type_sign_t) -> None:
        r"""Assign new value 
                
        :param v: new value
        :param nbytes: size of the new value in bytes
        :param sign: sign of the value
        """
        ...
    def compare(self, r: cnumber_t) -> int:
        ...
    def value(self, type: tinfo_t) -> uint64:
        r"""Get value. This function will properly extend the number sign to 64bits depending on the type sign. 
                
        """
        ...

class codegen_t:
    @property
    def ignore_micro(self) -> Any: ...
    @property
    def ii(self) -> Any: ...
    @property
    def insn(self) -> Any: ...
    @property
    def mb(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def analyze_prolog(self, fc: qflow_chart_t, reachable: bitset_t) -> merror_t:
        r"""Analyze prolog/epilog of the function to decompile. If prolog is found, allocate and fill 'mba->pi' structure. 
                
        :param fc: flow chart
        :param reachable: bitmap of reachable blocks
        :returns: error code
        """
        ...
    def clear(self) -> None:
        ...
    def emit(self, args: Any) -> minsn_t:
        r"""This function has the following signatures:
        
            0. emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *
            1. emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *
        
        # 0: emit(code: mcode_t, width: int, l: int, r: int, d: int, offsize: int) -> minsn_t *
        
        Emit one microinstruction. The L, R, D arguments usually mean the register number. However, they depend on CODE. For example:
        * for m_goto and m_jcnd L is the target address
        * for m_ldc L is the constant value to load
        
        
        
        :returns: created microinstruction. can be nullptr if the instruction got immediately optimized away.
        
        # 1: emit(code: mcode_t, l: const mop_t *, r: const mop_t *, d: const mop_t *) -> minsn_t *
        
        Emit one microinstruction. This variant accepts pointers to operands. It is more difficult to use but permits to create virtually any instruction. Operands may be nullptr when it makes sense. 
                
        
        """
        ...
    def emit_micro_mvm(self, code: mcode_t, dtype: op_dtype_t, l: int, r: int, d: int, offsize: int) -> minsn_t:
        r"""Emit one microinstruction. This variant takes a data type not a size. 
                
        """
        ...
    def gen_micro(self) -> merror_t:
        r"""Generate microcode for one instruction. The instruction is in INSN 
                
        :returns: MERR_OK - all ok MERR_BLOCK - all ok, need to switch to new block MERR_BADBLK - delete current block and continue other error codes are fatal
        """
        ...
    def load_effective_address(self, n: int, flags: int = 0) -> mreg_t:
        r"""Generate microcode to calculate the address of a memory operand. 
                
        :param n: - number of INSN operand
        :param flags: - reserved for future use
        :returns: register containing the operand address. mr_none - failed (not a memory operand)
        """
        ...
    def load_operand(self, opnum: int, flags: int = 0) -> mreg_t:
        r"""Generate microcode to load one operand. 
                
        :param opnum: number of INSN operand
        :param flags: reserved for future use
        :returns: register containing the operand.
        """
        ...
    def microgen_completed(self) -> None:
        r"""This method is called when the microcode generation is done.
        
        """
        ...
    def prepare_gen_micro(self) -> merror_t:
        r"""Setup internal data to handle new instruction. This method should be called before calling gen_micro(). Usually gen_micro() is called by the decompiler. You have to call this function explicitly only if you yourself call gen_micro(). The instruction is in INSN 
                
        :returns: MERR_OK - all ok other error codes are fatal
        """
        ...
    def store_operand(self, n: int, mop: mop_t, flags: int = 0, outins: minsn_t = None) -> bool:
        r"""Generate microcode to store an operand. In case of success an arbitrary number of instructions can be generated (and even no instruction if the source and target are the same) 
                
        :param n: - number of target INSN operand
        :param mop: - operand to be stored
        :param flags: - reserved for future use
        :param outins: - (OUT) the last generated instruction
        :returns: success
        """
        ...

class compiled_binpat_t:
    @property
    def bytes(self) -> Any: ...
    @property
    def encidx(self) -> Any: ...
    @property
    def mask(self) -> Any: ...
    @property
    def strlits(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: compiled_binpat_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: compiled_binpat_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def all_bytes_defined(self) -> bool:
        ...
    def qclear(self) -> None:
        ...

class compiled_binpat_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: compiled_binpat_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> compiled_binpat_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: compiled_binpat_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: compiled_binpat_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: compiled_binpat_t) -> bool:
        ...
    def append(self, x: compiled_binpat_t) -> None:
        ...
    def at(self, _idx: size_t) -> compiled_binpat_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: compiled_binpat_vec_t) -> None:
        ...
    def extract(self) -> compiled_binpat_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: compiled_binpat_t) -> bool:
        ...
    def inject(self, s: compiled_binpat_t, len: size_t) -> None:
        ...
    def insert(self, it: compiled_binpat_t, x: compiled_binpat_t) -> iterator:
        ...
    def parse(self, ea: ida_idaapi.ea_t, text: str, radix: int = -1, strlits_encoding: int = -1) -> compiled_binpat_vec_t:
        r"""Convert user-specified binary string to internal representation.
        
        The 'in' parameter contains space-separated tokens:
        
            *numbers (numeric base is determined by 'radix')
                - if value of number fits a byte, it is considered as a byte
                - if value of number fits a word, it is considered as 2 bytes
                - if value of number fits a dword,it is considered as 4 bytes
            * "..." string constants
            * 'x'  single-character constants
            * ?    variable bytes
        
        Note that string constants are surrounded with double quotes.
        
        Here are a few examples (assuming base 16):
        
            * CD 21          - bytes 0xCD, 0x21
            * 21CD           - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)
            * "Hello", 0     - the null terminated string "Hello"
            * L"Hello"       - 'H', 0, 'e', 0, 'l', 0, 'l', 0, 'o', 0
            * B8 ? ? ? ? 90  - byte 0xB8, 4 bytes with any value, byte 0x90
        
        This method will throw an exception if the pattern could not be parsed
        
        :param ea: linear address to convert for (the conversion depends on the
                   address, because the number of bits in a byte depend on the
                   segment type)
        :param text: input text string
        :param radix: numeric base of numbers (8,10,16). If `-1` (the default), then the default radix will be used (see get_default_radix)
        :param strlits_encoding: the target encoding into which the string
                             literals present in 'in', should be encoded.
                             Can be any from [1, get_encoding_qty()), or
                             the special values PBSENC_*
        :returns: a set of patterns
        """
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> compiled_binpat_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: compiled_binpat_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class compiler_info_t:
    @property
    def cm(self) -> Any: ...
    @property
    def defalign(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def size_b(self) -> Any: ...
    @property
    def size_e(self) -> Any: ...
    @property
    def size_i(self) -> Any: ...
    @property
    def size_l(self) -> Any: ...
    @property
    def size_ldbl(self) -> Any: ...
    @property
    def size_ll(self) -> Any: ...
    @property
    def size_s(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_cc(self) -> callcnv_t:
        ...
    def set_cc(self, cc: callcnv_t) -> None:
        ...

class const_aloc_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_location(self, v: argloc_t, off: int, size: int) -> int:
        ...

class creturn_t(ceinsn_t):
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: creturn_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: creturn_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: creturn_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: creturn_t) -> bool:
        ...
    def __lt__(self, r: creturn_t) -> bool:
        ...
    def __ne__(self, r: creturn_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: creturn_t) -> int:
        ...

class cswitch_t(ceinsn_t):
    @property
    def cases(self) -> Any: ...
    @property
    def expr(self) -> Any: ...
    @property
    def mvnf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cswitch_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cswitch_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cswitch_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cswitch_t) -> bool:
        ...
    def __lt__(self, r: cswitch_t) -> bool:
        ...
    def __ne__(self, r: cswitch_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: cswitch_t) -> int:
        ...

class ctext_position_t:
    @property
    def lnnum(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ctext_position_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ctext_position_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ctext_position_t) -> bool:
        ...
    def __init__(self, _lnnum: int = -1, _x: int = 0, _y: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: ctext_position_t) -> bool:
        ...
    def __lt__(self, r: ctext_position_t) -> bool:
        ...
    def __ne__(self, r: ctext_position_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: ctext_position_t) -> int:
        ...
    def in_ctree(self, hdrlines: int) -> bool:
        r"""Is the cursor in the variable/type declaration area? 
                
        :param hdrlines: Number of lines of the declaration area
        """
        ...

class cthrow_t(ceinsn_t):
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cthrow_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cthrow_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cthrow_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cthrow_t) -> bool:
        ...
    def __lt__(self, r: cthrow_t) -> bool:
        ...
    def __ne__(self, r: cthrow_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: cthrow_t) -> int:
        ...

class ctree_anchor_t:
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_index(self) -> int:
        ...
    def get_itp(self) -> item_preciser_t:
        ...
    def is_blkcmt_anchor(self) -> bool:
        ...
    def is_citem_anchor(self) -> bool:
        ...
    def is_itp_anchor(self) -> bool:
        ...
    def is_lvar_anchor(self) -> bool:
        ...
    def is_valid_anchor(self) -> bool:
        ...

class ctree_item_t:
    @property
    def citype(self) -> Any: ...
    @property
    def e(self) -> Any: ...
    @property
    def f(self) -> Any: ...
    @property
    def i(self) -> Any: ...
    @property
    def it(self) -> Any: ...
    @property
    def l(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dstr(self) -> str:
        ...
    def get_ea(self) -> ida_idaapi.ea_t:
        r"""Get address of the current item. Each ctree item has an address. 
                
        :returns: BADADDR if failed
        """
        ...
    def get_edm(self, parent: tinfo_t) -> int:
        r"""Get type of an enum member. If the current item is a symbolic constant, this function will return information about it. 
                
        :param parent: pointer to buffer for the enum type.
        :returns: member index or -1 if failed
        """
        ...
    def get_label_num(self, gln_flags: int) -> int:
        r"""Get label number of the current item. 
                
        :param gln_flags: Combination of get_label_num control bits
        :returns: -1 if failed or no label
        """
        ...
    def get_lvar(self) -> lvar_t:
        r"""Get pointer to local variable. If the current item is a local variable, this function will return pointer to its definition. 
                
        :returns: nullptr if failed
        """
        ...
    def get_udm(self, udm: udm_t = None, parent: tinfo_t = None, p_offset: uint64 = None) -> int:
        r"""Get type of a structure field. If the current item is a structure/union field, this function will return information about it. 
                
        :param udm: pointer to buffer for the udt member info.
        :param parent: pointer to buffer for the struct/union type.
        :param p_offset: pointer to the offset in bits inside udt.
        :returns: member index or -1 if failed Both output parameters can be nullptr.
        """
        ...
    def is_citem(self) -> bool:
        r"""Is the current item is a ctree item?
        
        """
        ...

class ctree_items_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ctree_items_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: ctree_items_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: citem_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: citem_t) -> bool:
        ...
    def append(self, args: Any) -> Any:
        ...
    def at(self, i: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: ctree_items_t) -> None:
        ...
    def extract(self) -> citem_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: citem_t) -> bool:
        ...
    def inject(self, s: citem_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: citem_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: ctree_items_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ctree_parentee_t(ctree_visitor_t):
    @property
    def bposvec(self) -> Any: ...
    @property
    def cv_flags(self) -> Any: ...
    @property
    def parents(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, post: bool = False) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_to(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse ctree. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def apply_to_exprs(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse only expressions. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def clr_prune(self) -> None:
        r"""Do not prune children. This is an internal function, no need to call it.
        
        """
        ...
    def clr_restart(self) -> None:
        r"""Do not restart. This is an internal function, no need to call it.
        
        """
        ...
    def is_postorder(self) -> bool:
        r"""Should the leave...() functions be called?
        
        """
        ...
    def leave_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def leave_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def maintain_parents(self) -> bool:
        r"""Should the parent information by maintained?
        
        """
        ...
    def must_prune(self) -> bool:
        r"""Should the traversal skip the children of the current item?
        
        """
        ...
    def must_restart(self) -> bool:
        r"""Should the traversal restart?
        
        """
        ...
    def only_insns(self) -> bool:
        r"""Should all expressions be automatically pruned?
        
        """
        ...
    def parent_expr(self) -> cexpr_t:
        r"""Get parent of the current item as an expression.
        
        """
        ...
    def parent_insn(self) -> cinsn_t:
        r"""Get parent of the current item as a statement.
        
        """
        ...
    def parent_item(self) -> citem_t:
        r"""Get parent of the current item as an item (statement or expression)
        
        """
        ...
    def prune_now(self) -> None:
        r"""Prune children. This function may be called by a visitor() to skip all children of the current item. 
                
        """
        ...
    def recalc_parent_types(self) -> bool:
        r"""Recalculate type of parent nodes. If a node type has been changed, the visitor must recalculate all parent types, otherwise the ctree becomes inconsistent. If during this recalculation a parent node is added/deleted, this function returns true. In this case the traversal must be stopped because the information about parent nodes is stale. 
                
        :returns: false-ok to continue the traversal, true-must stop.
        """
        ...
    def set_restart(self) -> None:
        r"""Restart the travesal. Meaningful only in apply_to_exprs()
        
        """
        ...
    def visit_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def visit_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...

class ctree_visitor_t:
    @property
    def bposvec(self) -> Any: ...
    @property
    def cv_flags(self) -> Any: ...
    @property
    def parents(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _flags: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_to(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse ctree. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def apply_to_exprs(self, item: citem_t, parent: citem_t) -> int:
        r"""Traverse only expressions. The traversal will start at the specified item and continue until of one the visit_...() functions return a non-zero value. 
                
        :param item: root of the ctree to traverse
        :param parent: parent of the specified item. can be specified as nullptr.
        :returns: 0 or a non-zero value returned by a visit_...() function
        """
        ...
    def clr_prune(self) -> None:
        r"""Do not prune children. This is an internal function, no need to call it.
        
        """
        ...
    def clr_restart(self) -> None:
        r"""Do not restart. This is an internal function, no need to call it.
        
        """
        ...
    def is_postorder(self) -> bool:
        r"""Should the leave...() functions be called?
        
        """
        ...
    def leave_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def leave_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement after having visited its children. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs post-order traserval, i.e. an item is visited after its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def maintain_parents(self) -> bool:
        r"""Should the parent information by maintained?
        
        """
        ...
    def must_prune(self) -> bool:
        r"""Should the traversal skip the children of the current item?
        
        """
        ...
    def must_restart(self) -> bool:
        r"""Should the traversal restart?
        
        """
        ...
    def only_insns(self) -> bool:
        r"""Should all expressions be automatically pruned?
        
        """
        ...
    def parent_expr(self) -> cexpr_t:
        r"""Get parent of the current item as an expression.
        
        """
        ...
    def parent_insn(self) -> cinsn_t:
        r"""Get parent of the current item as a statement.
        
        """
        ...
    def parent_item(self) -> citem_t:
        r"""Get parent of the current item as an item (statement or expression)
        
        """
        ...
    def prune_now(self) -> None:
        r"""Prune children. This function may be called by a visitor() to skip all children of the current item. 
                
        """
        ...
    def set_restart(self) -> None:
        r"""Restart the travesal. Meaningful only in apply_to_exprs()
        
        """
        ...
    def visit_expr(self, arg0: cexpr_t) -> int:
        r"""Visit an expression. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...
    def visit_insn(self, arg0: cinsn_t) -> int:
        r"""Visit a statement. This is a visitor function which should be overridden by a derived class to do some useful work. This visitor performs pre-order traserval, i.e. an item is visited before its children. 
                
        :returns: 0 to continue the traversal, nonzero to stop.
        """
        ...

class ctry_t(cblock_t, cinsn_list_t):
    @property
    def catchs(self) -> Any: ...
    @property
    def is_wind(self) -> Any: ...
    @property
    def new_state(self) -> Any: ...
    @property
    def old_state(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ctry_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ctry_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> cinsn_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ctry_t) -> bool:
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, r: ctry_t) -> bool:
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, r: ctry_t) -> bool:
        ...
    def __ne__(self, r: ctry_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: cinsn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, index: Any) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self) -> cinsn_list_t_iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: ctry_t) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> cinsn_list_t_iterator:
        ...
    def erase(self, p: cinsn_list_t_iterator) -> None:
        ...
    def find(self, item: Any) -> Any:
        ...
    def front(self) -> Any:
        ...
    def index(self, item: Any) -> Any:
        ...
    def insert(self, args: Any) -> cinsn_list_t_iterator:
        ...
    def pop_back(self) -> None:
        ...
    def pop_front(self) -> None:
        ...
    def push_back(self, args: Any) -> cinsn_t:
        ...
    def push_front(self, x: cinsn_t) -> None:
        ...
    def rbegin(self, args: Any) -> const_reverse_iterator:
        ...
    def remove(self, v: cinsn_t) -> bool:
        ...
    def rend(self, args: Any) -> const_reverse_iterator:
        ...
    def size(self) -> int:
        ...
    def splice(self, pos: iterator, other: cinsn_list_t, first: iterator, last: iterator) -> None:
        ...
    def swap(self, x: cinsn_list_t) -> None:
        ...

class custom_callcnv_t:
    @property
    def abibits(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def calc_arglocs(self, fti: func_type_data_t) -> bool:
        r"""Calculate the argument locations. This function must fill all fti->at(i).argloc instances. It may be called for variadic functions too, in calc_varglocs fails. 
                
        :param fti: function prototype
        :returns: success
        """
        ...
    def calc_purged_bytes(self, args: Any) -> int:
        r"""Calculate the number of purged bytes 
                
        :param fti: function prototype
        :param call_ea: address of the call instruction (not used yet)
        """
        ...
    def calc_retloc(self, fti: func_type_data_t) -> bool:
        r"""Calculate the location of the return value. This function must fill fti->retloc. 
                
        :param fti: function prototype
        :returns: success
        """
        ...
    def calc_varglocs(self, fti: func_type_data_t, regs: regobjs_t, stkargs: relobj_t, nfixed: int) -> bool:
        r"""Calculate the argument locations for a variadic function. This function must fill all fti->at(i).argloc instances and provide more detailed info about registers and stkargs. 
                
        :param fti: function prototype
        :param regs: buffer for hidden register arguments, may be nullptr
        :param stkargs: buffer for hidden stack arguments, may be nullptr
        :param nfixed: number of fixed arguments
        :returns: success
        """
        ...
    def decorate_name(self, name: str, should_decorate: bool, cc: callcnv_t, type: tinfo_t) -> bool:
        r"""Function to be overloaded for custom calling conventions.
        
        Decorate a function name. Some compilers decorate names depending on the calling convention. This function provides the means to handle it for custom callcnvs. Please note that this is about name decoration (C), not name mangling (C++). 
                
        """
        ...
    def find_varargs(self, fti: func_type_data_t, call_ea: ida_idaapi.ea_t, blk: mblock_t) -> ssize_t:
        r"""Discover variadic arguments. This function is called only for variadic functions. It is currently used by the decompiler. 
                
        :param fti: function prototype. find_varargs() should append the discovered variadic arguments to it.
        :param call_ea: address of the call instruction
        :param blk: microcode block with the call instruction
        :returns: >0 - total number of arguments after the call <0 - failure ==0 - means to use the standard algorithm to discover variadic args
        """
        ...
    def get_cc_regs(self, out: callregs_t) -> bool:
        r"""Retrieve generic information about call registers.
        
        """
        ...
    def get_stkarg_area_info(self, out: stkarg_area_info_t) -> bool:
        r"""Retrieve generic information about stack arguments.
        
        """
        ...
    def is_purging(self) -> bool:
        ...
    def is_usercall(self) -> bool:
        ...
    def is_vararg(self) -> bool:
        ...
    def lower_func_type(self, fti: func_type_data_t) -> int:
        r"""Lower a function type. See lower_type() for more explanations. 
                
        :param fti: function prototype
        :returns: <0-failure, >=0-ok, 2-made substantial changes
        """
        ...
    def validate_func(self, fti: func_type_data_t, reterr: str) -> bool:
        r"""Validate a function prototype. This function is used during parsing or deserializing a function prototype to verify semantic limitations of the prototype (for example, returning arrays is forbidden in C) 
                
        :param fti: function prototype
        :param reterr: buffer for error message
        """
        ...

class custom_data_type_ids_fids_array:
    @property
    def bytes(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> short:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, data: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: short) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class custom_data_type_ids_t:
    @property
    def dtid(self) -> Any: ...
    @property
    def fids(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_dtid(self) -> tid_t:
        ...
    def set(self, tid: tid_t) -> None:
        ...

class custom_data_type_info_t:
    @property
    def dtid(self) -> Any: ...
    @property
    def fid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class cwhile_t(cloop_t, ceinsn_t):
    @property
    def body(self) -> Any: ...
    @property
    def expr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: cwhile_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: cwhile_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: cwhile_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: cwhile_t) -> bool:
        ...
    def __lt__(self, r: cwhile_t) -> bool:
        ...
    def __ne__(self, r: cwhile_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, r: cloop_t) -> cloop_t:
        ...
    def cleanup(self) -> None:
        ...
    def compare(self, r: cwhile_t) -> int:
        ...

class data_format_t:
    r"""Information about a data format"""
    @property
    def hotkey(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def menu_name(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def props(self) -> Any: ...
    @property
    def text_width(self) -> Any: ...
    @property
    def value_size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __real__init__(self, _self: Any, name: str, value_size: asize_t = 0, menu_name: str = None, props: int = 0, hotkey: str = None, text_width: int = 0) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_present_in_menus(self) -> bool:
        r"""Should this format be shown in UI menus 
                
        :returns: success
        """
        ...

class data_type_t:
    r"""Information about a data type"""
    @property
    def asm_keyword(self) -> Any: ...
    @property
    def hotkey(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def menu_name(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def props(self) -> Any: ...
    @property
    def value_size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __real__init__(self, _self: Any, name: str, value_size: asize_t = 0, menu_name: str = None, hotkey: str = None, asm_keyword: str = None, props: int = 0) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_present_in_menus(self) -> bool:
        r"""Should this type be shown in UI menus 
                
        :returns: success
        """
        ...

class debapp_attrs_t:
    @property
    def addrsize(self) -> Any: ...
    @property
    def cbsize(self) -> Any: ...
    @property
    def is_be(self) -> Any: ...
    @property
    def platform(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class debug_event_t:
    @property
    def ea(self) -> Any: ...
    @property
    def handled(self) -> Any: ...
    @property
    def pid(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def bpt(self) -> bptaddr_t:
        r"""EXCEPTION
        
        """
        ...
    def bpt_ea(self) -> ida_idaapi.ea_t:
        r"""On some systems with special memory mappings the triggered ea might be different from the actual ea. Calculate the address to use. 
                
        """
        ...
    def clear(self) -> None:
        r"""clear the dependent information (see below), set event code to NO_EVENT
        
        """
        ...
    def clear_all(self) -> None:
        ...
    def copy(self, r: debug_event_t) -> debug_event_t:
        ...
    def eid(self) -> event_id_t:
        r"""Event code.
        
        """
        ...
    def exc(self) -> excinfo_t:
        ...
    def exit_code(self) -> int:
        r"""THREAD_STARTED (thread name) LIB_UNLOADED (unloaded library name) INFORMATION (will be displayed in the output window if not empty) 
                
        """
        ...
    def info(self) -> str:
        r"""BREAKPOINT
        
        """
        ...
    def is_bitness_changed(self) -> bool:
        r"""process bitness
        
        """
        ...
    def modinfo(self) -> modinfo_t:
        r"""Information that depends on the event code:
        
        < PROCESS_STARTED, PROCESS_ATTACHED, LIB_LOADED PROCESS_EXITED, THREAD_EXITED 
                
        """
        ...
    def set_bitness_changed(self, on: bool = True) -> None:
        ...
    def set_bpt(self) -> bptaddr_t:
        ...
    def set_eid(self, id: event_id_t) -> None:
        r"""Set event code. If the new event code is compatible with the old one then the dependent information (see below) will be preserved. Otherwise the event will be cleared and the new event code will be set. 
                
        """
        ...
    def set_exception(self) -> excinfo_t:
        ...
    def set_exit_code(self, id: event_id_t, code: int) -> None:
        ...
    def set_info(self, id: event_id_t) -> str:
        ...
    def set_modinfo(self, id: event_id_t) -> modinfo_t:
        ...

class debugger_t:
    ev_appcall: int  # 34
    ev_attach_process: int  # 4
    ev_bin_search: int  # 42
    ev_check_bpt: int  # 24
    ev_cleanup_appcall: int  # 35
    ev_close_file: int  # 28
    ev_dbg_enable_trace: int  # 38
    ev_detach_process: int  # 5
    ev_eval_lowcnd: int  # 36
    ev_exit_process: int  # 9
    ev_get_debapp_attrs: int  # 6
    ev_get_debmod_extensions: int  # 32
    ev_get_debug_event: int  # 10
    ev_get_dynamic_register_set: int  # 43
    ev_get_memory_info: int  # 21
    ev_get_processes: int  # 2
    ev_get_srcinfo_path: int  # 41
    ev_init_debugger: int  # 0
    ev_is_tracing_enabled: int  # 39
    ev_map_address: int  # 31
    ev_open_file: int  # 27
    ev_read_file: int  # 29
    ev_read_memory: int  # 22
    ev_read_registers: int  # 18
    ev_rebase_if_required_to: int  # 7
    ev_request_pause: int  # 8
    ev_resume: int  # 11
    ev_rexec: int  # 40
    ev_send_ioctl: int  # 37
    ev_set_backwards: int  # 12
    ev_set_dbg_options: int  # 44
    ev_set_exception_info: int  # 13
    ev_set_resume_mode: int  # 17
    ev_start_process: int  # 3
    ev_suspended: int  # 14
    ev_term_debugger: int  # 1
    ev_thread_continue: int  # 16
    ev_thread_get_sreg_base: int  # 20
    ev_thread_suspend: int  # 15
    ev_update_bpts: int  # 25
    ev_update_call_stack: int  # 33
    ev_update_lowcnds: int  # 26
    ev_write_file: int  # 30
    ev_write_memory: int  # 23
    ev_write_register: int  # 19
    @property
    def bpt_bytes(self) -> Any: ...
    @property
    def bpt_size(self) -> Any: ...
    @property
    def default_regclasses(self) -> Any: ...
    @property
    def filetype(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def memory_page_size(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def nregisters(self) -> Any: ...
    @property
    def processor(self) -> Any: ...
    @property
    def regclasses(self) -> Any: ...
    @property
    def registers(self) -> Any: ...
    @property
    def resume_modes(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def attach_process(self, pid: pid_t, event_id: int, dbg_proc_flags: int) -> drc_t:
        ...
    def bin_search(self, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t, srch_flags: int) -> drc_t:
        ...
    def cache_block_size(self) -> int:
        ...
    def can_continue_from_bpt(self) -> bool:
        ...
    def can_debug_standalone_dlls(self) -> bool:
        ...
    def check_bpt(self, bptvc: int, type: bpttype_t, ea: ida_idaapi.ea_t, len: int) -> drc_t:
        ...
    def cleanup_appcall(self, tid: thid_t) -> drc_t:
        ...
    def close_file(self, fn: int) -> None:
        ...
    def dbg_enable_trace(self, tid: thid_t, enable: bool, trace_flags: int) -> bool:
        ...
    def detach_process(self) -> drc_t:
        ...
    def eval_lowcnd(self, tid: thid_t, ea: ida_idaapi.ea_t) -> drc_t:
        ...
    def exit_process(self) -> drc_t:
        ...
    def fake_memory(self) -> bool:
        ...
    def get_debapp_attrs(self, out_pattrs: debapp_attrs_t) -> bool:
        ...
    def get_debmod_extensions(self) -> None:
        ...
    def get_debug_event(self, event: debug_event_t, timeout_ms: int) -> gdecode_t:
        ...
    def get_dynamic_register_set(self, regset: dynamic_register_set_t) -> bool:
        ...
    def get_memory_info(self, ranges: meminfo_vec_t) -> drc_t:
        ...
    def get_processes(self, procs: procinfo_vec_t) -> drc_t:
        ...
    def get_srcinfo_path(self, path: str, base: ida_idaapi.ea_t) -> bool:
        ...
    def has_appcall(self) -> bool:
        ...
    def has_attach_process(self) -> bool:
        ...
    def has_check_bpt(self) -> bool:
        ...
    def has_detach_process(self) -> bool:
        ...
    def has_get_processes(self) -> bool:
        ...
    def has_map_address(self) -> bool:
        ...
    def has_open_file(self) -> bool:
        ...
    def has_request_pause(self) -> bool:
        ...
    def has_rexec(self) -> bool:
        ...
    def has_set_exception_info(self) -> bool:
        ...
    def has_set_resume_mode(self) -> bool:
        ...
    def has_soft_bpt(self) -> bool:
        ...
    def has_thread_continue(self) -> bool:
        ...
    def has_thread_get_sreg_base(self) -> bool:
        ...
    def has_thread_suspend(self) -> bool:
        ...
    def has_update_call_stack(self) -> bool:
        ...
    def have_set_options(self) -> bool:
        ...
    def init_debugger(self, hostname: str, portnum: int, password: str) -> bool:
        ...
    def is_remote(self) -> bool:
        ...
    def is_resmod_avail(self, resmod: int) -> bool:
        ...
    def is_safe(self) -> bool:
        ...
    def is_tracing_enabled(self, tid: thid_t, tracebit: int) -> bool:
        ...
    def is_ttd(self) -> bool:
        ...
    def map_address(self, off: ida_idaapi.ea_t, regs: regval_t, regnum: int) -> ida_idaapi.ea_t:
        ...
    def may_disturb(self) -> bool:
        ...
    def may_take_exit_snapshot(self) -> bool:
        ...
    def must_have_hostname(self) -> bool:
        ...
    def open_file(self, file: str, fsize: uint64, readonly: bool) -> int:
        ...
    def read_file(self, fn: int, off: qoff64_t, buf: void, size: size_t) -> ssize_t:
        ...
    def read_memory(self, nbytes: size_t, ea: ida_idaapi.ea_t, buffer: void, size: size_t) -> drc_t:
        ...
    def read_registers(self, tid: thid_t, clsmask: int, values: regval_t) -> drc_t:
        ...
    def rebase_if_required_to(self, new_base: ida_idaapi.ea_t) -> None:
        ...
    def regs(self, idx: int) -> register_info_t:
        ...
    def request_pause(self) -> drc_t:
        ...
    def resume(self, event: debug_event_t) -> drc_t:
        ...
    def rexec(self, cmdline: str) -> int:
        ...
    def send_ioctl(self, fn: int, buf: void, poutbuf: void, poutsize: ssize_t) -> drc_t:
        ...
    def set_backwards(self, backwards: bool) -> drc_t:
        ...
    def set_exception_info(self, info: exception_info_t, qty: int) -> None:
        ...
    def set_resume_mode(self, tid: thid_t, resmod: resume_mode_t) -> drc_t:
        ...
    def start_process(self, path: str, args: str, envs: launch_env_t, startdir: str, dbg_proc_flags: int, input_path: str, input_file_crc32: int) -> drc_t:
        ...
    def supports_debthread(self) -> bool:
        ...
    def supports_lowcnds(self) -> bool:
        ...
    def suspended(self, dlls_added: bool, thr_names: thread_name_vec_t = None) -> None:
        ...
    def term_debugger(self) -> bool:
        ...
    def thread_continue(self, tid: thid_t) -> drc_t:
        ...
    def thread_get_sreg_base(self, answer: ea_t, tid: thid_t, sreg_value: int) -> drc_t:
        ...
    def thread_suspend(self, tid: thid_t) -> drc_t:
        ...
    def update_bpts(self, nbpts: int, bpts: update_bpt_info_t, nadd: int, ndel: int) -> drc_t:
        ...
    def update_call_stack(self, tid: thid_t, trace: call_stack_t) -> drc_t:
        ...
    def update_lowcnds(self, nupdated: int, lowcnds: lowcnd_t, nlowcnds: int) -> drc_t:
        ...
    def use_memregs(self) -> bool:
        ...
    def use_sregs(self) -> bool:
        ...
    def virtual_threads(self) -> bool:
        ...
    def write_file(self, fn: int, off: qoff64_t, buf: void) -> ssize_t:
        ...
    def write_memory(self, nbytes: size_t, ea: ida_idaapi.ea_t, buffer: void, size: size_t) -> drc_t:
        ...
    def write_register(self, tid: thid_t, regidx: int, value: regval_t) -> drc_t:
        ...

class direntry_t:
    BADIDX: int  # 18446744073709551615
    ROOTIDX: int  # 0
    @property
    def idx(self) -> Any: ...
    @property
    def isdir(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: direntry_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: direntry_t) -> bool:
        ...
    def __ne__(self, r: direntry_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def valid(self) -> bool:
        ...

class direntry_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: direntry_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> direntry_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: direntry_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: direntry_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: direntry_t) -> bool:
        ...
    def append(self, x: direntry_t) -> None:
        ...
    def at(self, _idx: size_t) -> direntry_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: direntry_vec_t) -> None:
        ...
    def extract(self) -> direntry_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: direntry_t) -> bool:
        ...
    def inject(self, s: direntry_t, len: size_t) -> None:
        ...
    def insert(self, it: direntry_t, x: direntry_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> direntry_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: direntry_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class dirspec_t:
    DSF_INODE_EA: int  # 1
    DSF_ORDERABLE: int  # 4
    DSF_PRIVRANGE: int  # 2
    @property
    def flags(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def nodename(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nm: str = None, f: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_attrs(self, inode: inode_t) -> str:
        ...
    def get_inode(self, dirpath: str, name: str) -> inode_t:
        r"""get the entry inode in the specified directory 
                
        :param dirpath: the absolute directory path with trailing slash
        :param name: the entry name in the directory
        :returns: the entry inode
        """
        ...
    def get_name(self, inode: inode_t, name_flags: int = 0) -> bool:
        r"""get the entry name. for example, the structure name 
                
        :param inode: inode number of the entry
        :param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
        :returns: false if the entry does not exist.
        """
        ...
    def is_orderable(self) -> bool:
        ...
    def rename_inode(self, inode: inode_t, newname: str) -> bool:
        r"""rename the entry 
                
        :returns: success
        """
        ...
    def unlink_inode(self, inode: inode_t) -> None:
        r"""event: unlinked an inode 
                
        """
        ...

class dirtree_cursor_t:
    @property
    def parent(self) -> Any: ...
    @property
    def rank(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __lt__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __ne__(self, r: dirtree_cursor_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: dirtree_cursor_t) -> int:
        ...
    def is_root_cursor(self) -> bool:
        ...
    def root_cursor(self) -> dirtree_cursor_t:
        ...
    def set_root_cursor(self) -> None:
        ...
    def valid(self) -> bool:
        ...

class dirtree_cursor_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: dirtree_cursor_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> dirtree_cursor_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: dirtree_cursor_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: dirtree_cursor_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: dirtree_cursor_t) -> bool:
        ...
    def append(self, x: dirtree_cursor_t) -> None:
        ...
    def at(self, _idx: size_t) -> dirtree_cursor_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: dirtree_cursor_vec_t) -> None:
        ...
    def extract(self) -> dirtree_cursor_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: dirtree_cursor_t) -> bool:
        ...
    def inject(self, s: dirtree_cursor_t, len: size_t) -> None:
        ...
    def insert(self, it: dirtree_cursor_t, x: dirtree_cursor_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> dirtree_cursor_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: dirtree_cursor_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class dirtree_iterator_t:
    @property
    def cursor(self) -> Any: ...
    @property
    def pattern(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dirtree_selection_t(dirtree_cursor_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: dirtree_cursor_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> dirtree_cursor_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: dirtree_cursor_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: dirtree_cursor_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: dirtree_cursor_t) -> bool:
        ...
    def append(self, x: dirtree_cursor_t) -> None:
        ...
    def at(self, _idx: size_t) -> dirtree_cursor_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: dirtree_cursor_vec_t) -> None:
        ...
    def extract(self) -> dirtree_cursor_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: dirtree_cursor_t) -> bool:
        ...
    def inject(self, s: dirtree_cursor_t, len: size_t) -> None:
        ...
    def insert(self, it: dirtree_cursor_t, x: dirtree_cursor_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> dirtree_cursor_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: dirtree_cursor_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class dirtree_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, ds: dirspec_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def change_rank(self, path: str, rank_delta: ssize_t) -> dterr_t:
        r"""Change ordering rank of an item. 
                
        :param path: path to the item
        :param rank_delta: the amount of the change. positive numbers mean to move down in the list; negative numbers mean to move up.
        :returns: dterr_t error code
        """
        ...
    def chdir(self, path: str) -> dterr_t:
        r"""Change current directory 
                
        :param path: new current directory
        :returns: dterr_t error code
        """
        ...
    def errstr(self, err: dterr_t) -> str:
        r"""Get textual representation of the error code.
        
        """
        ...
    def find_entry(self, de: direntry_t) -> dirtree_cursor_t:
        r"""Find the cursor corresponding to an entry of a directory 
                
        :param de: directory entry
        :returns: cursor corresponding to the directory entry
        """
        ...
    def findfirst(self, ff: dirtree_iterator_t, pattern: str) -> bool:
        r"""Start iterating over files in a directory 
                
        :param ff: directory iterator. it will be initialized by the function
        :param pattern: pattern to search for
        :returns: success
        """
        ...
    def findnext(self, ff: dirtree_iterator_t) -> bool:
        r"""Continue iterating over files in a directory 
                
        :param ff: directory iterator
        :returns: success
        """
        ...
    def get_abspath(self, args: Any) -> str:
        r"""This function has the following signatures:
        
            0. get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str
            1. get_abspath(relpath: str) -> str
        
        # 0: get_abspath(cursor: const dirtree_cursor_t &, name_flags: int=DTN_FULL_NAME) -> str
        
        Get absolute path pointed by the cursor 
                
        :returns: path; empty string if error
        
        # 1: get_abspath(relpath: str) -> str
        
        Construct an absolute path from the specified relative path. This function verifies the directory part of the specified path. The last component of the specified path is not verified. 
                
        :returns: path. empty path means wrong directory part of RELPATH
        
        """
        ...
    def get_dir_size(self, diridx: diridx_t) -> ssize_t:
        r"""Get dir size 
                
        :param diridx: directory index
        :returns: number of entries under this directory; if error, return -1
        """
        ...
    def get_entry_attrs(self, de: direntry_t) -> str:
        r"""Get entry attributes 
                
        :param de: directory entry
        :returns: name
        """
        ...
    def get_entry_name(self, de: direntry_t, name_flags: int = 0) -> str:
        r"""Get entry name 
                
        :param de: directory entry
        :param name_flags: how exactly the name should be retrieved. combination of bits for get_...name() methods bits
        :returns: name
        """
        ...
    def get_id(self) -> str:
        r"""netnode name
        
        """
        ...
    def get_nodename(self) -> str:
        r"""netnode name
        
        """
        ...
    def get_parent_cursor(self, cursor: dirtree_cursor_t) -> dirtree_cursor_t:
        r"""Get parent cursor. 
                
        :param cursor: a valid ditree cursor
        :returns: cursor's parent
        """
        ...
    def get_rank(self, diridx: diridx_t, de: direntry_t) -> ssize_t:
        r"""Get ordering rank of an item. 
                
        :param diridx: index of the parent directory
        :param de: directory entry
        :returns: number in a range of [0..n) where n is the number of entries in the parent directory. -1 if error
        """
        ...
    def getcwd(self) -> str:
        r"""Get current directory 
                
        :returns: the current working directory
        """
        ...
    def is_dir_ordered(self, diridx: diridx_t) -> bool:
        r"""Is dir ordered? 
                
        :returns: true if the dirtree has natural ordering
        """
        ...
    def is_orderable(self) -> bool:
        r"""Is dirtree orderable? 
                
        :returns: true if the dirtree is orderable
        """
        ...
    def isdir(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. isdir(path: str) -> bool
            1. isdir(de: const direntry_t &) -> bool
        
        # 0: isdir(path: str) -> bool
        
        Is a directory? 
                
        :returns: true if the specified path is a directory
        
        # 1: isdir(de: const direntry_t &) -> bool
        
        
        """
        ...
    def isfile(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. isfile(path: str) -> bool
            1. isfile(de: const direntry_t &) -> bool
        
        # 0: isfile(path: str) -> bool
        
        Is a file? 
                
        :returns: true if the specified path is a file
        
        # 1: isfile(de: const direntry_t &) -> bool
        
        
        """
        ...
    def link(self, args: Any) -> dterr_t:
        r"""This function has the following signatures:
        
            0. link(path: str) -> dterr_t
            1. link(inode: inode_t) -> dterr_t
        
        # 0: link(path: str) -> dterr_t
        
        Add a file item into a directory. 
                
        :returns: dterr_t error code
        
        # 1: link(inode: inode_t) -> dterr_t
        
        Add an inode into the current directory 
                
        :returns: dterr_t error code
        
        """
        ...
    def load(self) -> bool:
        r"""Load the tree structure from the netnode. If dirspec_t::id is empty, the operation will be considered a success. In addition, calling load() more than once will not do anything, and will be considered a success. 
                
        :returns: success
        """
        ...
    def mkdir(self, path: str) -> dterr_t:
        r"""Create a directory. 
                
        :param path: directory to create
        :returns: dterr_t error code
        """
        ...
    def notify_dirtree(self, added: bool, inode: inode_t) -> None:
        r"""Notify dirtree about a change of an inode. 
                
        :param added: are we adding or deleting an inode?
        :param inode: inode in question
        """
        ...
    def rename(self, _from: str, to: str) -> dterr_t:
        r"""Rename a directory entry. 
                
        :param to: destination path
        :returns: dterr_t error code
        """
        ...
    def resolve_cursor(self, cursor: dirtree_cursor_t) -> direntry_t:
        r"""Resolve cursor 
                
        :param cursor: to analyze
        :returns: directory entry; if the cursor is bad, the resolved entry will be invalid.
        """
        ...
    def resolve_path(self, path: str) -> direntry_t:
        r"""Resolve path 
                
        :param path: to analyze
        :returns: directory entry
        """
        ...
    def rmdir(self, path: str) -> dterr_t:
        r"""Remove a directory. 
                
        :param path: directory to delete
        :returns: dterr_t error code
        """
        ...
    def save(self) -> bool:
        r"""Save the tree structure to the netnode. 
                
        :returns: success
        """
        ...
    def set_id(self, nm: str) -> None:
        ...
    def set_natural_order(self, diridx: diridx_t, enable: bool) -> bool:
        r"""Enable/disable natural inode order in a directory. 
                
        :param diridx: directory index
        :param enable: action to do TRUE - enable ordering: re-order existing entries so that all subdirs are at the to beginning of the list, file entries are sorted and placed after the subdirs FALSE - disable ordering, no changes to existing entries
        :returns: SUCCESS
        """
        ...
    def set_nodename(self, nm: str) -> None:
        ...
    def traverse(self, v: dirtree_visitor_t) -> ssize_t:
        r"""Traverse dirtree, and be notified at each entry If the the visitor returns anything other than 0, iteration will stop, and that value returned. The tree is traversed using a depth-first algorithm. It is forbidden to modify the dirtree_t during traversal; doing so will result in undefined behavior. 
                
        :param v: the callback
        :returns: 0, or whatever the visitor returned
        """
        ...
    def unlink(self, args: Any) -> dterr_t:
        r"""This function has the following signatures:
        
            0. unlink(path: str) -> dterr_t
            1. unlink(inode: inode_t) -> dterr_t
        
        # 0: unlink(path: str) -> dterr_t
        
        Remove a file item from a directory. 
                
        :returns: dterr_t error code
        
        # 1: unlink(inode: inode_t) -> dterr_t
        
        Remove an inode from the current directory 
                
        :returns: dterr_t error code
        
        """
        ...

class dirtree_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit(self, c: dirtree_cursor_t, de: direntry_t) -> ssize_t:
        r"""Will be called for each entry in the dirtree_t If something other than 0 is returned, iteration will stop. 
                
        :param c: the current cursor
        :param de: the current entry
        :returns: 0 to keep iterating, or anything else to stop
        """
        ...

class disabled_script_timeout_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __enter__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __exit__(self, type: Any, value: Any, tb: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class disasm_line_t:
    @property
    def at(self) -> Any: ...
    @property
    def bg_color(self) -> Any: ...
    @property
    def is_default(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def prefix_color(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class disasm_text_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> disasm_line_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: disasm_line_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: disasm_line_t) -> None:
        ...
    def at(self, _idx: size_t) -> disasm_line_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: disasm_text_t) -> None:
        ...
    def extract(self) -> disasm_line_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: disasm_line_t, len: size_t) -> None:
        ...
    def insert(self, it: disasm_line_t, x: disasm_line_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> disasm_line_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: disasm_text_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class drawable_graph_t(gdl_graph_t):
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_tree_layout(self) -> bool:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class dyn_ea_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: int, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dyn_range_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: range_t, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dyn_regarg_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> regarg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: regarg_t, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: regarg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dyn_register_info_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> register_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: register_info_t, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: register_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dyn_regvar_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> regvar_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: regvar_t, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: regvar_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class dyn_stkpnt_array:
    @property
    def count(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> stkpnt_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _data: stkpnt_t, _count: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: stkpnt_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ea32_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: ea32_t) -> None:
        ...
    def cast(self) -> ea32_t:
        ...
    def frompointer(self, t: ea32_t) -> ea32_pointer:
        ...
    def value(self) -> ea32_t:
        ...

class ea64_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: ea64_t) -> None:
        ...
    def cast(self) -> ea64_t:
        ...
    def frompointer(self, t: ea64_t) -> ea64_pointer:
        ...
    def value(self) -> ea64_t:
        ...

class ea_array:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: size_t) -> ida_idaapi.ea_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nelements: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, index: size_t, value: ida_idaapi.ea_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cast(self) -> int:
        ...
    def frompointer(self, t: ea_t) -> ea_array:
        ...

class ea_name_t:
    @property
    def ea(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ea_name_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ea_name_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ea_name_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: ea_name_t) -> None:
        ...
    def at(self, _idx: size_t) -> ea_name_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: ea_name_vec_t) -> None:
        ...
    def extract(self) -> ea_name_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: ea_name_t, len: size_t) -> None:
        ...
    def insert(self, it: ea_name_t, x: ea_name_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ea_name_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: ea_name_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ea_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: ida_idaapi.ea_t) -> None:
        ...
    def cast(self) -> int:
        ...
    def frompointer(self, t: ea_t) -> ea_pointer:
        ...
    def value(self) -> ida_idaapi.ea_t:
        ...

class ea_t:
    r"""int([x]) -> integer
    int(x, base=10) -> integer
    
    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating-point
    numbers, this truncates towards zero.
    
    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
    """
    denominator: getset_descriptor  # <attribute 'denominator' of 'int' objects>
    imag: getset_descriptor  # <attribute 'imag' of 'int' objects>
    numerator: getset_descriptor  # <attribute 'numerator' of 'int' objects>
    real: getset_descriptor  # <attribute 'real' of 'int' objects>
    def __abs__(self) -> Any:
        r"""abs(self)"""
        ...
    def __add__(self, value: Any) -> Any:
        r"""Return self+value."""
        ...
    def __and__(self, value: Any) -> Any:
        r"""Return self&value."""
        ...
    def __bool__(self) -> Any:
        r"""True if self else False"""
        ...
    def __ceil__(self) -> Any:
        r"""Ceiling of an Integral returns itself."""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __divmod__(self, value: Any) -> Any:
        r"""Return divmod(self, value)."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __float__(self) -> Any:
        r"""float(self)"""
        ...
    def __floor__(self) -> Any:
        r"""Flooring an Integral returns itself."""
        ...
    def __floordiv__(self, value: Any) -> Any:
        r"""Return self//value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Convert to a string according to format_spec."""
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getnewargs__(self) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __index__(self) -> Any:
        r"""Return self converted to an integer, if self is suitable for use as an index into a list."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __int__(self) -> Any:
        r"""int(self)"""
        ...
    def __invert__(self) -> Any:
        r"""~self"""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lshift__(self, value: Any) -> Any:
        r"""Return self<<value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __mod__(self, value: Any) -> Any:
        r"""Return self%value."""
        ...
    def __mul__(self, value: Any) -> Any:
        r"""Return self*value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __neg__(self) -> Any:
        r"""-self"""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __or__(self, value: Any) -> Any:
        r"""Return self|value."""
        ...
    def __pos__(self) -> Any:
        r"""+self"""
        ...
    def __pow__(self, value: Any, mod: Any = None) -> Any:
        r"""Return pow(self, value, mod)."""
        ...
    def __radd__(self, value: Any) -> Any:
        r"""Return value+self."""
        ...
    def __rand__(self, value: Any) -> Any:
        r"""Return value&self."""
        ...
    def __rdivmod__(self, value: Any) -> Any:
        r"""Return divmod(value, self)."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __rfloordiv__(self, value: Any) -> Any:
        r"""Return value//self."""
        ...
    def __rlshift__(self, value: Any) -> Any:
        r"""Return value<<self."""
        ...
    def __rmod__(self, value: Any) -> Any:
        r"""Return value%self."""
        ...
    def __rmul__(self, value: Any) -> Any:
        r"""Return value*self."""
        ...
    def __ror__(self, value: Any) -> Any:
        r"""Return value|self."""
        ...
    def __round__(self, *args: Any, **kwargs: Any) -> Any:
        r"""Rounding an Integral returns itself.
        
        Rounding with an ndigits argument also returns an integer.
        """
        ...
    def __rpow__(self, value: Any, mod: Any = None) -> Any:
        r"""Return pow(value, self, mod)."""
        ...
    def __rrshift__(self, value: Any) -> Any:
        r"""Return value>>self."""
        ...
    def __rshift__(self, value: Any) -> Any:
        r"""Return self>>value."""
        ...
    def __rsub__(self, value: Any) -> Any:
        r"""Return value-self."""
        ...
    def __rtruediv__(self, value: Any) -> Any:
        r"""Return value/self."""
        ...
    def __rxor__(self, value: Any) -> Any:
        r"""Return value^self."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Returns size in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __sub__(self, value: Any) -> Any:
        r"""Return self-value."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __truediv__(self, value: Any) -> Any:
        r"""Return self/value."""
        ...
    def __trunc__(self) -> Any:
        r"""Truncating an Integral returns itself."""
        ...
    def __xor__(self, value: Any) -> Any:
        r"""Return self^value."""
        ...
    def as_integer_ratio(self) -> Any:
        r"""Return a pair of integers, whose ratio is equal to the original int.
        
        The ratio is in lowest terms and has a positive denominator.
        
        >>> (10).as_integer_ratio()
        (10, 1)
        >>> (-10).as_integer_ratio()
        (-10, 1)
        >>> (0).as_integer_ratio()
        (0, 1)
        """
        ...
    def bit_count(self) -> Any:
        r"""Number of ones in the binary representation of the absolute value of self.
        
        Also known as the population count.
        
        >>> bin(13)
        '0b1101'
        >>> (13).bit_count()
        3
        """
        ...
    def bit_length(self) -> Any:
        r"""Number of bits necessary to represent self in binary.
        
        >>> bin(37)
        '0b100101'
        >>> (37).bit_length()
        6
        """
        ...
    def conjugate(self) -> Any:
        r"""Returns self, the complex conjugate of any int."""
        ...
    def from_bytes(self, bytes: Any, byteorder: Any = 'big', signed: Any = False) -> Any:
        r"""Return the integer represented by the given array of bytes.
        
          bytes
            Holds the array of bytes to convert.  The argument must either
            support the buffer protocol or be an iterable object producing bytes.
            Bytes and bytearray are examples of built-in objects that support the
            buffer protocol.
          byteorder
            The byte order used to represent the integer.  If byteorder is 'big',
            the most significant byte is at the beginning of the byte array.  If
            byteorder is 'little', the most significant byte is at the end of the
            byte array.  To request the native byte order of the host system, use
            sys.byteorder as the byte order value.  Default is to use 'big'.
          signed
            Indicates whether two's complement is used to represent the integer.
        """
        ...
    def is_integer(self) -> Any:
        r"""Returns True. Exists for duck type compatibility with float.is_integer."""
        ...
    def to_bytes(self, length: Any = 1, byteorder: Any = 'big', signed: Any = False) -> Any:
        r"""Return an array of bytes representing an integer.
        
          length
            Length of bytes object to use.  An OverflowError is raised if the
            integer is not representable with the given number of bytes.  Default
            is length 1.
          byteorder
            The byte order used to represent the integer.  If byteorder is 'big',
            the most significant byte is at the beginning of the byte array.  If
            byteorder is 'little', the most significant byte is at the end of the
            byte array.  To request the native byte order of the host system, use
            sys.byteorder as the byte order value.  Default is to use 'big'.
          signed
            Determines whether two's complement is used to represent the integer.
            If signed is False and a negative integer is given, an OverflowError
            is raised.
        """
        ...

class eamap_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: eamap_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: eamap_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class eamap_t:
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: int) -> cinsnptrvec_t:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def keytype(self, *args: Any, **kwargs: Any) -> Any:
        r"""int([x]) -> integer
        int(x, base=10) -> integer
        
        Convert a number or string to an integer, or return 0 if no arguments
        are given.  If x is a number, return x.__int__().  For floating-point
        numbers, this truncates towards zero.
        
        If x is not a number or if base is given, then x must be a string,
        bytes, or bytearray instance representing an integer literal in the
        given base.  The literal can be preceded by '+' or '-' and be surrounded
        by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
        Base 0 means to interpret the base from the string as an integer literal.
        >>> int('0b100', base=0)
        4
        """
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, args: Any) -> Any:
        ...

class eavec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: uint64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: uint64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uint64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uint64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class edge_info_t:
    @property
    def color(self) -> Any: ...
    @property
    def dstoff(self) -> Any: ...
    @property
    def layout(self) -> Any: ...
    @property
    def srcoff(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def reverse_layout(self) -> None:
        ...

class edge_infos_wrapper_t:
    @property
    def ptr(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def clear(self) -> None:
        ...

class edge_layout_point_t:
    @property
    def e(self) -> Any: ...
    @property
    def pidx(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edge_layout_point_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edge_layout_point_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: edge_layout_point_t) -> int:
        ...

class edge_segment_t:
    @property
    def e(self) -> Any: ...
    @property
    def nseg(self) -> Any: ...
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: edge_segment_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def length(self) -> int:
        ...
    def toright(self) -> bool:
        ...

class edge_t:
    @property
    def dst(self) -> Any: ...
    @property
    def src(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, y: edge_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, x: int = 0, y: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, y: edge_t) -> bool:
        ...
    def __ne__(self, y: edge_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class edgevec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class edm_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edm_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        r"""Create an enumerator, with the specified name and value
        
        This constructor has the following signatures:
        
            1. edm_t(edm: edm_t)
            2. edm_t(name: str, value: int, cmt: str=None)
        
        :param name:  Enumerator name. Must not be empty (1st form)
        :param value: Enumerator value (1st form)
        :param cmt:   Enumerator repeatable comment. May be empty (1st form)
        :param edm:   An enum member to copy
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edm_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def empty(self) -> bool:
        ...
    def get_tid(self) -> tid_t:
        ...
    def swap(self, r: edm_t) -> None:
        ...

class edmvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edmvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> edm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edmvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: edm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: edm_t) -> bool:
        ...
    def append(self, x: edm_t) -> None:
        ...
    def at(self, _idx: size_t) -> edm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: edmvec_t) -> None:
        ...
    def extract(self) -> edm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: edm_t) -> bool:
        ...
    def inject(self, s: edm_t, len: size_t) -> None:
        ...
    def insert(self, it: edm_t, x: edm_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> edm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: edmvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class enum_const_t:
    @property
    def serial(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class enum_member_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edm_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        r"""Create an enumerator, with the specified name and value
        
        This constructor has the following signatures:
        
            1. edm_t(edm: edm_t)
            2. edm_t(name: str, value: int, cmt: str=None)
        
        :param name:  Enumerator name. Must not be empty (1st form)
        :param value: Enumerator value (1st form)
        :param cmt:   Enumerator repeatable comment. May be empty (1st form)
        :param edm:   An enum member to copy
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edm_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def empty(self) -> bool:
        ...
    def get_tid(self) -> tid_t:
        ...
    def swap(self, r: edm_t) -> None:
        ...

class enum_member_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edmvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> edm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edmvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: edm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: edm_t) -> bool:
        ...
    def append(self, x: edm_t) -> None:
        ...
    def at(self, _idx: size_t) -> edm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: edmvec_t) -> None:
        ...
    def extract(self) -> edm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: edm_t) -> bool:
        ...
    def inject(self, s: edm_t, len: size_t) -> None:
        ...
    def insert(self, it: edm_t, x: edm_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> edm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: edmvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class enum_type_data_t(edmvec_t):
    @property
    def bte(self) -> Any: ...
    @property
    def group_sizes(self) -> Any: ...
    @property
    def taenum_bits(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: edmvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> edm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: edmvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: edm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_constant(self, name: str, value: uint64, cmt: str = None) -> None:
        r"""add constant for regular enum
        
        """
        ...
    def add_unique(self, x: edm_t) -> bool:
        ...
    def all_constants(self) -> Any:
        r"""
        Generate tupples of all constants except of bitmasks.
        Each tupple is:
        [0] constant index
        [1] enum member index of group start
        [2] group size
        In case of regular enum the second element of tupple is 0 and the third element of tupple is the number of enum members.
        
        """
        ...
    def all_groups(self, skip_trivial: Any = False) -> Any:
        r"""
        Generate tuples for bitmask enum groups.
        Each tupple is:
        [0] enum member index of group start
        [1] group size
        Tupples may include or not the group with 1 element.
        
        """
        ...
    def append(self, x: edm_t) -> None:
        ...
    def at(self, _idx: size_t) -> edm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def calc_mask(self) -> uint64:
        ...
    def calc_nbytes(self) -> int:
        r"""get the width of enum in bytes
        
        """
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: edmvec_t) -> None:
        ...
    def extract(self) -> edm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def find_member(self, args: Any) -> ssize_t:
        r"""This function has the following signatures:
        
            0. find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t
            1. find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t
        
        # 0: find_member(name: str, from: size_t=0, to: size_t=size_t(-1)) -> ssize_t
        
        find member (constant or bmask) by name
        
        
        # 1: find_member(value: uint64, serial: uchar, from: size_t=0, to: size_t=size_t(-1), vmask: uint64=uint64(-1)) -> ssize_t
        
        find member (constant or bmask) by value
        
        
        """
        ...
    def front(self) -> Any:
        ...
    def get_constant_group(self, args: Any) -> Any:
        r"""get group parameters for the constant, valid for bitmask enum 
                
        :param group_start_index: index of the group mask
        :param group_size: group size (>=1)
        :param idx: constant index
        :returns: success
        """
        ...
    def get_enum_radix(self) -> int:
        r"""Get enum constant radix 
                
        :returns: radix or 1 for BTE_CHAR
        """
        ...
    def get_max_serial(self, value: uint64) -> uchar:
        r"""return the maximum serial for the value
        
        """
        ...
    def get_serial(self, index: size_t) -> uchar:
        r"""returns serial for the constant
        
        """
        ...
    def get_value_repr(self, repr: value_repr_t) -> tinfo_code_t:
        r"""get enum radix and other representation info 
                
        :param repr: value display info
        """
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: edm_t) -> bool:
        ...
    def has_lzero(self) -> bool:
        ...
    def inject(self, s: edm_t, len: size_t) -> None:
        ...
    def insert(self, it: edm_t, x: edm_t) -> iterator:
        ...
    def is_bf(self) -> bool:
        r"""is bitmask or ordinary enum?
        
        """
        ...
    def is_bin(self) -> bool:
        ...
    def is_char(self) -> bool:
        ...
    def is_dec(self) -> bool:
        ...
    def is_group_mask_at(self, idx: size_t) -> bool:
        r"""is the enum member at IDX a non-trivial group mask? a trivial group consist of one bit and has just one member, which can be considered as a mask or a bitfield constant 
                
        :param idx: index
        :returns: success
        """
        ...
    def is_hex(self) -> bool:
        ...
    def is_number_signed(self) -> bool:
        ...
    def is_oct(self) -> bool:
        ...
    def is_sbin(self) -> bool:
        ...
    def is_shex(self) -> bool:
        ...
    def is_soct(self) -> bool:
        ...
    def is_udec(self) -> bool:
        ...
    def is_valid_group_sizes(self) -> bool:
        r"""is valid group sizes
        
        """
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> edm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def set_enum_radix(self, radix: int, sign: bool) -> None:
        r"""Set radix to display constants 
                
        :param radix: radix with the special case 1 to display as character
        """
        ...
    def set_lzero(self, on: bool) -> None:
        ...
    def set_nbytes(self, nbytes: int) -> bool:
        r"""set enum width (nbytes)
        
        """
        ...
    def set_value_repr(self, repr: value_repr_t) -> tinfo_code_t:
        r"""set enum radix and other representation info 
                
        :param repr: value display info
        """
        ...
    def size(self) -> int:
        ...
    def store_64bit_values(self) -> bool:
        ...
    def swap(self, r: enum_type_data_t) -> None:
        r"""swap two instances
        
        """
        ...
    def truncate(self) -> None:
        ...

class eval_ctx_t:
    @property
    def ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _ea: ida_idaapi.ea_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class exception_info_t:
    @property
    def code(self) -> Any: ...
    @property
    def desc(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def break_on(self) -> bool:
        r"""Should we break on the exception?
        
        """
        ...
    def handle(self) -> bool:
        r"""Should we handle the exception?
        
        """
        ...

class excinfo_t:
    @property
    def can_cont(self) -> Any: ...
    @property
    def code(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def info(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class excvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> exception_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: exception_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: exception_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> exception_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: excvec_t) -> None:
        ...
    def extract(self) -> exception_info_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: exception_info_t, len: size_t) -> None:
        ...
    def insert(self, it: exception_info_t, x: exception_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> exception_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: excvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class file_enumerator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_file(self, file: str) -> int:
        ...

class fixup_data_t:
    @property
    def displacement(self) -> Any: ...
    @property
    def off(self) -> Any: ...
    @property
    def sel(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def calc_size(self) -> int:
        r"""calc_fixup_size()
        
        """
        ...
    def clr_extdef(self) -> None:
        ...
    def clr_unused(self) -> None:
        ...
    def get(self, source: ida_idaapi.ea_t) -> bool:
        r"""get_fixup()
        
        """
        ...
    def get_base(self) -> ida_idaapi.ea_t:
        r"""Get base of fixup. 
                
        """
        ...
    def get_desc(self, source: ida_idaapi.ea_t) -> str:
        r"""get_fixup_desc()
        
        """
        ...
    def get_flags(self) -> int:
        r"""Fixup flags Fixup flags.
        
        """
        ...
    def get_handler(self) -> fixup_handler_t:
        r"""get_fixup_handler()
        
        """
        ...
    def get_type(self) -> fixup_type_t:
        r"""Fixup type Types of fixups.
        
        """
        ...
    def get_value(self, ea: ida_idaapi.ea_t) -> int:
        r"""get_fixup_value()
        
        """
        ...
    def has_base(self) -> bool:
        r"""Is fixup relative?
        
        """
        ...
    def is_custom(self) -> bool:
        r"""is_fixup_custom()
        
        """
        ...
    def is_extdef(self) -> bool:
        ...
    def is_unused(self) -> bool:
        ...
    def patch_value(self, ea: ida_idaapi.ea_t) -> bool:
        r"""patch_fixup_value()
        
        """
        ...
    def set(self, source: ida_idaapi.ea_t) -> None:
        r"""set_fixup()
        
        """
        ...
    def set_base(self, new_base: ida_idaapi.ea_t) -> None:
        r"""Set base of fixup. The target should be set before a call of this function. 
                
        """
        ...
    def set_extdef(self) -> None:
        ...
    def set_sel(self, seg: segment_t) -> None:
        ...
    def set_target_sel(self) -> None:
        r"""Set selector of fixup to the target. The target should be set before a call of this function. 
                
        """
        ...
    def set_type(self, type_: fixup_type_t) -> None:
        ...
    def set_type_and_flags(self, type_: fixup_type_t, flags_: int = 0) -> None:
        ...
    def set_unused(self) -> None:
        ...
    def was_created(self) -> bool:
        r"""Is fixup artificial?
        
        """
        ...

class fixup_info_t:
    @property
    def ea(self) -> Any: ...
    @property
    def fd(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class flags64_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: flags64_t) -> None:
        ...
    def cast(self) -> flags64_t:
        ...
    def frompointer(self, t: flags64_t) -> flags64_pointer:
        ...
    def value(self) -> flags64_t:
        ...

class flags_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: flags_t) -> None:
        ...
    def cast(self) -> flags_t:
        ...
    def frompointer(self, t: flags_t) -> flags_pointer:
        ...
    def value(self) -> flags_t:
        ...

class fnumber_t:
    @property
    def fnum(self) -> Any: ...
    @property
    def nbytes(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: fnumber_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: fnumber_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: fnumber_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: fnumber_t) -> bool:
        ...
    def __lt__(self, r: fnumber_t) -> bool:
        ...
    def __ne__(self, r: fnumber_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def calc_max_exp(self) -> int:
        ...
    def compare(self, r: fnumber_t) -> int:
        ...
    def dereference_const_uint16(self) -> uint16:
        ...
    def dereference_uint16(self) -> uint16:
        ...
    def is_nan(self) -> bool:
        ...

class fpvalue_shorts_array_t:
    @property
    def bytes(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, data: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class fpvalue_t:
    @property
    def bytes(self) -> Any: ...
    @property
    def float(self) -> Any: ...
    @property
    def int64(self) -> Any: ...
    @property
    def shorts(self) -> Any: ...
    @property
    def sval(self) -> Any: ...
    @property
    def uint64(self) -> Any: ...
    @property
    def w(self) -> Any: ...
    def __add__(self, o: fpvalue_t) -> fpvalue_t:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: fpvalue_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: fpvalue_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: Any) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: fpvalue_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, r: fpvalue_t) -> bool:
        ...
    def __lt__(self, r: fpvalue_t) -> bool:
        ...
    def __mul__(self, o: fpvalue_t) -> fpvalue_t:
        ...
    def __ne__(self, r: fpvalue_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: Any, v: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, o: fpvalue_t) -> fpvalue_t:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def __truediv__(self, o: fpvalue_t) -> fpvalue_t:
        ...
    def assign(self, r: fpvalue_t) -> None:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: fpvalue_t) -> int:
        ...
    def copy(self) -> fpvalue_t:
        ...
    def eabs(self) -> None:
        r"""Calculate absolute value.
        
        """
        ...
    def fadd(self, y: fpvalue_t) -> fpvalue_error_t:
        r"""Arithmetic operations.
        
        """
        ...
    def fdiv(self, y: fpvalue_t) -> fpvalue_error_t:
        ...
    def fmul(self, y: fpvalue_t) -> fpvalue_error_t:
        ...
    def from_10bytes(self, fpval: void) -> fpvalue_error_t:
        r"""Conversions for 10-byte floating point values.
        
        """
        ...
    def from_12bytes(self, fpval: void) -> fpvalue_error_t:
        r"""Conversions for 12-byte floating point values.
        
        """
        ...
    def from_int64(self, x: int64) -> None:
        ...
    def from_str(self, p: str) -> fpvalue_error_t:
        r"""Convert string to IEEE. 
                
        """
        ...
    def from_sval(self, x: int) -> None:
        r"""Convert integer to IEEE.
        
        """
        ...
    def from_uint64(self, x: uint64) -> None:
        ...
    def fsub(self, y: fpvalue_t) -> fpvalue_error_t:
        ...
    def get_kind(self) -> fpvalue_kind_t:
        r"""Get value kind.
        
        """
        ...
    def is_negative(self) -> bool:
        r"""Is negative value?
        
        """
        ...
    def mul_pow2(self, power_of_2: int) -> fpvalue_error_t:
        r"""Multiply by a power of 2.
        
        """
        ...
    def negate(self) -> None:
        r"""Negate.
        
        """
        ...
    def new_from_str(self, p: str) -> fpvalue_t:
        ...
    def to_10bytes(self, fpval: void) -> fpvalue_error_t:
        ...
    def to_12bytes(self, fpval: void) -> fpvalue_error_t:
        ...
    def to_int64(self, round: bool = False) -> fpvalue_error_t:
        ...
    def to_str(self, args: Any) -> None:
        r"""Convert IEEE to string. 
                
        :param buf: the output buffer
        :param bufsize: the size of the output buffer
        :param mode: broken down into:
        * low byte: number of digits after '.'
        * second byte: FPNUM_LENGTH
        * third byte: FPNUM_DIGITS
        """
        ...
    def to_sval(self, round: bool = False) -> fpvalue_error_t:
        r"""Convert IEEE to integer (+-0.5 if round)
        
        """
        ...
    def to_uint64(self, round: bool = False) -> fpvalue_error_t:
        ...

class func_item_iterator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""
        Provide an iterator on code items
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next__(self, func: testf_t) -> bool:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def addresses(self) -> Any:
        r"""
        Provide an iterator on addresses contained within the function
        
        """
        ...
    def chunk(self) -> range_t:
        ...
    def code_items(self) -> Any:
        r"""
        Provide an iterator on code items contained within the function
        
        """
        ...
    def current(self) -> ida_idaapi.ea_t:
        ...
    def data_items(self) -> Any:
        r"""
        Provide an iterator on data items contained within the function
        
        """
        ...
    def decode_preceding_insn(self, visited: eavec_t, p_farref: bool, out: insn_t) -> bool:
        ...
    def decode_prev_insn(self, out: insn_t) -> bool:
        ...
    def first(self) -> bool:
        ...
    def head_items(self) -> Any:
        r"""
        Provide an iterator on item heads contained within the function
        
        """
        ...
    def last(self) -> bool:
        ...
    def next(self, func: testf_t) -> bool:
        ...
    def next_addr(self) -> bool:
        ...
    def next_code(self) -> bool:
        ...
    def next_data(self) -> bool:
        ...
    def next_head(self) -> bool:
        ...
    def next_not_tail(self) -> bool:
        ...
    def not_tails(self) -> Any:
        r"""
        Provide an iterator on non-tail addresses contained within the function
        
        """
        ...
    def prev(self, func: testf_t) -> bool:
        ...
    def prev_addr(self) -> bool:
        ...
    def prev_code(self) -> bool:
        ...
    def prev_data(self) -> bool:
        ...
    def prev_head(self) -> bool:
        ...
    def prev_not_tail(self) -> bool:
        ...
    def set(self, args: Any) -> bool:
        r"""Set a function range. if pfn == nullptr then a segment range will be set.
        
        """
        ...
    def set_ea(self, _ea: ida_idaapi.ea_t) -> bool:
        ...
    def set_range(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool:
        r"""Set an arbitrary range.
        
        """
        ...
    def succ(self, func: testf_t) -> bool:
        r"""Similar to next(), but succ() iterates the chunks from low to high addresses, while next() iterates through chunks starting at the function entry chunk 
                
        """
        ...
    def succ_code(self) -> bool:
        ...

class func_parent_iterator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""
        Provide an iterator on function parents
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next__(self) -> bool:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def first(self) -> bool:
        ...
    def last(self) -> bool:
        ...
    def next(self) -> bool:
        ...
    def parent(self) -> ida_idaapi.ea_t:
        ...
    def prev(self) -> bool:
        ...
    def reset_fnt(self, _fnt: func_t) -> None:
        ...
    def set(self, _fnt: func_t) -> bool:
        ...

class func_t(range_t):
    @property
    def argsize(self) -> Any: ...
    @property
    def color(self) -> Any: ...
    @property
    def end_ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def fpd(self) -> Any: ...
    @property
    def frame(self) -> Any: ...
    @property
    def frame_object(self) -> Any: ...
    @property
    def frregs(self) -> Any: ...
    @property
    def frsize(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def owner(self) -> Any: ...
    @property
    def pntqty(self) -> Any: ...
    @property
    def points(self) -> Any: ...
    @property
    def prototype(self) -> Any: ...
    @property
    def referers(self) -> Any: ...
    @property
    def refqty(self) -> Any: ...
    @property
    def regargqty(self) -> Any: ...
    @property
    def regargs(self) -> Any: ...
    @property
    def regvarqty(self) -> Any: ...
    @property
    def regvars(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def tailqty(self) -> Any: ...
    @property
    def tails(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __get_points__(self) -> dynamic_wrapped_array_t:
        ...
    def __get_referers__(self) -> dynamic_wrapped_array_t:
        ...
    def __get_regargs__(self) -> dynamic_wrapped_array_t:
        ...
    def __get_regvars__(self) -> dynamic_wrapped_array_t:
        ...
    def __get_tails__(self) -> dynamic_wrapped_array_t:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self, start: ida_idaapi.ea_t = 0, end: ida_idaapi.ea_t = 0, f: flags64_t = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).__iter__()
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def addresses(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).addresses()
        
        """
        ...
    def analyzed_sp(self) -> bool:
        r"""Has SP-analysis been performed?
        
        """
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def code_items(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).code_items()
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def data_items(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).data_items()
        
        """
        ...
    def does_return(self) -> bool:
        r"""Does function return?
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def get_frame_object(self) -> Any:
        r"""Retrieve the function frame, in the form of a structure
        where frame offsets that are accessed by the program, as well
        as areas for "saved registers" and "return address", are
        represented by structure members.
        
        If the function has no associated frame, return None
        
        :returns: a ida_typeinf.tinfo_t object representing the frame, or None
        """
        ...
    def get_name(self) -> Any:
        r"""Get the function name
        
        :returns: the function name
        """
        ...
    def get_prototype(self) -> Any:
        r"""Retrieve the function prototype.
        
        Once you have obtained the prototype, you can:
        
        * retrieve the return type through ida_typeinf.tinfo_t.get_rettype()
        * iterate on the arguments using ida_typeinf.tinfo_t.iter_func()
        
        If the function has no associated prototype, return None
        
        :returns: a ida_typeinf.tinfo_t object representing the prototype, or None
        """
        ...
    def head_items(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).head_items()
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def is_far(self) -> bool:
        r"""Is a far function?
        
        """
        ...
    def need_prolog_analysis(self) -> bool:
        r"""Needs prolog analysis?
        
        """
        ...
    def not_tails(self) -> Any:
        r"""
        Alias for func_item_iterator_t(self).not_tails()
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class func_tail_iterator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""
        Provide an iterator on function tails
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next__(self) -> bool:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def chunk(self) -> range_t:
        ...
    def first(self) -> bool:
        ...
    def last(self) -> bool:
        ...
    def main(self) -> bool:
        ...
    def next(self) -> bool:
        ...
    def prev(self) -> bool:
        ...
    def set(self, args: Any) -> bool:
        ...
    def set_ea(self, ea: ida_idaapi.ea_t) -> bool:
        ...
    def set_range(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool:
        ...

class func_type_data_t(funcargvec_t):
    @property
    def flags(self) -> Any: ...
    @property
    def retloc(self) -> Any: ...
    @property
    def rettype(self) -> Any: ...
    @property
    def spoiled(self) -> Any: ...
    @property
    def stkargs(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: funcargvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> funcarg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: funcargvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: funcarg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: funcarg_t) -> bool:
        ...
    def append(self, x: funcarg_t) -> None:
        ...
    def at(self, _idx: size_t) -> funcarg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def dump(self, praloc_bits: int = 2) -> bool:
        r"""Dump information that is not always visible in the function prototype. (argument locations, return location, total stkarg size) 
                
        """
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: funcargvec_t) -> None:
        ...
    def extract(self) -> funcarg_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def find_argument(self, args: Any) -> ssize_t:
        r"""find argument by name
        
        """
        ...
    def front(self) -> Any:
        ...
    def get_call_method(self) -> int:
        ...
    def get_explicit_cc(self) -> callcnv_t:
        ...
    def grow(self, args: Any) -> None:
        ...
    def guess_cc(self, purged: int, cc_flags: int) -> callcnv_t:
        r"""Guess function calling convention use the following info: argument locations and 'stkargs' 
                
        """
        ...
    def has(self, x: funcarg_t) -> bool:
        ...
    def inject(self, s: funcarg_t, len: size_t) -> None:
        ...
    def insert(self, it: funcarg_t, x: funcarg_t) -> iterator:
        ...
    def is_const(self) -> bool:
        ...
    def is_ctor(self) -> bool:
        ...
    def is_dtor(self) -> bool:
        ...
    def is_golang_cc(self) -> bool:
        ...
    def is_high(self) -> bool:
        ...
    def is_noret(self) -> bool:
        ...
    def is_pure(self) -> bool:
        ...
    def is_static(self) -> bool:
        ...
    def is_swift_cc(self) -> bool:
        ...
    def is_user_cc(self) -> bool:
        ...
    def is_vararg_cc(self) -> bool:
        ...
    def is_virtual(self) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> funcarg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def set_cc(self, cc: callcnv_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: func_type_data_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class funcarg_t:
    @property
    def argloc(self) -> Any: ...
    @property
    def cmt(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: funcarg_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        r"""Create a function argument, with the specified name and type.
        
        This constructor has the following signatures:
        
            1. funcarg_t(name: str, type, argloc: argloc_t)
            2. funcarg_t(funcarg: funcarg_t)
        
        In the 1st form, the 'type' descriptor, can be one of:
        
            * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
            * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
            * str: a C type declaration
        
        If an input argument is incorrect, the constructor may raise an exception
        
        :param name: a valid argument name. May not be empty (1st form).
        :param type: the member type (1st form).
        :param argloc: the argument location. Can be empty (1st form).
        :param funcarg: a funcarg_t to copy
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: funcarg_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class funcargvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: funcargvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> funcarg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: funcargvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: funcarg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: funcarg_t) -> bool:
        ...
    def append(self, x: funcarg_t) -> None:
        ...
    def at(self, _idx: size_t) -> funcarg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: funcargvec_t) -> None:
        ...
    def extract(self) -> funcarg_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: funcarg_t) -> bool:
        ...
    def inject(self, s: funcarg_t, len: size_t) -> None:
        ...
    def insert(self, it: funcarg_t, x: funcarg_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> funcarg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: funcargvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class gco_info_t:
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def regnum(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def stkoff(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append_to_list(self, list: mlist_t, mba: mba_t) -> bool:
        r"""Append operand info to LIST. This function converts IDA register number or stack offset to a decompiler list. 
                
        :param list: list to append to
        :param mba: microcode object
        """
        ...
    def cvt_to_ivl(self) -> vivl_t:
        r"""Convert operand info to VIVL. The returned VIVL can be used, for example, in a call of get_valranges(). 
                
        """
        ...
    def is_def(self) -> bool:
        ...
    def is_reg(self) -> bool:
        ...
    def is_use(self) -> bool:
        ...

class gdl_graph_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> node_iterator:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class generic_linput_t:
    @property
    def blocksize(self) -> Any: ...
    @property
    def filesize(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def read(self, off: qoff64_t, buffer: void, nbytes: size_t) -> ssize_t:
        ...

class graph_chains_t(block_chains_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> block_chains_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: block_chains_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def acquire(self) -> None:
        r"""Lock the chains.
        
        """
        ...
    def append(self, x: block_chains_t) -> None:
        ...
    def at(self, _idx: size_t) -> block_chains_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: block_chains_vec_t) -> None:
        ...
    def extract(self) -> block_chains_t:
        ...
    def for_all_chains(self, cv: chain_visitor_t, gca_flags: int) -> int:
        r"""Visit all chains 
                
        :param cv: chain visitor
        :param gca_flags: combination of GCA_ bits
        """
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: block_chains_t, len: size_t) -> None:
        ...
    def insert(self, it: block_chains_t, x: block_chains_t) -> iterator:
        ...
    def is_locked(self) -> bool:
        r"""Are the chains locked? It is a good idea to lock the chains before using them. This ensures that they won't be recalculated and reallocated during the use. See the chain_keeper_t class for that. 
                
        """
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> block_chains_t:
        ...
    def qclear(self) -> None:
        ...
    def release(self) -> None:
        r"""Unlock the chains.
        
        """
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: graph_chains_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class graph_item_t:
    @property
    def b(self) -> Any: ...
    @property
    def e(self) -> Any: ...
    @property
    def elp(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def p(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_edge(self) -> bool:
        ...
    def is_node(self) -> bool:
        ...

class graph_location_info_t:
    @property
    def orgx(self) -> Any: ...
    @property
    def orgy(self) -> Any: ...
    @property
    def zoom(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: graph_location_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: graph_location_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class graph_node_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_forbidden_edge(self, arg0: int, arg1: int) -> bool:
        r"""Should the edge between 'n' and 'm' be ignored?
        
        """
        ...
    def is_visited(self, n: int) -> bool:
        r"""Have we already visited the given node?
        
        """
        ...
    def reinit(self) -> None:
        r"""Reset visited nodes.
        
        """
        ...
    def set_visited(self, n: int) -> None:
        r"""Mark node as visited.
        
        """
        ...
    def visit_node(self, arg0: int) -> int:
        r"""Implements action to take when a node is visited.
        
        """
        ...

class graph_path_visitor_t:
    @property
    def path(self) -> Any: ...
    @property
    def prune(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def walk_backward(self, arg0: int) -> int:
        ...
    def walk_forward(self, arg0: int) -> int:
        ...

class graph_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_edge(self, arg2: edge_t, arg3: edge_info_t) -> int:
        ...
    def visit_node(self, arg2: int, arg3: rect_t) -> int:
        ...

class group_crinfo_t:
    @property
    def nodes(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class hexrays_failure_t:
    @property
    def code(self) -> Any: ...
    @property
    def errea(self) -> Any: ...
    @property
    def str(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def desc(self) -> str:
        ...

class hexwarn_t:
    @property
    def ea(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: hexwarn_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: hexwarn_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: hexwarn_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: hexwarn_t) -> bool:
        ...
    def __lt__(self, r: hexwarn_t) -> bool:
        ...
    def __ne__(self, r: hexwarn_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: hexwarn_t) -> int:
        ...

class hexwarns_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: hexwarns_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> hexwarn_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: hexwarns_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: hexwarn_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: hexwarn_t) -> bool:
        ...
    def append(self, args: Any) -> hexwarn_t:
        ...
    def at(self, i: size_t) -> hexwarn_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: hexwarns_t) -> None:
        ...
    def extract(self) -> hexwarn_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: hexwarn_t) -> bool:
        ...
    def inject(self, s: hexwarn_t, len: size_t) -> None:
        ...
    def insert(self, it: hexwarn_t, x: hexwarn_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> hexwarn_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: hexwarns_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class hidden_range_t(range_t):
    @property
    def color(self) -> Any: ...
    @property
    def description(self) -> Any: ...
    @property
    def end_ea(self) -> Any: ...
    @property
    def footer(self) -> Any: ...
    @property
    def header(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def visible(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class highlighter_cbs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cur_block_state(self) -> int:
        ...
    def prev_block_state(self) -> int:
        ...
    def set_block_state(self, arg0: int) -> None:
        ...
    def set_style(self, arg0: int, arg1: int, arg2: syntax_highlight_style) -> None:
        ...

class history_item_t(ctext_position_t):
    @property
    def curr_ea(self) -> Any: ...
    @property
    def end(self) -> Any: ...
    @property
    def func_ea(self) -> Any: ...
    @property
    def lnnum(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ctext_position_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ctext_position_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ctext_position_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: ctext_position_t) -> bool:
        ...
    def __lt__(self, r: ctext_position_t) -> bool:
        ...
    def __ne__(self, r: ctext_position_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: ctext_position_t) -> int:
        ...
    def in_ctree(self, hdrlines: int) -> bool:
        r"""Is the cursor in the variable/type declaration area? 
                
        :param hdrlines: Number of lines of the declaration area
        """
        ...

class history_t(qvector_history_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_history_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> history_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_history_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: history_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: history_item_t) -> bool:
        ...
    def append(self, args: Any) -> history_item_t:
        ...
    def at(self, i: size_t) -> history_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_history_t) -> None:
        ...
    def extract(self) -> history_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: history_item_t) -> bool:
        ...
    def inject(self, s: history_item_t, len: size_t) -> None:
        ...
    def insert(self, it: history_item_t, x: history_item_t) -> iterator:
        ...
    def pop(self) -> history_item_t:
        ...
    def pop_back(self) -> None:
        ...
    def push(self, v: history_item_t) -> None:
        ...
    def push_back(self, args: Any) -> history_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_history_t) -> None:
        ...
    def top(self, args: Any) -> history_item_t:
        ...
    def truncate(self) -> None:
        ...

class ida_lowertype_helper_t(lowertype_helper_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _tif: tinfo_t, _ea: ida_idaapi.ea_t, _pb: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def func_has_stkframe_hole(self, candidate: tinfo_t, candidate_data: func_type_data_t) -> bool:
        ...
    def get_func_purged_bytes(self, candidate: tinfo_t, arg3: func_type_data_t) -> int:
        ...

class idaapi_Cvar:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattr__(self, attr: Any) -> Any:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, attr: Any, value: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class idainfo:
    @property
    def abibits(self) -> Any: ...
    @property
    def abiname(self) -> Any: ...
    @property
    def af(self) -> Any: ...
    @property
    def af2(self) -> Any: ...
    @property
    def appcall_options(self) -> Any: ...
    @property
    def apptype(self) -> Any: ...
    @property
    def asmtype(self) -> Any: ...
    @property
    def baseaddr(self) -> Any: ...
    @property
    def bin_prefix_size(self) -> Any: ...
    @property
    def cc(self) -> Any: ...
    @property
    def cmt_indent(self) -> Any: ...
    @property
    def database_change_count(self) -> Any: ...
    @property
    def datatypes(self) -> Any: ...
    @property
    def demnames(self) -> Any: ...
    @property
    def filetype(self) -> Any: ...
    @property
    def highoff(self) -> Any: ...
    @property
    def indent(self) -> Any: ...
    @property
    def lenxref(self) -> Any: ...
    @property
    def lflags(self) -> Any: ...
    @property
    def listnames(self) -> Any: ...
    @property
    def long_demnames(self) -> Any: ...
    @property
    def lowoff(self) -> Any: ...
    @property
    def main(self) -> Any: ...
    @property
    def margin(self) -> Any: ...
    @property
    def maxEA(self) -> Any: ...
    @property
    def max_autoname_len(self) -> Any: ...
    @property
    def max_ea(self) -> Any: ...
    @property
    def maxref(self) -> Any: ...
    @property
    def minEA(self) -> Any: ...
    @property
    def min_ea(self) -> Any: ...
    @property
    def nametype(self) -> Any: ...
    @property
    def omax_ea(self) -> Any: ...
    @property
    def omin_ea(self) -> Any: ...
    @property
    def ostype(self) -> Any: ...
    @property
    def outflags(self) -> Any: ...
    @property
    def procName(self) -> Any: ...
    @property
    def procname(self) -> Any: ...
    @property
    def refcmtnum(self) -> Any: ...
    @property
    def s_cmtflg(self) -> Any: ...
    @property
    def s_genflags(self) -> Any: ...
    @property
    def s_limiter(self) -> Any: ...
    @property
    def s_prefflag(self) -> Any: ...
    @property
    def s_xrefflag(self) -> Any: ...
    @property
    def short_demnames(self) -> Any: ...
    @property
    def specsegs(self) -> Any: ...
    @property
    def start_cs(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def start_ip(self) -> Any: ...
    @property
    def start_sp(self) -> Any: ...
    @property
    def start_ss(self) -> Any: ...
    @property
    def strlit_break(self) -> Any: ...
    @property
    def strlit_flags(self) -> Any: ...
    @property
    def strlit_pref(self) -> Any: ...
    @property
    def strlit_sernum(self) -> Any: ...
    @property
    def strlit_zeroes(self) -> Any: ...
    @property
    def strtype(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    @property
    def type_xrefnum(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    @property
    def xrefnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def big_arg_align(self, args: Any) -> Any:
        ...
    def gen_lzero(self, args: Any) -> Any:
        ...
    def gen_null(self, args: Any) -> Any:
        ...
    def gen_tryblks(self, args: Any) -> Any:
        ...
    def get_abiname(self) -> str:
        ...
    def get_demname_form(self, args: Any) -> Any:
        ...
    def get_pack_mode(self, args: Any) -> Any:
        ...
    def is_32bit(self, args: Any) -> Any:
        ...
    def is_64bit(self, args: Any) -> Any:
        ...
    def is_auto_enabled(self, args: Any) -> Any:
        ...
    def is_be(self, args: Any) -> Any:
        ...
    def is_dll(self, args: Any) -> Any:
        ...
    def is_flat_off32(self, args: Any) -> Any:
        ...
    def is_graph_view(self, args: Any) -> Any:
        ...
    def is_hard_float(self, args: Any) -> Any:
        ...
    def is_kernel_mode(self, args: Any) -> Any:
        ...
    def is_mem_aligned4(self, args: Any) -> Any:
        ...
    def is_snapshot(self, args: Any) -> Any:
        ...
    def is_wide_high_byte_first(self, args: Any) -> Any:
        ...
    def like_binary(self, args: Any) -> Any:
        ...
    def line_pref_with_seg(self, args: Any) -> Any:
        ...
    def loading_idc(self, args: Any) -> Any:
        ...
    def map_stkargs(self, args: Any) -> Any:
        ...
    def pack_stkargs(self, args: Any) -> Any:
        ...
    def readonly_idb(self, args: Any) -> Any:
        ...
    def set_64bit(self, args: Any) -> Any:
        ...
    def set_auto_enabled(self, args: Any) -> Any:
        ...
    def set_be(self, args: Any) -> Any:
        ...
    def set_gen_lzero(self, args: Any) -> Any:
        ...
    def set_gen_null(self, args: Any) -> Any:
        ...
    def set_gen_tryblks(self, args: Any) -> Any:
        ...
    def set_graph_view(self, args: Any) -> Any:
        ...
    def set_line_pref_with_seg(self, args: Any) -> Any:
        ...
    def set_pack_mode(self, args: Any) -> Any:
        ...
    def set_show_auto(self, args: Any) -> Any:
        ...
    def set_show_line_pref(self, args: Any) -> Any:
        ...
    def set_show_void(self, args: Any) -> Any:
        ...
    def set_wide_high_byte_first(self, args: Any) -> Any:
        ...
    def show_auto(self, args: Any) -> Any:
        ...
    def show_line_pref(self, args: Any) -> Any:
        ...
    def show_void(self, args: Any) -> Any:
        ...
    def stack_ldbl(self, args: Any) -> Any:
        ...
    def stack_varargs(self, args: Any) -> Any:
        ...
    def use_allasm(self, args: Any) -> Any:
        ...
    def use_gcc_layout(self, args: Any) -> Any:
        ...

class idaplace_t(place_t):
    @property
    def ea(self) -> Any: ...
    @property
    def lnnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class idasgn_header_t:
    @property
    def apptype(self) -> Any: ...
    @property
    def ctype_crc(self) -> Any: ...
    @property
    def ctype_crc_3v(self) -> Any: ...
    @property
    def ctype_crc_alt(self) -> Any: ...
    @property
    def ctype_name(self) -> Any: ...
    @property
    def file_formats(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def libname_length(self) -> Any: ...
    @property
    def magic(self) -> Any: ...
    @property
    def number_of_modules(self) -> Any: ...
    @property
    def number_of_modules_v5(self) -> Any: ...
    @property
    def ostype(self) -> Any: ...
    @property
    def pattern_length(self) -> Any: ...
    @property
    def processor_id(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class idbattr_info_t:
    @property
    def bitmask(self) -> Any: ...
    @property
    def idi_flags(self) -> Any: ...
    @property
    def individual_node(self) -> Any: ...
    @property
    def maxsize(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def offset(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    @property
    def vmap(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, name: str, offset: uintptr_t, width: size_t, bitmask: uint64 = 0, tag: uchar = 0, idi_flags: uint = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: idbattr_info_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def has_individual_node(self) -> bool:
        ...
    def hashname(self) -> str:
        ...
    def is_bitfield(self) -> bool:
        ...
    def is_bitmap(self) -> bool:
        ...
    def is_boolean(self) -> bool:
        ...
    def is_buf_var(self) -> bool:
        ...
    def is_bytearray(self) -> bool:
        ...
    def is_cstr(self) -> bool:
        ...
    def is_decimal(self) -> bool:
        ...
    def is_hash(self) -> bool:
        ...
    def is_hexadecimal(self) -> bool:
        ...
    def is_incremented(self) -> bool:
        ...
    def is_node_altval(self) -> bool:
        ...
    def is_node_blob(self) -> bool:
        ...
    def is_node_supval(self) -> bool:
        ...
    def is_node_valobj(self) -> bool:
        ...
    def is_node_var(self) -> bool:
        ...
    def is_onoff(self) -> bool:
        ...
    def is_qstring(self) -> bool:
        ...
    def is_readonly_var(self) -> bool:
        ...
    def is_scalar_var(self) -> bool:
        ...
    def is_struc_field(self) -> bool:
        ...
    def is_val_mapped(self) -> bool:
        ...
    def ridx(self) -> int:
        ...
    def str_false(self) -> str:
        ...
    def str_true(self) -> str:
        ...
    def use_hlpstruc(self) -> bool:
        ...

class idbattr_valmap_t:
    @property
    def valname(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class idc_global_t:
    @property
    def name(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class idc_value_t:
    @property
    def e(self) -> Any: ...
    @property
    def funcidx(self) -> Any: ...
    @property
    def i64(self) -> Any: ...
    @property
    def num(self) -> Any: ...
    @property
    def obj(self) -> Any: ...
    @property
    def pvoid(self) -> Any: ...
    @property
    def reserve(self) -> Any: ...
    @property
    def str(self) -> Any: ...
    @property
    def vtype(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def c_str(self) -> str:
        r"""VT_STR
        
        """
        ...
    def clear(self) -> None:
        r"""See free_idcv()
        
        """
        ...
    def create_empty_string(self) -> None:
        ...
    def is_convertible(self) -> bool:
        r"""Convertible types are VT_LONG, VT_FLOAT, VT_INT64, and VT_STR.
        
        """
        ...
    def is_integral(self) -> bool:
        r"""Does value represent a whole number? 
                
        """
        ...
    def is_zero(self) -> bool:
        r"""Does value represent the integer 0?
        
        """
        ...
    def qstr(self) -> str:
        r"""VT_STR
        
        """
        ...
    def set_float(self, f: fpvalue_t) -> None:
        ...
    def set_int64(self, v: int64) -> None:
        ...
    def set_long(self, v: int) -> None:
        ...
    def set_pvoid(self, p: void) -> None:
        ...
    def set_string(self, args: Any) -> None:
        ...
    def swap(self, v: idc_value_t) -> None:
        r"""Set this = r and v = this.
        
        """
        ...
    def u_str(self) -> uchar:
        r"""VT_STR
        
        """
        ...

class idc_values_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> idc_value_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: idc_value_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: idc_value_t) -> None:
        ...
    def at(self, _idx: size_t) -> idc_value_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: idc_values_t) -> None:
        ...
    def extract(self) -> idc_value_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: idc_value_t, len: size_t) -> None:
        ...
    def insert(self, it: idc_value_t, x: idc_value_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> idc_value_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: idc_values_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class idp_desc_t:
    @property
    def checked(self) -> Any: ...
    @property
    def family(self) -> Any: ...
    @property
    def is_script(self) -> Any: ...
    @property
    def mtime(self) -> Any: ...
    @property
    def names(self) -> Any: ...
    @property
    def path(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class idp_name_t:
    @property
    def hidden(self) -> Any: ...
    @property
    def lname(self) -> Any: ...
    @property
    def sname(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_keyboard_data_t:
    @property
    def key(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_mouse_data_t:
    @property
    def button(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_shortcut_data_t:
    @property
    def action_name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class input_event_t:
    @property
    def cb(self) -> Any: ...
    @property
    def keyboard(self) -> Any: ...
    @property
    def kind(self) -> Any: ...
    @property
    def modifiers(self) -> Any: ...
    @property
    def mouse(self) -> Any: ...
    @property
    def shortcut(self) -> Any: ...
    @property
    def source(self) -> Any: ...
    @property
    def target(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_source_QEvent(self) -> Any:
        ...
    def get_target_QWidget(self) -> Any:
        ...

class insn_t:
    @property
    def Op1(self) -> Any: ...
    @property
    def Op2(self) -> Any: ...
    @property
    def Op3(self) -> Any: ...
    @property
    def Op4(self) -> Any: ...
    @property
    def Op5(self) -> Any: ...
    @property
    def Op6(self) -> Any: ...
    @property
    def Op7(self) -> Any: ...
    @property
    def Op8(self) -> Any: ...
    @property
    def auxpref(self) -> Any: ...
    @property
    def auxpref_u16(self) -> Any: ...
    @property
    def auxpref_u8(self) -> Any: ...
    @property
    def cs(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def insnpref(self) -> Any: ...
    @property
    def ip(self) -> Any: ...
    @property
    def itype(self) -> Any: ...
    @property
    def ops(self) -> Any: ...
    @property
    def segpref(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __get_auxpref__(self) -> int:
        ...
    def __get_operand__(self, n: int) -> op_t:
        ...
    def __get_ops__(self) -> wrapped_array_t:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""
        Operands can be accessed directly as indexes
        
        :returns: an operand of type op_t
        
        """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __set_auxpref__(self, v: int) -> None:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_cref(self, to: ida_idaapi.ea_t, opoff: int, type: cref_t) -> None:
        r"""Add a code cross-reference from the instruction. 
                
        :param to: target linear address
        :param opoff: offset of the operand from the start of instruction. if the offset is unknown, then 0.
        :param type: type of xref
        """
        ...
    def add_dref(self, to: ida_idaapi.ea_t, opoff: int, type: dref_t) -> None:
        r"""Add a data cross-reference from the instruction. See add_off_drefs() - usually it can be used in most cases. 
                
        :param to: target linear address
        :param opoff: offset of the operand from the start of instruction if the offset is unknown, then 0
        :param type: type of xref
        """
        ...
    def add_off_drefs(self, x: op_t, type: dref_t, outf: int) -> ida_idaapi.ea_t:
        r"""Add xrefs for an operand of the instruction. This function creates all cross references for 'enum', 'offset' and 'structure offset' operands. Use add_off_drefs() in the presence of negative offsets. 
                
        :param x: reference to operand
        :param type: type of xref
        :param outf: out_value() flags. These flags should match the flags used to output the operand
        :returns: if: is_off(): the reference target address (the same as calc_reference_data).
        :returns: if: is_stroff(): BADADDR because for stroffs the target address is unknown
        :returns: otherwise: BADADDR because enums do not represent addresses
        """
        ...
    def assign(self, other: insn_t) -> None:
        ...
    def create_op_data(self, args: Any) -> bool:
        ...
    def create_stkvar(self, x: op_t, v: adiff_t, flags_: int) -> bool:
        ...
    def get_canon_feature(self, args: Any) -> int:
        r"""see instruc_t::feature
        
        """
        ...
    def get_canon_mnem(self, args: Any) -> str:
        r"""see instruc_t::name
        
        """
        ...
    def get_next_byte(self) -> uint8:
        ...
    def get_next_dword(self) -> int:
        ...
    def get_next_qword(self) -> uint64:
        ...
    def get_next_word(self) -> uint16:
        ...
    def is_64bit(self) -> bool:
        r"""Belongs to a 64bit segment?
        
        """
        ...
    def is_canon_insn(self, args: Any) -> bool:
        r"""see processor_t::is_canon_insn()
        
        """
        ...
    def is_macro(self) -> bool:
        r"""Is a macro instruction?
        
        """
        ...

class instant_dbgopts_t:
    @property
    def attach(self) -> Any: ...
    @property
    def debmod(self) -> Any: ...
    @property
    def env(self) -> Any: ...
    @property
    def event_id(self) -> Any: ...
    @property
    def host(self) -> Any: ...
    @property
    def pid(self) -> Any: ...
    @property
    def port(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class int16_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int16) -> None:
        ...
    def cast(self) -> int16:
        ...
    def frompointer(self, t: int16) -> int16_pointer:
        ...
    def value(self) -> int16:
        ...

class int32_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int) -> None:
        ...
    def cast(self) -> int32:
        ...
    def frompointer(self, t: int32) -> int32_pointer:
        ...
    def value(self) -> int:
        ...

class int64_emulator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_mop_value(self, mop: mop_t) -> intval64_t:
        ...
    def minsn_value(self, insn: minsn_t) -> intval64_t:
        ...
    def mop_value(self, mop: mop_t) -> intval64_t:
        ...

class int64_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int64) -> None:
        ...
    def cast(self) -> int64:
        ...
    def frompointer(self, t: int64) -> int64_pointer:
        ...
    def value(self) -> int64:
        ...

class int64vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: int64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: int64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: int64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: int64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class int8_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int8) -> None:
        ...
    def cast(self) -> int8:
        ...
    def frompointer(self, t: int8) -> int8_pointer:
        ...
    def value(self) -> int8:
        ...

class int_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int) -> None:
        ...
    def cast(self) -> int:
        ...
    def frompointer(self, t: int) -> int_pointer:
        ...
    def value(self) -> int:
        ...

class interactive_graph_t(drawable_graph_t, gdl_graph_t):
    @property
    def belongs(self) -> Any: ...
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def edges(self) -> Any: ...
    @property
    def gid(self) -> Any: ...
    @property
    def node_flags(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def org_preds(self) -> Any: ...
    @property
    def org_succs(self) -> Any: ...
    @property
    def preds(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def succs(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_edge(self, i: int, j: int, ei: edge_info_t) -> bool:
        ...
    def add_node(self, r: rect_t) -> int:
        r"""Add a node, possibly with a specific geometry
        
        :param r: the node geometry (can be nullptr)
        :returns: the new node
        """
        ...
    def begin(self) -> node_iterator:
        ...
    def calc_group_ea(self, arg2: intvec_t) -> ida_idaapi.ea_t:
        ...
    def change_group_visibility(self, group: int, expand: bool) -> bool:
        r"""Expand/collapse a group node
        
        :param group: the group node
        :param expand: whether to expand or collapse
        :returns: success
        """
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_digraph_layout(self) -> bool:
        ...
    def create_group(self, nodes: intvec_t) -> int:
        r"""Create a new group node, that will contain all the nodes in 'nodes'.
        
        :param nodes: the nodes that will be part of the group
        :returns: the group node, or -1 in case of error
        """
        ...
    def create_tree_layout(self) -> bool:
        ...
    def del_custom_layout(self) -> None:
        ...
    def del_edge(self, i: int, j: int) -> bool:
        ...
    def del_node(self, n: int) -> ssize_t:
        r"""Delete a node
        
        :param n: the node to delete
        :returns: the number of deleted edges
        """
        ...
    def delete_group(self, group: int) -> bool:
        r"""Delete a group node.
        This deletes the group node only; it does not delete nodes that are part of the group.
        
        :param group: the group node
        :returns: success
        """
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        r"""Is the graph (visually) empty? 
                
        :returns: true if there are no visible nodes
        """
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        r"""Is the node visible?
        
        :param node: the node number
        :returns: success
        """
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_custom_layout(self) -> bool:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_first_subgraph_node(self, group: int) -> int:
        ...
    def get_graph_groups(self) -> bool:
        ...
    def get_next_subgraph_node(self, group: int, current: int) -> int:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_group(self, node: int) -> int:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def get_node_representative(self, node: int) -> int:
        r"""Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
        See also get_group_node() 
                
        :param node: the node
        :returns: the node that represents 'node', or 'node' if it's not part of any group
        """
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def is_collapsed_node(self, node: int) -> bool:
        ...
    def is_deleted_node(self, node: int) -> bool:
        ...
    def is_displayable_node(self, node: int) -> bool:
        ...
    def is_dot_node(self, node: int) -> bool:
        ...
    def is_group_node(self, node: int) -> bool:
        ...
    def is_simple_node(self, node: int) -> bool:
        ...
    def is_subgraph_node(self, node: int) -> bool:
        ...
    def is_uncollapsed_node(self, node: int) -> bool:
        ...
    def is_user_graph(self) -> bool:
        ...
    def is_visible_node(self, node: int) -> bool:
        r"""Is the node currently visible?
        An invisible node is a node that's part of a group that's currently collapsed.
        
        :param node: the node
        :returns: success
        """
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        r"""Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
        See also size()
        
        :returns: the number of visible nodes
        """
        ...
    def npred(self, b: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, b: int) -> int:
        ...
    def pred(self, b: int, i: int) -> int:
        ...
    def predset(self, b: int) -> intvec_t:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def redo_layout(self) -> bool:
        r"""Recompute the layout, according to the value of 'current_layout'.
        
        :returns: success
        """
        ...
    def refresh(self) -> bool:
        r"""Refresh the graph
        A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
        Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
        * discard all its internal rendering information,
        * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
        * re-create internal rendering information, and
        * repaint the view
        
        
        
        :returns: success
        """
        ...
    def replace_edge(self, i: int, j: int, x: int, y: int) -> bool:
        ...
    def reset(self) -> None:
        ...
    def resize(self, n: int) -> None:
        r"""Resize the graph to 'n' nodes
        
        :param n: the new size
        """
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def set_custom_layout(self) -> None:
        ...
    def set_deleted_node(self, node: int) -> None:
        ...
    def set_edge(self, e: edge_t, ei: edge_info_t) -> bool:
        ...
    def set_graph_groups(self) -> None:
        ...
    def set_node_group(self, node: int, group: int) -> None:
        ...
    def set_nrect(self, n: int, r: rect_t) -> bool:
        ...
    def size(self) -> int:
        r"""Get the total number of nodes (including group nodes, and including hidden nodes.)
        See also node_qty()
        
        :returns: the total number of nodes in the graph
        """
        ...
    def succ(self, b: int, i: int) -> int:
        ...
    def succset(self, b: int) -> intvec_t:
        ...

class interval_t:
    @property
    def x0(self) -> Any: ...
    @property
    def x1(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: interval_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: interval_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: int) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def intersect(self, r: interval_t) -> None:
        ...
    def length(self) -> int:
        ...
    def make_union(self, r: interval_t) -> None:
        ...
    def move_by(self, shift: int) -> None:
        ...

class intval64_t:
    @property
    def size(self) -> Any: ...
    @property
    def val(self) -> Any: ...
    def __add__(self, o: intval64_t) -> intval64_t:
        ...
    def __and__(self, o: intval64_t) -> intval64_t:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __div__(self, args: Any) -> Any:
        ...
    def __eq__(self, o: intval64_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, v: uint64 = 0, _s: int = 1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __invert__(self) -> intval64_t:
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lshift__(self, o: intval64_t) -> intval64_t:
        ...
    def __lt__(self, o: intval64_t) -> bool:
        ...
    def __mod__(self, o: intval64_t) -> intval64_t:
        ...
    def __mul__(self, o: intval64_t) -> intval64_t:
        ...
    def __ne__(self, o: intval64_t) -> bool:
        ...
    def __neg__(self) -> intval64_t:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __or__(self, o: intval64_t) -> intval64_t:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __rshift__(self, o: intval64_t) -> intval64_t:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __sub__(self, o: intval64_t) -> intval64_t:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def __truediv__(self, args: Any) -> Any:
        ...
    def __xor__(self, o: intval64_t) -> intval64_t:
        ...
    def high(self, target_sz: int) -> intval64_t:
        ...
    def low(self, target_sz: int) -> intval64_t:
        ...
    def sar(self, o: intval64_t) -> intval64_t:
        ...
    def sdiv(self, o: intval64_t) -> intval64_t:
        ...
    def sext(self, target_sz: int) -> intval64_t:
        ...
    def smod(self, o: intval64_t) -> intval64_t:
        ...
    def sval(self) -> int64:
        ...
    def uval(self) -> uint64:
        ...
    def zext(self, target_sz: int) -> intval64_t:
        ...

class intvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: intvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: intvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: intvec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: intvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ioports_fallback_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def handle(self, ports: ioports_t, line: str) -> bool:
        r""":param ports: i/o port definitions
        :param line: input line to parse
        :returns: success or fills ERRBUF with an error message
        """
        ...

class item_block_locator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_block_head(self, md: merge_data_t, idx: diff_source_idx_t, item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        ...
    def setup_blocks(self, md: merge_data_t, _from: diff_source_idx_t, to: diff_source_idx_t, region: diff_range_t) -> bool:
        ...

class iterator:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, n: iterator) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, n: int = -1) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, n: iterator) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __ref__(self) -> int:
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ivl_t(uval_ivl_t):
    @property
    def off(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ivl_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ivl_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ivl_t) -> bool:
        ...
    def __init__(self, _off: int = 0, _size: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: ivl_t) -> bool:
        ...
    def __lt__(self, r: ivl_t) -> bool:
        ...
    def __ne__(self, r: ivl_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: ivl_t) -> int:
        ...
    def contains(self, off2: int) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> int:
        ...
    def extend_to_cover(self, r: ivl_t) -> bool:
        ...
    def includes(self, ivl: ivl_t) -> bool:
        ...
    def intersect(self, r: ivl_t) -> None:
        ...
    def last(self) -> int:
        ...
    def overlap(self, ivl: ivl_t) -> bool:
        ...
    def valid(self) -> bool:
        ...

class ivl_with_name_t:
    @property
    def ivl(self) -> Any: ...
    @property
    def part(self) -> Any: ...
    @property
    def whole(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ivlset_t(uval_ivl_ivlset_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ivlset_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: ivlset_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: ivlset_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: ivlset_t) -> bool:
        ...
    def __lt__(self, r: ivlset_t) -> bool:
        ...
    def __ne__(self, r: ivlset_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(ivl: const ivl_t &) -> bool
            1. add(ea: ida_idaapi.ea_t, size: asize_t) -> bool
            2. add(ivs: const ivlset_t &) -> bool
        
        # 0: add(ivl: const ivl_t &) -> bool
        
        
        # 1: add(ea: ida_idaapi.ea_t, size: asize_t) -> bool
        
        
        # 2: add(ivs: const ivlset_t &) -> bool
        
        
        """
        ...
    def addmasked(self, ivs: ivlset_t, mask: ivl_t) -> bool:
        ...
    def all_values(self) -> bool:
        ...
    def begin(self, args: Any) -> iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: ivlset_t) -> int:
        ...
    def contains(self, off: int) -> bool:
        ...
    def count(self) -> int:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> iterator:
        ...
    def getivl(self, idx: int) -> ivl_t:
        ...
    def has_common(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. has_common(ivl: const ivl_t &, strict: bool=false) -> bool
            1. has_common(ivs: const ivlset_t &) -> bool
        
        # 0: has_common(ivl: const ivl_t &, strict: bool=false) -> bool
        
        
        # 1: has_common(ivs: const ivlset_t &) -> bool
        
        
        """
        ...
    def includes(self, ivs: ivlset_t) -> bool:
        ...
    def intersect(self, ivs: ivlset_t) -> bool:
        ...
    def lastivl(self) -> ivl_t:
        ...
    def nivls(self) -> int:
        ...
    def qclear(self) -> None:
        ...
    def set_all_values(self) -> None:
        ...
    def single_value(self, args: Any) -> bool:
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(ivl: const ivl_t &) -> bool
            1. sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool
            2. sub(ivs: const ivlset_t &) -> bool
        
        # 0: sub(ivl: const ivl_t &) -> bool
        
        
        # 1: sub(ea: ida_idaapi.ea_t, size: asize_t) -> bool
        
        
        # 2: sub(ivs: const ivlset_t &) -> bool
        
        
        """
        ...
    def swap(self, r: uval_ivl_ivlset_t) -> None:
        ...

class jobj_wrapper_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def get_dict(self) -> dict:
        r"""Retrieve the contents of this object, as a dict
        
        :returns: a dict containing all kvp's in this object
        """
        ...

class launch_env_t:
    @property
    def merge(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def envs(self) -> Any:
        ...
    def set(self, envvar: str, value: str) -> None:
        ...

class line_rendering_output_entries_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_rendering_output_entries_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_rendering_output_entries_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: line_rendering_output_entry_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: line_rendering_output_entry_t) -> bool:
        ...
    def append(self, x: line_rendering_output_entry_t) -> None:
        ...
    def at(self, _idx: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: line_rendering_output_entries_refs_t) -> None:
        ...
    def extract(self) -> line_rendering_output_entry_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: line_rendering_output_entry_t) -> bool:
        ...
    def inject(self, s: line_rendering_output_entry_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: line_rendering_output_entry_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, e: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: line_rendering_output_entries_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class line_rendering_output_entry_t:
    @property
    def bg_color(self) -> Any: ...
    @property
    def cpx(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def nchars(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_rendering_output_entry_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_rendering_output_entry_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_bg_color_direct(self) -> bool:
        ...
    def is_bg_color_empty(self) -> bool:
        ...
    def is_bg_color_key(self) -> bool:
        ...

class line_section_t:
    @property
    def length(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: line_section_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: line_section_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: cpidx_t) -> bool:
        ...
    def is_closed(self) -> bool:
        ...
    def is_open(self) -> bool:
        ...
    def valid(self) -> bool:
        ...

class linearray_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _ud: void) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def beginning(self) -> bool:
        r"""Are we at the beginning?
        
        """
        ...
    def copy_from(self, src: linearray_t) -> None:
        r"""Copy information from one linearray to another. Only linearray objects with compatible 'ud' fields can be copied. 
                
        """
        ...
    def down(self) -> str:
        r"""Get the next line going downwards. 'at' for the retrieved line is correct BEFORE calling this function. 
                
        """
        ...
    def ending(self) -> bool:
        ...
    def get_bg_color(self) -> bgcolor_t:
        r"""Get current background color. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_dlnnum(self) -> int:
        r"""Get default line number. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_linecnt(self) -> int:
        r"""Get number of lines for the current place. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_pfx_color(self) -> bgcolor_t:
        r"""Get current prefix color. (the same behavior as with get_place(): good before down() and after up()) 
                
        """
        ...
    def get_place(self) -> place_t:
        r"""Get the current place. If called before down(), then returns place of line which will be returned by down(). If called after up(), then returns place if line returned by up(). 
                
        """
        ...
    def set_max_lines(self, n: int) -> None:
        r"""Set max number of lines to generate for a place. 0 means to use the default value, MAX_ITEM_LINES from ida.cfg 
                
        """
        ...
    def set_place(self, new_at: place_t) -> int:
        r"""Position the array. This function must be called before calling any other member functions. 
                
        :param new_at: new position of the array. linearray will make a clone of this object.
        :returns: the delta of lines that the linearray_t had to adjust the place by. 
        For example, if the place_t has a lnnum of 5, but it turns out, upon generating lines, 
        that the number of lines for that particular place is only 2, then 3 will be returned.
        """
        ...
    def set_userdata(self, userd: void) -> None:
        r"""Change the user data.
        
        """
        ...
    def up(self) -> str:
        r"""Get the next line going upwards. 'at' for the retrieved line is correct AFTER calling this function. 
                
        """
        ...
    def userdata(self) -> None:
        r"""Get pointer to user data.
        
        """
        ...

class lines_rendering_input_t:
    @property
    def cb(self) -> Any: ...
    @property
    def sections_lines(self) -> Any: ...
    @property
    def sync_group(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lines_rendering_output_t:
    @property
    def entries(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lines_rendering_output_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: lines_rendering_output_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def swap(self, r: lines_rendering_output_t) -> None:
        ...

class listing_location_t:
    @property
    def cb(self) -> Any: ...
    @property
    def loc(self) -> Any: ...
    @property
    def tagged_sections(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class loader_input_t:
    r"""A helper class to work with linput_t related functions.
    This class is also used by file loaders scripts.
    """
    @property
    def __idc_cvt_id__(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, pycapsule: Any = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def close(self) -> Any:
        r"""Closes the file"""
        ...
    def file2base(self, pos: int, ea1: ea_t, ea2: ea_t, patchable: bool) -> Any:
        r"""Load portion of file into the database
        This function will include (ea1..ea2) into the addressing space of the
        program (make it enabled)
        
        :param li: pointer ot input source
        :param pos: position in the file
        :param ea1: start of range of destination linear addresses
        :param ea2: end of range of destination linear addresses
        :param patchable: should the kernel remember correspondance of
                          file offsets to linear addresses.
        :returns: 1-ok,0-read error, a warning is displayed
        """
        ...
    def filename(self) -> Any:
        ...
    def from_capsule(self, pycapsule: Any) -> loader_input_t:
        ...
    def from_fp(self, fp: Any) -> Any:
        r"""A static method to construct an instance from a FILE*
        
        :param fp: a FILE pointer
        :returns: a new instance, or None
        """
        ...
    def from_linput(self, linput: linput_t) -> loader_input_t:
        ...
    def get_byte(self) -> Any:
        r"""Reads a single byte from the file. Returns None if EOF or the read byte"""
        ...
    def get_linput(self) -> linput_t:
        ...
    def gets(self, len: int) -> Any:
        r"""Reads a line from the input file. Returns the read line or None
        
        :param len: the maximum line length
        :returns: a str, or None
        """
        ...
    def getz(self, size: int, fpos: int = -1) -> Any:
        r"""Returns a zero terminated string at the given position
        
        :param size: maximum size of the string
        :param fpos: if != -1 then seek will be performed before reading
        :returns: The string or None on failure.
        """
        ...
    def open(self, filename: Any, remote: Any = False) -> Any:
        r"""Opens a file (or a remote file)
        
        :param filename: the file name
        :param remote: whether the file is local, or remote
        :returns: Boolean
        """
        ...
    def open_memory(self, start: ea_t, size: int) -> Any:
        r"""Create a linput for process memory (By internally calling idaapi.create_memory_linput())
        This linput will use dbg->read_memory() to read data
        
        :param start: starting address of the input
        :param size: size of the memory range to represent as linput
                    if unknown, may be passed as 0
        """
        ...
    def opened(self) -> Any:
        r"""Checks if the file is opened or not"""
        ...
    def read(self, size: int = -1) -> Any:
        r"""Read up to size bytes (all data if size is negative). Return an empty bytes object on EOF.
        
        :param size: the maximum number of bytes to read
        :returns: a bytes object
        """
        ...
    def readbytes(self, size: int, big_endian: bool) -> Any:
        r"""Similar to read() but it respect the endianness
        
        :param size: the maximum number of bytes to read
        :param big_endian: endianness
        :returns: a str, or None
        """
        ...
    def seek(self, offset: int, whence: Any = 0) -> Any:
        r"""Set input source position
        
        :param offset: the seek offset
        :param whence: the position to seek from
        :returns: the new position (not 0 as fseek!)
        """
        ...
    def set_linput(self, linput: Any) -> Any:
        r"""Links the current loader_input_t instance to a linput_t instance
        
        :param linput: the linput_t to link to
        """
        ...
    def size(self) -> int64:
        ...
    def tell(self) -> Any:
        r"""Returns the current position"""
        ...

class loader_t:
    @property
    def flags(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lochist_entry_t:
    @property
    def plce(self) -> Any: ...
    @property
    def rinfo(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def acquire_place(self, in_p: place_t) -> None:
        ...
    def is_valid(self) -> bool:
        ...
    def place(self) -> place_t:
        ...
    def renderer_info(self) -> renderer_info_t:
        ...
    def set_place(self, p: place_t) -> None:
        ...

class lock_func:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _pfn: func_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lock_func_with_tails_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, pfn: func_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lock_segment:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _segm: segment_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class long_type:
    r"""int([x]) -> integer
    int(x, base=10) -> integer
    
    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating-point
    numbers, this truncates towards zero.
    
    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
    """
    denominator: getset_descriptor  # <attribute 'denominator' of 'int' objects>
    imag: getset_descriptor  # <attribute 'imag' of 'int' objects>
    numerator: getset_descriptor  # <attribute 'numerator' of 'int' objects>
    real: getset_descriptor  # <attribute 'real' of 'int' objects>
    def __abs__(self) -> Any:
        r"""abs(self)"""
        ...
    def __add__(self, value: Any) -> Any:
        r"""Return self+value."""
        ...
    def __and__(self, value: Any) -> Any:
        r"""Return self&value."""
        ...
    def __bool__(self) -> Any:
        r"""True if self else False"""
        ...
    def __ceil__(self) -> Any:
        r"""Ceiling of an Integral returns itself."""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __divmod__(self, value: Any) -> Any:
        r"""Return divmod(self, value)."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __float__(self) -> Any:
        r"""float(self)"""
        ...
    def __floor__(self) -> Any:
        r"""Flooring an Integral returns itself."""
        ...
    def __floordiv__(self, value: Any) -> Any:
        r"""Return self//value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Convert to a string according to format_spec."""
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getnewargs__(self) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __index__(self) -> Any:
        r"""Return self converted to an integer, if self is suitable for use as an index into a list."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __int__(self) -> Any:
        r"""int(self)"""
        ...
    def __invert__(self) -> Any:
        r"""~self"""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lshift__(self, value: Any) -> Any:
        r"""Return self<<value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __mod__(self, value: Any) -> Any:
        r"""Return self%value."""
        ...
    def __mul__(self, value: Any) -> Any:
        r"""Return self*value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __neg__(self) -> Any:
        r"""-self"""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __or__(self, value: Any) -> Any:
        r"""Return self|value."""
        ...
    def __pos__(self) -> Any:
        r"""+self"""
        ...
    def __pow__(self, value: Any, mod: Any = None) -> Any:
        r"""Return pow(self, value, mod)."""
        ...
    def __radd__(self, value: Any) -> Any:
        r"""Return value+self."""
        ...
    def __rand__(self, value: Any) -> Any:
        r"""Return value&self."""
        ...
    def __rdivmod__(self, value: Any) -> Any:
        r"""Return divmod(value, self)."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __rfloordiv__(self, value: Any) -> Any:
        r"""Return value//self."""
        ...
    def __rlshift__(self, value: Any) -> Any:
        r"""Return value<<self."""
        ...
    def __rmod__(self, value: Any) -> Any:
        r"""Return value%self."""
        ...
    def __rmul__(self, value: Any) -> Any:
        r"""Return value*self."""
        ...
    def __ror__(self, value: Any) -> Any:
        r"""Return value|self."""
        ...
    def __round__(self, *args: Any, **kwargs: Any) -> Any:
        r"""Rounding an Integral returns itself.
        
        Rounding with an ndigits argument also returns an integer.
        """
        ...
    def __rpow__(self, value: Any, mod: Any = None) -> Any:
        r"""Return pow(value, self, mod)."""
        ...
    def __rrshift__(self, value: Any) -> Any:
        r"""Return value>>self."""
        ...
    def __rshift__(self, value: Any) -> Any:
        r"""Return self>>value."""
        ...
    def __rsub__(self, value: Any) -> Any:
        r"""Return value-self."""
        ...
    def __rtruediv__(self, value: Any) -> Any:
        r"""Return value/self."""
        ...
    def __rxor__(self, value: Any) -> Any:
        r"""Return value^self."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Returns size in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __sub__(self, value: Any) -> Any:
        r"""Return self-value."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __truediv__(self, value: Any) -> Any:
        r"""Return self/value."""
        ...
    def __trunc__(self) -> Any:
        r"""Truncating an Integral returns itself."""
        ...
    def __xor__(self, value: Any) -> Any:
        r"""Return self^value."""
        ...
    def as_integer_ratio(self) -> Any:
        r"""Return a pair of integers, whose ratio is equal to the original int.
        
        The ratio is in lowest terms and has a positive denominator.
        
        >>> (10).as_integer_ratio()
        (10, 1)
        >>> (-10).as_integer_ratio()
        (-10, 1)
        >>> (0).as_integer_ratio()
        (0, 1)
        """
        ...
    def bit_count(self) -> Any:
        r"""Number of ones in the binary representation of the absolute value of self.
        
        Also known as the population count.
        
        >>> bin(13)
        '0b1101'
        >>> (13).bit_count()
        3
        """
        ...
    def bit_length(self) -> Any:
        r"""Number of bits necessary to represent self in binary.
        
        >>> bin(37)
        '0b100101'
        >>> (37).bit_length()
        6
        """
        ...
    def conjugate(self) -> Any:
        r"""Returns self, the complex conjugate of any int."""
        ...
    def from_bytes(self, bytes: Any, byteorder: Any = 'big', signed: Any = False) -> Any:
        r"""Return the integer represented by the given array of bytes.
        
          bytes
            Holds the array of bytes to convert.  The argument must either
            support the buffer protocol or be an iterable object producing bytes.
            Bytes and bytearray are examples of built-in objects that support the
            buffer protocol.
          byteorder
            The byte order used to represent the integer.  If byteorder is 'big',
            the most significant byte is at the beginning of the byte array.  If
            byteorder is 'little', the most significant byte is at the end of the
            byte array.  To request the native byte order of the host system, use
            sys.byteorder as the byte order value.  Default is to use 'big'.
          signed
            Indicates whether two's complement is used to represent the integer.
        """
        ...
    def is_integer(self) -> Any:
        r"""Returns True. Exists for duck type compatibility with float.is_integer."""
        ...
    def to_bytes(self, length: Any = 1, byteorder: Any = 'big', signed: Any = False) -> Any:
        r"""Return an array of bytes representing an integer.
        
          length
            Length of bytes object to use.  An OverflowError is raised if the
            integer is not representable with the given number of bytes.  Default
            is length 1.
          byteorder
            The byte order used to represent the integer.  If byteorder is 'big',
            the most significant byte is at the beginning of the byte array.  If
            byteorder is 'little', the most significant byte is at the end of the
            byte array.  To request the native byte order of the host system, use
            sys.byteorder as the byte order value.  Default is to use 'big'.
          signed
            Determines whether two's complement is used to represent the integer.
            If signed is False and a negative integer is given, an OverflowError
            is raised.
        """
        ...

class longlongvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: int64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: int64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: int64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: int64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class lowertype_helper_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def func_has_stkframe_hole(self, candidate: tinfo_t, candidate_data: func_type_data_t) -> bool:
        ...
    def get_func_purged_bytes(self, candidate: tinfo_t, candidate_data: func_type_data_t) -> int:
        ...

class lvar_locator_t:
    @property
    def defea(self) -> Any: ...
    @property
    def location(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lvar_locator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: lvar_locator_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: lvar_locator_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: lvar_locator_t) -> bool:
        ...
    def __lt__(self, r: lvar_locator_t) -> bool:
        ...
    def __ne__(self, r: lvar_locator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: lvar_locator_t) -> int:
        ...
    def get_reg1(self) -> mreg_t:
        r"""Get the register number of the variable.
        
        """
        ...
    def get_reg2(self) -> mreg_t:
        r"""Get the number of the second register (works only for ALOC_REG2 lvars)
        
        """
        ...
    def get_scattered(self) -> scattered_aloc_t:
        r"""Get information about scattered variable.
        
        """
        ...
    def get_stkoff(self) -> int:
        r"""Get offset of the varialbe in the stack frame. 
                
        :returns: a non-negative value for stack variables. The value is an offset from the bottom of the stack frame in terms of vd-offsets. negative values mean error (not a stack variable)
        """
        ...
    def is_reg1(self) -> bool:
        r"""Is variable located on one register?
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""Is variable located on two registers?
        
        """
        ...
    def is_reg_var(self) -> bool:
        r"""Is variable located on register(s)?
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""Is variable scattered?
        
        """
        ...
    def is_stk_var(self) -> bool:
        r"""Is variable located on the stack?
        
        """
        ...

class lvar_mapping_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: lvar_mapping_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: lvar_mapping_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class lvar_mapping_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: lvar_locator_t) -> lvar_locator_t:
        ...
    def size(self) -> int:
        ...

class lvar_ref_t:
    @property
    def idx(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def off(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lvar_ref_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: lvar_ref_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: lvar_ref_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: lvar_ref_t) -> bool:
        ...
    def __lt__(self, r: lvar_ref_t) -> bool:
        ...
    def __ne__(self, r: lvar_ref_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: lvar_ref_t) -> int:
        ...
    def swap(self, r: lvar_ref_t) -> None:
        ...
    def var(self) -> lvar_t:
        r"""Retrieve the referenced variable.
        
        """
        ...

class lvar_saved_info_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def ll(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lvar_saved_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: lvar_saved_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear_keep(self) -> None:
        ...
    def clr_nomap_lvar(self) -> None:
        ...
    def clr_noptr_lvar(self) -> None:
        ...
    def clr_split_lvar(self) -> None:
        ...
    def clr_unused_lvar(self) -> None:
        ...
    def has_info(self) -> bool:
        ...
    def is_kept(self) -> bool:
        ...
    def is_nomap_lvar(self) -> bool:
        ...
    def is_noptr_lvar(self) -> bool:
        ...
    def is_split_lvar(self) -> bool:
        ...
    def is_unused_lvar(self) -> bool:
        ...
    def set_keep(self) -> None:
        ...
    def set_nomap_lvar(self) -> None:
        ...
    def set_noptr_lvar(self) -> None:
        ...
    def set_split_lvar(self) -> None:
        ...
    def set_unused_lvar(self) -> None:
        ...

class lvar_saved_infos_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lvar_saved_infos_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> lvar_saved_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: lvar_saved_infos_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: lvar_saved_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: lvar_saved_info_t) -> bool:
        ...
    def append(self, args: Any) -> lvar_saved_info_t:
        ...
    def at(self, i: size_t) -> lvar_saved_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: lvar_saved_infos_t) -> None:
        ...
    def extract(self) -> lvar_saved_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: lvar_saved_info_t) -> bool:
        ...
    def inject(self, s: lvar_saved_info_t, len: size_t) -> None:
        ...
    def insert(self, it: lvar_saved_info_t, x: lvar_saved_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> lvar_saved_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: lvar_saved_infos_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class lvar_t(lvar_locator_t):
    @property
    def cmt(self) -> Any: ...
    @property
    def defblk(self) -> Any: ...
    @property
    def defea(self) -> Any: ...
    @property
    def divisor(self) -> Any: ...
    @property
    def has_nice_name(self) -> Any: ...
    @property
    def has_user_info(self) -> Any: ...
    @property
    def has_user_name(self) -> Any: ...
    @property
    def has_user_type(self) -> Any: ...
    @property
    def is_arg_var(self) -> Any: ...
    @property
    def is_fake_var(self) -> Any: ...
    @property
    def is_floating_var(self) -> Any: ...
    @property
    def is_mapdst_var(self) -> Any: ...
    @property
    def is_overlapped_var(self) -> Any: ...
    @property
    def is_result_var(self) -> Any: ...
    @property
    def is_spoiled_var(self) -> Any: ...
    @property
    def is_unknown_width(self) -> Any: ...
    @property
    def location(self) -> Any: ...
    @property
    def mreg_done(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def tif(self) -> Any: ...
    @property
    def typed(self) -> Any: ...
    @property
    def used(self) -> Any: ...
    @property
    def width(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: lvar_locator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: lvar_locator_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: lvar_locator_t) -> bool:
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: lvar_locator_t) -> bool:
        ...
    def __lt__(self, r: lvar_locator_t) -> bool:
        ...
    def __ne__(self, r: lvar_locator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def accepts_type(self, t: tinfo_t, may_change_thisarg: bool = False) -> bool:
        r"""Check if the variable accept the specified type. Some types are forbidden (void, function types, wrong arrays, etc) 
                
        """
        ...
    def append_list(self, mba: mba_t, lst: mlist_t, pad_if_scattered: bool = False) -> None:
        r"""Append local variable to mlist. 
                
        :param mba: ptr to the current mba_t
        :param lst: list to append to
        :param pad_if_scattered: if true, append padding bytes in case of scattered lvar
        """
        ...
    def clear_used(self) -> None:
        ...
    def clr_arg_var(self) -> None:
        ...
    def clr_automapped(self) -> None:
        ...
    def clr_decl_unused(self) -> None:
        ...
    def clr_dummy_arg(self) -> None:
        ...
    def clr_fake_var(self) -> None:
        ...
    def clr_floating_var(self) -> None:
        ...
    def clr_mapdst_var(self) -> None:
        ...
    def clr_mreg_done(self) -> None:
        ...
    def clr_noptr_var(self) -> None:
        ...
    def clr_notarg(self) -> None:
        ...
    def clr_overlapped_var(self) -> None:
        ...
    def clr_scattered_arg(self) -> None:
        ...
    def clr_shared(self) -> None:
        ...
    def clr_split_var(self) -> None:
        ...
    def clr_spoiled_var(self) -> None:
        ...
    def clr_thisarg(self) -> None:
        ...
    def clr_unknown_width(self) -> None:
        ...
    def clr_used_byref(self) -> None:
        ...
    def clr_user_info(self) -> None:
        ...
    def clr_user_name(self) -> None:
        ...
    def clr_user_type(self) -> None:
        ...
    def compare(self, r: lvar_locator_t) -> int:
        ...
    def get_reg1(self) -> mreg_t:
        r"""Get the register number of the variable.
        
        """
        ...
    def get_reg2(self) -> mreg_t:
        r"""Get the number of the second register (works only for ALOC_REG2 lvars)
        
        """
        ...
    def get_scattered(self) -> scattered_aloc_t:
        r"""Get information about scattered variable.
        
        """
        ...
    def get_stkoff(self) -> int:
        r"""Get offset of the varialbe in the stack frame. 
                
        :returns: a non-negative value for stack variables. The value is an offset from the bottom of the stack frame in terms of vd-offsets. negative values mean error (not a stack variable)
        """
        ...
    def has_common(self, v: lvar_t) -> bool:
        r"""Do variables overlap?
        
        """
        ...
    def has_common_bit(self, loc: vdloc_t, width2: asize_t) -> bool:
        r"""Does the variable overlap with the specified location?
        
        """
        ...
    def has_regname(self) -> bool:
        r"""Has a register name? (like _RAX)
        
        """
        ...
    def in_asm(self) -> bool:
        r"""Is variable used in an instruction translated into __asm?
        
        """
        ...
    def is_aliasable(self, mba: mba_t) -> bool:
        r"""Is the variable aliasable? 
                
        :param mba: ptr to the current mba_t Aliasable variables may be modified indirectly (through a pointer)
        """
        ...
    def is_automapped(self) -> bool:
        r"""Was the variable automatically mapped to another variable?
        
        """
        ...
    def is_decl_unused(self) -> bool:
        r"""Was declared as __unused by the user? See CVAR_UNUSED.
        
        """
        ...
    def is_dummy_arg(self) -> bool:
        r"""Is a dummy argument (added to fill a hole in the argument list)
        
        """
        ...
    def is_noptr_var(self) -> bool:
        r"""Variable type should not be a pointer.
        
        """
        ...
    def is_notarg(self) -> bool:
        r"""Is a local variable? (local variable cannot be an input argument)
        
        """
        ...
    def is_reg1(self) -> bool:
        r"""Is variable located on one register?
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""Is variable located on two registers?
        
        """
        ...
    def is_reg_var(self) -> bool:
        r"""Is variable located on register(s)?
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""Is variable scattered?
        
        """
        ...
    def is_shared(self) -> bool:
        r"""Is lvar mapped to several chains.
        
        """
        ...
    def is_split_var(self) -> bool:
        r"""Is a split variable?
        
        """
        ...
    def is_stk_var(self) -> bool:
        r"""Is variable located on the stack?
        
        """
        ...
    def is_thisarg(self) -> bool:
        r"""Is 'this' argument of a C++ member function?
        
        """
        ...
    def is_used_byref(self) -> bool:
        r"""Was the address of the variable taken?
        
        """
        ...
    def set_arg_var(self) -> None:
        ...
    def set_automapped(self) -> None:
        ...
    def set_decl_unused(self) -> None:
        ...
    def set_dummy_arg(self) -> None:
        ...
    def set_fake_var(self) -> None:
        ...
    def set_final_lvar_type(self, t: tinfo_t) -> None:
        r"""Set final variable type.
        
        """
        ...
    def set_floating_var(self) -> None:
        ...
    def set_lvar_type(self, t: tinfo_t, may_fail: bool = False) -> bool:
        r"""Set variable type Note: this function does not modify the idb, only the lvar instance in the memory. For permanent changes see modify_user_lvars() Also, the variable type is not considered as final by the decompiler and may be modified later by the type derivation. In some cases set_final_var_type() may work better, but it does not do persistent changes to the database neither. 
                
        :param t: new type
        :param may_fail: if false and type is bad, interr
        :returns: success
        """
        ...
    def set_mapdst_var(self) -> None:
        ...
    def set_mreg_done(self) -> None:
        ...
    def set_non_typed(self) -> None:
        ...
    def set_noptr_var(self) -> None:
        ...
    def set_notarg(self) -> None:
        ...
    def set_overlapped_var(self) -> None:
        ...
    def set_scattered_arg(self) -> None:
        ...
    def set_shared(self) -> None:
        ...
    def set_split_var(self) -> None:
        ...
    def set_spoiled_var(self) -> None:
        ...
    def set_thisarg(self) -> None:
        ...
    def set_typed(self) -> None:
        ...
    def set_unknown_width(self) -> None:
        ...
    def set_used(self) -> None:
        ...
    def set_used_byref(self) -> None:
        ...
    def set_user_name(self) -> None:
        ...
    def set_user_type(self) -> None:
        ...
    def set_width(self, w: int, svw_flags: int = 0) -> bool:
        r"""Change the variable width. We call the variable size 'width', it is represents the number of bytes. This function may change the variable type using set_lvar_type(). 
                
        :param w: new width
        :param svw_flags: combination of SVW_... bits
        :returns: success
        """
        ...
    def type(self) -> tinfo_t:
        r"""Get variable type.
        
        """
        ...
    def was_scattered_arg(self) -> bool:
        r"""Was lvar transformed from a scattered argument?
        
        """
        ...

class lvar_uservec_t:
    @property
    def lmaps(self) -> Any: ...
    @property
    def lvvec(self) -> Any: ...
    @property
    def stkoff_delta(self) -> Any: ...
    @property
    def ulv_flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def find_info(self, vloc: lvar_locator_t) -> lvar_saved_info_t:
        r"""find saved user settings for given var
        
        """
        ...
    def keep_info(self, v: lvar_t) -> None:
        r"""Preserve user settings for given var.
        
        """
        ...
    def swap(self, r: lvar_uservec_t) -> None:
        ...

class lvars_t(qvector_lvar_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_lvar_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> lvar_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_lvar_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: lvar_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: lvar_t) -> bool:
        ...
    def append(self, args: Any) -> lvar_t:
        ...
    def at(self, i: size_t) -> lvar_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_lvar_t) -> None:
        ...
    def extract(self) -> lvar_t:
        ...
    def find(self, ll: lvar_locator_t) -> lvar_t:
        r"""Find a variable at the specified location. 
                
        :param ll: variable location
        :returns: pointer to variable or nullptr
        """
        ...
    def find_input_lvar(self, argloc: vdloc_t, _size: int) -> int:
        r"""Find an input variable at the specified location. 
                
        :param argloc: variable location
        :param _size: variable size in bytes
        :returns: -1 if failed, otherwise an index into 'vars'
        """
        ...
    def find_input_reg(self, reg: int, _size: int = 1) -> int:
        r"""Find an input register variable. 
                
        :param reg: register to find
        :param _size: variable size in bytes
        :returns: -1 if failed, otherwise an index into 'vars'
        """
        ...
    def find_lvar(self, location: vdloc_t, width: int, defblk: int = -1) -> int:
        r"""Find a variable at the specified location. 
                
        :param location: variable location
        :param width: variable size in bytes
        :param defblk: definition block of the lvar. -1 means any block
        :returns: -1 if failed, otherwise an index into 'vars'
        """
        ...
    def find_stkvar(self, spoff: int, width: int) -> int:
        r"""Find a stack variable at the specified location. 
                
        :param spoff: offset from the minimal sp
        :param width: variable size in bytes
        :returns: -1 if failed, otherwise an index into 'vars'
        """
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: lvar_t) -> bool:
        ...
    def inject(self, s: lvar_t, len: size_t) -> None:
        ...
    def insert(self, it: lvar_t, x: lvar_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> lvar_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_lvar_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class macro_constructor_t:
    @property
    def reserved(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def build_macro(self, insn: insn_t, may_go_forward: bool) -> bool:
        r"""Try to extend the instruction.
        This function may modify 'insn' and return false; these changes will be accepted by the kernel but the instruction will not be considered as a macro.
        
        :param insn: Instruction to modify, usually the first instruction of the macro
        :param may_go_forward: Is it ok to consider the next instruction for the macro? This argument may be false, for example, if there is a cross reference to the end of INSN. In this case creating a macro is not desired. However, it may still be useful to perform minor tweaks to the instruction using the information about the surrounding instructions.
        :returns: true if created an macro instruction.
        """
        ...
    def construct_macro(self, insn: insn_t, enable: bool) -> bool:
        r"""Construct a macro instruction. This function may be called from ana() to generate a macro instruction.
        The real work is done by the 'build_macro()' virtual function. It must be defined by the processor module.
        construct_macro() modifies the database using the info provided by build_macro(). It verifies if the instruction can really be created (for example, that other items do not hinder), may plan to reanalyze the macro, etc. If the macro instructions are disabled by the user, construct_macro() will destroy the macro instruction. Note: if INSN_MODMAC is not set in insn.flags, the database will not be modified.
        
        :param insn: the instruction to modify into a macro
        :param enable: enable macro generation
        :returns: true: the macro instruction is generated in 'insn'
        :returns: false: did not create a macro
        """
        ...

class mba_range_iterator_t:
    @property
    def fii(self) -> Any: ...
    @property
    def rii(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def chunk(self) -> range_t:
        ...
    def is_snippet(self) -> bool:
        ...
    def next(self) -> bool:
        ...
    def set(self, mbr: mba_ranges_t) -> bool:
        ...

class mba_ranges_t:
    @property
    def pfn(self) -> Any: ...
    @property
    def ranges(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def is_fragmented(self) -> bool:
        ...
    def is_snippet(self) -> bool:
        ...
    def start(self) -> ida_idaapi.ea_t:
        ...

class mba_t:
    @property
    def aliased_memory(self) -> Any: ...
    @property
    def argidx(self) -> Any: ...
    @property
    def blocks(self) -> Any: ...
    @property
    def cc(self) -> Any: ...
    @property
    def consumed_argregs(self) -> Any: ...
    @property
    def entry_ea(self) -> Any: ...
    @property
    def error_ea(self) -> Any: ...
    @property
    def error_strarg(self) -> Any: ...
    @property
    def final_type(self) -> Any: ...
    @property
    def first_epilog_ea(self) -> Any: ...
    @property
    def fpd(self) -> Any: ...
    @property
    def frregs(self) -> Any: ...
    @property
    def frsize(self) -> Any: ...
    @property
    def fti_flags(self) -> Any: ...
    @property
    def fullsize(self) -> Any: ...
    @property
    def gotoff_stkvars(self) -> Any: ...
    @property
    def idb_node(self) -> Any: ...
    @property
    def idb_spoiled(self) -> Any: ...
    @property
    def idb_type(self) -> Any: ...
    @property
    def inargoff(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def last_prolog_ea(self) -> Any: ...
    @property
    def maturity(self) -> Any: ...
    @property
    def mbr(self) -> Any: ...
    @property
    def minargref(self) -> Any: ...
    @property
    def minstkref(self) -> Any: ...
    @property
    def minstkref_ea(self) -> Any: ...
    @property
    def natural(self) -> Any: ...
    @property
    def nodel_memory(self) -> Any: ...
    @property
    def notes(self) -> Any: ...
    @property
    def npurged(self) -> Any: ...
    @property
    def occurred_warns(self) -> Any: ...
    @property
    def pfn_flags(self) -> Any: ...
    @property
    def qty(self) -> Any: ...
    @property
    def reqmat(self) -> Any: ...
    @property
    def restricted_memory(self) -> Any: ...
    @property
    def retsize(self) -> Any: ...
    @property
    def retvaridx(self) -> Any: ...
    @property
    def shadow_args(self) -> Any: ...
    @property
    def spd_adjust(self) -> Any: ...
    @property
    def spoiled_list(self) -> Any: ...
    @property
    def stacksize(self) -> Any: ...
    @property
    def std_ivls(self) -> Any: ...
    @property
    def tmpstk_size(self) -> Any: ...
    @property
    def vars(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def alloc_fict_ea(self, real_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Allocate a fictional address. This function can be used to allocate a new unique address for a new instruction, if re-using any existing address leads to conflicts. For example, if the last instruction of the function modifies R0 and falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end of the function start of another function In this case R0 generates two different lvars at the same address:
        * one modified by LDM
        * another that represents the return value from the tail call
        
        
        Another example: a third-party plugin makes a copy of an instruction. This may lead to the generation of two variables at the same address. Example 3: fictional addresses can be used for new instructions created while modifying the microcode. This function can be used to allocate a new unique address for a new instruction or a variable. The fictional address is selected from an unallocated address range. 
                
        :param real_ea: real instruction address (BADADDR is ok too)
        :returns: a unique fictional address
        """
        ...
    def alloc_kreg(self, size: size_t, check_size: bool = True) -> mreg_t:
        r"""Allocate a kernel register. 
                
        :param size: size of the register in bytes
        :param check_size: if true, only the sizes that correspond to a size of a basic type will be accepted.
        :returns: allocated register. mr_none means failure.
        """
        ...
    def alloc_lvars(self) -> None:
        r"""Allocate local variables. Must be called only immediately after optimize_global(), with no modifications to the microcode. Converts registers, stack variables, and similar operands into mop_l. This call will not fail because all necessary checks were performed in optimize_global(). After this call the microcode reaches its final state. 
                
        """
        ...
    def analyze_calls(self, acflags: int) -> int:
        r"""Analyze calls and determine calling conventions. 
                
        :param acflags: permitted actions that are necessary for successful detection of calling conventions. See Bits for analyze_calls()
        :returns: number of calls. -1 means error.
        """
        ...
    def arg(self, n: int) -> lvar_t:
        r"""Get input argument of the decompiled function. 
                
        :param n: argument number (0..nargs-1)
        """
        ...
    def argbase(self) -> int:
        ...
    def argidx_ok(self) -> bool:
        ...
    def argidx_sorted(self) -> bool:
        ...
    def bad_call_sp_detected(self) -> bool:
        ...
    def build_graph(self) -> merror_t:
        r"""Build control flow graph. This function may be called only once. It calculates the type of each basic block and the adjacency list. optimize_local() calls this function if necessary. You need to call this function only before MMAT_LOCOPT. 
                
        :returns: error code
        """
        ...
    def calc_shins_flags(self) -> int:
        ...
    def callinfo_built(self) -> bool:
        ...
    def chain_varnums_ok(self) -> bool:
        ...
    def clr_cdtr(self) -> None:
        ...
    def clr_mba_flags(self, f: int) -> None:
        ...
    def clr_mba_flags2(self, f: int) -> None:
        ...
    def code16_bit_removed(self) -> bool:
        ...
    def common_stkvars_stkargs(self) -> bool:
        ...
    def copy_block(self, blk: mblock_t, new_serial: int, cpblk_flags: int = 3) -> mblock_t:
        r"""Make a copy of a block. This function makes a simple copy of the block. It does not fix the predecessor and successor lists, they must be fixed if necessary. 
                
        :param blk: block to copy
        :param new_serial: position of the copied block
        :param cpblk_flags: combination of Batch decompilation bits... bits
        :returns: pointer to the new copy
        """
        ...
    def create_helper_call(self, ea: ida_idaapi.ea_t, helper: str, rettype: tinfo_t = None, callargs: mcallargs_t = None, out: mop_t = None) -> minsn_t:
        r"""Create a call of a helper function. 
                
        :param ea: The desired address of the instruction
        :param helper: The helper name
        :param rettype: The return type (nullptr or empty type means 'void')
        :param callargs: The helper arguments (nullptr-no arguments)
        :param out: The operand where the call result should be stored. If this argument is not nullptr, "mov helper_call(), out" will be generated. Otherwise "call helper()" will be generated. Note: the size of this operand must be equal to the RETTYPE size
        :returns: pointer to the created instruction or nullptr if error
        """
        ...
    def deleted_pairs(self) -> bool:
        ...
    def deserialize(self, bytes: uchar) -> mba_t:
        r"""Deserialize a byte sequence into mbl array. 
                
        :param bytes: pointer to the beginning of the byte sequence.
        :returns: new mbl array
        """
        ...
    def display_numaddrs(self) -> bool:
        ...
    def display_valnums(self) -> bool:
        ...
    def dump(self) -> None:
        r"""Dump microcode to a file. The file will be created in the directory pointed by IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger. 
                
        """
        ...
    def dump_mba(self, _verify: bool, title: str) -> None:
        ...
    def find_mop(self, ctx: op_parent_info_t, ea: ida_idaapi.ea_t, is_dest: bool, list: mlist_t) -> mop_t:
        r"""Find an operand in the microcode. This function tries to find the operand that matches LIST. Any operand that overlaps with LIST is considered as a match. 
                
        :param ctx: context information for the result
        :param ea: desired address of the operand. BADADDR means to accept any address.
        :param is_dest: search for destination operand? this argument may be ignored if the exact match could not be found
        :param list: list of locations the correspond to the operand
        :returns: pointer to the operand or nullptr.
        """
        ...
    def for_all_insns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all instructions. This function visits all instruction and subinstructions. 
                
        :param mv: instruction visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def for_all_ops(self, mv: mop_visitor_t) -> int:
        r"""Visit all operands of all instructions. 
                
        :param mv: operand visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def for_all_topinsns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all top level instructions. 
                
        :param mv: instruction visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def free_kreg(self, reg: mreg_t, size: size_t) -> None:
        r"""Free a kernel register. If wrong arguments are passed, this function will generate an internal error. 
                
        :param reg: a previously allocated kernel register
        :param size: size of the register in bytes
        """
        ...
    def generated_asserts(self) -> bool:
        ...
    def get_args_region(self) -> ivl_t:
        ...
    def get_curfunc(self) -> func_t:
        ...
    def get_func_output_lists(self, args: Any) -> None:
        r"""Prepare the lists of registers & memory that are defined/killed by a function 
                
        :param return_regs: defined regs to return (eax,edx)
        :param spoiled: spoiled regs (flags,ecx,mem)
        :param type: the function type
        :param call_ea: the call insn address (if known)
        :param tail_call: is it the tail call?
        """
        ...
    def get_graph(self) -> mbl_graph_t:
        r"""Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT. 
                
        """
        ...
    def get_ida_argloc(self, v: lvar_t) -> argloc_t:
        ...
    def get_lvars_region(self) -> ivl_t:
        ...
    def get_mba_flags(self) -> int:
        ...
    def get_mba_flags2(self) -> int:
        ...
    def get_mblock(self, n: uint) -> mblock_t:
        r"""Get basic block by its serial number.
        
        """
        ...
    def get_shadow_region(self) -> ivl_t:
        ...
    def get_stack_region(self) -> ivl_t:
        ...
    def get_std_region(self, idx: memreg_index_t) -> ivl_t:
        r"""Get information about various memory regions. We map the stack frame to the global memory, to some unused range. 
                
        """
        ...
    def graph_insns(self) -> bool:
        ...
    def has_bad_sp(self) -> bool:
        ...
    def has_outlines(self) -> bool:
        ...
    def has_over_chains(self) -> bool:
        ...
    def has_passregs(self) -> bool:
        ...
    def has_stack_retval(self) -> bool:
        ...
    def idaloc2vd(self, loc: argloc_t, width: int) -> vdloc_t:
        ...
    def inline_func(self, cdg: codegen_t, blknum: int, ranges: mba_ranges_t, decomp_flags: int = 0, inline_flags: int = 0) -> merror_t:
        r"""Inline a range. This function may be called only during the initial microcode generation phase. 
                
        :param cdg: the codegenerator object
        :param blknum: the block contaning the call/jump instruction to inline
        :param ranges: the set of ranges to inline. in the case of multiple calls to inline_func(), ranges will be compared using their start addresses. if two ranges have the same address, they will be considered the same.
        :param decomp_flags: combination of decompile() flags bits
        :param inline_flags: combination of inline_func() flags bits
        :returns: error code
        """
        ...
    def insert_block(self, bblk: int) -> mblock_t:
        r"""Insert a block in the middle of the mbl array. The very first block of microcode must be empty, it is the entry block. The very last block of microcode must be BLT_STOP, it is the exit block. Therefore inserting a new block before the entry point or after the exit block is not a good idea. 
                
        :param bblk: the new block will be inserted before BBLK
        :returns: ptr to the new block
        """
        ...
    def is_cdtr(self) -> bool:
        ...
    def is_ctr(self) -> bool:
        ...
    def is_dtr(self) -> bool:
        ...
    def is_pattern(self) -> bool:
        ...
    def is_snippet(self) -> bool:
        ...
    def is_stkarg(self, v: lvar_t) -> bool:
        ...
    def is_thunk(self) -> bool:
        ...
    def loaded_gdl(self) -> bool:
        ...
    def locate_stkpnt(self, ea: ida_idaapi.ea_t) -> stkpnt_t:
        ...
    def lvar_names_ok(self) -> bool:
        ...
    def lvars_allocated(self) -> bool:
        ...
    def lvars_renamed(self) -> bool:
        ...
    def map_fict_ea(self, fict_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Resolve a fictional address. This function provides a reverse of the mapping made by alloc_fict_ea(). 
                
        :param fict_ea: fictional definition address
        :returns: the real instruction address
        """
        ...
    def mark_chains_dirty(self) -> None:
        r"""Mark the microcode use-def chains dirty. Call this function is any inter-block data dependencies got changed because of your modifications to the microcode. Failing to do so may cause an internal error. 
                
        """
        ...
    def may_refine_rettype(self) -> bool:
        ...
    def merge_blocks(self) -> bool:
        r"""Merge blocks. This function merges blocks constituting linear flow. It calls remove_empty_and_unreachable_blocks() as well. 
                
        :returns: true if changed any blocks
        """
        ...
    def optimize_global(self) -> merror_t:
        r"""Optimize microcode globally. This function applies various optimization methods until we reach the fixed point. After that it preallocates lvars unless reqmat forbids it. 
                
        :returns: error code
        """
        ...
    def optimize_local(self, locopt_bits: int) -> int:
        r"""Optimize each basic block locally 
                
        :param locopt_bits: combination of Bits for optimize_local() bits
        :returns: number of changes. 0 means nothing changed This function is called by the decompiler, usually there is no need to call it explicitly.
        """
        ...
    def optimized(self) -> bool:
        ...
    def precise_defeas(self) -> bool:
        ...
    def prop_complex(self) -> bool:
        ...
    def propagated_asserts(self) -> bool:
        ...
    def really_alloc(self) -> bool:
        ...
    def regargs_is_not_aligned(self) -> bool:
        ...
    def remove_block(self, blk: mblock_t) -> bool:
        r"""Delete a block. 
                
        :param blk: block to delete
        :returns: true if at least one of the other blocks became empty or unreachable
        """
        ...
    def remove_blocks(self, start_blk: int, end_blk: int) -> bool:
        ...
    def remove_empty_and_unreachable_blocks(self) -> bool:
        r"""Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be deleted. 
                
        """
        ...
    def returns_fpval(self) -> bool:
        ...
    def rtype_refined(self) -> bool:
        ...
    def save_snapshot(self, description: str) -> None:
        r"""Create and save microcode snapshot.
        
        """
        ...
    def saverest_done(self) -> bool:
        ...
    def serialize(self) -> None:
        r"""Serialize mbl array into a sequence of bytes.
        
        """
        ...
    def set_lvar_name(self, v: lvar_t, name: str, flagbits: int) -> bool:
        ...
    def set_maturity(self, mat: mba_maturity_t) -> merror_t:
        r"""Set maturity level. 
                
        :param mat: new maturity level
        :returns: error code Plugins may use this function to skip some parts of the analysis. The maturity level cannot be decreased.
        """
        ...
    def set_mba_flags(self, f: int) -> None:
        ...
    def set_mba_flags2(self, f: int) -> None:
        ...
    def set_nice_lvar_name(self, v: lvar_t, name: str) -> bool:
        ...
    def set_user_lvar_name(self, v: lvar_t, name: str) -> bool:
        ...
    def short_display(self) -> bool:
        ...
    def should_beautify(self) -> bool:
        ...
    def show_reduction(self) -> bool:
        ...
    def split_block(self, blk: mblock_t, start_insn: minsn_t) -> mblock_t:
        r"""Split a block: insert a new one after the block, move some instructions to new block 
                
        :param blk: block to be split
        :param start_insn: all instructions to be moved to new block: starting with this one up to the end
        :returns: ptr to the new block
        """
        ...
    def stkoff_ida2vd(self, off: int) -> int:
        ...
    def stkoff_vd2ida(self, off: int) -> int:
        ...
    def term(self) -> None:
        ...
    def use_frame(self) -> bool:
        ...
    def use_wingraph32(self) -> bool:
        ...
    def valranges_done(self) -> bool:
        ...
    def vd2idaloc(self, args: Any) -> argloc_t:
        r"""This function has the following signatures:
        
            0. vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
            1. vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t
        
        # 0: vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
        
        
        # 1: vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t
        
        
        """
        ...
    def verify(self, always: bool) -> None:
        r"""Verify microcode consistency. 
                
        :param always: if false, the check will be performed only if ida runs under debugger If any inconsistency is discovered, an internal error will be generated. We strongly recommend you to call this function before returing control to the decompiler from your callbacks, in the case if you modified the microcode. If the microcode is inconsistent, this function will generate an internal error. We provide the source code of this function in the plugins/hexrays_sdk/verifier directory for your reference.
        """
        ...
    def write_to_const_detected(self) -> bool:
        ...

class mbl_array_t:
    @property
    def aliased_memory(self) -> Any: ...
    @property
    def argidx(self) -> Any: ...
    @property
    def blocks(self) -> Any: ...
    @property
    def cc(self) -> Any: ...
    @property
    def consumed_argregs(self) -> Any: ...
    @property
    def entry_ea(self) -> Any: ...
    @property
    def error_ea(self) -> Any: ...
    @property
    def error_strarg(self) -> Any: ...
    @property
    def final_type(self) -> Any: ...
    @property
    def first_epilog_ea(self) -> Any: ...
    @property
    def fpd(self) -> Any: ...
    @property
    def frregs(self) -> Any: ...
    @property
    def frsize(self) -> Any: ...
    @property
    def fti_flags(self) -> Any: ...
    @property
    def fullsize(self) -> Any: ...
    @property
    def gotoff_stkvars(self) -> Any: ...
    @property
    def idb_node(self) -> Any: ...
    @property
    def idb_spoiled(self) -> Any: ...
    @property
    def idb_type(self) -> Any: ...
    @property
    def inargoff(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def last_prolog_ea(self) -> Any: ...
    @property
    def maturity(self) -> Any: ...
    @property
    def mbr(self) -> Any: ...
    @property
    def minargref(self) -> Any: ...
    @property
    def minstkref(self) -> Any: ...
    @property
    def minstkref_ea(self) -> Any: ...
    @property
    def natural(self) -> Any: ...
    @property
    def nodel_memory(self) -> Any: ...
    @property
    def notes(self) -> Any: ...
    @property
    def npurged(self) -> Any: ...
    @property
    def occurred_warns(self) -> Any: ...
    @property
    def pfn_flags(self) -> Any: ...
    @property
    def qty(self) -> Any: ...
    @property
    def reqmat(self) -> Any: ...
    @property
    def restricted_memory(self) -> Any: ...
    @property
    def retsize(self) -> Any: ...
    @property
    def retvaridx(self) -> Any: ...
    @property
    def shadow_args(self) -> Any: ...
    @property
    def spd_adjust(self) -> Any: ...
    @property
    def spoiled_list(self) -> Any: ...
    @property
    def stacksize(self) -> Any: ...
    @property
    def std_ivls(self) -> Any: ...
    @property
    def tmpstk_size(self) -> Any: ...
    @property
    def vars(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def alloc_fict_ea(self, real_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Allocate a fictional address. This function can be used to allocate a new unique address for a new instruction, if re-using any existing address leads to conflicts. For example, if the last instruction of the function modifies R0 and falls through to the next function, it will be a tail call: LDM R0!, {R4,R7} end of the function start of another function In this case R0 generates two different lvars at the same address:
        * one modified by LDM
        * another that represents the return value from the tail call
        
        
        Another example: a third-party plugin makes a copy of an instruction. This may lead to the generation of two variables at the same address. Example 3: fictional addresses can be used for new instructions created while modifying the microcode. This function can be used to allocate a new unique address for a new instruction or a variable. The fictional address is selected from an unallocated address range. 
                
        :param real_ea: real instruction address (BADADDR is ok too)
        :returns: a unique fictional address
        """
        ...
    def alloc_kreg(self, size: size_t, check_size: bool = True) -> mreg_t:
        r"""Allocate a kernel register. 
                
        :param size: size of the register in bytes
        :param check_size: if true, only the sizes that correspond to a size of a basic type will be accepted.
        :returns: allocated register. mr_none means failure.
        """
        ...
    def alloc_lvars(self) -> None:
        r"""Allocate local variables. Must be called only immediately after optimize_global(), with no modifications to the microcode. Converts registers, stack variables, and similar operands into mop_l. This call will not fail because all necessary checks were performed in optimize_global(). After this call the microcode reaches its final state. 
                
        """
        ...
    def analyze_calls(self, acflags: int) -> int:
        r"""Analyze calls and determine calling conventions. 
                
        :param acflags: permitted actions that are necessary for successful detection of calling conventions. See Bits for analyze_calls()
        :returns: number of calls. -1 means error.
        """
        ...
    def arg(self, n: int) -> lvar_t:
        r"""Get input argument of the decompiled function. 
                
        :param n: argument number (0..nargs-1)
        """
        ...
    def argbase(self) -> int:
        ...
    def argidx_ok(self) -> bool:
        ...
    def argidx_sorted(self) -> bool:
        ...
    def bad_call_sp_detected(self) -> bool:
        ...
    def build_graph(self) -> merror_t:
        r"""Build control flow graph. This function may be called only once. It calculates the type of each basic block and the adjacency list. optimize_local() calls this function if necessary. You need to call this function only before MMAT_LOCOPT. 
                
        :returns: error code
        """
        ...
    def calc_shins_flags(self) -> int:
        ...
    def callinfo_built(self) -> bool:
        ...
    def chain_varnums_ok(self) -> bool:
        ...
    def clr_cdtr(self) -> None:
        ...
    def clr_mba_flags(self, f: int) -> None:
        ...
    def clr_mba_flags2(self, f: int) -> None:
        ...
    def code16_bit_removed(self) -> bool:
        ...
    def common_stkvars_stkargs(self) -> bool:
        ...
    def copy_block(self, blk: mblock_t, new_serial: int, cpblk_flags: int = 3) -> mblock_t:
        r"""Make a copy of a block. This function makes a simple copy of the block. It does not fix the predecessor and successor lists, they must be fixed if necessary. 
                
        :param blk: block to copy
        :param new_serial: position of the copied block
        :param cpblk_flags: combination of Batch decompilation bits... bits
        :returns: pointer to the new copy
        """
        ...
    def create_helper_call(self, ea: ida_idaapi.ea_t, helper: str, rettype: tinfo_t = None, callargs: mcallargs_t = None, out: mop_t = None) -> minsn_t:
        r"""Create a call of a helper function. 
                
        :param ea: The desired address of the instruction
        :param helper: The helper name
        :param rettype: The return type (nullptr or empty type means 'void')
        :param callargs: The helper arguments (nullptr-no arguments)
        :param out: The operand where the call result should be stored. If this argument is not nullptr, "mov helper_call(), out" will be generated. Otherwise "call helper()" will be generated. Note: the size of this operand must be equal to the RETTYPE size
        :returns: pointer to the created instruction or nullptr if error
        """
        ...
    def deleted_pairs(self) -> bool:
        ...
    def deserialize(self, bytes: uchar) -> mba_t:
        r"""Deserialize a byte sequence into mbl array. 
                
        :param bytes: pointer to the beginning of the byte sequence.
        :returns: new mbl array
        """
        ...
    def display_numaddrs(self) -> bool:
        ...
    def display_valnums(self) -> bool:
        ...
    def dump(self) -> None:
        r"""Dump microcode to a file. The file will be created in the directory pointed by IDA_DUMPDIR envvar. Dump will be created only if IDA is run under debugger. 
                
        """
        ...
    def dump_mba(self, _verify: bool, title: str) -> None:
        ...
    def find_mop(self, ctx: op_parent_info_t, ea: ida_idaapi.ea_t, is_dest: bool, list: mlist_t) -> mop_t:
        r"""Find an operand in the microcode. This function tries to find the operand that matches LIST. Any operand that overlaps with LIST is considered as a match. 
                
        :param ctx: context information for the result
        :param ea: desired address of the operand. BADADDR means to accept any address.
        :param is_dest: search for destination operand? this argument may be ignored if the exact match could not be found
        :param list: list of locations the correspond to the operand
        :returns: pointer to the operand or nullptr.
        """
        ...
    def for_all_insns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all instructions. This function visits all instruction and subinstructions. 
                
        :param mv: instruction visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def for_all_ops(self, mv: mop_visitor_t) -> int:
        r"""Visit all operands of all instructions. 
                
        :param mv: operand visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def for_all_topinsns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all top level instructions. 
                
        :param mv: instruction visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def free_kreg(self, reg: mreg_t, size: size_t) -> None:
        r"""Free a kernel register. If wrong arguments are passed, this function will generate an internal error. 
                
        :param reg: a previously allocated kernel register
        :param size: size of the register in bytes
        """
        ...
    def generated_asserts(self) -> bool:
        ...
    def get_args_region(self) -> ivl_t:
        ...
    def get_curfunc(self) -> func_t:
        ...
    def get_func_output_lists(self, args: Any) -> None:
        r"""Prepare the lists of registers & memory that are defined/killed by a function 
                
        :param return_regs: defined regs to return (eax,edx)
        :param spoiled: spoiled regs (flags,ecx,mem)
        :param type: the function type
        :param call_ea: the call insn address (if known)
        :param tail_call: is it the tail call?
        """
        ...
    def get_graph(self) -> mbl_graph_t:
        r"""Get control graph. Call build_graph() if you need the graph before MMAT_LOCOPT. 
                
        """
        ...
    def get_ida_argloc(self, v: lvar_t) -> argloc_t:
        ...
    def get_lvars_region(self) -> ivl_t:
        ...
    def get_mba_flags(self) -> int:
        ...
    def get_mba_flags2(self) -> int:
        ...
    def get_mblock(self, n: uint) -> mblock_t:
        r"""Get basic block by its serial number.
        
        """
        ...
    def get_shadow_region(self) -> ivl_t:
        ...
    def get_stack_region(self) -> ivl_t:
        ...
    def get_std_region(self, idx: memreg_index_t) -> ivl_t:
        r"""Get information about various memory regions. We map the stack frame to the global memory, to some unused range. 
                
        """
        ...
    def graph_insns(self) -> bool:
        ...
    def has_bad_sp(self) -> bool:
        ...
    def has_outlines(self) -> bool:
        ...
    def has_over_chains(self) -> bool:
        ...
    def has_passregs(self) -> bool:
        ...
    def has_stack_retval(self) -> bool:
        ...
    def idaloc2vd(self, loc: argloc_t, width: int) -> vdloc_t:
        ...
    def inline_func(self, cdg: codegen_t, blknum: int, ranges: mba_ranges_t, decomp_flags: int = 0, inline_flags: int = 0) -> merror_t:
        r"""Inline a range. This function may be called only during the initial microcode generation phase. 
                
        :param cdg: the codegenerator object
        :param blknum: the block contaning the call/jump instruction to inline
        :param ranges: the set of ranges to inline. in the case of multiple calls to inline_func(), ranges will be compared using their start addresses. if two ranges have the same address, they will be considered the same.
        :param decomp_flags: combination of decompile() flags bits
        :param inline_flags: combination of inline_func() flags bits
        :returns: error code
        """
        ...
    def insert_block(self, bblk: int) -> mblock_t:
        r"""Insert a block in the middle of the mbl array. The very first block of microcode must be empty, it is the entry block. The very last block of microcode must be BLT_STOP, it is the exit block. Therefore inserting a new block before the entry point or after the exit block is not a good idea. 
                
        :param bblk: the new block will be inserted before BBLK
        :returns: ptr to the new block
        """
        ...
    def is_cdtr(self) -> bool:
        ...
    def is_ctr(self) -> bool:
        ...
    def is_dtr(self) -> bool:
        ...
    def is_pattern(self) -> bool:
        ...
    def is_snippet(self) -> bool:
        ...
    def is_stkarg(self, v: lvar_t) -> bool:
        ...
    def is_thunk(self) -> bool:
        ...
    def loaded_gdl(self) -> bool:
        ...
    def locate_stkpnt(self, ea: ida_idaapi.ea_t) -> stkpnt_t:
        ...
    def lvar_names_ok(self) -> bool:
        ...
    def lvars_allocated(self) -> bool:
        ...
    def lvars_renamed(self) -> bool:
        ...
    def map_fict_ea(self, fict_ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Resolve a fictional address. This function provides a reverse of the mapping made by alloc_fict_ea(). 
                
        :param fict_ea: fictional definition address
        :returns: the real instruction address
        """
        ...
    def mark_chains_dirty(self) -> None:
        r"""Mark the microcode use-def chains dirty. Call this function is any inter-block data dependencies got changed because of your modifications to the microcode. Failing to do so may cause an internal error. 
                
        """
        ...
    def may_refine_rettype(self) -> bool:
        ...
    def merge_blocks(self) -> bool:
        r"""Merge blocks. This function merges blocks constituting linear flow. It calls remove_empty_and_unreachable_blocks() as well. 
                
        :returns: true if changed any blocks
        """
        ...
    def optimize_global(self) -> merror_t:
        r"""Optimize microcode globally. This function applies various optimization methods until we reach the fixed point. After that it preallocates lvars unless reqmat forbids it. 
                
        :returns: error code
        """
        ...
    def optimize_local(self, locopt_bits: int) -> int:
        r"""Optimize each basic block locally 
                
        :param locopt_bits: combination of Bits for optimize_local() bits
        :returns: number of changes. 0 means nothing changed This function is called by the decompiler, usually there is no need to call it explicitly.
        """
        ...
    def optimized(self) -> bool:
        ...
    def precise_defeas(self) -> bool:
        ...
    def prop_complex(self) -> bool:
        ...
    def propagated_asserts(self) -> bool:
        ...
    def really_alloc(self) -> bool:
        ...
    def regargs_is_not_aligned(self) -> bool:
        ...
    def remove_block(self, blk: mblock_t) -> bool:
        r"""Delete a block. 
                
        :param blk: block to delete
        :returns: true if at least one of the other blocks became empty or unreachable
        """
        ...
    def remove_blocks(self, start_blk: int, end_blk: int) -> bool:
        ...
    def remove_empty_and_unreachable_blocks(self) -> bool:
        r"""Delete all empty and unreachable blocks. Blocks marked with MBL_KEEP won't be deleted. 
                
        """
        ...
    def returns_fpval(self) -> bool:
        ...
    def rtype_refined(self) -> bool:
        ...
    def save_snapshot(self, description: str) -> None:
        r"""Create and save microcode snapshot.
        
        """
        ...
    def saverest_done(self) -> bool:
        ...
    def serialize(self) -> None:
        r"""Serialize mbl array into a sequence of bytes.
        
        """
        ...
    def set_lvar_name(self, v: lvar_t, name: str, flagbits: int) -> bool:
        ...
    def set_maturity(self, mat: mba_maturity_t) -> merror_t:
        r"""Set maturity level. 
                
        :param mat: new maturity level
        :returns: error code Plugins may use this function to skip some parts of the analysis. The maturity level cannot be decreased.
        """
        ...
    def set_mba_flags(self, f: int) -> None:
        ...
    def set_mba_flags2(self, f: int) -> None:
        ...
    def set_nice_lvar_name(self, v: lvar_t, name: str) -> bool:
        ...
    def set_user_lvar_name(self, v: lvar_t, name: str) -> bool:
        ...
    def short_display(self) -> bool:
        ...
    def should_beautify(self) -> bool:
        ...
    def show_reduction(self) -> bool:
        ...
    def split_block(self, blk: mblock_t, start_insn: minsn_t) -> mblock_t:
        r"""Split a block: insert a new one after the block, move some instructions to new block 
                
        :param blk: block to be split
        :param start_insn: all instructions to be moved to new block: starting with this one up to the end
        :returns: ptr to the new block
        """
        ...
    def stkoff_ida2vd(self, off: int) -> int:
        ...
    def stkoff_vd2ida(self, off: int) -> int:
        ...
    def term(self) -> None:
        ...
    def use_frame(self) -> bool:
        ...
    def use_wingraph32(self) -> bool:
        ...
    def valranges_done(self) -> bool:
        ...
    def vd2idaloc(self, args: Any) -> argloc_t:
        r"""This function has the following signatures:
        
            0. vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
            1. vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t
        
        # 0: vd2idaloc(loc: const vdloc_t &, width: int) -> argloc_t
        
        
        # 1: vd2idaloc(loc: const vdloc_t &, width: int, spd: int) -> argloc_t
        
        
        """
        ...
    def verify(self, always: bool) -> None:
        r"""Verify microcode consistency. 
                
        :param always: if false, the check will be performed only if ida runs under debugger If any inconsistency is discovered, an internal error will be generated. We strongly recommend you to call this function before returing control to the decompiler from your callbacks, in the case if you modified the microcode. If the microcode is inconsistent, this function will generate an internal error. We provide the source code of this function in the plugins/hexrays_sdk/verifier directory for your reference.
        """
        ...
    def write_to_const_detected(self) -> bool:
        ...

class mbl_graph_t(simple_graph_t, gdl_graph_t):
    @property
    def colored_gdl_edges(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> iterator:
        ...
    def compute_dominators(self, domin: array_of_node_bitset_t, post: bool = False) -> None:
        ...
    def compute_immediate_dominators(self, domin: array_of_node_bitset_t, idomin: intvec_t, post: bool = False) -> None:
        ...
    def depth_first_postorder(self, post: node_ordering_t) -> int:
        ...
    def depth_first_preorder(self, pre: node_ordering_t) -> int:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_chain_stamp(self) -> int:
        ...
    def get_du(self, gctype: gctype_t) -> graph_chains_t:
        r"""Get def-use chains.
        
        """
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_mblock(self, n: int) -> mblock_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def get_ud(self, gctype: gctype_t) -> graph_chains_t:
        r"""Get use-def chains.
        
        """
        ...
    def goup(self, node: int) -> int:
        ...
    def inc(self, p: iterator, n: int = 1) -> None:
        ...
    def is_du_chain_dirty(self, gctype: gctype_t) -> bool:
        r"""Is the def-use chain of the specified kind dirty?
        
        """
        ...
    def is_redefined_globally(self, args: Any) -> bool:
        r"""Is LIST redefined in the graph?
        
        """
        ...
    def is_ud_chain_dirty(self, gctype: gctype_t) -> bool:
        r"""Is the use-def chain of the specified kind dirty?
        
        """
        ...
    def is_used_globally(self, args: Any) -> bool:
        r"""Is LIST used in the graph?
        
        """
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class mblock_t:
    @property
    def dead_at_start(self) -> Any: ...
    @property
    def dnu(self) -> Any: ...
    @property
    def end(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def head(self) -> Any: ...
    @property
    def maxbsp(self) -> Any: ...
    @property
    def maybdef(self) -> Any: ...
    @property
    def maybuse(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def minbargref(self) -> Any: ...
    @property
    def minbstkref(self) -> Any: ...
    @property
    def mustbdef(self) -> Any: ...
    @property
    def mustbuse(self) -> Any: ...
    @property
    def nextb(self) -> Any: ...
    @property
    def predset(self) -> Any: ...
    @property
    def prevb(self) -> Any: ...
    @property
    def serial(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    @property
    def succset(self) -> Any: ...
    @property
    def tail(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append_def_list(self, list: mlist_t, op: mop_t, maymust: maymust_t) -> None:
        r"""Append def-list of an operand. This function calculates list of locations that may or must be modified by the operand and appends it to LIST. 
                
        :param list: ptr to the output buffer. we will append to it.
        :param op: operand to calculate the def list of
        :param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.
        """
        ...
    def append_use_list(self, args: Any) -> None:
        r"""Append use-list of an operand. This function calculates list of locations that may or must be used by the operand and appends it to LIST. 
                
        :param list: ptr to the output buffer. we will append to it.
        :param op: operand to calculate the use list of
        :param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
        :param mask: if only part of the operand should be considered, a bitmask can be used to specify which part. example: op=AX,mask=0xFF means that we will consider only AL.
        """
        ...
    def build_def_list(self, ins: minsn_t, maymust: maymust_t) -> mlist_t:
        r"""Build def-list of an instruction. This function calculates list of locations that may or must be modified by the instruction. Examples: "stx ebx.4, ds.2, eax.4", may-list: all aliasable memory "stx ebx.4, ds.2, eax.4", must-list: empty Since STX uses EAX for indirect access, it may modify any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be modified, this is why the must-list is empty. 
                
        :param ins: instruction to calculate the def list of
        :param maymust: should we calculate 'may-def' or 'must-def' list? see maymust_t for more details.
        :returns: the calculated def-list
        """
        ...
    def build_lists(self, kill_deads: bool) -> int:
        r"""Build def-use lists and eliminate deads. 
                
        :param kill_deads: do delete dead instructions?
        :returns: the number of eliminated instructions Better mblock_t::call make_lists_ready() rather than this function.
        """
        ...
    def build_use_list(self, ins: minsn_t, maymust: maymust_t) -> mlist_t:
        r"""Build use-list of an instruction. This function calculates list of locations that may or must be used by the instruction. Examples: "ldx ds.2, eax.4, ebx.4", may-list: all aliasable memory "ldx ds.2, eax.4, ebx.4", must-list: empty Since LDX uses EAX for indirect access, it may access any aliasable memory. On the other hand, we cannot tell for sure which memory cells will be accessed, this is why the must-list is empty. 
                
        :param ins: instruction to calculate the use list of
        :param maymust: should we calculate 'may-use' or 'must-use' list? see maymust_t for more details.
        :returns: the calculated use-list
        """
        ...
    def dump(self) -> None:
        r"""Dump block info. This function is useful for debugging, see mba_t::dump for info 
                
        """
        ...
    def dump_block(self, title: str) -> None:
        ...
    def empty(self) -> bool:
        ...
    def find_access(self, op: mop_t, parent: minsn_t, mend: minsn_t, fdflags: int) -> minsn_t:
        r"""Find the instruction that accesses the specified operand. This function search inside one block. 
                
        :param op: operand to search for
        :param parent: ptr to ptr to a top level instruction. in: denotes the beginning of the search range. out: denotes the parent of the found instruction.
        :param mend: end instruction of the range (must be a top level insn) mend is excluded from the range. it can be specified as nullptr. parent and mend must belong to the same block.
        :param fdflags: combination of bits for mblock_t::find_access bits
        :returns: the instruction that accesses the operand. this instruction may be a sub-instruction. to find out the top level instruction, check out *parent. nullptr means 'not found'.
        """
        ...
    def find_def(self, op: mop_t, p_i1: minsn_t, i2: minsn_t, fdflags: int) -> minsn_t:
        ...
    def find_first_use(self, args: Any) -> minsn_t:
        r"""This function has the following signatures:
        
            0. find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
            1. find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
        
        # 0: find_first_use(list: mlist_t *, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
        
        Find the first insn that uses the specified list in the insn range. 
                
        :returns: pointer to such instruction or nullptr. Upon return LIST will contain only locations not redefined by insns [i1..result]
        
        # 1: find_first_use(list: mlist_t *, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
        
        
        """
        ...
    def find_redefinition(self, args: Any) -> minsn_t:
        r"""This function has the following signatures:
        
            0. find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
            1. find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
        
        # 0: find_redefinition(list: const mlist_t &, i1: const minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> const minsn_t *
        
        Find the first insn that redefines any part of the list in the insn range. 
                
        :returns: pointer to such instruction or nullptr.
        
        # 1: find_redefinition(list: const mlist_t &, i1: minsn_t *, i2: const minsn_t *, maymust: maymust_t=MAY_ACCESS) -> minsn_t *
        
        
        """
        ...
    def find_use(self, op: mop_t, p_i1: minsn_t, i2: minsn_t, fdflags: int) -> minsn_t:
        ...
    def for_all_insns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all instructions. This function visits subinstructions too. 
                
        :param mv: instruction visitor
        :returns: zero or the value returned by mv.visit_insn() See also mba_t::for_all_topinsns()
        """
        ...
    def for_all_ops(self, mv: mop_visitor_t) -> int:
        r"""Visit all operands. This function visit subinstruction operands too. 
                
        :param mv: operand visitor
        :returns: zero or the value returned by mv.visit_mop()
        """
        ...
    def for_all_uses(self, list: mlist_t, i1: minsn_t, i2: minsn_t, mmv: mlist_mop_visitor_t) -> int:
        r"""Visit all operands that use LIST. 
                
        :param list: ptr to the list of locations. it may be modified: parts that get redefined by the instructions in [i1,i2) will be deleted.
        :param i1: starting instruction. must be a top level insn.
        :param i2: ending instruction (excluded). must be a top level insn.
        :param mmv: operand visitor
        :returns: zero or the value returned by mmv.visit_mop()
        """
        ...
    def get_reginsn_qty(self) -> int:
        r"""Calculate number of regular instructions in the block. Assertions are skipped by this function. 
                
        :returns: Number of non-assertion instructions in the block.
        """
        ...
    def get_valranges(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool
            1. get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool
        
        # 0: get_valranges(res: valrng_t *, vivl: const vivl_t &, vrflags: int) -> bool
        
        Find possible values for a block. 
                
        
        # 1: get_valranges(res: valrng_t *, vivl: const vivl_t &, m: const minsn_t *, vrflags: int) -> bool
        
        Find possible values for an instruction. 
                
        
        """
        ...
    def insert_into_block(self, nm: minsn_t, om: minsn_t) -> minsn_t:
        r"""Insert instruction into the doubly linked list 
                
        :param nm: new instruction
        :param om: existing instruction, part of the doubly linked list if nullptr, then the instruction will be inserted at the beginning of the list NM will be inserted immediately after OM
        :returns: pointer to NM
        """
        ...
    def is_branch(self) -> bool:
        ...
    def is_call_block(self) -> bool:
        ...
    def is_nway(self) -> bool:
        ...
    def is_redefined(self, args: Any) -> bool:
        r"""Is the list redefined by the specified instructions? 
                
        :param list: list of locations to check.
        :param i1: starting instruction of the range (must be a top level insn)
        :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
        :param maymust: should we search in 'may-access' or 'must-access' mode?
        """
        ...
    def is_rhs_redefined(self, ins: minsn_t, i1: minsn_t, i2: minsn_t) -> bool:
        r"""Is the right hand side of the instruction redefined the insn range? "right hand side" corresponds to the source operands of the instruction. 
                
        :param ins: instruction to consider
        :param i1: starting instruction of the range (must be a top level insn)
        :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
        """
        ...
    def is_simple_goto_block(self) -> bool:
        ...
    def is_simple_jcnd_block(self) -> bool:
        ...
    def is_unknown_call(self) -> bool:
        ...
    def is_used(self, args: Any) -> bool:
        r"""Is the list used by the specified instruction range? 
                
        :param list: list of locations. LIST may be modified by the function: redefined locations will be removed from it.
        :param i1: starting instruction of the range (must be a top level insn)
        :param i2: end instruction of the range (must be a top level insn) i2 is excluded from the range. it can be specified as nullptr. i1 and i2 must belong to the same block.
        :param maymust: should we search in 'may-access' or 'must-access' mode?
        """
        ...
    def lists_dirty(self) -> bool:
        ...
    def lists_ready(self) -> bool:
        ...
    def make_lists_ready(self) -> int:
        ...
    def make_nop(self, m: minsn_t) -> None:
        r"""Erase the instruction (convert it to nop) and mark the lists dirty. This is the recommended function to use because it also marks the block use-def lists dirty. 
                
        """
        ...
    def mark_lists_dirty(self) -> None:
        ...
    def needs_propagation(self) -> bool:
        ...
    def npred(self) -> int:
        r"""Get number of block predecessors.
        
        """
        ...
    def nsucc(self) -> int:
        r"""Get number of block successors.
        
        """
        ...
    def optimize_block(self) -> int:
        r"""Optimize a basic block. Usually there is no need to call this function explicitly because the decompiler will call it itself if optinsn_t::func or optblock_t::func return non-zero. 
                
        :returns: number of changes made to the block
        """
        ...
    def optimize_insn(self, args: Any) -> int:
        r"""Optimize one instruction in the context of the block. 
                
        :param m: pointer to a top level instruction
        :param optflags: combination of optimization flags bits
        :returns: number of changes made to the block This function may change other instructions in the block too. However, it will not destroy top level instructions (it may convert them to nop's). This function performs only intrablock modifications. See also minsn_t::optimize_solo()
        """
        ...
    def optimize_useless_jump(self) -> int:
        r"""Remove a jump at the end of the block if it is useless. This function preserves any side effects when removing a useless jump. Both conditional and unconditional jumps are handled (and jtbl too). This function deletes useless jumps, not only replaces them with a nop. (please note that \optimize_insn does not handle useless jumps). 
                
        :returns: number of changes made to the block
        """
        ...
    def pred(self, n: int) -> int:
        ...
    def preds(self) -> Any:
        r"""
        Iterates the list of predecessor blocks
        
        """
        ...
    def remove_from_block(self, m: minsn_t) -> minsn_t:
        r"""Remove instruction from the doubly linked list 
                
        :param m: instruction to remove The removed instruction is not deleted, the caller gets its ownership
        :returns: pointer to the next instruction
        """
        ...
    def request_demote64(self) -> None:
        ...
    def request_propagation(self) -> None:
        ...
    def succ(self, n: int) -> int:
        ...
    def succs(self) -> Any:
        r"""
        Iterates the list of successor blocks
        
        """
        ...

class mcallarg_t(mop_t):
    @property
    def a(self) -> Any: ...
    @property
    def argloc(self) -> Any: ...
    @property
    def b(self) -> Any: ...
    @property
    def c(self) -> Any: ...
    @property
    def cstr(self) -> Any: ...
    @property
    def d(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def f(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def fpc(self) -> Any: ...
    @property
    def g(self) -> Any: ...
    @property
    def helper(self) -> Any: ...
    @property
    def l(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def nnn(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def oprops(self) -> Any: ...
    @property
    def pair(self) -> Any: ...
    @property
    def r(self) -> Any: ...
    @property
    def s(self) -> Any: ...
    @property
    def scif(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def t(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def valnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, rop: mop_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, rop: mop_t) -> bool:
        ...
    def __ne__(self, rop: mop_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_ld_mcode(self, mcode: mcode_t, ea: ida_idaapi.ea_t, newsize: int) -> None:
        r"""Apply a unary opcode to the operand. 
                
        :param mcode: opcode to apply. it must accept 'l' and 'd' operands but not 'r'. examples: m_low/m_high/m_xds/m_xdu
        :param ea: value of minsn_t::ea for the newly created insruction
        :param newsize: new operand size Example: apply_ld_mcode(m_low) will convert op => low(op)
        """
        ...
    def apply_xds(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def apply_xdu(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def assign(self, rop: mop_t) -> mop_t:
        ...
    def change_size(self, nsize: int, sideff: side_effect_t = 1) -> bool:
        r"""Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1 
                
        :param nsize: new operand size
        :param sideff: may modify the database because of the size change?
        :returns: success
        """
        ...
    def copy_mop(self, op: mop_t) -> None:
        ...
    def create_from_insn(self, m: minsn_t) -> None:
        r"""Create operand from an instruction. This function creates a nested instruction that can be used as an operand. Example: if m="add x,y,z", our operand will be (t=mop_d,d=m). The destination operand of 'add' (z) is lost. 
                
        :param m: instruction to embed into operand. may not be nullptr.
        """
        ...
    def create_from_ivlset(self, mba: mba_t, ivs: ivlset_t, fullsize: int) -> bool:
        r"""Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4) 
                
        :param mba: pointer to microcode
        :param ivs: set of memory intervals
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_mlist(self, mba: mba_t, lst: mlist_t, fullsize: int) -> bool:
        r"""Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our operand will be (t=mop_r, r=R0, size=4) 
                
        :param mba: pointer to microcode
        :param lst: list of locations
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_scattered_vdloc(self, mba: mba_t, name: str, type: tinfo_t, loc: vdloc_t) -> None:
        r"""Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4, EDX.4}) 
                
        :param mba: pointer to microcode
        :param name: name of the operand, if available
        :param type: type of the operand, must be present
        :param loc: a scattered location
        :returns: success
        """
        ...
    def create_from_vdloc(self, mba: mba_t, loc: vdloc_t, _size: int) -> None:
        r"""Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0, size=_SIZE) 
                
        :param mba: pointer to microcode
        :param loc: location
        :param _size: operand size Note: this function cannot handle scattered locations.
        :returns: success
        """
        ...
    def double_size(self, sideff: side_effect_t = 1) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equal_mops(self, rop: mop_t, eqflags: int) -> bool:
        r"""Compare operands. This is the main comparison function for operands. 
                
        :param rop: operand to compare with
        :param eqflags: combination of comparison bits bits
        """
        ...
    def erase(self) -> None:
        ...
    def erase_but_keep_size(self) -> None:
        ...
    def for_all_ops(self, mv: mop_visitor_t, type: tinfo_t = None, is_target: bool = False) -> int:
        r"""Visit the operand and all its sub-operands. This function visits the current operand as well. 
                
        :param mv: visitor object
        :param type: operand type
        :param is_target: is a destination operand?
        """
        ...
    def for_all_scattered_submops(self, sv: scif_visitor_t) -> int:
        r"""Visit all sub-operands of a scattered operand. This function does not visit the current operand, only its sub-operands. All sub-operands are synthetic and are destroyed after the visitor. This function works only with scattered operands. 
                
        :param sv: visitor object
        """
        ...
    def get_insn(self, code: mcode_t) -> minsn_t:
        r"""Get subinstruction of the operand. If the operand has a subinstruction with the specified opcode, return it. 
                
        :param code: desired opcode
        :returns: pointer to the instruction or nullptr
        """
        ...
    def get_stkoff(self, p_vdoff: sval_t) -> bool:
        r"""Get the referenced stack offset. This function can also handle mop_sc if it is entirely mapped into a continuous stack region. 
                
        :param p_vdoff: the output buffer
        :returns: success
        """
        ...
    def get_stkvar(self, udm: udm_t = None, p_idaoff: uval_t = None) -> ssize_t:
        r"""Retrieve the referenced stack variable. 
                
        :param udm: stkvar, may be nullptr
        :param p_idaoff: if specified, will hold IDA stkoff after the call.
        :returns: index of stkvar in the frame or -1
        """
        ...
    def has_side_effects(self, include_ldx_and_divs: bool = False) -> bool:
        r"""Has any side effects? 
                
        :param include_ldx_and_divs: consider ldx/div/mod as having side effects?
        """
        ...
    def is01(self) -> bool:
        r"""Are the possible values of the operand only 0 and 1? This function returns true for 0/1 constants, bit registers, the result of 'set' insns, etc. 
                
        """
        ...
    def is_arglist(self) -> bool:
        r"""Is a list of arguments?
        
        """
        ...
    def is_bit_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_bit_reg() -> bool
            1. is_bit_reg(reg: mreg_t) -> bool
        
        # 0: is_bit_reg() -> bool
        
        
        # 1: is_bit_reg(reg: mreg_t) -> bool
        
        Is a bit register? This includes condition codes and eventually other bit registers 
                
        
        """
        ...
    def is_cc(self) -> bool:
        r"""Is a condition code?
        
        """
        ...
    def is_ccflags(self) -> bool:
        ...
    def is_constant(self, is_signed: bool = True) -> bool:
        r"""Retrieve value of a constant integer operand. 
                
        :param is_signed: should treat the value as signed
        :returns: true if the operand is mop_n
        """
        ...
    def is_equal_to(self, n: uint64, is_signed: bool = True) -> bool:
        ...
    def is_extended_from(self, nbytes: int, is_signed: bool) -> bool:
        r"""Does the high part of the operand consist of zero or sign bytes?
        
        """
        ...
    def is_for_abi(self) -> bool:
        ...
    def is_glbaddr(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_glbaddr() -> bool
            1. is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        # 0: is_glbaddr() -> bool
        
        Is address of a global memory cell?
        
        
        # 1: is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        Is address of the specified global memory cell?
        
        
        """
        ...
    def is_glbaddr_from_fixup(self) -> bool:
        ...
    def is_glbvar(self) -> bool:
        r"""Is a global variable?
        
        """
        ...
    def is_impptr_done(self) -> bool:
        ...
    def is_insn(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_insn() -> bool
            1. is_insn(code: mcode_t) -> bool
        
        # 0: is_insn() -> bool
        
        Is a sub-instruction?
        
        
        # 1: is_insn(code: mcode_t) -> bool
        
        Is a sub-instruction with the specified opcode?
        
        
        """
        ...
    def is_kreg(self) -> bool:
        r"""Is a kernel register?
        
        """
        ...
    def is_lowaddr(self) -> bool:
        ...
    def is_mblock(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_mblock() -> bool
            1. is_mblock(serial: int) -> bool
        
        # 0: is_mblock() -> bool
        
        Is a block reference?
        
        
        # 1: is_mblock(serial: int) -> bool
        
        Is a block reference to the specified block?
        
        
        """
        ...
    def is_negative_constant(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_pcval(self) -> bool:
        ...
    def is_positive_constant(self) -> bool:
        ...
    def is_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_reg() -> bool
            1. is_reg(_r: mreg_t) -> bool
            2. is_reg(_r: mreg_t, _size: int) -> bool
        
        # 0: is_reg() -> bool
        
        Is a register operand? See also get_mreg_name() 
                
        
        # 1: is_reg(_r: mreg_t) -> bool
        
        Is the specified register?
        
        
        # 2: is_reg(_r: mreg_t, _size: int) -> bool
        
        Is the specified register of the specified size?
        
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""Is a scattered operand?
        
        """
        ...
    def is_sign_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of the sign bytes? 
                
        :param nbytes: number of bytes that were sign extended. the remaining size-nbytes high bytes must be sign bytes Example: is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3 bytes are certainly sign bits
        """
        ...
    def is_stkaddr(self) -> bool:
        r"""Is address of a stack variable?
        
        """
        ...
    def is_stkvar(self) -> bool:
        r"""Is a stack variable?
        
        """
        ...
    def is_udt(self) -> bool:
        ...
    def is_undef_val(self) -> bool:
        ...
    def is_zero(self) -> bool:
        ...
    def is_zero_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of zero bytes? 
                
        :param nbytes: number of bytes that were zero extended. the remaining size-nbytes high bytes must be zero Example: is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6 bytes are certainly zero
        """
        ...
    def lexcompare(self, rop: mop_t) -> int:
        ...
    def make_blkref(self, blknum: int) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_first_half(self, width: int) -> bool:
        r"""Make the first part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_fpnum(self, bytes: void) -> bool:
        r"""Create a floating point constant operand. 
                
        :param bytes: pointer to the floating point value as used by the current processor (e.g. for x86 it must be in IEEE 754)
        :returns: success
        """
        ...
    def make_gvar(self, ea: ida_idaapi.ea_t) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_helper(self, name: str) -> None:
        r"""Create a helper operand. A helper operand usually keeps a built-in function name like "va_start" It is essentially just an arbitrary identifier without any additional info. 
                
        """
        ...
    def make_high_half(self, width: int) -> bool:
        r"""Make the high part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_insn(self, ins: minsn_t) -> None:
        r"""Create a nested instruction.
        
        """
        ...
    def make_int(self, val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None:
        ...
    def make_low_half(self, width: int) -> bool:
        r"""Make the low part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_number(self, args: Any) -> None:
        r"""Create an integer constant operand. 
                
        :param _value: value to store in the operand
        :param _size: size of the value in bytes (1,2,4,8)
        :param _ea: address of the processor instruction that made the value
        :param opnum: operand number of the processor instruction
        """
        ...
    def make_reg(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. make_reg(reg: mreg_t) -> None
            1. make_reg(reg: mreg_t, _size: int) -> None
        
        # 0: make_reg(reg: mreg_t) -> None
        
        Create a register operand.
        
        
        # 1: make_reg(reg: mreg_t, _size: int) -> None
        
        
        """
        ...
    def make_reg_pair(self, loreg: int, hireg: int, halfsize: int) -> None:
        r"""Create pair of registers. 
                
        :param loreg: register holding the low part of the value
        :param hireg: register holding the high part of the value
        :param halfsize: the size of each of loreg/hireg
        """
        ...
    def make_second_half(self, width: int) -> bool:
        r"""Make the second part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_stkvar(self, mba: mba_t, off: int) -> None:
        ...
    def make_uint(self, val: int, val_ea: ida_idaapi.ea_t, opno: int = 0) -> None:
        ...
    def may_use_aliased_memory(self) -> bool:
        r"""Is it possible for the operand to use aliased memory?
        
        """
        ...
    def preserve_side_effects(self, blk: mblock_t, top: minsn_t, moved_calls: bool = None) -> bool:
        r"""Move subinstructions with side effects out of the operand. If we decide to delete an instruction operand, it is a good idea to call this function. Alternatively we should skip such operands by calling mop_t::has_side_effects() For example, if we transform: jnz x, x, @blk => goto @blk then we must call this function before deleting the X operands. 
                
        :param blk: current block
        :param top: top level instruction that contains our operand
        :param moved_calls: pointer to the boolean that will track if all side effects get handled correctly. must be false initially.
        :returns: false failed to preserve a side effect, it is not safe to delete the operand true no side effects or successfully preserved them
        """
        ...
    def probably_floating(self) -> bool:
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def set_for_abi(self) -> None:
        ...
    def set_impptr_done(self) -> None:
        ...
    def set_lowaddr(self) -> None:
        ...
    def set_regarg(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None
            1. set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None
            2. set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None
        
        # 0: set_regarg(mr: mreg_t, sz: int, tif: const tinfo_t &) -> None
        
        
        # 1: set_regarg(mr: mreg_t, tif: const tinfo_t &) -> None
        
        
        # 2: set_regarg(mr: mreg_t, dt: char, sign: type_sign_t=type_unsigned) -> None
        
        
        """
        ...
    def set_udt(self) -> None:
        ...
    def set_undef_val(self) -> None:
        ...
    def shift_mop(self, offset: int) -> bool:
        r"""Shift the operand. This function shifts only the beginning of the operand. The operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1 
                
        :param offset: shift count (the number of bytes to shift)
        :returns: success
        """
        ...
    def signed_value(self) -> int64:
        ...
    def swap(self, rop: mop_t) -> None:
        ...
    def unsigned_value(self) -> uint64:
        ...
    def update_numop_value(self, val: uint64) -> None:
        ...
    def value(self, is_signed: bool) -> uint64:
        r"""Retrieve value of a constant integer operand. These functions can be called only for mop_n operands. See is_constant() that can be called on any operand. 
                
        """
        ...
    def zero(self) -> None:
        ...

class mcallargs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: mcallargs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> mcallarg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: mcallargs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: mcallarg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: mcallarg_t) -> bool:
        ...
    def append(self, x: mcallarg_t) -> None:
        ...
    def at(self, _idx: size_t) -> mcallarg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: mcallargs_t) -> None:
        ...
    def extract(self) -> mcallarg_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: mcallarg_t) -> bool:
        ...
    def inject(self, s: mcallarg_t, len: size_t) -> None:
        ...
    def insert(self, it: mcallarg_t, x: mcallarg_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> mcallarg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: mcallargs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class mcallinfo_t:
    @property
    def args(self) -> Any: ...
    @property
    def call_spd(self) -> Any: ...
    @property
    def callee(self) -> Any: ...
    @property
    def cc(self) -> Any: ...
    @property
    def dead_regs(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def fti_attrs(self) -> Any: ...
    @property
    def pass_regs(self) -> Any: ...
    @property
    def retregs(self) -> Any: ...
    @property
    def return_argloc(self) -> Any: ...
    @property
    def return_regs(self) -> Any: ...
    @property
    def return_type(self) -> Any: ...
    @property
    def role(self) -> Any: ...
    @property
    def solid_args(self) -> Any: ...
    @property
    def spoiled(self) -> Any: ...
    @property
    def stkargs_top(self) -> Any: ...
    @property
    def visible_memory(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dstr(self) -> str:
        ...
    def get_type(self) -> tinfo_t:
        ...
    def is_vararg(self) -> bool:
        ...
    def lexcompare(self, f: mcallinfo_t) -> int:
        ...
    def set_type(self, type: tinfo_t) -> bool:
        ...

class mcases_t:
    @property
    def targets(self) -> Any: ...
    @property
    def values(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: mcases_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: mcases_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: mcases_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: mcases_t) -> bool:
        ...
    def __lt__(self, r: mcases_t) -> bool:
        ...
    def __ne__(self, r: mcases_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: mcases_t) -> int:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def resize(self, s: int) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: mcases_t) -> None:
        ...

class meminfo_vec_t(meminfo_vec_template_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: meminfo_vec_template_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> memory_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: meminfo_vec_template_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: memory_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: memory_info_t) -> bool:
        ...
    def append(self, x: memory_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> memory_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: meminfo_vec_template_t) -> None:
        ...
    def extract(self) -> memory_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: memory_info_t) -> bool:
        ...
    def inject(self, s: memory_info_t, len: size_t) -> None:
        ...
    def insert(self, it: memory_info_t, x: memory_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> memory_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: meminfo_vec_template_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class meminfo_vec_template_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: meminfo_vec_template_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> memory_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: meminfo_vec_template_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: memory_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: memory_info_t) -> bool:
        ...
    def append(self, x: memory_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> memory_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: meminfo_vec_template_t) -> None:
        ...
    def extract(self) -> memory_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: memory_info_t) -> bool:
        ...
    def inject(self, s: memory_info_t, len: size_t) -> None:
        ...
    def insert(self, it: memory_info_t, x: memory_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> memory_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: meminfo_vec_template_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class memory_info_t(range_t):
    @property
    def bitness(self) -> Any: ...
    @property
    def end_ea(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def perm(self) -> Any: ...
    @property
    def sbase(self) -> Any: ...
    @property
    def sclass(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: memory_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: memory_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class memreg_info_t:
    @property
    def bytes(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_bytes(self) -> Any:
        ...

class memreg_infos_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> memreg_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: memreg_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: memreg_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> memreg_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: memreg_infos_t) -> None:
        ...
    def extract(self) -> memreg_info_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: memreg_info_t, len: size_t) -> None:
        ...
    def insert(self, it: memreg_info_t, x: memreg_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> memreg_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: memreg_infos_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class merge_data_t:
    @property
    def dbctx_ids(self) -> Any: ...
    @property
    def ev_handlers(self) -> Any: ...
    @property
    def item_block_locator(self) -> Any: ...
    @property
    def last_udt_related_merger(self) -> Any: ...
    @property
    def nbases(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def add_event_handler(self, handler: merge_handler_t) -> None:
        ...
    def base_id(self) -> int:
        ...
    def compare_merging_tifs(self, tif1: tinfo_t, diffidx1: diff_source_idx_t, tif2: tinfo_t, diffidx2: diff_source_idx_t) -> int:
        r"""compare types from two databases 
                
        :param tif1: type
        :param diffidx1: database index, diff_source_idx_t
        :param tif2: type
        :param diffidx2: database index, diff_source_idx_t
        :returns: -1, 0, 1
        """
        ...
    def get_block_head(self, idx: diff_source_idx_t, item_head: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        ...
    def has_existing_node(self, nodename: str) -> bool:
        r"""check that node exists in any of databases
        
        """
        ...
    def local_id(self) -> int:
        ...
    def map_privrange_id(self, tid: tid_t, ea: ida_idaapi.ea_t, _from: diff_source_idx_t, to: diff_source_idx_t, strict: bool = True) -> bool:
        r"""map IDs of structures, enumerations and their members 
                
        :param tid: item ID in TO database
        :param ea: item ID to find counterpart
        :param to: destination database index, diff_source_idx_t
        :param strict: raise interr if could not map
        :returns: success
        """
        ...
    def map_tinfo(self, tif: tinfo_t, _from: diff_source_idx_t, to: diff_source_idx_t, strict: bool = True) -> bool:
        r"""migrate type, replaces type references into FROM database to references into TO database 
                
        :param tif: type to migrate, will be cleared in case of fail
        :param to: destination database index, diff_source_idx_t
        :param strict: raise interr if could not map
        :returns: success
        """
        ...
    def remote_id(self) -> int:
        ...
    def remove_event_handler(self, handler: merge_handler_t) -> None:
        ...
    def set_dbctx_ids(self, local: int, remote: int, base: int) -> None:
        ...
    def setup_blocks(self, dst_idx: diff_source_idx_t, src_idx: diff_source_idx_t, region: diff_range_t) -> bool:
        ...

class merge_handler_params_t:
    @property
    def insert_after(self) -> Any: ...
    @property
    def kind(self) -> Any: ...
    @property
    def label(self) -> Any: ...
    @property
    def md(self) -> Any: ...
    @property
    def mh_flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _md: merge_data_t, _label: str, _kind: merge_kind_t, _insert_after: merge_kind_t, _mh_flags: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def ui_complex_details(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_complex_details() -> bool
            1. ui_complex_details(_mh_flags: int) -> bool
        
        # 0: ui_complex_details() -> bool
        
        
        # 1: ui_complex_details(_mh_flags: int) -> bool
        
        Do not display the diffpos details in the chooser. For example, the MERGE_KIND_SCRIPTS handler puts the script body as the diffpos detail. It would not be great to show them as part of the chooser. 
                
        
        """
        ...
    def ui_complex_name(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_complex_name() -> bool
            1. ui_complex_name(_mh_flags: int) -> bool
        
        # 0: ui_complex_name() -> bool
        
        
        # 1: ui_complex_name(_mh_flags: int) -> bool
        
        It customary to create long diffpos names having many components that are separated by any 7-bit ASCII character (besides of '\0'). In this case it is possible to instruct IDA to use this separator to create a multi-column chooser. For example the MERGE_KIND_ENUMS handler has the following diffpos name: enum_1,enum_2 If MH_UI_COMMANAME is specified, IDA will create 2 columns for these names. 
                
        
        """
        ...
    def ui_dp_shortname(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_dp_shortname() -> bool
            1. ui_dp_shortname(_mh_flags: int) -> bool
        
        # 0: ui_dp_shortname() -> bool
        
        
        # 1: ui_dp_shortname(_mh_flags: int) -> bool
        
        The detail pane shows the diffpos details for the current diffpos range as a tree-like view. In this pane the diffpos names are used as tree node names and the diffpos details as their children. Sometimes, for complex diffpos names, the first part of the name looks better than the entire name. For example, the MERGE_KIND_SEGMENTS handler has the following diffpos name: <range>,<segm1>,<segm2>,<segm3> if MH_UI_DP_SHORTNAME is specified, IDA will use <range> as a tree node name 
                
        
        """
        ...
    def ui_has_details(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_has_details() -> bool
            1. ui_has_details(_mh_flags: int) -> bool
        
        # 0: ui_has_details() -> bool
        
        
        # 1: ui_has_details(_mh_flags: int) -> bool
        
        Should IDA display the diffpos detail pane?
        
        
        """
        ...
    def ui_indent(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_indent() -> bool
            1. ui_indent(_mh_flags: int) -> bool
        
        # 0: ui_indent() -> bool
        
        
        # 1: ui_indent(_mh_flags: int) -> bool
        
        In the ordinary situation the spaces from the both sides of diffpos name are trimmed. Use this UI hint to preserve the leading spaces. 
                
        
        """
        ...
    def ui_linediff(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. ui_linediff() -> bool
            1. ui_linediff(_mh_flags: int) -> bool
        
        # 0: ui_linediff() -> bool
        
        
        # 1: ui_linediff(_mh_flags: int) -> bool
        
        In detail pane IDA shows difference between diffpos details. IDA marks added or deleted detail by color. In the modified detail the changes are marked. Use this UI hint if you do not want to show the differences inside detail. 
                
        
        """
        ...
    def ui_split_char(self, args: Any) -> char:
        r"""This function has the following signatures:
        
            0. ui_split_char() -> char
            1. ui_split_char(_mh_flags: int) -> char
        
        # 0: ui_split_char() -> char
        
        
        # 1: ui_split_char(_mh_flags: int) -> char
        
        
        """
        ...
    def ui_split_str(self, args: Any) -> str:
        r"""This function has the following signatures:
        
            0. ui_split_str() -> str
            1. ui_split_str(_mh_flags: int) -> str
        
        # 0: ui_split_str() -> str
        
        
        # 1: ui_split_str(_mh_flags: int) -> str
        
        
        """
        ...

class merge_node_helper_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append_eavec(self, s: str, prefix: str, eas: eavec_t) -> None:
        r"""can be used by derived classes
        
        """
        ...
    def get_column_headers(self, arg0: qstrvec_t, arg1: uchar, arg2: void) -> None:
        r"""get column headers for chooser (to be used in linear_diff_source_t::get_column_headers) 
                
        """
        ...
    def get_netnode(self) -> netnode:
        r"""return netnode to be used as source. If this function returns BADNODE netnode will be created using netnode name passed to create_nodeval_diff_source 
                
        """
        ...
    def is_mergeable(self, arg0: uchar, arg1: nodeidx_t) -> bool:
        r"""filter: check if we should perform merging for given record
        
        """
        ...
    def map_scalar(self, arg0: nodeidx_t, arg1: void, arg2: diff_source_idx_t, arg3: diff_source_idx_t) -> None:
        r"""map scalar/string/buffered value
        
        """
        ...
    def map_string(self, arg0: str, arg1: void, arg2: diff_source_idx_t, arg3: diff_source_idx_t) -> None:
        ...
    def print_entry_details(self, arg0: qstrvec_t, arg1: uchar, arg2: nodeidx_t, arg3: void) -> None:
        r"""print the details of the specified entry usually contains multiple lines, one for each attribute or detail. (to be used in print_diffpos_details) 
                
        """
        ...
    def print_entry_name(self, arg0: uchar, arg1: nodeidx_t, arg2: void) -> str:
        r"""print the name of the specified entry (to be used in print_diffpos_name) 
                
        """
        ...
    def refresh(self, arg0: uchar, arg1: void) -> None:
        r"""notify helper that some data was changed in the database and internal structures (e.g. caches) should be refreshed 
                
        """
        ...

class merge_node_info_t:
    @property
    def name(self) -> Any: ...
    @property
    def nds_flags(self) -> Any: ...
    @property
    def node_helper(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, name: str, tag: uchar, nds_flags: int, node_helper: merge_node_helper_t = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class microcode_filter_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply(self, cdg: codegen_t) -> merror_t:
        r"""generate microcode for an instruction 
                
        :returns: MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error
        """
        ...
    def match(self, cdg: codegen_t) -> bool:
        r"""check if the filter object is to be applied 
                
        :returns: success
        """
        ...

class minsn_t:
    @property
    def d(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def iprops(self) -> Any: ...
    @property
    def l(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def next(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def opcode(self) -> Any: ...
    @property
    def prev(self) -> Any: ...
    @property
    def r(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, ri: minsn_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clr_assert(self) -> None:
        ...
    def clr_combinable(self) -> None:
        ...
    def clr_combined(self) -> None:
        ...
    def clr_fpinsn(self) -> None:
        ...
    def clr_ignlowsrc(self) -> None:
        ...
    def clr_multimov(self) -> None:
        ...
    def clr_noret_icall(self) -> None:
        ...
    def clr_propagatable(self) -> None:
        ...
    def clr_tailcall(self) -> None:
        ...
    def contains_call(self, with_helpers: bool = False) -> bool:
        r"""Does the instruction contain a call?
        
        """
        ...
    def contains_opcode(self, mcode: mcode_t) -> bool:
        r"""Does the instruction have the specified opcode? This function searches subinstructions as well. 
                
        :param mcode: opcode to search for.
        """
        ...
    def deserialize(self, bytes: uchar, format_version: int) -> bool:
        r"""Deserialize an instruction 
                
        :param bytes: pointer to serialized data
        :param format_version: serialization format version. this value is returned by minsn_t::serialize()
        :returns: success
        """
        ...
    def dstr(self) -> str:
        r"""Get displayable text without tags in a static buffer.
        
        """
        ...
    def equal_insns(self, m: minsn_t, eqflags: int) -> bool:
        r"""Compare instructions. This is the main comparison function for instructions. 
                
        :param m: instruction to compare with
        :param eqflags: combination of comparison bits bits
        """
        ...
    def find_call(self, with_helpers: bool = False) -> minsn_t:
        r"""Find a call instruction. Check for the current instruction and its subinstructions. 
                
        :param with_helpers: consider helper calls as well?
        """
        ...
    def find_ins_op(self, op: mcode_t = 0) -> minsn_t:
        r"""Find an operand that is a subinsruction with the specified opcode. This function checks only the 'l' and 'r' operands of the current insn. 
                
        :param op: opcode to search for
        :returns: &l or &r or nullptr
        """
        ...
    def find_num_op(self) -> mop_t:
        r"""Find a numeric operand of the current instruction. This function checks only the 'l' and 'r' operands of the current insn. 
                
        :returns: &l or &r or nullptr
        """
        ...
    def find_opcode(self, mcode: mcode_t) -> minsn_t:
        r"""Find a (sub)insruction with the specified opcode. 
                
        :param mcode: opcode to search for.
        """
        ...
    def for_all_insns(self, mv: minsn_visitor_t) -> int:
        r"""Visit all instructions. This function visits the instruction itself and all its subinstructions. 
                
        :param mv: instruction visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def for_all_ops(self, mv: mop_visitor_t) -> int:
        r"""Visit all instruction operands. This function visits subinstruction operands as well. 
                
        :param mv: operand visitor
        :returns: non-zero value returned by mv.visit_mop() or zero
        """
        ...
    def get_role(self) -> funcrole_t:
        r"""Get the function role of a call.
        
        """
        ...
    def get_split_size(self) -> int:
        ...
    def has_side_effects(self, include_ldx_and_divs: bool = False) -> bool:
        r"""Does the instruction have a side effect? 
                
        :param include_ldx_and_divs: consider ldx/div/mod as having side effects? stx is always considered as having side effects. Apart from ldx/std only call may have side effects.
        """
        ...
    def is_after(self, m: minsn_t) -> bool:
        r"""Is the instruction after the specified one? 
                
        :param m: the instruction to compare against in the list
        """
        ...
    def is_alloca(self) -> bool:
        ...
    def is_assert(self) -> bool:
        ...
    def is_between(self, m1: minsn_t, m2: minsn_t) -> bool:
        r"""Is the instruction in the specified range of instructions? 
                
        :param m1: beginning of the range in the doubly linked list
        :param m2: end of the range in the doubly linked list (excluded, may be nullptr) This function assumes that m1 and m2 belong to the same basic block and they are top level instructions.
        """
        ...
    def is_bswap(self) -> bool:
        ...
    def is_cleaning_pop(self) -> bool:
        ...
    def is_combinable(self) -> bool:
        ...
    def is_combined(self) -> bool:
        ...
    def is_extstx(self) -> bool:
        ...
    def is_farcall(self) -> bool:
        ...
    def is_fpinsn(self) -> bool:
        ...
    def is_helper(self, name: str) -> bool:
        r"""Is a helper call with the specified name? Helper calls usually have well-known function names (see Well known function names) but they may have any other name. The decompiler does not assume any special meaning for non-well-known names. 
                
        """
        ...
    def is_ignlowsrc(self) -> bool:
        ...
    def is_inverted_jx(self) -> bool:
        ...
    def is_like_move(self) -> bool:
        ...
    def is_mbarrier(self) -> bool:
        ...
    def is_memcpy(self) -> bool:
        ...
    def is_memset(self) -> bool:
        ...
    def is_mov(self) -> bool:
        ...
    def is_multimov(self) -> bool:
        ...
    def is_noret_call(self, flags: int = 0) -> bool:
        r"""Is a non-returing call? 
                
        :param flags: combination of NORET_... bits
        """
        ...
    def is_optional(self) -> bool:
        ...
    def is_persistent(self) -> bool:
        ...
    def is_propagatable(self) -> bool:
        ...
    def is_readflags(self) -> bool:
        ...
    def is_tailcall(self) -> bool:
        ...
    def is_unknown_call(self) -> bool:
        r"""Is an unknown call? Unknown calls are calls without the argument list (mcallinfo_t). Usually the argument lists are determined by mba_t::analyze_calls(). Unknown calls exist until the MMAT_CALLS maturity level. See also mblock_t::is_call_block 
                
        """
        ...
    def is_wild_match(self) -> bool:
        ...
    def lexcompare(self, ri: minsn_t) -> int:
        ...
    def may_use_aliased_memory(self) -> bool:
        r"""Is it possible for the instruction to use aliased memory?
        
        """
        ...
    def modifies_d(self) -> bool:
        r"""Does the instruction modify its 'd' operand? Some instructions (e.g. m_stx) do not modify the 'd' operand. 
                
        """
        ...
    def modifies_pair_mop(self) -> bool:
        ...
    def optimize_solo(self, optflags: int = 0) -> int:
        r"""Optimize one instruction without context. This function does not have access to the instruction context (the previous and next instructions in the list, the block number, etc). It performs only basic optimizations that are available without this info. 
                
        :param optflags: combination of optimization flags bits
        :returns: number of changes, 0-unchanged See also mblock_t::optimize_insn()
        """
        ...
    def optimize_subtree(self, blk: mblock_t, top: minsn_t, parent: minsn_t, converted_call: ea_t, optflags: int = 2) -> int:
        r"""Optimize instruction in its context. Do not use this function, use mblock_t::optimize() 
                
        """
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def serialize(self, b: bytevec_t) -> int:
        r"""Serialize an instruction 
                
        :param b: the output buffer
        :returns: the serialization format that was used to store info
        """
        ...
    def set_assert(self) -> None:
        ...
    def set_cleaning_pop(self) -> None:
        ...
    def set_combinable(self) -> None:
        ...
    def set_extstx(self) -> None:
        ...
    def set_farcall(self) -> None:
        ...
    def set_fpinsn(self) -> None:
        ...
    def set_ignlowsrc(self) -> None:
        ...
    def set_inverted_jx(self) -> None:
        ...
    def set_mbarrier(self) -> None:
        ...
    def set_multimov(self) -> None:
        ...
    def set_noret_icall(self) -> None:
        ...
    def set_optional(self) -> None:
        ...
    def set_persistent(self) -> None:
        ...
    def set_split_size(self, s: int) -> None:
        ...
    def set_tailcall(self) -> None:
        ...
    def set_unmerged(self) -> None:
        ...
    def set_wild_match(self) -> None:
        ...
    def setaddr(self, new_ea: ida_idaapi.ea_t) -> None:
        r"""Change the instruction address. This function modifies subinstructions as well. 
                
        """
        ...
    def swap(self, m: minsn_t) -> None:
        r"""Swap two instructions. The prev/next fields are not modified by this function because it would corrupt the doubly linked list. 
                
        """
        ...
    def was_noret_icall(self) -> bool:
        ...
    def was_split(self) -> bool:
        ...
    def was_unmerged(self) -> bool:
        ...
    def was_unpaired(self) -> bool:
        ...

class minsn_visitor_t(op_parent_info_t):
    @property
    def blk(self) -> Any: ...
    @property
    def curins(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def topins(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_minsn(self) -> int:
        ...

class mlist_mop_visitor_t:
    @property
    def changed(self) -> Any: ...
    @property
    def curins(self) -> Any: ...
    @property
    def list(self) -> Any: ...
    @property
    def prune(self) -> Any: ...
    @property
    def topins(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_mop(self, op: mop_t) -> int:
        ...

class mlist_t:
    @property
    def mem(self) -> Any: ...
    @property
    def reg(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: mlist_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: mlist_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: mlist_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: mlist_t) -> bool:
        ...
    def __lt__(self, r: mlist_t) -> bool:
        ...
    def __ne__(self, r: mlist_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(r: mreg_t, size: int) -> bool
            1. add(r: const rlist_t &) -> bool
            2. add(ivl: const ivl_t &) -> bool
            3. add(lst: const mlist_t &) -> bool
        
        # 0: add(r: mreg_t, size: int) -> bool
        
        
        # 1: add(r: const rlist_t &) -> bool
        
        
        # 2: add(ivl: const ivl_t &) -> bool
        
        
        # 3: add(lst: const mlist_t &) -> bool
        
        
        """
        ...
    def addmem(self, ea: ida_idaapi.ea_t, size: asize_t) -> bool:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: mlist_t) -> int:
        ...
    def count(self) -> int:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def has(self, r: mreg_t) -> bool:
        ...
    def has_all(self, r: mreg_t, size: int) -> bool:
        ...
    def has_any(self, r: mreg_t, size: int) -> bool:
        ...
    def has_common(self, lst: mlist_t) -> bool:
        ...
    def has_memory(self) -> bool:
        ...
    def includes(self, lst: mlist_t) -> bool:
        ...
    def intersect(self, lst: mlist_t) -> bool:
        ...
    def is_subset_of(self, lst: mlist_t) -> bool:
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(r: mreg_t, size: int) -> bool
            1. sub(ivl: const ivl_t &) -> bool
            2. sub(lst: const mlist_t &) -> bool
        
        # 0: sub(r: mreg_t, size: int) -> bool
        
        
        # 1: sub(ivl: const ivl_t &) -> bool
        
        
        # 2: sub(lst: const mlist_t &) -> bool
        
        
        """
        ...
    def swap(self, r: mlist_t) -> None:
        ...

class mnumber_t(operand_locator_t):
    @property
    def ea(self) -> Any: ...
    @property
    def opnum(self) -> Any: ...
    @property
    def org_value(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: mnumber_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: mnumber_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: mnumber_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: mnumber_t) -> bool:
        ...
    def __lt__(self, r: mnumber_t) -> bool:
        ...
    def __ne__(self, r: mnumber_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: mnumber_t) -> int:
        ...
    def update_value(self, val64: uint64) -> None:
        ...

class moddata_diff_helper_t:
    @property
    def additional_mh_flags(self) -> Any: ...
    @property
    def fields(self) -> Any: ...
    @property
    def module_name(self) -> Any: ...
    @property
    def netnode_name(self) -> Any: ...
    @property
    def nfields(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _module_name: str, _netnode_name: str, _fields: idbattr_info_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_struc_ptr(self, arg0: merge_data_t, arg1: diff_source_idx_t, arg2: idbattr_info_t) -> None:
        ...
    def merge_ending(self, arg0: diff_source_idx_t, arg1: void) -> None:
        ...
    def merge_starting(self, arg0: diff_source_idx_t, arg1: void) -> None:
        ...
    def print_diffpos_details(self, arg0: qstrvec_t, arg1: idbattr_info_t) -> None:
        ...
    def str2val(self, arg0: uint64, arg1: idbattr_info_t, arg2: str) -> bool:
        ...
    def val2str(self, arg0: str, arg1: idbattr_info_t, arg2: uint64) -> bool:
        ...

class modinfo_t:
    @property
    def base(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def rebase_to(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class mop_addr_t(mop_t):
    @property
    def a(self) -> Any: ...
    @property
    def b(self) -> Any: ...
    @property
    def c(self) -> Any: ...
    @property
    def cstr(self) -> Any: ...
    @property
    def d(self) -> Any: ...
    @property
    def f(self) -> Any: ...
    @property
    def fpc(self) -> Any: ...
    @property
    def g(self) -> Any: ...
    @property
    def helper(self) -> Any: ...
    @property
    def insize(self) -> Any: ...
    @property
    def l(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def nnn(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def oprops(self) -> Any: ...
    @property
    def outsize(self) -> Any: ...
    @property
    def pair(self) -> Any: ...
    @property
    def r(self) -> Any: ...
    @property
    def s(self) -> Any: ...
    @property
    def scif(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def t(self) -> Any: ...
    @property
    def valnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, rop: mop_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, rop: mop_t) -> bool:
        ...
    def __ne__(self, rop: mop_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_ld_mcode(self, mcode: mcode_t, ea: ida_idaapi.ea_t, newsize: int) -> None:
        r"""Apply a unary opcode to the operand. 
                
        :param mcode: opcode to apply. it must accept 'l' and 'd' operands but not 'r'. examples: m_low/m_high/m_xds/m_xdu
        :param ea: value of minsn_t::ea for the newly created insruction
        :param newsize: new operand size Example: apply_ld_mcode(m_low) will convert op => low(op)
        """
        ...
    def apply_xds(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def apply_xdu(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def assign(self, rop: mop_t) -> mop_t:
        ...
    def change_size(self, nsize: int, sideff: side_effect_t = 1) -> bool:
        r"""Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1 
                
        :param nsize: new operand size
        :param sideff: may modify the database because of the size change?
        :returns: success
        """
        ...
    def create_from_insn(self, m: minsn_t) -> None:
        r"""Create operand from an instruction. This function creates a nested instruction that can be used as an operand. Example: if m="add x,y,z", our operand will be (t=mop_d,d=m). The destination operand of 'add' (z) is lost. 
                
        :param m: instruction to embed into operand. may not be nullptr.
        """
        ...
    def create_from_ivlset(self, mba: mba_t, ivs: ivlset_t, fullsize: int) -> bool:
        r"""Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4) 
                
        :param mba: pointer to microcode
        :param ivs: set of memory intervals
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_mlist(self, mba: mba_t, lst: mlist_t, fullsize: int) -> bool:
        r"""Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our operand will be (t=mop_r, r=R0, size=4) 
                
        :param mba: pointer to microcode
        :param lst: list of locations
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_scattered_vdloc(self, mba: mba_t, name: str, type: tinfo_t, loc: vdloc_t) -> None:
        r"""Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4, EDX.4}) 
                
        :param mba: pointer to microcode
        :param name: name of the operand, if available
        :param type: type of the operand, must be present
        :param loc: a scattered location
        :returns: success
        """
        ...
    def create_from_vdloc(self, mba: mba_t, loc: vdloc_t, _size: int) -> None:
        r"""Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0, size=_SIZE) 
                
        :param mba: pointer to microcode
        :param loc: location
        :param _size: operand size Note: this function cannot handle scattered locations.
        :returns: success
        """
        ...
    def double_size(self, sideff: side_effect_t = 1) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equal_mops(self, rop: mop_t, eqflags: int) -> bool:
        r"""Compare operands. This is the main comparison function for operands. 
                
        :param rop: operand to compare with
        :param eqflags: combination of comparison bits bits
        """
        ...
    def erase(self) -> None:
        ...
    def erase_but_keep_size(self) -> None:
        ...
    def for_all_ops(self, mv: mop_visitor_t, type: tinfo_t = None, is_target: bool = False) -> int:
        r"""Visit the operand and all its sub-operands. This function visits the current operand as well. 
                
        :param mv: visitor object
        :param type: operand type
        :param is_target: is a destination operand?
        """
        ...
    def for_all_scattered_submops(self, sv: scif_visitor_t) -> int:
        r"""Visit all sub-operands of a scattered operand. This function does not visit the current operand, only its sub-operands. All sub-operands are synthetic and are destroyed after the visitor. This function works only with scattered operands. 
                
        :param sv: visitor object
        """
        ...
    def get_insn(self, code: mcode_t) -> minsn_t:
        r"""Get subinstruction of the operand. If the operand has a subinstruction with the specified opcode, return it. 
                
        :param code: desired opcode
        :returns: pointer to the instruction or nullptr
        """
        ...
    def get_stkoff(self, p_vdoff: sval_t) -> bool:
        r"""Get the referenced stack offset. This function can also handle mop_sc if it is entirely mapped into a continuous stack region. 
                
        :param p_vdoff: the output buffer
        :returns: success
        """
        ...
    def get_stkvar(self, udm: udm_t = None, p_idaoff: uval_t = None) -> ssize_t:
        r"""Retrieve the referenced stack variable. 
                
        :param udm: stkvar, may be nullptr
        :param p_idaoff: if specified, will hold IDA stkoff after the call.
        :returns: index of stkvar in the frame or -1
        """
        ...
    def has_side_effects(self, include_ldx_and_divs: bool = False) -> bool:
        r"""Has any side effects? 
                
        :param include_ldx_and_divs: consider ldx/div/mod as having side effects?
        """
        ...
    def is01(self) -> bool:
        r"""Are the possible values of the operand only 0 and 1? This function returns true for 0/1 constants, bit registers, the result of 'set' insns, etc. 
                
        """
        ...
    def is_arglist(self) -> bool:
        r"""Is a list of arguments?
        
        """
        ...
    def is_bit_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_bit_reg() -> bool
            1. is_bit_reg(reg: mreg_t) -> bool
        
        # 0: is_bit_reg() -> bool
        
        
        # 1: is_bit_reg(reg: mreg_t) -> bool
        
        Is a bit register? This includes condition codes and eventually other bit registers 
                
        
        """
        ...
    def is_cc(self) -> bool:
        r"""Is a condition code?
        
        """
        ...
    def is_ccflags(self) -> bool:
        ...
    def is_constant(self, is_signed: bool = True) -> bool:
        r"""Retrieve value of a constant integer operand. 
                
        :param is_signed: should treat the value as signed
        :returns: true if the operand is mop_n
        """
        ...
    def is_equal_to(self, n: uint64, is_signed: bool = True) -> bool:
        ...
    def is_extended_from(self, nbytes: int, is_signed: bool) -> bool:
        r"""Does the high part of the operand consist of zero or sign bytes?
        
        """
        ...
    def is_for_abi(self) -> bool:
        ...
    def is_glbaddr(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_glbaddr() -> bool
            1. is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        # 0: is_glbaddr() -> bool
        
        Is address of a global memory cell?
        
        
        # 1: is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        Is address of the specified global memory cell?
        
        
        """
        ...
    def is_glbaddr_from_fixup(self) -> bool:
        ...
    def is_glbvar(self) -> bool:
        r"""Is a global variable?
        
        """
        ...
    def is_impptr_done(self) -> bool:
        ...
    def is_insn(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_insn() -> bool
            1. is_insn(code: mcode_t) -> bool
        
        # 0: is_insn() -> bool
        
        Is a sub-instruction?
        
        
        # 1: is_insn(code: mcode_t) -> bool
        
        Is a sub-instruction with the specified opcode?
        
        
        """
        ...
    def is_kreg(self) -> bool:
        r"""Is a kernel register?
        
        """
        ...
    def is_lowaddr(self) -> bool:
        ...
    def is_mblock(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_mblock() -> bool
            1. is_mblock(serial: int) -> bool
        
        # 0: is_mblock() -> bool
        
        Is a block reference?
        
        
        # 1: is_mblock(serial: int) -> bool
        
        Is a block reference to the specified block?
        
        
        """
        ...
    def is_negative_constant(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_pcval(self) -> bool:
        ...
    def is_positive_constant(self) -> bool:
        ...
    def is_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_reg() -> bool
            1. is_reg(_r: mreg_t) -> bool
            2. is_reg(_r: mreg_t, _size: int) -> bool
        
        # 0: is_reg() -> bool
        
        Is a register operand? See also get_mreg_name() 
                
        
        # 1: is_reg(_r: mreg_t) -> bool
        
        Is the specified register?
        
        
        # 2: is_reg(_r: mreg_t, _size: int) -> bool
        
        Is the specified register of the specified size?
        
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""Is a scattered operand?
        
        """
        ...
    def is_sign_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of the sign bytes? 
                
        :param nbytes: number of bytes that were sign extended. the remaining size-nbytes high bytes must be sign bytes Example: is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3 bytes are certainly sign bits
        """
        ...
    def is_stkaddr(self) -> bool:
        r"""Is address of a stack variable?
        
        """
        ...
    def is_stkvar(self) -> bool:
        r"""Is a stack variable?
        
        """
        ...
    def is_udt(self) -> bool:
        ...
    def is_undef_val(self) -> bool:
        ...
    def is_zero(self) -> bool:
        ...
    def is_zero_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of zero bytes? 
                
        :param nbytes: number of bytes that were zero extended. the remaining size-nbytes high bytes must be zero Example: is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6 bytes are certainly zero
        """
        ...
    def lexcompare(self, ra: mop_addr_t) -> int:
        ...
    def make_blkref(self, blknum: int) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_first_half(self, width: int) -> bool:
        r"""Make the first part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_fpnum(self, bytes: void) -> bool:
        r"""Create a floating point constant operand. 
                
        :param bytes: pointer to the floating point value as used by the current processor (e.g. for x86 it must be in IEEE 754)
        :returns: success
        """
        ...
    def make_gvar(self, ea: ida_idaapi.ea_t) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_helper(self, name: str) -> None:
        r"""Create a helper operand. A helper operand usually keeps a built-in function name like "va_start" It is essentially just an arbitrary identifier without any additional info. 
                
        """
        ...
    def make_high_half(self, width: int) -> bool:
        r"""Make the high part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_insn(self, ins: minsn_t) -> None:
        r"""Create a nested instruction.
        
        """
        ...
    def make_low_half(self, width: int) -> bool:
        r"""Make the low part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_number(self, args: Any) -> None:
        r"""Create an integer constant operand. 
                
        :param _value: value to store in the operand
        :param _size: size of the value in bytes (1,2,4,8)
        :param _ea: address of the processor instruction that made the value
        :param opnum: operand number of the processor instruction
        """
        ...
    def make_reg(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. make_reg(reg: mreg_t) -> None
            1. make_reg(reg: mreg_t, _size: int) -> None
        
        # 0: make_reg(reg: mreg_t) -> None
        
        Create a register operand.
        
        
        # 1: make_reg(reg: mreg_t, _size: int) -> None
        
        
        """
        ...
    def make_reg_pair(self, loreg: int, hireg: int, halfsize: int) -> None:
        r"""Create pair of registers. 
                
        :param loreg: register holding the low part of the value
        :param hireg: register holding the high part of the value
        :param halfsize: the size of each of loreg/hireg
        """
        ...
    def make_second_half(self, width: int) -> bool:
        r"""Make the second part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_stkvar(self, mba: mba_t, off: int) -> None:
        ...
    def may_use_aliased_memory(self) -> bool:
        r"""Is it possible for the operand to use aliased memory?
        
        """
        ...
    def preserve_side_effects(self, blk: mblock_t, top: minsn_t, moved_calls: bool = None) -> bool:
        r"""Move subinstructions with side effects out of the operand. If we decide to delete an instruction operand, it is a good idea to call this function. Alternatively we should skip such operands by calling mop_t::has_side_effects() For example, if we transform: jnz x, x, @blk => goto @blk then we must call this function before deleting the X operands. 
                
        :param blk: current block
        :param top: top level instruction that contains our operand
        :param moved_calls: pointer to the boolean that will track if all side effects get handled correctly. must be false initially.
        :returns: false failed to preserve a side effect, it is not safe to delete the operand true no side effects or successfully preserved them
        """
        ...
    def probably_floating(self) -> bool:
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def set_for_abi(self) -> None:
        ...
    def set_impptr_done(self) -> None:
        ...
    def set_lowaddr(self) -> None:
        ...
    def set_udt(self) -> None:
        ...
    def set_undef_val(self) -> None:
        ...
    def shift_mop(self, offset: int) -> bool:
        r"""Shift the operand. This function shifts only the beginning of the operand. The operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1 
                
        :param offset: shift count (the number of bytes to shift)
        :returns: success
        """
        ...
    def signed_value(self) -> int64:
        ...
    def swap(self, rop: mop_t) -> None:
        ...
    def unsigned_value(self) -> uint64:
        ...
    def update_numop_value(self, val: uint64) -> None:
        ...
    def value(self, is_signed: bool) -> uint64:
        r"""Retrieve value of a constant integer operand. These functions can be called only for mop_n operands. See is_constant() that can be called on any operand. 
                
        """
        ...
    def zero(self) -> None:
        ...

class mop_pair_t:
    @property
    def hop(self) -> Any: ...
    @property
    def lop(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class mop_t:
    @property
    def a(self) -> Any: ...
    @property
    def b(self) -> Any: ...
    @property
    def c(self) -> Any: ...
    @property
    def cstr(self) -> Any: ...
    @property
    def d(self) -> Any: ...
    @property
    def f(self) -> Any: ...
    @property
    def fpc(self) -> Any: ...
    @property
    def g(self) -> Any: ...
    @property
    def helper(self) -> Any: ...
    @property
    def l(self) -> Any: ...
    @property
    def meminfo(self) -> Any: ...
    @property
    def nnn(self) -> Any: ...
    @property
    def obj_id(self) -> Any: ...
    @property
    def oprops(self) -> Any: ...
    @property
    def pair(self) -> Any: ...
    @property
    def r(self) -> Any: ...
    @property
    def s(self) -> Any: ...
    @property
    def scif(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def t(self) -> Any: ...
    @property
    def valnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, rop: mop_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, rop: mop_t) -> bool:
        ...
    def __ne__(self, rop: mop_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_ld_mcode(self, mcode: mcode_t, ea: ida_idaapi.ea_t, newsize: int) -> None:
        r"""Apply a unary opcode to the operand. 
                
        :param mcode: opcode to apply. it must accept 'l' and 'd' operands but not 'r'. examples: m_low/m_high/m_xds/m_xdu
        :param ea: value of minsn_t::ea for the newly created insruction
        :param newsize: new operand size Example: apply_ld_mcode(m_low) will convert op => low(op)
        """
        ...
    def apply_xds(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def apply_xdu(self, ea: ida_idaapi.ea_t, newsize: int) -> None:
        ...
    def assign(self, rop: mop_t) -> mop_t:
        ...
    def change_size(self, nsize: int, sideff: side_effect_t = 1) -> bool:
        r"""Change the operand size. Examples: change_size(AL.1, 2) -> AX.2 change_size(qword_00000008.8, 4) -> dword_00000008.4 change_size(xdu.8(op.4), 4) -> op.4 change_size(#0x12345678.4, 1) -> #0x78.1 
                
        :param nsize: new operand size
        :param sideff: may modify the database because of the size change?
        :returns: success
        """
        ...
    def create_from_insn(self, m: minsn_t) -> None:
        r"""Create operand from an instruction. This function creates a nested instruction that can be used as an operand. Example: if m="add x,y,z", our operand will be (t=mop_d,d=m). The destination operand of 'add' (z) is lost. 
                
        :param m: instruction to embed into operand. may not be nullptr.
        """
        ...
    def create_from_ivlset(self, mba: mba_t, ivs: ivlset_t, fullsize: int) -> bool:
        r"""Create operand from ivlset_t. Example: if IVS contains [glbvar..glbvar+4), our operand will be (t=mop_v, g=&glbvar, size=4) 
                
        :param mba: pointer to microcode
        :param ivs: set of memory intervals
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_mlist(self, mba: mba_t, lst: mlist_t, fullsize: int) -> bool:
        r"""Create operand from mlist_t. Example: if LST contains 4 bits for R0.4, our operand will be (t=mop_r, r=R0, size=4) 
                
        :param mba: pointer to microcode
        :param lst: list of locations
        :param fullsize: mba->fullsize
        :returns: success
        """
        ...
    def create_from_scattered_vdloc(self, mba: mba_t, name: str, type: tinfo_t, loc: vdloc_t) -> None:
        r"""Create operand from scattered vdloc_t. Example: if LOC is (ALOC_DIST, {EAX.4, EDX.4}) and TYPE is _LARGE_INTEGER, our operand will be (t=mop_sc, scif={EAX.4, EDX.4}) 
                
        :param mba: pointer to microcode
        :param name: name of the operand, if available
        :param type: type of the operand, must be present
        :param loc: a scattered location
        :returns: success
        """
        ...
    def create_from_vdloc(self, mba: mba_t, loc: vdloc_t, _size: int) -> None:
        r"""Create operand from vdloc_t. Example: if LOC contains (type=ALOC_REG1, r=R0), our operand will be (t=mop_r, r=R0, size=_SIZE) 
                
        :param mba: pointer to microcode
        :param loc: location
        :param _size: operand size Note: this function cannot handle scattered locations.
        :returns: success
        """
        ...
    def double_size(self, sideff: side_effect_t = 1) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equal_mops(self, rop: mop_t, eqflags: int) -> bool:
        r"""Compare operands. This is the main comparison function for operands. 
                
        :param rop: operand to compare with
        :param eqflags: combination of comparison bits bits
        """
        ...
    def erase(self) -> None:
        ...
    def erase_but_keep_size(self) -> None:
        ...
    def for_all_ops(self, mv: mop_visitor_t, type: tinfo_t = None, is_target: bool = False) -> int:
        r"""Visit the operand and all its sub-operands. This function visits the current operand as well. 
                
        :param mv: visitor object
        :param type: operand type
        :param is_target: is a destination operand?
        """
        ...
    def for_all_scattered_submops(self, sv: scif_visitor_t) -> int:
        r"""Visit all sub-operands of a scattered operand. This function does not visit the current operand, only its sub-operands. All sub-operands are synthetic and are destroyed after the visitor. This function works only with scattered operands. 
                
        :param sv: visitor object
        """
        ...
    def get_insn(self, code: mcode_t) -> minsn_t:
        r"""Get subinstruction of the operand. If the operand has a subinstruction with the specified opcode, return it. 
                
        :param code: desired opcode
        :returns: pointer to the instruction or nullptr
        """
        ...
    def get_stkoff(self, p_vdoff: sval_t) -> bool:
        r"""Get the referenced stack offset. This function can also handle mop_sc if it is entirely mapped into a continuous stack region. 
                
        :param p_vdoff: the output buffer
        :returns: success
        """
        ...
    def get_stkvar(self, udm: udm_t = None, p_idaoff: uval_t = None) -> ssize_t:
        r"""Retrieve the referenced stack variable. 
                
        :param udm: stkvar, may be nullptr
        :param p_idaoff: if specified, will hold IDA stkoff after the call.
        :returns: index of stkvar in the frame or -1
        """
        ...
    def has_side_effects(self, include_ldx_and_divs: bool = False) -> bool:
        r"""Has any side effects? 
                
        :param include_ldx_and_divs: consider ldx/div/mod as having side effects?
        """
        ...
    def is01(self) -> bool:
        r"""Are the possible values of the operand only 0 and 1? This function returns true for 0/1 constants, bit registers, the result of 'set' insns, etc. 
                
        """
        ...
    def is_arglist(self) -> bool:
        r"""Is a list of arguments?
        
        """
        ...
    def is_bit_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_bit_reg() -> bool
            1. is_bit_reg(reg: mreg_t) -> bool
        
        # 0: is_bit_reg() -> bool
        
        
        # 1: is_bit_reg(reg: mreg_t) -> bool
        
        Is a bit register? This includes condition codes and eventually other bit registers 
                
        
        """
        ...
    def is_cc(self) -> bool:
        r"""Is a condition code?
        
        """
        ...
    def is_ccflags(self) -> bool:
        ...
    def is_constant(self, is_signed: bool = True) -> bool:
        r"""Retrieve value of a constant integer operand. 
                
        :param is_signed: should treat the value as signed
        :returns: true if the operand is mop_n
        """
        ...
    def is_equal_to(self, n: uint64, is_signed: bool = True) -> bool:
        ...
    def is_extended_from(self, nbytes: int, is_signed: bool) -> bool:
        r"""Does the high part of the operand consist of zero or sign bytes?
        
        """
        ...
    def is_for_abi(self) -> bool:
        ...
    def is_glbaddr(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_glbaddr() -> bool
            1. is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        # 0: is_glbaddr() -> bool
        
        Is address of a global memory cell?
        
        
        # 1: is_glbaddr(ea: ida_idaapi.ea_t) -> bool
        
        Is address of the specified global memory cell?
        
        
        """
        ...
    def is_glbaddr_from_fixup(self) -> bool:
        ...
    def is_glbvar(self) -> bool:
        r"""Is a global variable?
        
        """
        ...
    def is_impptr_done(self) -> bool:
        ...
    def is_insn(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_insn() -> bool
            1. is_insn(code: mcode_t) -> bool
        
        # 0: is_insn() -> bool
        
        Is a sub-instruction?
        
        
        # 1: is_insn(code: mcode_t) -> bool
        
        Is a sub-instruction with the specified opcode?
        
        
        """
        ...
    def is_kreg(self) -> bool:
        r"""Is a kernel register?
        
        """
        ...
    def is_lowaddr(self) -> bool:
        ...
    def is_mblock(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_mblock() -> bool
            1. is_mblock(serial: int) -> bool
        
        # 0: is_mblock() -> bool
        
        Is a block reference?
        
        
        # 1: is_mblock(serial: int) -> bool
        
        Is a block reference to the specified block?
        
        
        """
        ...
    def is_negative_constant(self) -> bool:
        ...
    def is_one(self) -> bool:
        ...
    def is_pcval(self) -> bool:
        ...
    def is_positive_constant(self) -> bool:
        ...
    def is_reg(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_reg() -> bool
            1. is_reg(_r: mreg_t) -> bool
            2. is_reg(_r: mreg_t, _size: int) -> bool
        
        # 0: is_reg() -> bool
        
        Is a register operand? See also get_mreg_name() 
                
        
        # 1: is_reg(_r: mreg_t) -> bool
        
        Is the specified register?
        
        
        # 2: is_reg(_r: mreg_t, _size: int) -> bool
        
        Is the specified register of the specified size?
        
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""Is a scattered operand?
        
        """
        ...
    def is_sign_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of the sign bytes? 
                
        :param nbytes: number of bytes that were sign extended. the remaining size-nbytes high bytes must be sign bytes Example: is_sign_extended_from(xds.4(op.1), 1) -> true because the high 3 bytes are certainly sign bits
        """
        ...
    def is_stkaddr(self) -> bool:
        r"""Is address of a stack variable?
        
        """
        ...
    def is_stkvar(self) -> bool:
        r"""Is a stack variable?
        
        """
        ...
    def is_udt(self) -> bool:
        ...
    def is_undef_val(self) -> bool:
        ...
    def is_zero(self) -> bool:
        ...
    def is_zero_extended_from(self, nbytes: int) -> bool:
        r"""Does the high part of the operand consist of zero bytes? 
                
        :param nbytes: number of bytes that were zero extended. the remaining size-nbytes high bytes must be zero Example: is_zero_extended_from(xdu.8(op.1), 2) -> true because the high 6 bytes are certainly zero
        """
        ...
    def lexcompare(self, rop: mop_t) -> int:
        ...
    def make_blkref(self, blknum: int) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_first_half(self, width: int) -> bool:
        r"""Make the first part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_fpnum(self, bytes: void) -> bool:
        r"""Create a floating point constant operand. 
                
        :param bytes: pointer to the floating point value as used by the current processor (e.g. for x86 it must be in IEEE 754)
        :returns: success
        """
        ...
    def make_gvar(self, ea: ida_idaapi.ea_t) -> None:
        r"""Create a global variable operand.
        
        """
        ...
    def make_helper(self, name: str) -> None:
        r"""Create a helper operand. A helper operand usually keeps a built-in function name like "va_start" It is essentially just an arbitrary identifier without any additional info. 
                
        """
        ...
    def make_high_half(self, width: int) -> bool:
        r"""Make the high part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_insn(self, ins: minsn_t) -> None:
        r"""Create a nested instruction.
        
        """
        ...
    def make_low_half(self, width: int) -> bool:
        r"""Make the low part of the operand. This function takes into account the memory endianness (byte sex) 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_number(self, args: Any) -> None:
        r"""Create an integer constant operand. 
                
        :param _value: value to store in the operand
        :param _size: size of the value in bytes (1,2,4,8)
        :param _ea: address of the processor instruction that made the value
        :param opnum: operand number of the processor instruction
        """
        ...
    def make_reg(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. make_reg(reg: mreg_t) -> None
            1. make_reg(reg: mreg_t, _size: int) -> None
        
        # 0: make_reg(reg: mreg_t) -> None
        
        Create a register operand.
        
        
        # 1: make_reg(reg: mreg_t, _size: int) -> None
        
        
        """
        ...
    def make_reg_pair(self, loreg: int, hireg: int, halfsize: int) -> None:
        r"""Create pair of registers. 
                
        :param loreg: register holding the low part of the value
        :param hireg: register holding the high part of the value
        :param halfsize: the size of each of loreg/hireg
        """
        ...
    def make_second_half(self, width: int) -> bool:
        r"""Make the second part of the operand. This function does not care about the memory endianness 
                
        :param width: the desired size of the operand part in bytes
        :returns: success
        """
        ...
    def make_stkvar(self, mba: mba_t, off: int) -> None:
        ...
    def may_use_aliased_memory(self) -> bool:
        r"""Is it possible for the operand to use aliased memory?
        
        """
        ...
    def preserve_side_effects(self, blk: mblock_t, top: minsn_t, moved_calls: bool = None) -> bool:
        r"""Move subinstructions with side effects out of the operand. If we decide to delete an instruction operand, it is a good idea to call this function. Alternatively we should skip such operands by calling mop_t::has_side_effects() For example, if we transform: jnz x, x, @blk => goto @blk then we must call this function before deleting the X operands. 
                
        :param blk: current block
        :param top: top level instruction that contains our operand
        :param moved_calls: pointer to the boolean that will track if all side effects get handled correctly. must be false initially.
        :returns: false failed to preserve a side effect, it is not safe to delete the operand true no side effects or successfully preserved them
        """
        ...
    def probably_floating(self) -> bool:
        ...
    def replace_by(self, o: Any) -> Any:
        ...
    def set_for_abi(self) -> None:
        ...
    def set_impptr_done(self) -> None:
        ...
    def set_lowaddr(self) -> None:
        ...
    def set_udt(self) -> None:
        ...
    def set_undef_val(self) -> None:
        ...
    def shift_mop(self, offset: int) -> bool:
        r"""Shift the operand. This function shifts only the beginning of the operand. The operand size will be changed. Examples: shift_mop(AH.1, -1) -> AX.2 shift_mop(qword_00000008.8, 4) -> dword_0000000C.4 shift_mop(xdu.8(op.4), 4) -> #0.4 shift_mop(#0x12345678.4, 3) -> #12.1 
                
        :param offset: shift count (the number of bytes to shift)
        :returns: success
        """
        ...
    def signed_value(self) -> int64:
        ...
    def swap(self, rop: mop_t) -> None:
        ...
    def unsigned_value(self) -> uint64:
        ...
    def update_numop_value(self, val: uint64) -> None:
        ...
    def value(self, is_signed: bool) -> uint64:
        r"""Retrieve value of a constant integer operand. These functions can be called only for mop_n operands. See is_constant() that can be called on any operand. 
                
        """
        ...
    def zero(self) -> None:
        ...

class mop_visitor_t(op_parent_info_t):
    @property
    def blk(self) -> Any: ...
    @property
    def curins(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def prune(self) -> Any: ...
    @property
    def topins(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_mop(self, op: mop_t, type: tinfo_t, is_target: bool) -> int:
        ...

class mopvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: mopvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> mop_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: mopvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: mop_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: mop_t) -> bool:
        ...
    def append(self, x: mop_t) -> None:
        ...
    def at(self, _idx: size_t) -> mop_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: mopvec_t) -> None:
        ...
    def extract(self) -> mop_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: mop_t) -> bool:
        ...
    def inject(self, s: mop_t, len: size_t) -> None:
        ...
    def insert(self, it: mop_t, x: mop_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> mop_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: mopvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class mutable_graph_t(drawable_graph_t, gdl_graph_t):
    @property
    def belongs(self) -> Any: ...
    @property
    def callback_ud(self) -> Any: ...
    @property
    def circle_center(self) -> Any: ...
    @property
    def circle_radius(self) -> Any: ...
    @property
    def current_layout(self) -> Any: ...
    @property
    def edges(self) -> Any: ...
    @property
    def gid(self) -> Any: ...
    @property
    def node_flags(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def org_preds(self) -> Any: ...
    @property
    def org_succs(self) -> Any: ...
    @property
    def preds(self) -> Any: ...
    @property
    def rect_edges_made(self) -> Any: ...
    @property
    def succs(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_edge(self, i: int, j: int, ei: edge_info_t) -> bool:
        ...
    def add_node(self, r: rect_t) -> int:
        r"""Add a node, possibly with a specific geometry
        
        :param r: the node geometry (can be nullptr)
        :returns: the new node
        """
        ...
    def begin(self) -> node_iterator:
        ...
    def calc_group_ea(self, arg2: intvec_t) -> ida_idaapi.ea_t:
        ...
    def change_group_visibility(self, group: int, expand: bool) -> bool:
        r"""Expand/collapse a group node
        
        :param group: the group node
        :param expand: whether to expand or collapse
        :returns: success
        """
        ...
    def create_circle_layout(self, p: point_t, radius: int) -> bool:
        ...
    def create_digraph_layout(self) -> bool:
        ...
    def create_group(self, nodes: intvec_t) -> int:
        r"""Create a new group node, that will contain all the nodes in 'nodes'.
        
        :param nodes: the nodes that will be part of the group
        :returns: the group node, or -1 in case of error
        """
        ...
    def create_tree_layout(self) -> bool:
        ...
    def del_custom_layout(self) -> None:
        ...
    def del_edge(self, i: int, j: int) -> bool:
        ...
    def del_node(self, n: int) -> ssize_t:
        r"""Delete a node
        
        :param n: the node to delete
        :returns: the number of deleted edges
        """
        ...
    def delete_group(self, group: int) -> bool:
        r"""Delete a group node.
        This deletes the group node only; it does not delete nodes that are part of the group.
        
        :param group: the group node
        :returns: success
        """
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        r"""Is the graph (visually) empty? 
                
        :returns: true if there are no visible nodes
        """
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        r"""Is the node visible?
        
        :param node: the node number
        :returns: success
        """
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_custom_layout(self) -> bool:
        ...
    def get_edge(self, e: edge_t) -> edge_info_t:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_first_subgraph_node(self, group: int) -> int:
        ...
    def get_graph_groups(self) -> bool:
        ...
    def get_next_subgraph_node(self, group: int, current: int) -> int:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_group(self, node: int) -> int:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def get_node_representative(self, node: int) -> int:
        r"""Get the node that currently visually represents 'node'. This will find the "closest" parent group node that's visible, by attempting to walk up the group nodes that contain 'node', and will stop when it finds a node that is currently visible.
        See also get_group_node() 
                
        :param node: the node
        :returns: the node that represents 'node', or 'node' if it's not part of any group
        """
        ...
    def grcall(self, code: int) -> ssize_t:
        ...
    def is_collapsed_node(self, node: int) -> bool:
        ...
    def is_deleted_node(self, node: int) -> bool:
        ...
    def is_displayable_node(self, node: int) -> bool:
        ...
    def is_dot_node(self, node: int) -> bool:
        ...
    def is_group_node(self, node: int) -> bool:
        ...
    def is_simple_node(self, node: int) -> bool:
        ...
    def is_subgraph_node(self, node: int) -> bool:
        ...
    def is_uncollapsed_node(self, node: int) -> bool:
        ...
    def is_user_graph(self) -> bool:
        ...
    def is_visible_node(self, node: int) -> bool:
        r"""Is the node currently visible?
        An invisible node is a node that's part of a group that's currently collapsed.
        
        :param node: the node
        :returns: success
        """
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        r"""Get the number of visible nodes (the list can be retrieved using gdl.hpp's node_iterator)
        See also size()
        
        :returns: the number of visible nodes
        """
        ...
    def npred(self, b: int) -> int:
        ...
    def nrect(self, n: int) -> rect_t:
        ...
    def nsucc(self, b: int) -> int:
        ...
    def pred(self, b: int, i: int) -> int:
        ...
    def predset(self, b: int) -> intvec_t:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def redo_layout(self) -> bool:
        r"""Recompute the layout, according to the value of 'current_layout'.
        
        :returns: success
        """
        ...
    def refresh(self) -> bool:
        r"""Refresh the graph
        A graph needs refreshing when it's "backing data". E.g., if the number (or contents) of the objects in the above example, change.
        Let's say the user's plugin ends up finding a 5th piece of scattered data. It should then add it to its internal list of known objects, and tell IDA that the graph needs to be refreshed, using refresh_viewer(). This will cause IDA to:
        * discard all its internal rendering information,
        * call interactive_graph_t::refresh() on the graph so that the user's plugin has a chance to "sync" the number of nodes & edges that this graph contains, to the information that the plugin has collected so far
        * re-create internal rendering information, and
        * repaint the view
        
        
        
        :returns: success
        """
        ...
    def replace_edge(self, i: int, j: int, x: int, y: int) -> bool:
        ...
    def reset(self) -> None:
        ...
    def resize(self, n: int) -> None:
        r"""Resize the graph to 'n' nodes
        
        :param n: the new size
        """
        ...
    def set_callback(self, _callback: hook_cb_t, _ud: void) -> None:
        ...
    def set_custom_layout(self) -> None:
        ...
    def set_deleted_node(self, node: int) -> None:
        ...
    def set_edge(self, e: edge_t, ei: edge_info_t) -> bool:
        ...
    def set_graph_groups(self) -> None:
        ...
    def set_node_group(self, node: int, group: int) -> None:
        ...
    def set_nrect(self, n: int, r: rect_t) -> bool:
        ...
    def size(self) -> int:
        r"""Get the total number of nodes (including group nodes, and including hidden nodes.)
        See also node_qty()
        
        :returns: the total number of nodes in the graph
        """
        ...
    def succ(self, b: int, i: int) -> int:
        ...
    def succset(self, b: int) -> intvec_t:
        ...

class navstack_entry_t(lochist_entry_t):
    @property
    def plce(self) -> Any: ...
    @property
    def rinfo(self) -> Any: ...
    @property
    def ud_str(self) -> Any: ...
    @property
    def widget_id(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def acquire_place(self, in_p: place_t) -> None:
        ...
    def is_valid(self) -> bool:
        ...
    def place(self) -> place_t:
        ...
    def renderer_info(self) -> renderer_info_t:
        ...
    def set_place(self, p: place_t) -> None:
        ...

class navstack_t:
    @property
    def flags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_all_current(self, out: navstack_entry_vec_t) -> None:
        ...
    def get_current(self, out: navstack_entry_t, widget_id: str) -> bool:
        ...
    def get_current_stack_entry(self, out: navstack_entry_t) -> bool:
        ...
    def get_stack_entry(self, out: navstack_entry_t, index: int) -> bool:
        ...
    def init(self, defpos: navstack_entry_t, stream_name: str, _flags: int) -> bool:
        ...
    def is_history_enabled(self) -> bool:
        ...
    def netcode(self) -> nodeidx_t:
        ...
    def perform_move(self, stream_name: str, source_stream_name: str, widget_id: str, move_stack: bool) -> bool:
        ...
    def set_current(self, e: navstack_entry_t, in_charge: bool) -> None:
        ...
    def set_stack_entry(self, index: int, e: navstack_entry_t) -> None:
        ...
    def stack_back(self, out: navstack_entry_t, cnt: int, try_to_unhide: bool) -> bool:
        ...
    def stack_clear(self, new_tip: navstack_entry_t) -> None:
        ...
    def stack_forward(self, out: navstack_entry_t, cnt: int, try_to_unhide: bool) -> bool:
        ...
    def stack_index(self) -> int:
        ...
    def stack_jump(self, try_to_unhide: bool, e: navstack_entry_t) -> None:
        ...
    def stack_nav(self, out: navstack_entry_t, forward: bool, cnt: int, try_to_unhide: bool) -> bool:
        ...
    def stack_seek(self, out: navstack_entry_t, index: int, try_to_unhide: bool) -> bool:
        ...
    def stack_size(self) -> int:
        ...

class netnode:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, args: Any) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, args: Any) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def altdel(self, args: Any) -> bool:
        ...
    def altdel_all(self, args: Any) -> bool:
        ...
    def altdel_ea(self, args: Any) -> bool:
        ...
    def altdel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def altfirst(self, args: Any) -> nodeidx_t:
        ...
    def altfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def altlast(self, args: Any) -> nodeidx_t:
        ...
    def altlast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def altnext(self, args: Any) -> nodeidx_t:
        ...
    def altnext_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def altprev(self, args: Any) -> nodeidx_t:
        ...
    def altprev_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def altset(self, args: Any) -> bool:
        ...
    def altset_ea(self, args: Any) -> bool:
        ...
    def altset_idx8(self, alt: uchar, val: nodeidx_t, tag: uchar) -> bool:
        ...
    def altshift(self, args: Any) -> int:
        ...
    def altval(self, args: Any) -> nodeidx_t:
        ...
    def altval_ea(self, args: Any) -> nodeidx_t:
        ...
    def altval_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def blobshift(self, _from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> int:
        ...
    def blobsize(self, _start: nodeidx_t, tag: uchar) -> int:
        ...
    def blobsize_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> int:
        ...
    def chardel(self, alt: nodeidx_t, tag: uchar) -> bool:
        ...
    def chardel_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def chardel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def charfirst(self, tag: uchar) -> nodeidx_t:
        ...
    def charfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def charlast(self, tag: uchar) -> nodeidx_t:
        ...
    def charlast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def charnext(self, cur: nodeidx_t, tag: uchar) -> nodeidx_t:
        ...
    def charnext_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def charprev(self, cur: nodeidx_t, tag: uchar) -> nodeidx_t:
        ...
    def charprev_idx8(self, cur: uchar, tag: uchar) -> nodeidx_t:
        ...
    def charset(self, alt: nodeidx_t, val: uchar, tag: uchar) -> bool:
        ...
    def charset_ea(self, ea: ida_idaapi.ea_t, val: uchar, tag: uchar) -> bool:
        ...
    def charset_idx8(self, alt: uchar, val: uchar, tag: uchar) -> bool:
        ...
    def charshift(self, _from: nodeidx_t, to: nodeidx_t, size: nodeidx_t, tag: uchar) -> int:
        ...
    def charval(self, alt: nodeidx_t, tag: uchar) -> uchar:
        ...
    def charval_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> uchar:
        ...
    def charval_idx8(self, alt: uchar, tag: uchar) -> uchar:
        ...
    def copyto(self, destnode: netnode, count: nodeidx_t = 1) -> int:
        ...
    def create(self, args: Any) -> bool:
        ...
    def delblob(self, _start: nodeidx_t, tag: uchar) -> int:
        ...
    def delblob_ea(self, ea: ida_idaapi.ea_t, tag: uchar) -> int:
        ...
    def delvalue(self) -> bool:
        ...
    def eadel(self, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def eadel_idx8(self, idx: uchar, tag: uchar) -> bool:
        ...
    def eaget(self, ea: ida_idaapi.ea_t, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def eaget_idx(self, idx: nodeidx_t, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def eaget_idx8(self, idx: uchar, tag: uchar) -> ida_idaapi.ea_t:
        ...
    def easet(self, ea: ida_idaapi.ea_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def easet_idx(self, idx: nodeidx_t, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def easet_idx8(self, idx: uchar, addr: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def end(self) -> bool:
        ...
    def exist(self, _name: str) -> bool:
        r"""Does the netnode with the specified name exist?
        
        """
        ...
    def get_name(self) -> ssize_t:
        ...
    def getblob(self, start: Any, tag: Any) -> Any:
        r"""Get a blob from a netnode.
        
        :param start: the index where the blob starts (it may span on multiple indexes)
        :param tag: the netnode tag
        :returns: a blob, or None
        """
        ...
    def getblob_ea(self, ea: ida_idaapi.ea_t, tag: char) -> Any:
        ...
    def getclob(self, start: Any, tag: Any) -> Any:
        r"""Get a large amount of text from a netnode.
        
        :param start: the index where the clob starts (it may span on multiple indexes)
        :param tag: the netnode tag
        :returns: a clob, or None
        """
        ...
    def hashdel(self, args: Any) -> bool:
        ...
    def hashdel_all(self, args: Any) -> bool:
        ...
    def hashfirst(self, args: Any) -> ssize_t:
        ...
    def hashlast(self, args: Any) -> ssize_t:
        ...
    def hashnext(self, args: Any) -> ssize_t:
        ...
    def hashprev(self, args: Any) -> ssize_t:
        ...
    def hashset(self, args: Any) -> bool:
        ...
    def hashset_buf(self, args: Any) -> bool:
        ...
    def hashset_idx(self, args: Any) -> bool:
        ...
    def hashstr(self, args: Any) -> ssize_t:
        ...
    def hashstr_buf(self, args: Any) -> Any:
        ...
    def hashval(self, args: Any) -> ssize_t:
        ...
    def hashval_long(self, args: Any) -> nodeidx_t:
        ...
    def index(self) -> nodeidx_t:
        ...
    def kill(self) -> None:
        ...
    def long_value(self) -> nodeidx_t:
        ...
    def lower_bound(self, args: Any) -> nodeidx_t:
        ...
    def lower_bound_ea(self, args: Any) -> nodeidx_t:
        ...
    def lower_bound_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def moveto(self, destnode: netnode, count: nodeidx_t = 1) -> int:
        ...
    def next(self) -> bool:
        ...
    def prev(self) -> bool:
        ...
    def rename(self, newname: str, namlen: size_t = 0) -> bool:
        ...
    def set(self, value: void) -> bool:
        ...
    def set_long(self, x: nodeidx_t) -> bool:
        ...
    def setblob(self, buf: void, _start: nodeidx_t, tag: uchar) -> bool:
        ...
    def setblob_ea(self, buf: void, ea: ida_idaapi.ea_t, tag: uchar) -> bool:
        ...
    def start(self) -> bool:
        ...
    def supdel(self, args: Any) -> bool:
        ...
    def supdel_all(self, tag: uchar) -> bool:
        ...
    def supdel_ea(self, args: Any) -> bool:
        ...
    def supdel_idx8(self, alt: uchar, tag: uchar) -> bool:
        ...
    def supdel_range(self, idx1: nodeidx_t, idx2: nodeidx_t, tag: uchar) -> int:
        ...
    def supdel_range_idx8(self, idx1: uchar, idx2: uchar, tag: uchar) -> int:
        ...
    def supfirst(self, args: Any) -> nodeidx_t:
        ...
    def supfirst_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def suplast(self, args: Any) -> nodeidx_t:
        ...
    def suplast_idx8(self, tag: uchar) -> nodeidx_t:
        ...
    def supnext(self, args: Any) -> nodeidx_t:
        ...
    def supnext_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def supprev(self, args: Any) -> nodeidx_t:
        ...
    def supprev_idx8(self, alt: uchar, tag: uchar) -> nodeidx_t:
        ...
    def supset(self, args: Any) -> bool:
        ...
    def supset_ea(self, args: Any) -> bool:
        ...
    def supset_idx8(self, alt: uchar, value: void, tag: uchar) -> bool:
        ...
    def supshift(self, args: Any) -> int:
        ...
    def supstr(self, args: Any) -> ssize_t:
        ...
    def supstr_ea(self, args: Any) -> ssize_t:
        ...
    def supstr_idx8(self, alt: uchar, tag: uchar) -> ssize_t:
        ...
    def supval(self, args: Any) -> ssize_t:
        ...
    def supval_ea(self, args: Any) -> ssize_t:
        ...
    def supval_idx8(self, args: Any) -> ssize_t:
        ...
    def valobj(self, args: Any) -> ssize_t:
        ...
    def valstr(self) -> ssize_t:
        ...
    def value_exists(self) -> bool:
        ...

class node_bitset_t(bitset_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bitset_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bitset_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bitset_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, r: bitset_t) -> bool:
        ...
    def __len__(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def __lt__(self, r: bitset_t) -> bool:
        ...
    def __ne__(self, r: bitset_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(bit: int) -> bool
            1. add(bit: int, width: int) -> bool
            2. add(ml: const bitset_t &) -> bool
        
        # 0: add(bit: int) -> bool
        
        
        # 1: add(bit: int, width: int) -> bool
        
        
        # 2: add(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def back(self) -> int:
        ...
    def begin(self) -> iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: bitset_t) -> int:
        ...
    def copy(self, m: bitset_t) -> bitset_t:
        ...
    def count(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def cut_at(self, maxbit: int) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> iterator:
        ...
    def fill_with_ones(self, maxbit: int) -> None:
        ...
    def front(self) -> int:
        ...
    def has(self, bit: int) -> bool:
        ...
    def has_all(self, bit: int, width: int) -> bool:
        ...
    def has_any(self, bit: int, width: int) -> bool:
        ...
    def has_common(self, ml: bitset_t) -> bool:
        ...
    def inc(self, p: iterator, n: int = 1) -> None:
        ...
    def includes(self, ml: bitset_t) -> bool:
        ...
    def intersect(self, ml: bitset_t) -> bool:
        ...
    def is_subset_of(self, ml: bitset_t) -> bool:
        ...
    def itat(self, n: int) -> iterator:
        ...
    def itv(self, it: iterator) -> int:
        ...
    def last(self) -> int:
        ...
    def shift_down(self, shift: int) -> None:
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(bit: int) -> bool
            1. sub(bit: int, width: int) -> bool
            2. sub(ml: const bitset_t &) -> bool
        
        # 0: sub(bit: int) -> bool
        
        
        # 1: sub(bit: int, width: int) -> bool
        
        
        # 2: sub(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def swap(self, r: bitset_t) -> None:
        ...

class node_info_t:
    @property
    def bg_color(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def frame_color(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_flags_for_valid(self) -> int:
        r"""Get combination of Node info flags describing which attributes are valid.
        
        """
        ...
    def valid_bg_color(self) -> bool:
        r"""Has valid bg_color?
        
        """
        ...
    def valid_ea(self) -> bool:
        r"""Has valid ea?
        
        """
        ...
    def valid_flags(self) -> bool:
        r"""Has valid flags?
        
        """
        ...
    def valid_frame_color(self) -> bool:
        r"""Has valid frame_color?
        
        """
        ...
    def valid_text(self) -> bool:
        r"""Has non-empty text?
        
        """
        ...

class node_iterator:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, n: node_iterator) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, _g: gdl_graph_t, n: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, n: node_iterator) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __ref__(self) -> int:
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class node_layout_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: node_layout_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> rect_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: node_layout_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: rect_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: rect_t) -> bool:
        ...
    def append(self, x: rect_t) -> None:
        ...
    def at(self, _idx: size_t) -> rect_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: node_layout_t) -> None:
        ...
    def extract(self) -> rect_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: rect_t) -> bool:
        ...
    def inject(self, s: rect_t, len: size_t) -> None:
        ...
    def insert(self, it: rect_t, x: rect_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> rect_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: node_layout_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class node_ordering_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def clr(self, _node: int) -> bool:
        ...
    def node(self, _order: size_t) -> int:
        ...
    def order(self, _node: int) -> int:
        ...
    def resize(self, n: int) -> None:
        ...
    def set(self, _node: int, num: int) -> None:
        ...
    def size(self) -> int:
        ...

class num_range_t:
    @property
    def maxval(self) -> Any: ...
    @property
    def minval(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _min: int64, _max: int64) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class number_format_t:
    @property
    def flags(self) -> Any: ...
    @property
    def flags32(self) -> Any: ...
    @property
    def opnum(self) -> Any: ...
    @property
    def org_nbytes(self) -> Any: ...
    @property
    def props(self) -> Any: ...
    @property
    def serial(self) -> Any: ...
    @property
    def type_name(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _opnum: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_radix(self) -> int:
        r"""Get number radix 
                
        :returns: 2,8,10, or 16
        """
        ...
    def has_unmutable_type(self) -> bool:
        ...
    def is_char(self) -> bool:
        r"""Is a character constant?
        
        """
        ...
    def is_dec(self) -> bool:
        r"""Is a decimal number?
        
        """
        ...
    def is_enum(self) -> bool:
        r"""Is a symbolic constant?
        
        """
        ...
    def is_fixed(self) -> bool:
        r"""Is number representation fixed? Fixed representation cannot be modified by the decompiler 
                
        """
        ...
    def is_hex(self) -> bool:
        r"""Is a hexadecimal number?
        
        """
        ...
    def is_numop(self) -> bool:
        r"""Is a number?
        
        """
        ...
    def is_oct(self) -> bool:
        r"""Is a octal number?
        
        """
        ...
    def is_stroff(self) -> bool:
        r"""Is a structure field offset?
        
        """
        ...
    def needs_to_be_inverted(self) -> bool:
        r"""Does the number need to be negated or bitwise negated? Returns true if the user requested a negation but it is not done yet 
                
        """
        ...

class object_t:
    r"""Helper class used to initialize empty objects"""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        r"""Allow access to object attributes by index (like dictionaries)"""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, kwds: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class octet_generator_t:
    @property
    def avail_bits(self) -> Any: ...
    @property
    def ea(self) -> Any: ...
    @property
    def high_byte_first(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _ea: ida_idaapi.ea_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def invert_byte_order(self) -> None:
        ...

class op_parent_info_t:
    @property
    def blk(self) -> Any: ...
    @property
    def curins(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def topins(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _mba: mba_t = None, _blk: mblock_t = None, _topins: minsn_t = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class op_t:
    @property
    def addr(self) -> Any: ...
    @property
    def dtype(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    @property
    def offb(self) -> Any: ...
    @property
    def offo(self) -> Any: ...
    @property
    def phrase(self) -> Any: ...
    @property
    def reg(self) -> Any: ...
    @property
    def specflag1(self) -> Any: ...
    @property
    def specflag2(self) -> Any: ...
    @property
    def specflag3(self) -> Any: ...
    @property
    def specflag4(self) -> Any: ...
    @property
    def specval(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    @property
    def value64(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __get_addr__(self) -> ida_idaapi.ea_t:
        ...
    def __get_reg_phrase__(self) -> uint16:
        ...
    def __get_specval__(self) -> ida_idaapi.ea_t:
        ...
    def __get_value64__(self) -> uint64:
        ...
    def __get_value__(self) -> ida_idaapi.ea_t:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __set_addr__(self, v: ida_idaapi.ea_t) -> None:
        ...
    def __set_reg_phrase__(self, r: uint16) -> None:
        ...
    def __set_specval__(self, v: ida_idaapi.ea_t) -> None:
        ...
    def __set_value64__(self, v: uint64) -> None:
        ...
    def __set_value__(self, v: ida_idaapi.ea_t) -> None:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, other: op_t) -> None:
        ...
    def clr_shown(self) -> None:
        r"""Set operand to hidden.
        
        """
        ...
    def has_reg(self, r: Any) -> Any:
        r"""Checks if the operand accesses the given processor register"""
        ...
    def is_imm(self, v: int) -> bool:
        r"""Is immediate operand?
        
        """
        ...
    def is_reg(self, r: int) -> bool:
        r"""Is register operand?
        
        """
        ...
    def set_shown(self) -> None:
        r"""Set operand to be shown.
        
        """
        ...
    def shown(self) -> bool:
        r"""Is operand set to be shown?
        
        """
        ...

class operand_locator_t:
    @property
    def ea(self) -> Any: ...
    @property
    def opnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: operand_locator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: operand_locator_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: operand_locator_t) -> bool:
        ...
    def __init__(self, _ea: ida_idaapi.ea_t, _opnum: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: operand_locator_t) -> bool:
        ...
    def __lt__(self, r: operand_locator_t) -> bool:
        ...
    def __ne__(self, r: operand_locator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: operand_locator_t) -> int:
        ...

class operands_array:
    @property
    def bytes(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> op_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, data: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: op_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class opinfo_t:
    @property
    def cd(self) -> Any: ...
    @property
    def ec(self) -> Any: ...
    @property
    def path(self) -> Any: ...
    @property
    def ri(self) -> Any: ...
    @property
    def strtype(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class optblock_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def func(self, blk: mblock_t) -> int:
        r"""Optimize a block. This function usually performs the optimizations that require analyzing the entire block and/or its neighbors. For example it can recognize patterns and perform conversions like: b0: b0: ... ... jnz x, 0, @b2 => jnz x, 0, @b2 b1: b1: add x, 0, y mov x, y ... ... 
                
        :param blk: Basic block to optimize as a whole.
        :returns: number of changes made to the block. See also mark_lists_dirty.
        """
        ...
    def install(self) -> None:
        ...
    def remove(self) -> bool:
        ...

class optinsn_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def func(self, blk: mblock_t, ins: minsn_t, optflags: int) -> int:
        r"""Optimize an instruction. 
                
        :param blk: current basic block. maybe nullptr, which means that the instruction must be optimized without context
        :param ins: instruction to optimize; it is always a top-level instruction. the callback may not delete the instruction but may convert it into nop (see mblock_t::make_nop). to optimize sub-instructions, visit them using minsn_visitor_t. sub-instructions may not be converted into nop but can be converted to "mov x,x". for example: add x,0,x => mov x,x this callback may change other instructions in the block, but should do this with care, e.g. to no break the propagation algorithm if called with OPTI_NO_LDXOPT.
        :param optflags: combination of optimization flags bits
        :returns: number of changes made to the instruction. if after this call the instruction's use/def lists have changed, you must mark the block level lists as dirty (see mark_lists_dirty)
        """
        ...
    def install(self) -> None:
        ...
    def remove(self) -> bool:
        ...

class outctx_base_t:
    @property
    def F32(self) -> Any: ...
    @property
    def default_lnnum(self) -> Any: ...
    @property
    def insn_ea(self) -> Any: ...
    @property
    def outbuf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def close_comment(self) -> None:
        ...
    def clr_gen_label(self) -> None:
        ...
    def display_hidden(self) -> bool:
        ...
    def display_voids(self) -> bool:
        ...
    def flush_buf(self, buf: str, indent: int = -1) -> bool:
        r"""Append contents of 'buf' to the line array. Behaves like flush_outbuf but accepts an arbitrary buffer 
                
        """
        ...
    def flush_outbuf(self, indent: int = -1) -> bool:
        r"""------------------------------------------------------------------------- Functions to populate the output line array (lnar) Move the contents of the output buffer to the line array (outbuf->lnar) The kernel augments the outbuf contents with additional text like the line prefix, user-defined comments, xrefs, etc at this call. 
                
        """
        ...
    def forbid_annotations(self) -> int:
        ...
    def force_code(self) -> bool:
        ...
    def gen_block_cmt(self, cmt: str, color: color_t) -> bool:
        r"""Generate big non-indented comment lines. 
                
        :param cmt: comment text. may contain \n characters to denote new lines. should not contain comment character (;)
        :param color: color of comment text (one of Color tags)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_border_line(self, solid: bool = False) -> bool:
        r"""Generate thin border line. This function does nothing if generation of border lines is disabled. 
                
        :param solid: generate solid border line (with =), otherwise with -
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_cmt_line(self, format: str) -> bool:
        r"""Generate one non-indented comment line, colored with COLOR_AUTOCMT. 
                
        :param format: printf() style format line. The resulting comment line should not include comment character (;)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_collapsed_line(self, format: str) -> bool:
        r"""Generate one non-indented comment line, colored with COLOR_COLLAPSED. 
                
        :param format: printf() style format line. The resulting comment line should not include comment character (;)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_empty_line(self) -> bool:
        r"""Generate empty line. This function does nothing if generation of empty lines is disabled. 
                
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_empty_line_without_annotations(self) -> None:
        ...
    def gen_printf(self, indent: int, format: str) -> bool:
        r"""printf-like function to add lines to the line array. 
                
        :param indent: indention of the line. if indent == -1, the kernel will indent the line at idainfo::indent. if indent < 0, -indent will be used for indention. The first line printed with indent < 0 is considered as the most important line at the current address. Usually it is the line with the instruction itself. This line will be displayed in the cross-reference lists and other places. If you need to output an additional line before the main line then pass DEFAULT_INDENT instead of -1. The kernel will know that your line is not the most important one.
        :param format: printf style colored line to generate
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_xref_lines(self) -> bool:
        ...
    def getF(self) -> flags64_t:
        ...
    def get_stkvar(self, x: op_t, v: int, vv: sval_t, is_sp_based: int, _frame: tinfo_t) -> ssize_t:
        ...
    def init_lines_array(self, answers: qstrvec_t, maxsize: int) -> None:
        ...
    def multiline(self) -> bool:
        ...
    def only_main_line(self) -> bool:
        ...
    def out_addr_tag(self, ea: ida_idaapi.ea_t) -> None:
        r"""Output "address" escape sequence.
        
        """
        ...
    def out_btoa(self, Word: int, radix: char = 0) -> None:
        r"""Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
                
        """
        ...
    def out_char(self, c: char) -> None:
        r"""Output one character. The character is output without color codes. see also out_symbol() 
                
        """
        ...
    def out_chars(self, c: char, n: int) -> None:
        r"""Append a character multiple times.
        
        """
        ...
    def out_colored_register_line(self, str: str) -> None:
        r"""Output a colored line with register names in it. The register names will be substituted by user-defined names (regvar_t) Please note that out_tagoff tries to make substitutions too (when called with COLOR_REG) 
                
        """
        ...
    def out_keyword(self, str: str) -> None:
        r"""Output a string with COLOR_KEYWORD color.
        
        """
        ...
    def out_line(self, str: str, color: color_t = 0) -> None:
        r"""Output a string with the specified color.
        
        """
        ...
    def out_long(self, v: int, radix: char) -> None:
        r"""Output a number with appropriate color. Low level function. Use out_value() if you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of COLOR_NUMBER. 'suspop' is initialized:
        * in out_one_operand()
        * in ..\ida\gl.cpp (before calling processor_t::d_out())
        
        
        
        :param v: value to output
        :param radix: base (2,8,10,16)
        """
        ...
    def out_lvar(self, name: str, width: int = -1) -> None:
        r"""Output local variable name with COLOR_LOCNAME color.
        
        """
        ...
    def out_name_expr(self, args: Any) -> bool:
        r"""Output a name expression. 
                
        :param x: instruction operand referencing the name expression
        :param ea: address to convert to name expression
        :param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. You may pass BADADDR for this parameter but I discourage it because it prohibits checks.
        :returns: true if the name expression has been produced
        """
        ...
    def out_printf(self, format: str) -> int:
        r"""------------------------------------------------------------------------- Functions to append text to the current output buffer (outbuf) Append a formatted string to the output string. 
                
        :returns: the number of characters appended
        """
        ...
    def out_register(self, str: str) -> None:
        r"""Output a character with COLOR_REG color.
        
        """
        ...
    def out_spaces(self, len: ssize_t) -> None:
        r"""Appends spaces to outbuf until its tag_strlen becomes 'len'.
        
        """
        ...
    def out_symbol(self, c: char) -> None:
        r"""Output a character with COLOR_SYMBOL color.
        
        """
        ...
    def out_tagoff(self, tag: color_t) -> None:
        r"""Output "turn color off" escape sequence.
        
        """
        ...
    def out_tagon(self, tag: color_t) -> None:
        r"""Output "turn color on" escape sequence.
        
        """
        ...
    def out_value(self, x: op_t, outf: int = 0) -> flags64_t:
        r"""Output immediate value. Try to use this function to output all constants of instruction operands. This function outputs a number from x.addr or x.value in the form determined by F. It outputs colored text. 
                
        :param x: value to output
        :param outf: Output value flags
        :returns: flags of the output value, otherwise:
        :returns: -1: if printed a number with COLOR_ERROR
        :returns: 0: if printed a nice number or character or segment or enum
        """
        ...
    def print_label_now(self) -> bool:
        ...
    def restore_ctxflags(self, saved_flags: int) -> None:
        ...
    def retrieve_cmt(self) -> ssize_t:
        ...
    def retrieve_name(self, arg2: str, arg3: color_t) -> ssize_t:
        ...
    def set_comment_addr(self, ea: ida_idaapi.ea_t) -> None:
        ...
    def set_dlbind_opnd(self) -> None:
        ...
    def set_gen_cmt(self, on: bool = True) -> None:
        ...
    def set_gen_demangled_label(self) -> None:
        ...
    def set_gen_label(self) -> None:
        ...
    def set_gen_xrefs(self, on: bool = True) -> None:
        ...
    def setup_outctx(self, prefix: str, makeline_flags: int) -> None:
        r"""Initialization; normally used only by the kernel.
        
        """
        ...
    def stack_view(self) -> bool:
        ...
    def term_outctx(self, prefix: str = None) -> int:
        r"""Finalize the output context. 
                
        :returns: the number of generated lines.
        """
        ...

class outctx_t(outctx_base_t):
    @property
    def F32(self) -> Any: ...
    @property
    def ash(self) -> Any: ...
    @property
    def bin_ea(self) -> Any: ...
    @property
    def bin_state(self) -> Any: ...
    @property
    def bin_width(self) -> Any: ...
    @property
    def curlabel(self) -> Any: ...
    @property
    def default_lnnum(self) -> Any: ...
    @property
    def gl_bpsize(self) -> Any: ...
    @property
    def insn(self) -> Any: ...
    @property
    def insn_ea(self) -> Any: ...
    @property
    def next_line_ea(self) -> Any: ...
    @property
    def outbuf(self) -> Any: ...
    @property
    def ph(self) -> Any: ...
    @property
    def prefix_ea(self) -> Any: ...
    @property
    def procmod(self) -> Any: ...
    @property
    def saved_immvals(self) -> Any: ...
    @property
    def wif(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def close_comment(self) -> None:
        ...
    def clr_gen_label(self) -> None:
        ...
    def display_hidden(self) -> bool:
        ...
    def display_voids(self) -> bool:
        ...
    def flush_buf(self, buf: str, indent: int = -1) -> bool:
        r"""Append contents of 'buf' to the line array. Behaves like flush_outbuf but accepts an arbitrary buffer 
                
        """
        ...
    def flush_outbuf(self, indent: int = -1) -> bool:
        r"""------------------------------------------------------------------------- Functions to populate the output line array (lnar) Move the contents of the output buffer to the line array (outbuf->lnar) The kernel augments the outbuf contents with additional text like the line prefix, user-defined comments, xrefs, etc at this call. 
                
        """
        ...
    def forbid_annotations(self) -> int:
        ...
    def force_code(self) -> bool:
        ...
    def gen_block_cmt(self, cmt: str, color: color_t) -> bool:
        r"""Generate big non-indented comment lines. 
                
        :param cmt: comment text. may contain \n characters to denote new lines. should not contain comment character (;)
        :param color: color of comment text (one of Color tags)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_border_line(self, solid: bool = False) -> bool:
        r"""Generate thin border line. This function does nothing if generation of border lines is disabled. 
                
        :param solid: generate solid border line (with =), otherwise with -
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_cmt_line(self, format: str) -> bool:
        r"""Generate one non-indented comment line, colored with COLOR_AUTOCMT. 
                
        :param format: printf() style format line. The resulting comment line should not include comment character (;)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_collapsed_line(self, format: str) -> bool:
        r"""Generate one non-indented comment line, colored with COLOR_COLLAPSED. 
                
        :param format: printf() style format line. The resulting comment line should not include comment character (;)
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_empty_line(self) -> bool:
        r"""Generate empty line. This function does nothing if generation of empty lines is disabled. 
                
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_empty_line_without_annotations(self) -> None:
        ...
    def gen_func_footer(self, pfn: func_t) -> None:
        ...
    def gen_func_header(self, pfn: func_t) -> None:
        ...
    def gen_header(self, args: Any) -> None:
        ...
    def gen_header_extra(self) -> None:
        ...
    def gen_printf(self, indent: int, format: str) -> bool:
        r"""printf-like function to add lines to the line array. 
                
        :param indent: indention of the line. if indent == -1, the kernel will indent the line at idainfo::indent. if indent < 0, -indent will be used for indention. The first line printed with indent < 0 is considered as the most important line at the current address. Usually it is the line with the instruction itself. This line will be displayed in the cross-reference lists and other places. If you need to output an additional line before the main line then pass DEFAULT_INDENT instead of -1. The kernel will know that your line is not the most important one.
        :param format: printf style colored line to generate
        :returns: overflow, lnar_maxsize has been reached
        """
        ...
    def gen_xref_lines(self) -> bool:
        ...
    def getF(self) -> flags64_t:
        ...
    def get_stkvar(self, x: op_t, v: int, vv: sval_t, is_sp_based: int, _frame: tinfo_t) -> ssize_t:
        ...
    def init_lines_array(self, answers: qstrvec_t, maxsize: int) -> None:
        ...
    def multiline(self) -> bool:
        ...
    def only_main_line(self) -> bool:
        ...
    def out_addr_tag(self, ea: ida_idaapi.ea_t) -> None:
        r"""Output "address" escape sequence.
        
        """
        ...
    def out_btoa(self, Word: int, radix: char = 0) -> None:
        r"""Output a number with the specified base (binary, octal, decimal, hex) The number is output without color codes. see also out_long() 
                
        """
        ...
    def out_char(self, c: char) -> None:
        r"""Output one character. The character is output without color codes. see also out_symbol() 
                
        """
        ...
    def out_chars(self, c: char, n: int) -> None:
        r"""Append a character multiple times.
        
        """
        ...
    def out_colored_register_line(self, str: str) -> None:
        r"""Output a colored line with register names in it. The register names will be substituted by user-defined names (regvar_t) Please note that out_tagoff tries to make substitutions too (when called with COLOR_REG) 
                
        """
        ...
    def out_custom_mnem(self, mnem: str, width: int = 8, postfix: str = None) -> None:
        r"""Output custom mnemonic for 'insn'. E.g. if it should differ from the one in 'ph.instruc'. This function outputs colored text. See out_mnem 
                
        :param mnem: custom mnemonic
        :param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
        :param postfix: optional postfix added to 'mnem'
        """
        ...
    def out_data(self, analyze_only: bool) -> None:
        ...
    def out_fcref_names(self) -> None:
        r"""Print addresses referenced *from* the specified address as commented symbolic names. This function is used to show, for example, multiple callees of an indirect call. This function outputs colored text. 
                
        """
        ...
    def out_immchar_cmts(self) -> None:
        r"""Print all operand values as commented character constants. This function is used to comment void operands with their representation in the form of character constants. This function outputs colored text. 
                
        """
        ...
    def out_keyword(self, str: str) -> None:
        r"""Output a string with COLOR_KEYWORD color.
        
        """
        ...
    def out_line(self, str: str, color: color_t = 0) -> None:
        r"""Output a string with the specified color.
        
        """
        ...
    def out_long(self, v: int, radix: char) -> None:
        r"""Output a number with appropriate color. Low level function. Use out_value() if you can. if 'suspop' is set then this function uses COLOR_VOIDOP instead of COLOR_NUMBER. 'suspop' is initialized:
        * in out_one_operand()
        * in ..\ida\gl.cpp (before calling processor_t::d_out())
        
        
        
        :param v: value to output
        :param radix: base (2,8,10,16)
        """
        ...
    def out_lvar(self, name: str, width: int = -1) -> None:
        r"""Output local variable name with COLOR_LOCNAME color.
        
        """
        ...
    def out_mnem(self, width: int = 8, postfix: str = None) -> None:
        r"""Output instruction mnemonic for 'insn' using information in 'ph.instruc' array. This function outputs colored text. It should be called from processor_t::ev_out_insn() or processor_t::ev_out_mnem() handler. It will output at least one space after the instruction. mnemonic even if the specified 'width' is not enough. 
                
        :param width: width of field with mnemonic. if < 0, then 'postfix' will be output before the mnemonic, i.e. as a prefix
        :param postfix: optional postfix added to the instruction mnemonic
        """
        ...
    def out_mnemonic(self) -> None:
        r"""Output instruction mnemonic using information in 'insn'. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_mnem() or out_mnem. This function outputs colored text. 
                
        """
        ...
    def out_name_expr(self, args: Any) -> bool:
        r"""Output a name expression. 
                
        :param x: instruction operand referencing the name expression
        :param ea: address to convert to name expression
        :param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. You may pass BADADDR for this parameter but I discourage it because it prohibits checks.
        :returns: true if the name expression has been produced
        """
        ...
    def out_one_operand(self, n: int) -> bool:
        r"""Use this function to output an operand of an instruction. This function checks for the existence of a manually defined operand and will output it if it exists. It should be called from processor_t::ev_out_insn() and it will call processor_t::ev_out_operand(). This function outputs colored text. 
                
        :param n: 0..UA_MAXOP-1 operand number
        :returns: 1: operand is displayed
        :returns: 0: operand is hidden
        """
        ...
    def out_printf(self, format: str) -> int:
        r"""------------------------------------------------------------------------- Functions to append text to the current output buffer (outbuf) Append a formatted string to the output string. 
                
        :returns: the number of characters appended
        """
        ...
    def out_register(self, str: str) -> None:
        r"""Output a character with COLOR_REG color.
        
        """
        ...
    def out_spaces(self, len: ssize_t) -> None:
        r"""Appends spaces to outbuf until its tag_strlen becomes 'len'.
        
        """
        ...
    def out_specea(self, segtype: uchar) -> bool:
        ...
    def out_symbol(self, c: char) -> None:
        r"""Output a character with COLOR_SYMBOL color.
        
        """
        ...
    def out_tagoff(self, tag: color_t) -> None:
        r"""Output "turn color off" escape sequence.
        
        """
        ...
    def out_tagon(self, tag: color_t) -> None:
        r"""Output "turn color on" escape sequence.
        
        """
        ...
    def out_value(self, x: op_t, outf: int = 0) -> flags64_t:
        r"""Output immediate value. Try to use this function to output all constants of instruction operands. This function outputs a number from x.addr or x.value in the form determined by F. It outputs colored text. 
                
        :param x: value to output
        :param outf: Output value flags
        :returns: flags of the output value, otherwise:
        :returns: -1: if printed a number with COLOR_ERROR
        :returns: 0: if printed a nice number or character or segment or enum
        """
        ...
    def print_label_now(self) -> bool:
        ...
    def restore_ctxflags(self, saved_flags: int) -> None:
        ...
    def retrieve_cmt(self) -> ssize_t:
        ...
    def retrieve_name(self, arg2: str, arg3: color_t) -> ssize_t:
        ...
    def set_bin_state(self, value: int) -> None:
        ...
    def set_comment_addr(self, ea: ida_idaapi.ea_t) -> None:
        ...
    def set_dlbind_opnd(self) -> None:
        ...
    def set_gen_cmt(self, on: bool = True) -> None:
        ...
    def set_gen_demangled_label(self) -> None:
        ...
    def set_gen_label(self) -> None:
        ...
    def set_gen_xrefs(self, on: bool = True) -> None:
        ...
    def setup_outctx(self, prefix: str, flags: int) -> None:
        r"""Initialization; normally used only by the kernel.
        
        """
        ...
    def stack_view(self) -> bool:
        ...
    def term_outctx(self, prefix: str = None) -> int:
        r"""Finalize the output context. 
                
        :returns: the number of generated lines.
        """
        ...

class params_t:
    @property
    def p1(self) -> Any: ...
    @property
    def p2(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _p1: int64, _p2: int64) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class place_t:
    @property
    def lnnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class plugin_info_t:
    @property
    def arg(self) -> Any: ...
    @property
    def comment(self) -> Any: ...
    @property
    def dllmem(self) -> Any: ...
    @property
    def entry(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def hotkey(self) -> Any: ...
    @property
    def idaplg_name(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def next(self) -> Any: ...
    @property
    def org_hotkey(self) -> Any: ...
    @property
    def org_name(self) -> Any: ...
    @property
    def path(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class plugin_options_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def erase(self, name: str) -> bool:
        ...
    def find(self, name: str) -> plugin_option_t:
        ...

class plugin_t(pyidc_opaque_object_t):
    r"""Base class for all scripted plugins."""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def run(self, arg: Any) -> Any:
        ...
    def term(self) -> Any:
        ...

class plugmod_t(pyidc_opaque_object_t):
    r"""Base class for all scripted multi-plugins."""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class point_t:
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: point_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: point_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, r: point_t) -> point_t:
        ...
    def negate(self) -> None:
        ...
    def sub(self, r: point_t) -> point_t:
        ...

class pointseq_t(pointvec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: pointvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> point_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: pointvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: point_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: point_t) -> bool:
        ...
    def append(self, x: point_t) -> None:
        ...
    def at(self, _idx: size_t) -> point_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: pointvec_t) -> None:
        ...
    def extract(self) -> point_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: point_t) -> bool:
        ...
    def inject(self, s: point_t, len: size_t) -> None:
        ...
    def insert(self, it: point_t, x: point_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> point_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: pointvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class pointvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: pointvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> point_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: pointvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: point_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: point_t) -> bool:
        ...
    def append(self, x: point_t) -> None:
        ...
    def at(self, _idx: size_t) -> point_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: pointvec_t) -> None:
        ...
    def extract(self) -> point_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: point_t) -> bool:
        ...
    def inject(self, s: point_t, len: size_t) -> None:
        ...
    def insert(self, it: point_t, x: point_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> point_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: pointvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class predicate_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def should_display(self, til: til_t, name: str, type: type_t, fields: p_list) -> bool:
        ...

class printop_t:
    @property
    def aflags(self) -> Any: ...
    @property
    def features(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def is_ti_valid(self) -> Any: ...
    @property
    def suspop(self) -> Any: ...
    @property
    def ti(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_ti(self) -> opinfo_t:
        ...
    def is_aflags_initialized(self) -> bool:
        ...
    def is_f64(self) -> bool:
        ...
    def is_ti_initialized(self) -> bool:
        ...
    def set_aflags_initialized(self, v: bool = True) -> None:
        ...
    def set_ti_initialized(self, v: bool = True) -> None:
        ...

class process_info_t:
    @property
    def name(self) -> Any: ...
    @property
    def pid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class processor_t(IDP_Hooks):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def auto_empty(self, args: Any) -> Any:
        ...
    def auto_empty_finally(self, args: Any) -> Any:
        ...
    def closebase(self, args: Any) -> Any:
        ...
    def compiler_changed(self, args: Any) -> Any:
        ...
    def deleting_func(self, pfn: Any) -> Any:
        ...
    def determined_main(self, args: Any) -> Any:
        ...
    def ev_add_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: cref_t) -> int:
        r"""A code reference is being created. 
                  
        :param to: (::ea_t)
        :param type: (cref_t)
        :returns: <0: cancel cref creation
        :returns: 0: not implemented or continue
        """
        ...
    def ev_add_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: dref_t) -> int:
        r"""A data reference is being created. 
                  
        :param to: (::ea_t)
        :param type: (dref_t)
        :returns: <0: cancel dref creation
        :returns: 0: not implemented or continue
        """
        ...
    def ev_adjust_argloc(self, argloc: argloc_t, optional_type: tinfo_t, size: int) -> int:
        r"""Adjust argloc according to its type/size and platform endianess 
                  
        :param argloc: (argloc_t *), inout
        :param size: (int) 'size' makes no sense if type != nullptr (type->get_size() should be used instead)
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error
        """
        ...
    def ev_adjust_libfunc_ea(self, sig: idasgn_t, libfun: libfunc_t, ea: ea_t) -> int:
        r"""Called when a signature module has been matched against bytes in the database. This is used to compute the offset at which a particular module's libfunc should be applied. 
                  
        :param sig: (const idasgn_t *)
        :param libfun: (const libfunc_t *)
        :param ea: (::ea_t *)
        :returns: 1: the ea_t pointed to by the third argument was modified.
        :returns: <=0: not modified. use default algorithm.
        """
        ...
    def ev_adjust_refinfo(self, ri: refinfo_t, ea: ida_idaapi.ea_t, n: int, fd: fixup_data_t) -> int:
        r"""Called from apply_fixup before converting operand to reference. Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) 
                  
        :param ri: (refinfo_t *)
        :param ea: (::ea_t) instruction address
        :param n: (int) operand number
        :param fd: (const fixup_data_t *)
        :returns: <0: do not create an offset
        :returns: 0: not implemented or refinfo adjusted
        """
        ...
    def ev_ana_insn(self, args: Any) -> Any:
        ...
    def ev_analyze_prolog(self, ea: ida_idaapi.ea_t) -> int:
        r"""Analyzes function prolog, epilog, and updates purge, and function attributes 
                  
        :param ea: (::ea_t) start of function
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_arch_changed(self) -> int:
        r"""The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. 
                  
        :returns: 1: if success
        :returns: 0: not implemented or failed
        """
        ...
    def ev_arg_addrs_ready(self, caller: ida_idaapi.ea_t, n: int, tif: tinfo_t, addrs: ea_t) -> int:
        r"""Argument address info is ready. 
                  
        :param caller: (::ea_t)
        :param n: (int) number of formal arguments
        :param tif: (tinfo_t *) call prototype
        :param addrs: (::ea_t *) argument intilization addresses
        :returns: <0: do not save into idb; other values mean "ok to save"
        """
        ...
    def ev_asm_installed(self, asmnum: int) -> int:
        r"""After setting a new assembler 
                  
        :param asmnum: (int) See also ev_newasm
        """
        ...
    def ev_assemble(self, args: Any) -> Any:
        ...
    def ev_auto_queue_empty(self, args: Any) -> Any:
        ...
    def ev_calc_arglocs(self, fti: func_type_data_t) -> int:
        r"""Calculate function argument locations. This callback should fill retloc, all arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions. 
                  
        :param fti: (func_type_data_t *) points to the func type info
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error
        """
        ...
    def ev_calc_cdecl_purged_bytes(self, ea: ida_idaapi.ea_t) -> int:
        r"""Calculate number of purged bytes after call. 
                  
        :param ea: (::ea_t) address of the call instruction
        :returns: number of purged bytes (usually add sp, N)
        """
        ...
    def ev_calc_next_eas(self, res: eavec_t, insn: insn_t, over: bool) -> int:
        r"""Calculate list of addresses the instruction in 'insn' may pass control to. This callback is required for source level debugging. 
                  
        :param res: (eavec_t *), out: array for the results.
        :param insn: (const insn_t*) the instruction
        :param over: (bool) calculate for step over (ignore call targets)
        :returns: <0: incalculable (indirect jumps, for example)
        :returns: >=0: number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true)
        """
        ...
    def ev_calc_purged_bytes(self, p_purged_bytes: int, fti: func_type_data_t) -> int:
        r"""Calculate number of purged bytes by the given function type. 
                  
        :param p_purged_bytes: (int *) ptr to output
        :param fti: (const func_type_data_t *) func type details
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_calc_retloc(self, retloc: argloc_t, rettype: tinfo_t, cc: callcnv_t) -> int:
        r"""Calculate return value location. 
                  
        :param retloc: (argloc_t *)
        :param rettype: (const tinfo_t *)
        :param cc: (::callcnv_t)
        :returns: 0: not implemented
        :returns: 1: ok,
        :returns: -1: error
        """
        ...
    def ev_calc_spdelta(self, spdelta: sval_t, insn: insn_t) -> int:
        r"""Calculate amount of change to sp for the given insn. This event is required to decompile code snippets. 
                  
        :param spdelta: (sval_t *)
        :param insn: (const insn_t *)
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_calc_step_over(self, target: Any, ip: Any) -> Any:
        ...
    def ev_calc_switch_cases(self, casevec: casevec_t, targets: eavec_t, insn_ea: ida_idaapi.ea_t, si: switch_info_t) -> int:
        r"""Calculate case values and targets for a custom jump table. 
                  
        :param casevec: (::casevec_t *) vector of case values (may be nullptr)
        :param targets: (eavec_t *) corresponding target addresses (my be nullptr)
        :param insn_ea: (::ea_t) address of the 'indirect jump' instruction
        :param si: (switch_info_t *) switch information
        :returns: 1: ok
        :returns: <=0: failed
        """
        ...
    def ev_calc_varglocs(self, ftd: func_type_data_t, aux_regs: regobjs_t, aux_stkargs: relobj_t, nfixed: int) -> int:
        r"""Calculate locations of the arguments that correspond to '...'. 
                  
        :param ftd: (func_type_data_t *), inout: info about all arguments (including varargs)
        :param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be nullptr
        :param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be nullptr
        :param nfixed: (int) number of fixed arguments
        :returns: 0: not implemented
        :returns: 1: ok
        :returns: -1: error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs
        """
        ...
    def ev_calcrel(self) -> int:
        r"""Reserved.
        
        """
        ...
    def ev_can_have_type(self, args: Any) -> Any:
        ...
    def ev_clean_tbit(self, ea: ida_idaapi.ea_t, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Clear the TF bit after an insn like pushf stored it in memory. 
                  
        :param ea: (::ea_t) instruction address
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 1: ok
        :returns: 0: failed
        """
        ...
    def ev_cmp_operands(self, args: Any) -> Any:
        ...
    def ev_coagulate(self, args: Any) -> Any:
        ...
    def ev_coagulate_dref(self, from_ea: Any, to_ea: Any, may_define: Any, _code_ea: Any) -> Any:
        ...
    def ev_create_flat_group(self, image_base: ida_idaapi.ea_t, bitness: int, dataseg_sel: sel_t) -> int:
        r"""Create special segment representing the flat group. 
                  
        :param image_base: (::ea_t)
        :param bitness: (int)
        :param dataseg_sel: (::sel_t) return value is ignored
        """
        ...
    def ev_create_func_frame(self, pfn: Any) -> Any:
        ...
    def ev_create_merge_handlers(self, md: merge_data_t) -> int:
        r"""Create merge handlers, if needed 
                  
        :param md: (merge_data_t *) This event is generated immediately after opening idbs.
        :returns: must be 0
        """
        ...
    def ev_create_switch_xrefs(self, args: Any) -> Any:
        ...
    def ev_creating_segm(self, s: Any) -> Any:
        ...
    def ev_cvt64_hashval(self, node: nodeidx_t, tag: uchar, name: str, data: uchar) -> int:
        r"""perform 32-64 conversion for a hash value 
                  
        :param node: (::nodeidx_t)
        :param tag: (uchar)
        :param name: (const ::char *)
        :param data: (const uchar *)
        :returns: 0: nothing was done
        :returns: 1: converted successfully
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_cvt64_supval(self, node: nodeidx_t, tag: uchar, idx: nodeidx_t, data: uchar) -> int:
        r"""perform 32-64 conversion for a netnode array element 
                  
        :param node: (::nodeidx_t)
        :param tag: (uchar)
        :param idx: (::nodeidx_t)
        :param data: (const uchar *)
        :returns: 0: nothing was done
        :returns: 1: converted successfully
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_decorate_name(self, name: str, mangle: bool, cc: int, optional_type: tinfo_t) -> Any:
        r"""Decorate/undecorate a C symbol name. 
                  
        :param name: (const char *) name of symbol
        :param mangle: (bool) true-mangle, false-unmangle
        :param cc: (::callcnv_t) calling convention
        :returns: 1: if success
        :returns: 0: not implemented or failed
        """
        ...
    def ev_del_cref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> int:
        r"""A code reference is being deleted. 
                  
        :param to: (::ea_t)
        :param expand: (bool)
        :returns: <0: cancel cref deletion
        :returns: 0: not implemented or continue
        """
        ...
    def ev_del_dref(self, _from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> int:
        r"""A data reference is being deleted. 
                  
        :param to: (::ea_t)
        :returns: <0: cancel dref deletion
        :returns: 0: not implemented or continue
        """
        ...
    def ev_delay_slot_insn(self, ea: ida_idaapi.ea_t, bexec: bool, fexec: bool) -> Any:
        r"""Get delay slot instruction 
                  
        :param ea: (::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
        :param bexec: (bool *) execute slot if jumping, initially set to 'true'
        :param fexec: (bool *) execute slot if not jumping, initally set to 'true'
        :returns: 1: positive answer
        :returns: <=0: ordinary insn
        """
        ...
    def ev_demangle_name(self, name: str, disable_mask: int, demreq: int) -> Any:
        r"""Demangle a C++ (or another language) name into a user-readable string. This event is called by demangle_name() 
                  
        :param name: (const char *) mangled name
        :param disable_mask: (uint32) flags to inhibit parts of output or compiler info/other (see MNG_)
        :param demreq: (demreq_type_t) operation to perform
        :returns: 1: if success
        :returns: 0: not implemented
        """
        ...
    def ev_emu_insn(self, args: Any) -> Any:
        ...
    def ev_endbinary(self, args: Any) -> Any:
        ...
    def ev_ending_undo(self, action_name: str, is_undo: bool) -> int:
        r"""Ended undoing/redoing an action 
                  
        :param action_name: (const char *) action that we finished undoing/redoing. is not nullptr.
        :param is_undo: (bool) true if performing undo, false if performing redo
        """
        ...
    def ev_equal_reglocs(self, a1: argloc_t, a2: argloc_t) -> int:
        r"""Are 2 register arglocs the same?. We need this callback for the pc module. 
                  
        :param a1: (argloc_t *)
        :param a2: (argloc_t *)
        :returns: 1: yes
        :returns: -1: no
        :returns: 0: not implemented
        """
        ...
    def ev_extract_address(self, out_ea: ea_t, screen_ea: ida_idaapi.ea_t, string: str, position: size_t) -> int:
        r"""Extract address from a string. 
                  
        :param out_ea: (ea_t *), out
        :param screen_ea: (ea_t)
        :param string: (const char *)
        :param position: (size_t)
        :returns: 1: ok
        :returns: 0: kernel should use the standard algorithm
        :returns: -1: error
        """
        ...
    def ev_find_op_value(self, pinsn: insn_t, opn: int) -> Any:
        r"""Find operand value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                  
        :param pinsn: (const insn_t *) instruction
        :param opn: (int) operand index
        :returns: 1: if implemented, and value was found
        :returns: 0: not implemented, -1 decoding failed, or no value found
        """
        ...
    def ev_find_reg_value(self, pinsn: insn_t, reg: int) -> Any:
        r"""Find register value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
                  
        :param pinsn: (const insn_t *) instruction
        :param reg: (int) register index
        :returns: 1: if implemented, and value was found
        :returns: 0: not implemented, -1 decoding failed, or no value found
        """
        ...
    def ev_func_bounds(self, _possible_return_code: Any, pfn: Any, max_func_end_ea: Any) -> Any:
        ...
    def ev_gen_asm_or_lst(self, starting: bool, fp: FILE, is_asm: bool, flags: int, outline: html_line_cb_t) -> int:
        r"""Callback: generating asm or lst file. The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output 
                  
        :param starting: (bool) beginning listing generation
        :param fp: (FILE *) output file
        :param is_asm: (bool) true:assembler, false:listing
        :param flags: (int) flags passed to gen_file()
        :param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines
        :returns: void: 
        """
        ...
    def ev_gen_map_file(self, nlines: Any, fp: Any) -> Any:
        ...
    def ev_gen_regvar_def(self, ctx: Any, v: Any) -> Any:
        ...
    def ev_gen_src_file_lnnum(self, args: Any) -> Any:
        ...
    def ev_gen_stkvar_def(self, outctx: outctx_t, stkvar: udm_t, v: int, tid: tid_t) -> int:
        r"""Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte 
                  
        :param outctx: (outctx_t *)
        :param stkvar: (const udm_t *)
        :param v: (sval_t)
        :param tid: (tid_t) stkvar TID
        :returns: 1: ok
        :returns: 0: not implemented
        """
        ...
    def ev_get_abi_info(self, comp: comp_t) -> int:
        r"""Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore 
                  
        :param comp: (comp_t) - compiler ID
        :returns: 0: not implemented
        :returns: 1: ok
        """
        ...
    def ev_get_autocmt(self, args: Any) -> Any:
        ...
    def ev_get_bg_color(self, color: bgcolor_t, ea: ida_idaapi.ea_t) -> int:
        r"""Get item background color. Plugins can hook this callback to color disassembly lines dynamically 
                  
        :param color: (bgcolor_t *), out
        :param ea: (::ea_t)
        :returns: 0: not implemented
        :returns: 1: color set
        """
        ...
    def ev_get_cc_regs(self, regs: callregs_t, cc: callcnv_t) -> int:
        r"""Get register allocation convention for given calling convention 
                  
        :param regs: (callregs_t *), out
        :param cc: (::callcnv_t)
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_get_code16_mode(self, ea: ida_idaapi.ea_t) -> int:
        r"""Get ISA 16-bit mode 
                  
        :param ea: (ea_t) address to get the ISA mode
        :returns: 1: 16-bit mode
        :returns: 0: not implemented or 32-bit mode
        """
        ...
    def ev_get_dbr_opnum(self, opnum: int, insn: insn_t) -> int:
        r"""Get the number of the operand to be displayed in the debugger reference view (text mode). 
                  
        :param opnum: (int *) operand number (out, -1 means no such operand)
        :param insn: (const insn_t*) the instruction
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_get_default_enum_size(self) -> int:
        r"""Get default enum size. Not generated anymore. inf_get_cc_size_e() is used instead 
                  
        """
        ...
    def ev_get_frame_retsize(self, frsize: Any, pfn: Any) -> Any:
        ...
    def ev_get_macro_insn_head(self, head: ea_t, ip: ida_idaapi.ea_t) -> int:
        r"""Calculate the start of a macro instruction. This notification is called if IP points to the middle of an instruction 
                  
        :param head: (::ea_t *), out: answer, BADADDR means normal instruction
        :param ip: (::ea_t) instruction address
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_get_operand_string(self, buf: Any, insn: Any, opnum: Any) -> Any:
        ...
    def ev_get_procmod(self) -> int:
        r"""Get pointer to the processor module object. All processor modules must implement this. The pointer is returned as size_t. 
                  
        """
        ...
    def ev_get_reg_accesses(self, accvec: reg_accesses_t, insn: insn_t, flags: int) -> int:
        r"""Get info about the registers that are used/changed by an instruction. 
                  
        :param accvec: (reg_accesses_t*) out: info about accessed registers
        :param insn: (const insn_t *) instruction in question
        :param flags: (int) reserved, must be 0
        :returns: -1: if accvec is nullptr
        :returns: 1: found the requested access (and filled accvec)
        :returns: 0: not implemented
        """
        ...
    def ev_get_reg_info(self, main_regname: char, bitrange: bitrange_t, regname: str) -> int:
        r"""Get register information by its name. example: "ah" returns:
        * main_regname="eax"
        * bitrange_t = { offset==8, nbits==8 }
        
        
        This callback may be unimplemented if the register names are all present in processor_t::reg_names and they all have the same size 
                  
        :param main_regname: (const char **), out
        :param bitrange: (bitrange_t *), out: position and size of the value within 'main_regname' (empty bitrange == whole register)
        :param regname: (const char *)
        :returns: 1: ok
        :returns: -1: failed (not found)
        :returns: 0: unimplemented
        """
        ...
    def ev_get_reg_name(self, reg: int, width: size_t, reghi: int) -> Any:
        r"""Generate text representation of a register. Most processor modules do not need to implement this callback. It is useful only if processor_t::reg_names[reg] does not provide the correct register name. 
                  
        :param reg: (int) internal register number as defined in the processor module
        :param width: (size_t) register width in bytes
        :param reghi: (int) if not -1 then this function will return the register pair
        :returns: -1: if error
        :returns: strlen(buf): if success
        """
        ...
    def ev_get_simd_types(self, out: simd_info_vec_t, simd_attrs: simd_info_t, argloc: argloc_t, create_tifs: bool) -> int:
        r"""Get SIMD-related types according to given attributes ant/or argument location 
                  
        :param out: (::simd_info_vec_t *)
        :param simd_attrs: (const simd_info_t *), may be nullptr
        :param argloc: (const argloc_t *), may be nullptr
        :param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
        :returns: number: of found types
        :returns: -1: error If name==nullptr, initialize all SIMD types
        """
        ...
    def ev_get_stkarg_area_info(self, out: stkarg_area_info_t, cc: callcnv_t) -> int:
        r"""Get some metrics of the stack argument area. 
                  
        :param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
        :param cc: (::callcnv_t) calling convention
        :returns: 1: if success
        :returns: 0: not implemented
        """
        ...
    def ev_get_stkvar_scale_factor(self) -> int:
        r"""Should stack variable references be multiplied by a coefficient before being used in the stack frame?. Currently used by TMS320C55 because the references into the stack should be multiplied by 2 
                  
        :returns: scaling factor
        :returns: 0: not implemented
        """
        ...
    def ev_getreg(self, regval: uval_t, regnum: int) -> int:
        r"""IBM PC only internal request, should never be used for other purpose Get register value by internal index 
                  
        :param regval: (uval_t *), out
        :param regnum: (int)
        :returns: 1: ok
        :returns: 0: not implemented
        :returns: -1: failed (undefined value or bad regnum)
        """
        ...
    def ev_init(self, idp_modname: str) -> int:
        r"""The IDP module is just loaded. 
                  
        :param idp_modname: (const char *) processor module name
        :returns: <0: on failure
        """
        ...
    def ev_insn_reads_tbit(self, insn: insn_t, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Check if insn will read the TF bit. 
                  
        :param insn: (const insn_t*) the instruction
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 2: yes, will generate 'step' exception
        :returns: 1: yes, will store the TF bit in memory
        :returns: 0: no
        """
        ...
    def ev_is_addr_insn(self, type: int, insn: insn_t) -> int:
        r"""Does the instruction calculate some address using an immediate operand? e.g. in PC such operand may be o_displ: 'lea eax, [esi+4]' 
                  
        :param type: (int *) pointer to the returned instruction type:
        * 0 the "add" instruction (the immediate operand is a relative value)
        * 1 the "move" instruction (the immediate operand is an absolute value)
        * 2 the "sub" instruction (the immediate operand is a relative value)
        :param insn: (const insn_t *) instruction
        :returns: >0 the operand number+1
        :returns: 0: not implemented
        """
        ...
    def ev_is_align_insn(self, args: Any) -> Any:
        ...
    def ev_is_alloca_probe(self, args: Any) -> Any:
        ...
    def ev_is_basic_block_end(self, args: Any) -> Any:
        ...
    def ev_is_call_insn(self, args: Any) -> Any:
        ...
    def ev_is_cond_insn(self, insn: insn_t) -> int:
        r"""Is conditional instruction? 
                  
        :param insn: (const insn_t *) instruction address
        :returns: 1: yes
        :returns: -1: no
        :returns: 0: not implemented or not instruction
        """
        ...
    def ev_is_control_flow_guard(self, p_reg: int, insn: insn_t) -> int:
        r"""Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) 
                  
        :param p_reg: (int *) indirect register number, may be -1
        :param insn: (const insn_t *) call/jump instruction
        :returns: -1: no thunk detected
        :returns: 1: indirect call
        :returns: 2: security check routine call (NOP)
        :returns: 3: return thunk
        :returns: 0: not implemented
        """
        ...
    def ev_is_far_jump(self, args: Any) -> Any:
        ...
    def ev_is_indirect_jump(self, args: Any) -> Any:
        ...
    def ev_is_insn_table_jump(self, args: Any) -> Any:
        ...
    def ev_is_jump_func(self, pfn: func_t, jump_target: ea_t, func_pointer: ea_t) -> int:
        r"""Is the function a trivial "jump" function?. 
                  
        :param pfn: (func_t *)
        :param jump_target: (::ea_t *)
        :param func_pointer: (::ea_t *)
        :returns: <0: no
        :returns: 0: don't know
        :returns: 1: yes, see 'jump_target' and 'func_pointer'
        """
        ...
    def ev_is_ret_insn(self, args: Any) -> Any:
        ...
    def ev_is_sane_insn(self, args: Any) -> Any:
        ...
    def ev_is_sp_based(self, mode: Any, insn: Any, op: Any) -> Any:
        ...
    def ev_is_switch(self, args: Any) -> Any:
        ...
    def ev_last_cb_before_loader(self) -> int:
        ...
    def ev_loader(self) -> int:
        r"""This code and higher ones are reserved for the loaders. The arguments and the return values are defined by the loaders 
                  
        """
        ...
    def ev_lower_func_type(self, argnums: intvec_t, fti: func_type_data_t) -> int:
        r"""Get function arguments which should be converted to pointers when lowering function prototype. The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. 
                  
        :param argnums: (intvec_t *), out - numbers of arguments to be converted to pointers in acsending order
        :param fti: (func_type_data_t *), inout func type details
        :returns: 0: not implemented
        :returns: 1: argnums was filled
        :returns: 2: argnums was filled and made substantial changes to fti argnums[0] can contain a special negative value indicating that the return value should be passed as a hidden 'retstr' argument: -1 this argument is passed as the first one and the function returns a pointer to the argument, -2 this argument is passed as the last one and the function returns a pointer to the argument, -3 this argument is passed as the first one and the function returns 'void'.
        """
        ...
    def ev_max_ptr_size(self) -> int:
        r"""Get maximal size of a pointer in bytes. 
                  
        :returns: max possible size of a pointer
        """
        ...
    def ev_may_be_func(self, args: Any) -> Any:
        ...
    def ev_may_show_sreg(self, args: Any) -> Any:
        ...
    def ev_moving_segm(self, s: Any, to_ea: Any, flags: Any) -> Any:
        ...
    def ev_newasm(self, asmnum: int) -> int:
        r"""Before setting a new assembler. 
                  
        :param asmnum: (int) See also ev_asm_installed
        """
        ...
    def ev_newbinary(self, args: Any) -> Any:
        ...
    def ev_newfile(self, args: Any) -> Any:
        ...
    def ev_newprc(self, args: Any) -> Any:
        ...
    def ev_next_exec_insn(self, target: ea_t, ea: ida_idaapi.ea_t, tid: int, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Get next address to be executed This function must return the next address to be executed. If the instruction following the current one is executed, then it must return BADADDR Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. 
                  
        :param target: (::ea_t *), out: pointer to the answer
        :param ea: (::ea_t) instruction address
        :param tid: (int) current therad id
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 0: unimplemented
        :returns: 1: implemented
        """
        ...
    def ev_oldfile(self, args: Any) -> Any:
        ...
    def ev_out_assumes(self, args: Any) -> Any:
        ...
    def ev_out_data(self, args: Any) -> Any:
        ...
    def ev_out_footer(self, args: Any) -> Any:
        ...
    def ev_out_header(self, args: Any) -> Any:
        ...
    def ev_out_insn(self, args: Any) -> Any:
        ...
    def ev_out_label(self, args: Any) -> Any:
        ...
    def ev_out_mnem(self, args: Any) -> Any:
        ...
    def ev_out_operand(self, args: Any) -> Any:
        ...
    def ev_out_segend(self, ctx: Any, s: Any) -> Any:
        ...
    def ev_out_segstart(self, ctx: Any, s: Any) -> Any:
        ...
    def ev_out_special_item(self, args: Any) -> Any:
        ...
    def ev_privrange_changed(self, old_privrange: range_t, delta: adiff_t) -> int:
        r"""Privrange interval has been moved to a new location. Most common actions to be done by module in this case: fix indices of netnodes used by module 
                  
        :param old_privrange: (const range_t *) - old privrange interval
        :param delta: (::adiff_t)
        :returns: 0: Ok
        :returns: -1: error (and message in errbuf)
        """
        ...
    def ev_realcvt(self, m: void, e: fpvalue_t, swt: uint16) -> int:
        r"""Floating point -> IEEE conversion 
                  
        :param m: (void *) ptr to processor-specific floating point value
        :param e: (fpvalue_t *) IDA representation of a floating point value
        :param swt: (uint16) operation (see realcvt() in ieee.h)
        :returns: 0: not implemented
        """
        ...
    def ev_rename(self, args: Any) -> Any:
        ...
    def ev_replaying_undo(self, action_name: str, vec: undo_records_t, is_undo: bool) -> int:
        r"""Replaying an undo/redo buffer 
                  
        :param action_name: (const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers.
        :param vec: (const undo_records_t *)
        :param is_undo: (bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo
        """
        ...
    def ev_set_code16_mode(self, ea: ida_idaapi.ea_t, code16: bool) -> int:
        r"""Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode 
                  
        :param ea: (ea_t) address to set new ISA mode
        :param code16: (bool) true for 16-bit mode, false for 32-bit mode
        """
        ...
    def ev_set_idp_options(self, keyword: Any, value_type: Any, value: Any, idb_loaded: Any) -> Any:
        ...
    def ev_set_proc_options(self, args: Any) -> Any:
        ...
    def ev_setup_til(self) -> int:
        r"""Setup default type libraries. (called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. 
                  
        :returns: void: 
        """
        ...
    def ev_str2reg(self, args: Any) -> Any:
        ...
    def ev_term(self) -> int:
        r"""The IDP module is being unloaded.
        
        """
        ...
    def ev_treat_hindering_item(self, args: Any) -> Any:
        ...
    def ev_undefine(self, args: Any) -> Any:
        ...
    def ev_update_call_stack(self, stack: call_stack_t, tid: int, getreg: regval_getter_t, regvalues: regval_t) -> int:
        r"""Calculate the call stack trace for the given thread. This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. 
                  
        :param stack: (call_stack_t *) result
        :param tid: (int) thread id
        :param getreg: (::processor_t::regval_getter_t *) function to get register values
        :param regvalues: (const regval_t *) register values array
        :returns: 1: ok
        :returns: -1: failed
        :returns: 0: unimplemented
        """
        ...
    def ev_use_arg_types(self, ea: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> int:
        r"""Use information about callee arguments. 
                  
        :param ea: (::ea_t) address of the call instruction
        :param fti: (func_type_data_t *) info about function type
        :param rargs: (funcargvec_t *) array of register arguments
        :returns: 1: (and removes handled arguments from fti and rargs)
        :returns: 0: not implemented
        """
        ...
    def ev_use_regarg_type(self, ea: ida_idaapi.ea_t, rargs: funcargvec_t) -> Any:
        r"""Use information about register argument. 
                  
        :param ea: (::ea_t) address of the instruction
        :param rargs: (const funcargvec_t *) vector of register arguments (including regs extracted from scattered arguments)
        :returns: 1: 
        :returns: 0: not implemented
        """
        ...
    def ev_use_stkarg_type(self, ea: ida_idaapi.ea_t, arg: funcarg_t) -> int:
        r"""Use information about a stack argument. 
                  
        :param ea: (::ea_t) address of the push instruction which pushes the function argument into the stack
        :param arg: (const funcarg_t *) argument info
        :returns: 1: ok
        :returns: <=0: failed, the kernel will create a comment with the argument name or type for the instruction
        """
        ...
    def ev_validate_flirt_func(self, args: Any) -> Any:
        ...
    def ev_verify_noreturn(self, pfn: Any) -> Any:
        ...
    def ev_verify_sp(self, pfn: Any) -> Any:
        ...
    def func_added(self, pfn: Any) -> Any:
        ...
    def get_auxpref(self, insn: Any) -> Any:
        r"""This function returns insn.auxpref value"""
        ...
    def get_idpdesc(self) -> Any:
        r"""
        This function must be present and should return the list of
        short processor names similar to the one in ph.psnames.
        This method can be overridden to return to the kernel a different IDP description.
        
        """
        ...
    def hook(self) -> bool:
        ...
    def idasgn_loaded(self, args: Any) -> Any:
        ...
    def kernel_config_loaded(self, args: Any) -> Any:
        ...
    def make_code(self, args: Any) -> Any:
        ...
    def make_data(self, args: Any) -> Any:
        ...
    def renamed(self, args: Any) -> Any:
        ...
    def savebase(self, args: Any) -> Any:
        ...
    def segm_moved(self, from_ea: Any, to_ea: Any, size: Any, changed_netmap: Any) -> Any:
        ...
    def set_func_end(self, args: Any) -> Any:
        ...
    def set_func_start(self, args: Any) -> Any:
        ...
    def sgr_changed(self, args: Any) -> Any:
        ...
    def unhook(self) -> bool:
        ...

class procinfo_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> process_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: process_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: process_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> process_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: procinfo_vec_t) -> None:
        ...
    def extract(self) -> process_info_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: process_info_t, len: size_t) -> None:
        ...
    def insert(self, it: process_info_t, x: process_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> process_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: procinfo_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ptr_type_data_t:
    @property
    def based_ptr_size(self) -> Any: ...
    @property
    def closure(self) -> Any: ...
    @property
    def delta(self) -> Any: ...
    @property
    def obj_type(self) -> Any: ...
    @property
    def parent(self) -> Any: ...
    @property
    def taptr_bits(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ptr_type_data_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: ptr_type_data_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def is_code_ptr(self) -> bool:
        r"""Are we pointing to code?
        
        """
        ...
    def is_shifted(self) -> bool:
        ...
    def swap(self, r: ptr_type_data_t) -> None:
        r"""Set this = r and r = this.
        
        """
        ...

class py_clinked_object_t(pyidc_opaque_object_t):
    r"""
    This is a utility and base class for C linked objects
    
    """
    @property
    def clink(self) -> Any: ...
    @property
    def clink_ptr(self) -> Any: ...
    def __del__(self) -> Any:
        r"""Delete the link upon object destruction (only if not static)"""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, lnk: Any = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def assign(self, other: Any) -> Any:
        r"""
        Overwrite me.
        This method allows you to assign an instance contents to anothers
        :returns: Boolean
        
        """
        ...
    def copy(self) -> Any:
        r"""Returns a new copy of this class"""
        ...

class pyidc_cvt_helper__:
    r"""
    This is a special helper object that helps detect which kind
    of object is this python object wrapping and how to convert it
    back and from IDC.
    This object is characterized by its special attribute and its value
    
    """
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, cvt_id: Any, value: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class pyidc_opaque_object_t:
    r"""This is the base class for all Python<->IDC opaque objects"""
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        r"""Initialize self.  See help(type(self)) for accurate signature."""
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class qbasic_block_t(range_t):
    @property
    def end_ea(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class qfile_t:
    r"""A helper class to work with FILE related functions."""
    @property
    def __idc_cvt_id__(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def close(self) -> Any:
        r"""Closes the file"""
        ...
    def filename(self) -> Any:
        ...
    def flush(self) -> Any:
        ...
    def from_capsule(self, pycapsule: Any) -> qfile_t:
        ...
    def from_fp(self, fp: FILE) -> qfile_t:
        ...
    def get_byte(self) -> Any:
        r"""Reads a single byte from the file. Returns None if EOF or the read byte"""
        ...
    def get_fp(self) -> FILE:
        ...
    def gets(self, len: Any) -> Any:
        r"""Reads a line from the input file. Returns the read line or None
        
        :param len: the maximum line length
        """
        ...
    def open(self, filename: Any, mode: Any) -> Any:
        r"""Opens a file
        
        :param filename: the file name
        :param mode: The mode string, ala fopen() style
        :returns: Boolean
        """
        ...
    def opened(self) -> Any:
        r"""Checks if the file is opened or not"""
        ...
    def put_byte(self) -> Any:
        r"""Writes a single byte to the file
        
        :param chr: the byte value
        """
        ...
    def puts(self, str: str) -> int:
        ...
    def read(self, size: Any) -> Any:
        r"""Reads from the file. Returns the buffer or None
        
        :param size: the maximum number of bytes to read
        :returns: a str, or None
        """
        ...
    def readbytes(self, size: Any, big_endian: Any) -> Any:
        r"""Similar to read() but it respect the endianness
        
        :param size: the maximum number of bytes to read
        :param big_endian: endianness
        :returns: a str, or None
        """
        ...
    def seek(self, offset: Any, whence: Any = 0) -> Any:
        r"""Set input source position
        
        :param offset: the seek offset
        :param whence: the position to seek from
        :returns: the new position (not 0 as fseek!)
        """
        ...
    def size(self) -> int64:
        ...
    def tell(self) -> Any:
        r"""Returns the current position"""
        ...
    def tmpfile(self) -> Any:
        r"""A static method to construct an instance using a temporary file"""
        ...
    def write(self, buf: Any) -> Any:
        r"""Writes to the file. Returns 0 or the number of bytes written
        
        :param buf: the str to write
        :returns: result code
        """
        ...
    def writebytes(self, size: Any, big_endian: Any) -> Any:
        r"""Similar to write() but it respect the endianness
        
        :param buf: the str to write
        :param big_endian: endianness
        :returns: result code
        """
        ...

class qflow_chart_t(cancellable_graph_t, gdl_graph_t):
    @property
    def bounds(self) -> Any: ...
    @property
    def cancelled(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def nproper(self) -> Any: ...
    @property
    def pfn(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, n: int) -> qbasic_block_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append_to_flowchart(self, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None:
        ...
    def begin(self) -> node_iterator:
        ...
    def calc_block_type(self, blknum: size_t) -> fc_block_type_t:
        ...
    def create(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None
            1. create(_title: str, ranges: const rangevec_t &, _flags: int) -> None
        
        # 0: create(_title: str, _pfn: func_t *, _ea1: ida_idaapi.ea_t, _ea2: ida_idaapi.ea_t, _flags: int) -> None
        
        
        # 1: create(_title: str, ranges: const rangevec_t &, _flags: int) -> None
        
        
        """
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> node_iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, args: Any) -> char:
        ...
    def is_noret_block(self, blknum: size_t) -> bool:
        ...
    def is_ret_block(self, blknum: size_t) -> bool:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_names(self) -> bool:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def refresh(self) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class qmutex_locker_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _lock: __qmutex_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class qrefcnt_obj_t:
    @property
    def refcnt(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def release(self) -> None:
        r"""Call destructor. We use release() instead of operator delete() to maintain binary compatibility with all compilers (vc and gcc use different vtable layouts for operator delete) 
                
        """
        ...

class qstring_printer_t(vc_printer_t, vd_printer_t):
    @property
    def func(self) -> Any: ...
    @property
    def hdrlines(self) -> Any: ...
    @property
    def lastchar(self) -> Any: ...
    @property
    def s(self) -> Any: ...
    @property
    def tmpbuf(self) -> Any: ...
    @property
    def with_tags(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, f: cfunc_t, tags: bool) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_s(self) -> str:
        ...
    def oneliner(self) -> bool:
        r"""Are we generating one-line text representation? 
                
        :returns: `true` if the output will occupy one line without line breaks
        """
        ...

class quick_widget_commands_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, callback: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def add(self, caption: Any, flags: Any, menu_index: Any, icon: Any, emb: Any, shortcut: Any) -> Any:
        ...
    def populate_popup(self, widget: Any, popup: Any) -> Any:
        ...

class qvector_carg_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_carg_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> carg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_carg_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: carg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: carg_t) -> bool:
        ...
    def append(self, args: Any) -> carg_t:
        ...
    def at(self, i: size_t) -> carg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_carg_t) -> None:
        ...
    def extract(self) -> carg_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: carg_t) -> bool:
        ...
    def inject(self, s: carg_t, len: size_t) -> None:
        ...
    def insert(self, it: carg_t, x: carg_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> carg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_carg_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_catchexprs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_catchexprs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> catchexpr_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_catchexprs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: catchexpr_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: catchexpr_t) -> bool:
        ...
    def append(self, x: catchexpr_t) -> None:
        ...
    def at(self, _idx: size_t) -> catchexpr_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_catchexprs_t) -> None:
        ...
    def extract(self) -> catchexpr_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: catchexpr_t) -> bool:
        ...
    def inject(self, s: catchexpr_t, len: size_t) -> None:
        ...
    def insert(self, it: catchexpr_t, x: catchexpr_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> catchexpr_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_catchexprs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_ccase_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_ccase_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ccase_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_ccase_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ccase_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: ccase_t) -> bool:
        ...
    def append(self, args: Any) -> ccase_t:
        ...
    def at(self, i: size_t) -> ccase_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_ccase_t) -> None:
        ...
    def extract(self) -> ccase_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: ccase_t) -> bool:
        ...
    def inject(self, s: ccase_t, len: size_t) -> None:
        ...
    def insert(self, it: ccase_t, x: ccase_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ccase_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_ccase_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_ccatchvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_ccatchvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ccatch_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_ccatchvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ccatch_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: ccatch_t) -> bool:
        ...
    def append(self, x: ccatch_t) -> None:
        ...
    def at(self, _idx: size_t) -> ccatch_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_ccatchvec_t) -> None:
        ...
    def extract(self) -> ccatch_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: ccatch_t) -> bool:
        ...
    def inject(self, s: ccatch_t, len: size_t) -> None:
        ...
    def insert(self, it: ccatch_t, x: ccatch_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ccatch_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_ccatchvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_history_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_history_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> history_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_history_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: history_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: history_item_t) -> bool:
        ...
    def append(self, x: history_item_t) -> None:
        ...
    def at(self, _idx: size_t) -> history_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_history_t) -> None:
        ...
    def extract(self) -> history_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: history_item_t) -> bool:
        ...
    def inject(self, s: history_item_t, len: size_t) -> None:
        ...
    def insert(self, it: history_item_t, x: history_item_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> history_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_history_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_lvar_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_lvar_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> lvar_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_lvar_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: lvar_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: lvar_t) -> bool:
        ...
    def append(self, args: Any) -> lvar_t:
        ...
    def at(self, i: size_t) -> lvar_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_lvar_t) -> None:
        ...
    def extract(self) -> lvar_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: lvar_t) -> bool:
        ...
    def inject(self, s: lvar_t, len: size_t) -> None:
        ...
    def insert(self, it: lvar_t, x: lvar_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> lvar_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_lvar_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class qvector_snapshotvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: qvector_snapshotvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: qvector_snapshotvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: snapshot_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: snapshot_t) -> bool:
        ...
    def append(self, x: snapshot_t) -> None:
        ...
    def at(self, _idx: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: qvector_snapshotvec_t) -> None:
        ...
    def extract(self) -> snapshot_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: snapshot_t) -> bool:
        ...
    def inject(self, s: snapshot_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: snapshot_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: qvector_snapshotvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class range_t:
    @property
    def end_ea(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self, ea1: ida_idaapi.ea_t = 0, ea2: ida_idaapi.ea_t = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class rangeset_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, aset: rangeset_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, idx: Any) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        r"""Get the number of range_t elements in the set.
        
        """
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, aset: rangeset_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(range: const range_t &) -> bool
            1. add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
            2. add(aset: const rangeset_t &) -> bool
        
        # 0: add(range: const range_t &) -> bool
        
        Add an address range to the set. If 'range' intersects an existing element e, then e is extended to include 'range', and any superfluous elements (subsets of e) are removed. 
                
        :returns: false if 'range' was not added (the set was unchanged)
        
        # 1: add(start: ida_idaapi.ea_t, _end: ida_idaapi.ea_t) -> bool
        
        Create a new range_t from 'start' and 'end' and add it to the set.
        
        
        # 2: add(aset: const rangeset_t &) -> bool
        
        Add each element of 'aset' to the set. 
                
        :returns: false if no elements were added (the set was unchanged)
        
        """
        ...
    def as_rangevec(self) -> rangevec_t:
        r"""Return underlying rangevec_t object.
        
        """
        ...
    def begin(self) -> iterator:
        r"""Get an iterator that points to the first element in the set.
        
        """
        ...
    def cached_range(self) -> range_t:
        r"""When searching the rangeset, we keep a cached element to help speed up searches. 
                
        :returns: a pointer to the cached element
        """
        ...
    def clear(self) -> None:
        r"""Delete all elements from the set. See qvector::clear()
        
        """
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(aset: const rangeset_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Does an element of the rangeset contain 'ea'? See range_t::contains(ea_t)
        
        
        # 1: contains(aset: const rangeset_t &) -> bool
        
        Is every element in 'aset' contained in an element of this rangeset?. See range_t::contains(range_t)
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Does the set have zero elements.
        
        """
        ...
    def end(self) -> iterator:
        r"""Get an iterator that points to the end of the set. (This is NOT the last element)
        
        """
        ...
    def find_range(self, ea: ida_idaapi.ea_t) -> range_t:
        r"""Get the element from the set that contains 'ea'. 
                
        :returns: nullptr if there is no such element
        """
        ...
    def getrange(self, idx: int) -> range_t:
        r"""Get the range_t at index 'idx'.
        
        """
        ...
    def has_common(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. has_common(range: const range_t &) -> bool
            1. has_common(aset: const rangeset_t &) -> bool
        
        # 0: has_common(range: const range_t &) -> bool
        
        Is there an ea in 'range' that is also in the rangeset?
        
        
        # 1: has_common(aset: const rangeset_t &) -> bool
        
        Does any element of 'aset' overlap with an element in this rangeset?. See range_t::overlaps()
        
        
        """
        ...
    def includes(self, range: range_t) -> bool:
        r"""Is every ea in 'range' contained in the rangeset?
        
        """
        ...
    def intersect(self, aset: rangeset_t) -> bool:
        r"""Set the rangeset to its intersection with 'aset'. 
                
        :returns: false if the set was unchanged
        """
        ...
    def is_equal(self, aset: rangeset_t) -> bool:
        r"""Do this rangeset and 'aset' have identical elements?
        
        """
        ...
    def is_subset_of(self, aset: rangeset_t) -> bool:
        r"""Is every element in the rangeset contained in an element of 'aset'?
        
        """
        ...
    def lastrange(self) -> range_t:
        r"""Get the last range_t in the set.
        
        """
        ...
    def next_addr(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Get the smallest ea_t value greater than 'ea' contained in the rangeset.
        
        """
        ...
    def next_range(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Get the smallest ea_t value greater than 'ea' that is not in the same range as 'ea'.
        
        """
        ...
    def nranges(self) -> int:
        r"""Get the number of range_t elements in the set.
        
        """
        ...
    def prev_addr(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Get the largest ea_t value less than 'ea' contained in the rangeset.
        
        """
        ...
    def prev_range(self, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
        r"""Get the largest ea_t value less than 'ea' that is not in the same range as 'ea'.
        
        """
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(range: const range_t &) -> bool
            1. sub(ea: ida_idaapi.ea_t) -> bool
            2. sub(aset: const rangeset_t &) -> bool
        
        # 0: sub(range: const range_t &) -> bool
        
        Subtract an address range from the set. All subsets of 'range' will be removed, and all elements that intersect 'range' will be truncated/split so they do not include 'range'. 
                
        :returns: false if 'range' was not subtracted (the set was unchanged)
        
        # 1: sub(ea: ida_idaapi.ea_t) -> bool
        
        Subtract an ea (an range of size 1) from the set. See sub(const range_t &)
        
        
        # 2: sub(aset: const rangeset_t &) -> bool
        
        Subtract each range in 'aset' from the set 
                
        :returns: false if nothing was subtracted (the set was unchanged)
        
        """
        ...
    def swap(self, r: rangeset_t) -> None:
        r"""Set this = 'r' and 'r' = this. See qvector::swap()
        
        """
        ...

class rangevec_base_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class rangevec_t(rangevec_base_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class rect_t:
    @property
    def bottom(self) -> Any: ...
    @property
    def left(self) -> Any: ...
    @property
    def right(self) -> Any: ...
    @property
    def top(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rect_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rect_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def area(self) -> int:
        ...
    def bottomright(self) -> point_t:
        ...
    def center(self) -> point_t:
        ...
    def contains(self, p: point_t) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def grow(self, delta: int) -> None:
        ...
    def height(self) -> int:
        ...
    def intersect(self, r: rect_t) -> None:
        ...
    def is_intersection_empty(self, r: rect_t) -> bool:
        ...
    def make_union(self, r: rect_t) -> None:
        ...
    def move_by(self, p: point_t) -> None:
        ...
    def move_to(self, p: point_t) -> None:
        ...
    def topleft(self) -> point_t:
        ...
    def verify(self) -> None:
        ...
    def width(self) -> int:
        ...

class refinfo_t:
    @property
    def base(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def target(self) -> Any: ...
    @property
    def tdelta(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def init(self, args: Any) -> None:
        ...
    def is_custom(self) -> bool:
        ...
    def is_no_ones(self) -> bool:
        ...
    def is_no_zeros(self) -> bool:
        ...
    def is_pastend(self) -> bool:
        ...
    def is_rvaoff(self) -> bool:
        ...
    def is_selfref(self) -> bool:
        ...
    def is_signed(self) -> bool:
        ...
    def is_subtract(self) -> bool:
        ...
    def is_target_optional(self) -> bool:
        r"""< is_reftype_target_optional()
        
        """
        ...
    def no_base_xref(self) -> bool:
        ...
    def set_type(self, rt: reftype_t) -> None:
        ...
    def type(self) -> reftype_t:
        ...

class reg_access_t:
    @property
    def access_type(self) -> Any: ...
    @property
    def opnum(self) -> Any: ...
    @property
    def range(self) -> Any: ...
    @property
    def regnum(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reg_access_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: reg_access_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def have_common_bits(self, r: reg_access_t) -> bool:
        ...

class reg_access_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reg_access_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> reg_access_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: reg_access_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: reg_access_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: reg_access_t) -> bool:
        ...
    def append(self, x: reg_access_t) -> None:
        ...
    def at(self, _idx: size_t) -> reg_access_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: reg_access_vec_t) -> None:
        ...
    def extract(self) -> reg_access_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: reg_access_t) -> bool:
        ...
    def inject(self, s: reg_access_t, len: size_t) -> None:
        ...
    def insert(self, it: reg_access_t, x: reg_access_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> reg_access_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: reg_access_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class reg_accesses_t(reg_access_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reg_access_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> reg_access_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: reg_access_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: reg_access_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: reg_access_t) -> bool:
        ...
    def append(self, x: reg_access_t) -> None:
        ...
    def at(self, _idx: size_t) -> reg_access_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: reg_access_vec_t) -> None:
        ...
    def extract(self) -> reg_access_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: reg_access_t) -> bool:
        ...
    def inject(self, s: reg_access_t, len: size_t) -> None:
        ...
    def insert(self, it: reg_access_t, x: reg_access_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> reg_access_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: reg_access_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class reg_info_t:
    @property
    def reg(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reg_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: reg_info_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: reg_info_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: reg_info_t) -> bool:
        ...
    def __lt__(self, r: reg_info_t) -> bool:
        ...
    def __ne__(self, r: reg_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: reg_info_t) -> int:
        ...

class reg_value_def_t:
    ABORTED: int  # 3
    NOVAL: int  # 0
    SPVAL: int  # 2
    UVAL: int  # 1
    @property
    def LIKE_GOT(self) -> Any: ...
    @property
    def PC_BASED(self) -> Any: ...
    @property
    def SHORT_INSN(self) -> Any: ...
    @property
    def def_ea(self) -> Any: ...
    @property
    def def_itype(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def val(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reg_value_def_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: reg_value_def_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def dstr(self, how: dstr_val_t, pm: procmod_t = None) -> str:
        r"""Return the string representation.
        
        """
        ...
    def is_like_got(self) -> bool:
        ...
    def is_pc_based(self) -> bool:
        ...
    def is_short_insn(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. is_short_insn() -> bool
            1. is_short_insn(insn: const insn_t &) -> bool
        
        # 0: is_short_insn() -> bool
        
        
        # 1: is_short_insn(insn: const insn_t &) -> bool
        
        
        """
        ...

class reg_value_info_t:
    ADD: int  # 0
    AND: int  # 3
    AND_NOT: int  # 5
    CONTAINED: int  # 2
    CONTAINS: int  # 1
    EQUAL: int  # 0
    MOVT: int  # 9
    NEG: int  # 10
    NOT: int  # 11
    NOT_COMPARABLE: int  # 3
    OR: int  # 2
    SAR: int  # 8
    SLL: int  # 6
    SLR: int  # 7
    SUB: int  # 1
    XOR: int  # 4
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> reg_value_def_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def aborted(self) -> bool:
        r"""Return 'true' if the tracking process was aborted.
        
        """
        ...
    def add(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Add R to the value, save INSN as a defining instruction. 
                
        """
        ...
    def add_num(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. add_num(r: int, insn: const insn_t &) -> None
            1. add_num(r: int) -> None
        
        # 0: add_num(r: int, insn: const insn_t &) -> None
        
        Add R to the value, save INSN as a defining instruction. 
                
        
        # 1: add_num(r: int) -> None
        
        Add R to the value, do not change the defining instructions. 
                
        
        """
        ...
    def band(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Make bitwise AND of R to the value, save INSN as a defining instruction. 
                
        """
        ...
    def bandnot(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Make bitwise AND of the inverse of R to the value, save INSN as a defining instruction. 
                
        """
        ...
    def bnot(self, insn: insn_t) -> None:
        r"""Make bitwise inverse of the value, save INSN as a defining instruction. 
                
        """
        ...
    def bor(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Make bitwise OR of R to the value, save INSN as a defining instruction. 
                
        """
        ...
    def bxor(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Make bitwise eXclusive OR of R to the value, save INSN as a defining instruction. 
                
        """
        ...
    def clear(self) -> None:
        r"""Undefine the value.
        
        """
        ...
    def empty(self) -> bool:
        r"""Return 'true' if we know nothing about a value.
        
        """
        ...
    def extend(self, pm: procmod_t, width: int, is_signed: bool) -> None:
        r"""Sign-, or zero-extend the number or SP delta value to full size. The initial value is considered to be of size WIDTH. 
                
        """
        ...
    def get_aborting_depth(self) -> int:
        r"""Return the aborting depth if the value is ABORTED.
        
        """
        ...
    def get_def_ea(self) -> ida_idaapi.ea_t:
        r"""Return the defining address.
        
        """
        ...
    def get_def_itype(self) -> uint16:
        r"""Return the defining instruction code (processor specific).
        
        """
        ...
    def get_num(self) -> bool:
        r"""Return the number if the value is a constant. 
                
        """
        ...
    def get_spd(self) -> bool:
        r"""Return the SP delta if the value depends on the stack pointer. 
                
        """
        ...
    def has_any_vals_flag(self, val_flags: uint16) -> bool:
        ...
    def have_all_vals_flag(self, val_flags: uint16) -> bool:
        r"""Check the given flag for each value.
        
        """
        ...
    def is_all_vals_like_got(self) -> bool:
        ...
    def is_all_vals_pc_based(self) -> bool:
        ...
    def is_any_vals_like_got(self) -> bool:
        ...
    def is_any_vals_pc_based(self) -> bool:
        ...
    def is_badinsn(self) -> bool:
        r"""Return 'true' if the value is unknown because of a bad insn.
        
        """
        ...
    def is_dead_end(self) -> bool:
        r"""Return 'true' if the value is undefined because of a dead end.
        
        """
        ...
    def is_known(self) -> bool:
        r"""Return 'true' if the value is known (i.e. it is a number or SP delta).
        
        """
        ...
    def is_num(self) -> bool:
        r"""Return 'true' if the value is a constant.
        
        """
        ...
    def is_spd(self) -> bool:
        r"""Return 'true' if the value depends on the stack pointer.
        
        """
        ...
    def is_special(self) -> bool:
        r"""Return 'true' if the value requires special handling.
        
        """
        ...
    def is_unkfunc(self) -> bool:
        r"""Return 'true' if the value is unknown from the function start.
        
        """
        ...
    def is_unkinsn(self) -> bool:
        r"""Return 'true' if the value is unknown after executing the insn.
        
        """
        ...
    def is_unkloop(self) -> bool:
        r"""Return 'true' if the value is unknown because it changes in a loop.
        
        """
        ...
    def is_unkmult(self) -> bool:
        r"""Return 'true' if the value is unknown because the register has incompatible values (a number and SP delta). 
                
        """
        ...
    def is_unknown(self) -> bool:
        r"""Return 'true' if the value is unknown.
        
        """
        ...
    def is_unkvals(self) -> bool:
        r"""Return 'true' if the value is unknown because the register has too many values. 
                
        """
        ...
    def is_unkxref(self) -> bool:
        r"""Return 'true' if the value is unknown because there are too many xrefs.
        
        """
        ...
    def is_value_unique(self) -> bool:
        r"""Check that the value is unique.
        
        """
        ...
    def make_aborted(self, bblk_ea: ida_idaapi.ea_t, aborting_depth: int = -1) -> reg_value_info_t:
        r"""Return the value after aborting. 
                
        """
        ...
    def make_badinsn(self, insn_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value after a bad insn. 
                
        """
        ...
    def make_dead_end(self, dead_end_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the undefined value because of a dead end. 
                
        """
        ...
    def make_initial_sp(self, func_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the value that is the initial stack pointer. 
                
        """
        ...
    def make_num(self, args: Any) -> reg_value_info_t:
        r"""This function has the following signatures:
        
            0. make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t
            1. make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t
        
        # 0: make_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> reg_value_info_t
        
        Return the value that is the RVAL number. 
                
        
        # 1: make_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> reg_value_info_t
        
        Return the value that is the RVAL number. 
                
        
        """
        ...
    def make_unkfunc(self, func_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value from the function start. 
                
        """
        ...
    def make_unkinsn(self, insn: insn_t) -> reg_value_info_t:
        r"""Return the unknown value after executing the insn. 
                
        """
        ...
    def make_unkloop(self, bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value if it changes in a loop. 
                
        """
        ...
    def make_unkmult(self, bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value if the register has incompatible values. 
                
        """
        ...
    def make_unkvals(self, bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value if the register has too many values. 
                
        """
        ...
    def make_unkxref(self, bblk_ea: ida_idaapi.ea_t) -> reg_value_info_t:
        r"""Return the unknown value if there are too many xrefs. 
                
        """
        ...
    def movt(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Replace the top 16 bits with bottom 16 bits of R, leaving the bottom 16 bits untouched, save INSN as a defining instruction. 
                
        """
        ...
    def neg(self, insn: insn_t) -> None:
        r"""Negate the value, save INSN as a defining instruction.
        
        """
        ...
    def sar(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Shift arithmetically the value right by R, save INSN as a defining instruction. 
                
        """
        ...
    def set_aborted(self, bblk_ea: ida_idaapi.ea_t, aborting_depth: int = -1) -> None:
        r"""Set the value after aborting. 
                
        """
        ...
    def set_all_vals_flag(self, val_flags: uint16) -> None:
        r"""Set the given flag for each value.
        
        """
        ...
    def set_all_vals_got_based(self) -> None:
        ...
    def set_all_vals_pc_based(self) -> None:
        ...
    def set_badinsn(self, insn_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown after a bad insn. 
                
        """
        ...
    def set_dead_end(self, dead_end_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be undefined because of a dead end. 
                
        """
        ...
    def set_num(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None
            1. set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None
            2. set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None
        
        # 0: set_num(rval: int, insn: const insn_t &, val_flags: uint16=0) -> None
        
        Set the value to be a number after executing an insn. 
                
        
        # 1: set_num(rvals: uvalvec_t *, insn: const insn_t &) -> None
        
        Set the value to be numbers after executing an insn. 
                
        
        # 2: set_num(rval: int, val_ea: ida_idaapi.ea_t, val_flags: uint16=0) -> None
        
        Set the value to be a number before an address. 
                
        
        """
        ...
    def set_unkfunc(self, func_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown from the function start. 
                
        """
        ...
    def set_unkinsn(self, insn: insn_t) -> None:
        r"""Set the value to be unknown after executing the insn. 
                
        """
        ...
    def set_unkloop(self, bblk_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown because it changes in a loop. 
                
        """
        ...
    def set_unkmult(self, bblk_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown because the register has incompatible values. 
                
        """
        ...
    def set_unkvals(self, bblk_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown because the register has too many values. 
                
        """
        ...
    def set_unkxref(self, bblk_ea: ida_idaapi.ea_t) -> None:
        r"""Set the value to be unknown because there are too many xrefs. 
                
        """
        ...
    def shift_left(self, r: int) -> None:
        r"""Shift the value left by R, do not change the defining instructions. 
                
        """
        ...
    def shift_right(self, r: int) -> None:
        r"""Shift the value right by R, do not change the defining instructions. 
                
        """
        ...
    def sll(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Shift the value left by R, save INSN as a defining instruction. 
                
        """
        ...
    def slr(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Shift logically the value right by R, save INSN as a defining instruction. 
                
        """
        ...
    def sub(self, r: reg_value_info_t, insn: insn_t) -> None:
        r"""Subtract R from the value, save INSN as a defining instruction. 
                
        """
        ...
    def swap(self, r: reg_value_info_t) -> None:
        ...
    def trunc_uval(self, pm: procmod_t) -> None:
        r"""Truncate the number to the application bitness. 
                
        """
        ...
    def vals_union(self, r: reg_value_info_t) -> set_compare_res_t:
        r"""Add values from R into THIS ignoring duplicates. 
                
        :returns: EQUAL: THIS is not changed
        :returns: CONTAINS: THIS is not changed
        :returns: CONTAINED: THIS is a copy of R
        :returns: NOT_COMPARABLE: values from R are added to THIS
        """
        ...

class regarg_t:
    @property
    def name(self) -> Any: ...
    @property
    def reg(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def swap(self, r: regarg_t) -> None:
        ...

class reginfovec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: reginfovec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> reg_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: reginfovec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: reg_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: reg_info_t) -> bool:
        ...
    def append(self, args: Any) -> reg_info_t:
        ...
    def at(self, i: size_t) -> reg_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: reginfovec_t) -> None:
        ...
    def extract(self) -> reg_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: reg_info_t) -> bool:
        ...
    def inject(self, s: reg_info_t, len: size_t) -> None:
        ...
    def insert(self, it: reg_info_t, x: reg_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> reg_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: reginfovec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class register_info_t:
    @property
    def bit_strings(self) -> Any: ...
    @property
    def default_bit_strings_mask(self) -> Any: ...
    @property
    def dtype(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def register_class(self) -> Any: ...
    @property
    def register_class_mask(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class regobj_t:
    @property
    def regidx(self) -> Any: ...
    @property
    def relocate(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def size(self) -> int:
        ...

class regobjs_t(regobjvec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> regobj_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: regobj_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: regobj_t) -> None:
        ...
    def at(self, _idx: size_t) -> regobj_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: regobjvec_t) -> None:
        ...
    def extract(self) -> regobj_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: regobj_t, len: size_t) -> None:
        ...
    def insert(self, it: regobj_t, x: regobj_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> regobj_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: regobjvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class regobjvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> regobj_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: regobj_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: regobj_t) -> None:
        ...
    def at(self, _idx: size_t) -> regobj_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: regobjvec_t) -> None:
        ...
    def extract(self) -> regobj_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: regobj_t, len: size_t) -> None:
        ...
    def insert(self, it: regobj_t, x: regobj_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> regobj_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: regobjvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class regval_t:
    @property
    def ival(self) -> Any: ...
    @property
    def rvtype(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: regval_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: regval_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def bytes(self, args: Any) -> bytevec_t:
        ...
    def clear(self) -> None:
        r"""Clear register value.
        
        """
        ...
    def get_data(self, args: Any) -> None:
        ...
    def get_data_size(self) -> int:
        ...
    def pyval(self, dtype: op_dtype_t) -> Any:
        ...
    def set_bytes(self, args: Any) -> bytevec_t:
        ...
    def set_float(self, v: bytevec_t) -> None:
        ...
    def set_int(self, x: uint64) -> None:
        ...
    def set_pyval(self, o: Any, dtype: op_dtype_t) -> bool:
        ...
    def set_unavailable(self) -> None:
        ...
    def swap(self, r: regval_t) -> None:
        r"""Set this = r and r = this.
        
        """
        ...
    def use_bytevec(self) -> bool:
        ...

class regvals_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: regvals_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> regval_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: regvals_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: regval_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: regval_t) -> bool:
        ...
    def append(self, x: regval_t) -> None:
        ...
    def at(self, _idx: size_t) -> regval_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: regvals_t) -> None:
        ...
    def extract(self) -> regval_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: regval_t) -> bool:
        ...
    def inject(self, s: regval_t, len: size_t) -> None:
        ...
    def insert(self, it: regval_t, x: regval_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> regval_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: regvals_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class regvar_t(range_t):
    @property
    def canon(self) -> Any: ...
    @property
    def cmt(self) -> Any: ...
    @property
    def end_ea(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def user(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...
    def swap(self, r: regvar_t) -> None:
        ...

class renderer_info_pos_t:
    @property
    def cx(self) -> Any: ...
    @property
    def cy(self) -> Any: ...
    @property
    def node(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: renderer_info_pos_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: renderer_info_pos_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class renderer_info_t:
    @property
    def gli(self) -> Any: ...
    @property
    def pos(self) -> Any: ...
    @property
    def rtype(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: renderer_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: renderer_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class renderer_pos_info_t:
    @property
    def cx(self) -> Any: ...
    @property
    def cy(self) -> Any: ...
    @property
    def node(self) -> Any: ...
    @property
    def sx(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: renderer_pos_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: renderer_pos_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class rlist_t(bitset_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: bitset_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: bitset_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: bitset_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        ...
    def __le__(self, r: bitset_t) -> bool:
        ...
    def __len__(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def __lt__(self, r: bitset_t) -> bool:
        ...
    def __ne__(self, r: bitset_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. add(bit: int) -> bool
            1. add(bit: int, width: int) -> bool
            2. add(ml: const bitset_t &) -> bool
        
        # 0: add(bit: int) -> bool
        
        
        # 1: add(bit: int, width: int) -> bool
        
        
        # 2: add(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def back(self) -> int:
        ...
    def begin(self) -> iterator:
        ...
    def clear(self) -> None:
        ...
    def compare(self, r: bitset_t) -> int:
        ...
    def copy(self, m: bitset_t) -> bitset_t:
        ...
    def count(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. count() -> int
            1. count(bit: int) -> int
        
        # 0: count() -> int
        
        
        # 1: count(bit: int) -> int
        
        
        """
        ...
    def cut_at(self, maxbit: int) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> iterator:
        ...
    def fill_with_ones(self, maxbit: int) -> None:
        ...
    def front(self) -> int:
        ...
    def has(self, bit: int) -> bool:
        ...
    def has_all(self, bit: int, width: int) -> bool:
        ...
    def has_any(self, bit: int, width: int) -> bool:
        ...
    def has_common(self, ml: bitset_t) -> bool:
        ...
    def inc(self, p: iterator, n: int = 1) -> None:
        ...
    def includes(self, ml: bitset_t) -> bool:
        ...
    def intersect(self, ml: bitset_t) -> bool:
        ...
    def is_subset_of(self, ml: bitset_t) -> bool:
        ...
    def itat(self, n: int) -> iterator:
        ...
    def itv(self, it: iterator) -> int:
        ...
    def last(self) -> int:
        ...
    def shift_down(self, shift: int) -> None:
        ...
    def sub(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. sub(bit: int) -> bool
            1. sub(bit: int, width: int) -> bool
            2. sub(ml: const bitset_t &) -> bool
        
        # 0: sub(bit: int) -> bool
        
        
        # 1: sub(bit: int, width: int) -> bool
        
        
        # 2: sub(ml: const bitset_t &) -> bool
        
        
        """
        ...
    def swap(self, r: bitset_t) -> None:
        ...

class row_info_t:
    @property
    def bottom(self) -> Any: ...
    @property
    def nodes(self) -> Any: ...
    @property
    def top(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def height(self) -> int:
        ...

class rrel_t:
    @property
    def off(self) -> Any: ...
    @property
    def reg(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class scattered_aloc_t(argpartvec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: argpartvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> argpart_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: argpartvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: argpart_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: argpart_t) -> bool:
        ...
    def append(self, x: argpart_t) -> None:
        ...
    def at(self, _idx: size_t) -> argpart_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: argpartvec_t) -> None:
        ...
    def extract(self) -> argpart_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: argpart_t) -> bool:
        ...
    def inject(self, s: argpart_t, len: size_t) -> None:
        ...
    def insert(self, it: argpart_t, x: argpart_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> argpart_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: argpartvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class scattered_segm_t(range_t):
    @property
    def end_ea(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class scif_t(vdloc_t, argloc_t):
    @property
    def mba(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: vdloc_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: vdloc_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: vdloc_t) -> bool:
        ...
    def __init__(self, _mba: mba_t, tif: tinfo_t, n: str = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: vdloc_t) -> bool:
        ...
    def __lt__(self, r: vdloc_t) -> bool:
        ...
    def __ne__(self, r: vdloc_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def advance(self, delta: int) -> bool:
        r"""Move the location to point 'delta' bytes further.
        
        """
        ...
    def align_reg_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set register offset to align it to the upper part of _SLOTSIZE.
        
        """
        ...
    def align_stkoff_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set stack offset to align to the upper part of _SLOTSIZE.
        
        """
        ...
    def atype(self) -> argloc_type_t:
        r"""Get type (Argument location types)
        
        """
        ...
    def calc_offset(self) -> int:
        r"""Calculate offset that can be used to compare 2 similar arglocs.
        
        """
        ...
    def compare(self, r: vdloc_t) -> int:
        ...
    def consume_rrel(self, p: rrel_t) -> None:
        r"""Set register-relative location - can't be nullptr.
        
        """
        ...
    def consume_scattered(self, p: scattered_aloc_t) -> None:
        r"""Set distributed argument location.
        
        """
        ...
    def get_biggest(self) -> biggest_t:
        r"""Get largest element in internal union.
        
        """
        ...
    def get_custom(self) -> None:
        r"""Get custom argloc info. Use if atype() == ALOC_CUSTOM 
                
        """
        ...
    def get_ea(self) -> ida_idaapi.ea_t:
        r"""Get the global address. Use when atype() == ALOC_STATIC 
                
        """
        ...
    def get_reginfo(self) -> int:
        r"""Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def get_rrel(self) -> rrel_t:
        r"""Get register-relative info. Use when atype() == ALOC_RREL 
                
        """
        ...
    def has_reg(self) -> bool:
        r"""TRUE if argloc has a register part.
        
        """
        ...
    def has_stkoff(self) -> bool:
        r"""TRUE if argloc has a stack part.
        
        """
        ...
    def in_stack(self) -> bool:
        r"""TRUE if argloc is in stack entirely.
        
        """
        ...
    def is_aliasable(self, mb: mba_t, size: int) -> bool:
        ...
    def is_badloc(self) -> bool:
        r"""See ALOC_NONE.
        
        """
        ...
    def is_custom(self) -> bool:
        r"""See ALOC_CUSTOM.
        
        """
        ...
    def is_ea(self) -> bool:
        r"""See ALOC_STATIC.
        
        """
        ...
    def is_fragmented(self) -> bool:
        r"""is_scattered() || is_reg2()
        
        """
        ...
    def is_mixed_scattered(self) -> bool:
        r"""mixed scattered: consists of register and stack parts
        
        """
        ...
    def is_reg(self) -> bool:
        r"""is_reg1() || is_reg2()
        
        """
        ...
    def is_reg1(self) -> bool:
        r"""See ALOC_REG1.
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""See ALOC_REG2.
        
        """
        ...
    def is_rrel(self) -> bool:
        r"""See ALOC_RREL.
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""See ALOC_DIST.
        
        """
        ...
    def is_stkoff(self) -> bool:
        r"""See ALOC_STACK.
        
        """
        ...
    def reg1(self) -> int:
        ...
    def reg2(self) -> int:
        r"""Get info for the second register. Use when atype() == ALOC_REG2 
                
        """
        ...
    def regoff(self) -> int:
        r"""Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
                
        """
        ...
    def scattered(self) -> scattered_aloc_t:
        r"""Get scattered argument info. Use when atype() == ALOC_DIST 
                
        """
        ...
    def set_badloc(self) -> None:
        r"""Set to invalid location.
        
        """
        ...
    def set_ea(self, _ea: ida_idaapi.ea_t) -> None:
        r"""Set static ea location.
        
        """
        ...
    def set_reg1(self, r1: int) -> None:
        ...
    def set_reg2(self, _reg1: int, _reg2: int) -> None:
        r"""Set secondary register location.
        
        """
        ...
    def set_stkoff(self, off: int) -> None:
        r"""Set stack offset location.
        
        """
        ...
    def stkoff(self) -> int:
        r"""Get the stack offset. Use if atype() == ALOC_STACK 
                
        """
        ...
    def swap(self, r: argloc_t) -> None:
        r"""Assign this == r and r == this.
        
        """
        ...

class scif_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_scif_mop(self, r: mop_t, off: int) -> int:
        ...

class screen_graph_selection_base_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> selection_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: selection_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: selection_item_t) -> bool:
        ...
    def append(self, x: selection_item_t) -> None:
        ...
    def at(self, _idx: size_t) -> selection_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: screen_graph_selection_base_t) -> None:
        ...
    def extract(self) -> selection_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: selection_item_t) -> bool:
        ...
    def inject(self, s: selection_item_t, len: size_t) -> None:
        ...
    def insert(self, it: selection_item_t, x: selection_item_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> selection_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: screen_graph_selection_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class screen_graph_selection_t(screen_graph_selection_base_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> selection_item_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: screen_graph_selection_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: selection_item_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, s: screen_graph_selection_t) -> None:
        ...
    def add_node(self, node: int) -> None:
        ...
    def add_point(self, e: edge_t, idx: int) -> None:
        ...
    def add_unique(self, x: selection_item_t) -> bool:
        ...
    def append(self, x: selection_item_t) -> None:
        ...
    def at(self, _idx: size_t) -> selection_item_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def del_node(self, node: int) -> None:
        ...
    def del_point(self, e: edge_t, idx: int) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: screen_graph_selection_base_t) -> None:
        ...
    def extract(self) -> selection_item_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, item: selection_item_t) -> bool:
        ...
    def inject(self, s: selection_item_t, len: size_t) -> None:
        ...
    def insert(self, it: selection_item_t, x: selection_item_t) -> iterator:
        ...
    def items_count(self, look_for_nodes: bool) -> int:
        ...
    def nodes_count(self) -> int:
        ...
    def points_count(self) -> int:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> selection_item_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def sub(self, s: screen_graph_selection_t) -> None:
        ...
    def swap(self, r: screen_graph_selection_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class section_lines_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: section_lines_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> Any:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: section_lines_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: twinline_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: twinline_t) -> bool:
        ...
    def append(self, x: twinline_t) -> None:
        ...
    def at(self, _idx: size_t) -> Any:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: section_lines_refs_t) -> None:
        ...
    def extract(self) -> twinline_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: twinline_t) -> bool:
        ...
    def inject(self, s: twinline_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: twinline_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> Any:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: section_lines_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class sections_lines_refs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sections_lines_refs_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> section_lines_refs_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sections_lines_refs_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: section_lines_refs_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: section_lines_refs_t) -> bool:
        ...
    def append(self, x: section_lines_refs_t) -> None:
        ...
    def at(self, _idx: size_t) -> section_lines_refs_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sections_lines_refs_t) -> None:
        ...
    def extract(self) -> section_lines_refs_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: section_lines_refs_t) -> bool:
        ...
    def inject(self, s: section_lines_refs_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: section_lines_refs_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> section_lines_refs_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sections_lines_refs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class segm_move_info_t:
    @property
    def size(self) -> Any: ...
    @property
    def to(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: segm_move_info_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, _from: ida_idaapi.ea_t = 0, _to: ida_idaapi.ea_t = 0, _sz: size_t = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: segm_move_info_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class segm_move_info_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: segm_move_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> segm_move_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: segm_move_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: segm_move_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: segm_move_info_t) -> bool:
        ...
    def append(self, x: segm_move_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> segm_move_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: segm_move_info_vec_t) -> None:
        ...
    def extract(self) -> segm_move_info_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: segm_move_info_t) -> bool:
        ...
    def inject(self, s: segm_move_info_t, len: size_t) -> None:
        ...
    def insert(self, it: segm_move_info_t, x: segm_move_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> segm_move_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: segm_move_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class segm_move_infos_t(segm_move_info_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: segm_move_info_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> segm_move_info_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: segm_move_info_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: segm_move_info_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: segm_move_info_t) -> bool:
        ...
    def append(self, x: segm_move_info_t) -> None:
        ...
    def at(self, _idx: size_t) -> segm_move_info_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: segm_move_info_vec_t) -> None:
        ...
    def extract(self) -> segm_move_info_t:
        ...
    def find(self, ea: ida_idaapi.ea_t) -> segm_move_info_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: segm_move_info_t) -> bool:
        ...
    def inject(self, s: segm_move_info_t, len: size_t) -> None:
        ...
    def insert(self, it: segm_move_info_t, x: segm_move_info_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> segm_move_info_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: segm_move_info_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class segment_defsr_array:
    @property
    def bytes(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, data: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class segment_t(range_t):
    @property
    def align(self) -> Any: ...
    @property
    def bitness(self) -> Any: ...
    @property
    def color(self) -> Any: ...
    @property
    def comb(self) -> Any: ...
    @property
    def defsr(self) -> Any: ...
    @property
    def end_ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def orgbase(self) -> Any: ...
    @property
    def perm(self) -> Any: ...
    @property
    def sclass(self) -> Any: ...
    @property
    def sel(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def abits(self) -> int:
        r"""Get number of address bits.
        
        """
        ...
    def abytes(self) -> int:
        r"""Get number of address bytes.
        
        """
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def clr_comorg(self) -> None:
        ...
    def clr_ob_ok(self) -> None:
        ...
    def comorg(self) -> bool:
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def is_16bit(self) -> bool:
        r"""Is a 16-bit segment?
        
        """
        ...
    def is_32bit(self) -> bool:
        r"""Is a 32-bit segment?
        
        """
        ...
    def is_64bit(self) -> bool:
        r"""Is a 64-bit segment?
        
        """
        ...
    def is_header_segm(self) -> bool:
        ...
    def is_hidden_segtype(self) -> bool:
        ...
    def is_loader_segm(self) -> bool:
        ...
    def is_visible_segm(self) -> bool:
        ...
    def ob_ok(self) -> bool:
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def set_comorg(self) -> None:
        ...
    def set_debugger_segm(self, debseg: bool) -> None:
        ...
    def set_header_segm(self, on: bool) -> None:
        ...
    def set_hidden_segtype(self, hide: bool) -> None:
        ...
    def set_loader_segm(self, ldrseg: bool) -> None:
        ...
    def set_ob_ok(self) -> None:
        ...
    def set_visible_segm(self, visible: bool) -> None:
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...
    def update(self) -> bool:
        r"""Update segment information. You must call this function after modification of segment characteristics. Note that not all fields of segment structure may be modified directly, there are special functions to modify some fields. 
                
        :returns: success
        """
        ...
    def use64(self) -> bool:
        r"""Is a 64-bit segment?
        
        """
        ...

class seh_t(try_handler_t, rangevec_t, rangevec_base_t):
    @property
    def disp(self) -> Any: ...
    @property
    def filter(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    @property
    def seh_code(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class sel_array:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: size_t) -> sel_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nelements: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, index: size_t, value: sel_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cast(self) -> sel_t:
        ...
    def frompointer(self, t: sel_t) -> sel_array:
        ...

class sel_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: sel_t) -> None:
        ...
    def cast(self) -> sel_t:
        ...
    def frompointer(self, t: sel_t) -> sel_pointer:
        ...
    def value(self) -> sel_t:
        ...

class selection_item_t:
    @property
    def elp(self) -> Any: ...
    @property
    def is_node(self) -> Any: ...
    @property
    def node(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: selection_item_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: selection_item_t) -> bool:
        ...
    def __ne__(self, r: selection_item_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: selection_item_t) -> int:
        ...

class short_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: short) -> None:
        ...
    def cast(self) -> short:
        ...
    def frompointer(self, t: short) -> short_pointer:
        ...
    def value(self) -> short:
        ...

class simd_info_t:
    @property
    def memtype(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def tif(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def match_pattern(self, pattern: simd_info_t) -> bool:
        ...

class simple_graph_t(gdl_graph_t):
    @property
    def colored_gdl_edges(self) -> Any: ...
    @property
    def title(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> iterator:
        ...
    def compute_dominators(self, domin: array_of_node_bitset_t, post: bool = False) -> None:
        ...
    def compute_immediate_dominators(self, domin: array_of_node_bitset_t, idomin: intvec_t, post: bool = False) -> None:
        ...
    def depth_first_postorder(self, post: node_ordering_t) -> int:
        ...
    def depth_first_preorder(self, pre: node_ordering_t) -> int:
        ...
    def edge(self, node: int, i: int, ispred: bool) -> int:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> iterator:
        ...
    def entry(self) -> int:
        ...
    def exists(self, node: int) -> bool:
        ...
    def exit(self) -> int:
        ...
    def front(self) -> int:
        ...
    def get_edge_color(self, i: int, j: int) -> bgcolor_t:
        ...
    def get_node_color(self, n: int) -> bgcolor_t:
        ...
    def get_node_label(self, n: int) -> char:
        ...
    def goup(self, node: int) -> int:
        ...
    def inc(self, p: iterator, n: int = 1) -> None:
        ...
    def nedge(self, node: int, ispred: bool) -> int:
        ...
    def node_qty(self) -> int:
        ...
    def npred(self, node: int) -> int:
        ...
    def nsucc(self, node: int) -> int:
        ...
    def pred(self, node: int, i: int) -> int:
        ...
    def print_edge(self, fp: FILE, i: int, j: int) -> bool:
        ...
    def print_graph_attributes(self, fp: FILE) -> None:
        ...
    def print_node(self, fp: FILE, n: int) -> bool:
        ...
    def print_node_attributes(self, fp: FILE, n: int) -> None:
        ...
    def size(self) -> int:
        ...
    def succ(self, node: int, i: int) -> int:
        ...

class simplecustviewer_t:
    r"""The base class for implementing simple custom viewers"""
    def AddLine(self, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Adds a colored line to the view
        :returns: Boolean
        
        """
        ...
    def ClearLines(self) -> Any:
        r"""Clears all the lines"""
        ...
    def Close(self) -> Any:
        r"""
        Destroys the view.
        One has to call Create() afterwards.
        Show() can be called and it will call Create() internally.
        :returns: Boolean
        
        """
        ...
    def Count(self) -> Any:
        r"""Returns the number of lines in the view"""
        ...
    def Create(self, title: Any) -> Any:
        r"""
        Creates the custom view. This should be the first method called after instantiation
        
        :param title: The title of the view
        :returns: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                 In this case better close existing windows
        
        """
        ...
    def DelLine(self, lineno: Any) -> Any:
        r"""
        Deletes an existing line
        :returns: Boolean
        
        """
        ...
    def EditLine(self, lineno: Any, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Edits an existing line.
        :returns: Boolean
        
        """
        ...
    def GetCurrentLine(self, mouse: Any = 0, notags: Any = 0) -> Any:
        r"""
        Returns the current line.
        :param mouse: Current line at mouse pos
        :param notags: If True then tag_remove() will be called before returning the line
        :returns: Returns the current line (colored or uncolored) or None on failure
        
        """
        ...
    def GetCurrentWord(self, mouse: Any = 0) -> Any:
        r"""
        Returns the current word
        :param mouse: Use mouse position or cursor position
        :returns: None if failed or a String containing the current word at mouse or cursor
        
        """
        ...
    def GetLine(self, lineno: Any) -> Any:
        r"""
        Returns a line
        :param lineno: The line number
        :returns: a tuple (colored_line, fgcolor, bgcolor), or None
        
        """
        ...
    def GetLineNo(self, mouse: Any = 0) -> Any:
        r"""Calls GetPos() and returns the current line number or -1 on failure"""
        ...
    def GetPos(self, mouse: Any = 0) -> Any:
        r"""
        Returns the current cursor or mouse position.
        :param mouse: return mouse position
        :returns: Returns a tuple (lineno, x, y)
        
        """
        ...
    def GetSelection(self) -> Any:
        r"""
        Returns the selected range or None
        :returns: tuple(x1, y1, x2, y2), or None if no selection
        
        """
        ...
    def GetWidget(self) -> Any:
        r"""
        Return the TWidget underlying this view.
        
        :returns: The TWidget underlying this view, or None.
        
        """
        ...
    def InsertLine(self, lineno: Any, line: Any, fgcolor: Any = None, bgcolor: Any = None) -> Any:
        r"""
        Inserts a line in the given position
        :returns: Boolean
        
        """
        ...
    def IsFocused(self) -> Any:
        r"""Returns True if the current view is the focused view"""
        ...
    def Jump(self, lineno: Any, x: Any = 0, y: Any = 0) -> Any:
        ...
    def OnPopup(self, form: Any, popup_handle: Any) -> Any:
        r"""
        Context menu popup is about to be shown. Create items dynamically if you wish
        :returns: Boolean. True if you handled the event
        
        """
        ...
    def PatchLine(self, lineno: Any, offs: Any, value: Any) -> Any:
        r"""Patches an existing line character at the given offset. This is a low level function. You must know what you're doing"""
        ...
    def Refresh(self) -> Any:
        ...
    def RefreshCurrent(self) -> Any:
        r"""Refreshes the current line only"""
        ...
    def Show(self) -> Any:
        r"""
        Shows an already created view. It the view was closed, then it will call Create() for you
        :returns: Boolean
        
        """
        ...
    def UI_Hooks_Trampoline(self, v: Any) -> Any:
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class simpleline_place_t(place_t):
    @property
    def lnnum(self) -> Any: ...
    @property
    def n(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...

class simpleline_t:
    @property
    def bgcolor(self) -> Any: ...
    @property
    def color(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class sint8_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: sint8) -> None:
        ...
    def cast(self) -> sint8:
        ...
    def frompointer(self, t: sint8) -> sint8_pointer:
        ...
    def value(self) -> sint8:
        ...

class sizevec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sizevec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sizevec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: size_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: size_t) -> bool:
        ...
    def append(self, x: size_t) -> None:
        ...
    def at(self, _idx: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sizevec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: size_t) -> bool:
        ...
    def inject(self, s: size_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: size_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sizevec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class snapshot_t:
    @property
    def children(self) -> Any: ...
    @property
    def desc(self) -> Any: ...
    @property
    def filename(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def id(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: snapshot_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: snapshot_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: snapshot_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: snapshot_t) -> bool:
        ...
    def __lt__(self, r: snapshot_t) -> bool:
        ...
    def __ne__(self, r: snapshot_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...

class sreg_range_t(range_t):
    @property
    def end_ea(self) -> Any: ...
    @property
    def start_ea(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    @property
    def val(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: range_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: range_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: range_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: range_t) -> bool:
        ...
    def __lt__(self, r: range_t) -> bool:
        ...
    def __ne__(self, r: range_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        r"""Set start_ea, end_ea to 0.
        
        """
        ...
    def compare(self, r: range_t) -> int:
        ...
    def contains(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. contains(ea: ida_idaapi.ea_t) -> bool
            1. contains(r: const range_t &) -> bool
        
        # 0: contains(ea: ida_idaapi.ea_t) -> bool
        
        Compare two range_t instances, based on the start_ea.
        
        Is 'ea' in the address range? 
                
        
        # 1: contains(r: const range_t &) -> bool
        
        Is every ea in 'r' also in this range_t?
        
        
        """
        ...
    def empty(self) -> bool:
        r"""Is the size of the range_t <= 0?
        
        """
        ...
    def extend(self, ea: ida_idaapi.ea_t) -> None:
        r"""Ensure that the range_t includes 'ea'.
        
        """
        ...
    def intersect(self, r: range_t) -> None:
        r"""Assign the range_t to the intersection between the range_t and 'r'.
        
        """
        ...
    def overlaps(self, r: range_t) -> bool:
        r"""Is there an ea in 'r' that is also in this range_t?
        
        """
        ...
    def size(self) -> int:
        r"""Get end_ea - start_ea.
        
        """
        ...

class ssize_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: ssize_t) -> None:
        ...
    def cast(self) -> ssize_t:
        ...
    def frompointer(self, t: ssize_t) -> ssize_pointer:
        ...
    def value(self) -> ssize_t:
        ...

class stkarg_area_info_t:
    @property
    def cb(self) -> Any: ...
    @property
    def linkage_area(self) -> Any: ...
    @property
    def shadow_size(self) -> Any: ...
    @property
    def stkarg_offset(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class stkpnt_t:
    @property
    def ea(self) -> Any: ...
    @property
    def spd(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: stkpnt_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: stkpnt_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: stkpnt_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: stkpnt_t) -> bool:
        ...
    def __lt__(self, r: stkpnt_t) -> bool:
        ...
    def __ne__(self, r: stkpnt_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: stkpnt_t) -> int:
        ...

class stkpnts_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: stkpnts_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: stkpnts_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: stkpnts_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: stkpnts_t) -> bool:
        ...
    def __lt__(self, r: stkpnts_t) -> bool:
        ...
    def __ne__(self, r: stkpnts_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: stkpnts_t) -> int:
        ...

class stkvar_ref_t:
    @property
    def mba(self) -> Any: ...
    @property
    def off(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: stkvar_ref_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: stkvar_ref_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: stkvar_ref_t) -> bool:
        ...
    def __init__(self, m: mba_t, o: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: stkvar_ref_t) -> bool:
        ...
    def __lt__(self, r: stkvar_ref_t) -> bool:
        ...
    def __ne__(self, r: stkvar_ref_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: stkvar_ref_t) -> int:
        ...
    def get_stkvar(self, udm: udm_t = None, p_idaoff: uval_t = None) -> ssize_t:
        r"""Retrieve the referenced stack variable. 
                
        :param udm: stkvar, may be nullptr
        :param p_idaoff: if specified, will hold IDA stkoff after the call.
        :returns: index of stkvar in the frame or -1
        """
        ...
    def swap(self, r: stkvar_ref_t) -> None:
        ...

class strarray_t:
    @property
    def code(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class string_info_t:
    @property
    def ea(self) -> Any: ...
    @property
    def length(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: string_info_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class strpath_ids_array:
    @property
    def bytes(self) -> Any: ...
    @property
    def data(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, data: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class strpath_t:
    @property
    def delta(self) -> Any: ...
    @property
    def ids(self) -> Any: ...
    @property
    def len(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class strvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> simpleline_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: simpleline_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, args: Any) -> simpleline_t:
        ...
    def at(self, i: size_t) -> simpleline_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: strvec_t) -> None:
        ...
    def extract(self) -> simpleline_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: simpleline_t, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: simpleline_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> simpleline_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: strvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class strwinsetup_t:
    @property
    def display_only_existing_strings(self) -> Any: ...
    @property
    def ignore_heads(self) -> Any: ...
    @property
    def minlen(self) -> Any: ...
    @property
    def only_7bit(self) -> Any: ...
    @property
    def strtypes(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class sval_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int) -> None:
        ...
    def cast(self) -> sval_t:
        ...
    def frompointer(self, t: sval_t) -> sval_pointer:
        ...
    def value(self) -> int:
        ...

class svalvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: int64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: int64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: int64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: int64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class switch_info_t:
    SWITCH_INFO_VERSION: int  # 2
    @property
    def custom(self) -> Any: ...
    @property
    def defjump(self) -> Any: ...
    @property
    def elbase(self) -> Any: ...
    @property
    def expr_ea(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def ind_lowcase(self) -> Any: ...
    @property
    def jcases(self) -> Any: ...
    @property
    def jumps(self) -> Any: ...
    @property
    def lowcase(self) -> Any: ...
    @property
    def marks(self) -> Any: ...
    @property
    def ncases(self) -> Any: ...
    @property
    def regdtype(self) -> Any: ...
    @property
    def regnum(self) -> Any: ...
    @property
    def startea(self) -> Any: ...
    @property
    def values(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, other: switch_info_t) -> None:
        ...
    def clear(self) -> None:
        ...
    def get_jrange_vrange(self, jrange: range_t = None, vrange: range_t = None) -> bool:
        r"""get separate parts of the switch
        
        """
        ...
    def get_jtable_element_size(self) -> int:
        ...
    def get_jtable_size(self) -> int:
        ...
    def get_lowcase(self) -> int:
        ...
    def get_shift(self) -> int:
        r"""See SWI_SHIFT_MASK. possible answers: 0..3. 
                
        """
        ...
    def get_version(self) -> int:
        ...
    def get_vtable_element_size(self) -> int:
        ...
    def has_default(self) -> bool:
        ...
    def has_elbase(self) -> bool:
        ...
    def is_custom(self) -> bool:
        ...
    def is_indirect(self) -> bool:
        ...
    def is_nolowcase(self) -> bool:
        ...
    def is_sparse(self) -> bool:
        ...
    def is_subtract(self) -> bool:
        ...
    def is_user_defined(self) -> bool:
        ...
    def set_elbase(self, base: ida_idaapi.ea_t) -> None:
        ...
    def set_expr(self, r: int, dt: op_dtype_t) -> None:
        ...
    def set_jtable_element_size(self, size: int) -> None:
        ...
    def set_jtable_size(self, size: int) -> None:
        ...
    def set_shift(self, shift: int) -> None:
        r"""See SWI_SHIFT_MASK.
        
        """
        ...
    def set_vtable_element_size(self, size: int) -> None:
        ...
    def use_std_table(self) -> bool:
        ...

class sync_source_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, _o: sync_source_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, _o: sync_source_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_register(self) -> str:
        ...
    def get_widget(self) -> TWidget:
        ...
    def is_register(self) -> bool:
        ...
    def is_widget(self) -> bool:
        ...

class sync_source_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sync_source_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> sync_source_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sync_source_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: sync_source_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: sync_source_t) -> bool:
        ...
    def append(self, x: sync_source_t) -> None:
        ...
    def at(self, _idx: size_t) -> sync_source_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sync_source_vec_t) -> None:
        ...
    def extract(self) -> sync_source_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: sync_source_t) -> bool:
        ...
    def inject(self, s: sync_source_t, len: size_t) -> None:
        ...
    def insert(self, it: sync_source_t, x: sync_source_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, x: sync_source_t) -> None:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sync_source_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class synced_group_t(sync_source_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: sync_source_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> sync_source_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: sync_source_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: sync_source_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: sync_source_t) -> bool:
        ...
    def append(self, x: sync_source_t) -> None:
        ...
    def at(self, _idx: size_t) -> sync_source_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: sync_source_vec_t) -> None:
        ...
    def extract(self) -> sync_source_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, ss: sync_source_t) -> bool:
        ...
    def has_register(self, r: str) -> bool:
        ...
    def has_widget(self, v: TWidget) -> bool:
        ...
    def inject(self, s: sync_source_t, len: size_t) -> None:
        ...
    def insert(self, it: sync_source_t, x: sync_source_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, x: sync_source_t) -> None:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: sync_source_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tagged_line_section_t(line_section_t):
    @property
    def length(self) -> Any: ...
    @property
    def start(self) -> Any: ...
    @property
    def tag(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def contains(self, x: cpidx_t) -> bool:
        ...
    def is_closed(self) -> bool:
        ...
    def is_open(self) -> bool:
        ...
    def substr(self, _in: str, end: tagged_line_section_t = None) -> bool:
        ...
    def valid(self) -> bool:
        ...
    def valid_in(self, _in: str) -> bool:
        ...

class tagged_line_section_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tagged_line_section_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tagged_line_section_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: tagged_line_section_t) -> bool:
        ...
    def append(self, x: tagged_line_section_t) -> None:
        ...
    def at(self, _idx: size_t) -> tagged_line_section_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tagged_line_section_vec_t) -> None:
        ...
    def extract(self) -> tagged_line_section_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: tagged_line_section_t) -> bool:
        ...
    def inject(self, s: tagged_line_section_t, len: size_t) -> None:
        ...
    def insert(self, it: tagged_line_section_t, x: tagged_line_section_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tagged_line_section_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tagged_line_section_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tagged_line_sections_t(tagged_line_section_vec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tagged_line_section_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tagged_line_section_vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tagged_line_section_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: tagged_line_section_t) -> bool:
        ...
    def append(self, x: tagged_line_section_t) -> None:
        ...
    def at(self, _idx: size_t) -> tagged_line_section_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tagged_line_section_vec_t) -> None:
        ...
    def extract(self) -> tagged_line_section_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def first(self, tag: color_t) -> tagged_line_section_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: tagged_line_section_t) -> bool:
        ...
    def inject(self, s: tagged_line_section_t, len: size_t) -> None:
        ...
    def insert(self, it: tagged_line_section_t, x: tagged_line_section_t) -> iterator:
        ...
    def nearest_after(self, range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def nearest_at(self, x: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def nearest_before(self, range: tagged_line_section_t, start: cpidx_t, tag: color_t = 0) -> tagged_line_section_t:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tagged_line_section_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def sections_at(self, out: tagged_line_sections_t, x: cpidx_t, tag: color_t = 0) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tagged_line_section_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tev_info_reg_t:
    @property
    def info(self) -> Any: ...
    @property
    def registers(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class tev_info_t:
    @property
    def ea(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class tev_reg_value_t:
    @property
    def reg_idx(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class tev_reg_values_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tev_reg_value_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tev_reg_value_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: tev_reg_value_t) -> None:
        ...
    def at(self, _idx: size_t) -> tev_reg_value_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tev_reg_values_t) -> None:
        ...
    def extract(self) -> tev_reg_value_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: tev_reg_value_t, len: size_t) -> None:
        ...
    def insert(self, it: tev_reg_value_t, x: tev_reg_value_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tev_reg_value_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tev_reg_values_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tevinforeg_vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tev_info_reg_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tev_info_reg_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: tev_info_reg_t) -> None:
        ...
    def at(self, _idx: size_t) -> tev_info_reg_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tevinforeg_vec_t) -> None:
        ...
    def extract(self) -> tev_info_reg_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: tev_info_reg_t, len: size_t) -> None:
        ...
    def insert(self, it: tev_info_reg_t, x: tev_info_reg_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tev_info_reg_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tevinforeg_vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class text_sink_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class text_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> twinline_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: twinline_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: twinline_t) -> None:
        ...
    def at(self, _idx: size_t) -> twinline_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: text_t) -> None:
        ...
    def extract(self) -> twinline_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: twinline_t, len: size_t) -> None:
        ...
    def insert(self, it: twinline_t, x: twinline_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> twinline_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: text_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class textctrl_info_t(py_clinked_object_t, pyidc_opaque_object_t):
    r"""Class representing textctrl_info_t"""
    TXTF_ACCEPTTABS: int  # 2
    TXTF_AUTOINDENT: int  # 1
    TXTF_FIXEDFONT: int  # 32
    TXTF_MODIFIED: int  # 16
    TXTF_READONLY: int  # 4
    TXTF_SELECTED: int  # 8
    @property
    def clink(self) -> Any: ...
    @property
    def clink_ptr(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def tabsize(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __del__(self) -> Any:
        r"""Delete the link upon object destruction (only if not static)"""
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __get_flags__(self) -> Any:
        r"""Returns the flags value"""
        ...
    def __get_tabsize__(self) -> Any:
        r"""Returns the tabsize value"""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, text: Any = '', flags: Any = 0, tabsize: Any = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        r"""Return repr(self)."""
        ...
    def __set_flags__(self, flags: Any) -> Any:
        r"""Sets the flags value"""
        ...
    def __set_tabsize__(self, tabsize: Any) -> Any:
        r"""Sets the tabsize value"""
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def assign(self, other: Any) -> Any:
        r"""Copies the contents of 'other' to 'self'"""
        ...
    def copy(self) -> Any:
        r"""Returns a new copy of this class"""
        ...

class thread_name_t:
    @property
    def name(self) -> Any: ...
    @property
    def tid(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class tid_array:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: size_t) -> tid_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nelements: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, index: size_t, value: tid_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cast(self) -> tid_t:
        ...
    def frompointer(self, t: tid_t) -> tid_array:
        ...

class tid_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: tid_t) -> None:
        ...
    def cast(self) -> tid_t:
        ...
    def frompointer(self, t: tid_t) -> tid_pointer:
        ...
    def value(self) -> tid_t:
        ...

class til_symbol_t:
    @property
    def name(self) -> Any: ...
    @property
    def til(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, n: str = None, t: til_t = None) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class til_t:
    @property
    def cc(self) -> Any: ...
    @property
    def desc(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def nbases(self) -> Any: ...
    @property
    def nrefs(self) -> Any: ...
    @property
    def nstreams(self) -> Any: ...
    @property
    def streams(self) -> Any: ...
    @property
    def type_names(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: til_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: til_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def base(self, n: int) -> til_t:
        ...
    def find_base(self, n: str) -> til_t:
        r"""Find the base til with the provided name 
                
        :param n: the base til name
        :returns: the found til_t, or nullptr
        """
        ...
    def get_named_type(self, name: Any) -> Any:
        r"""Retrieves a tinfo_t representing the named type in this type library.
        
        :param name: a type name
        :returns: a new tinfo_t object, or None if not found
        """
        ...
    def get_numbered_type(self, ordinal: Any) -> Any:
        r"""Retrieves a tinfo_t representing the numbered type in this type library.
        
        :param ordinal: a type ordinal
        :returns: a new tinfo_t object, or None if not found
        """
        ...
    def get_type_names(self) -> Any:
        ...
    def import_type(self, src: Any) -> Any:
        r"""Import a type (and all its dependencies) into this type info library.
        
        :param src: The type to import
        :returns: the imported copy, or None
        """
        ...
    def is_dirty(self) -> bool:
        r"""Has the til been modified? (TIL_MOD)
        
        """
        ...
    def named_types(self) -> Any:
        r"""Returns a generator over the named types contained in this
        type library.
        
        Every iteration returns a fresh new tinfo_t object
        
        :returns: a tinfo_t-producing generator
        """
        ...
    def numbered_types(self) -> Any:
        r"""Returns a generator over the numbered types contained in this
        type library.
        
        Every iteration returns a fresh new tinfo_t object
        
        :returns: a tinfo_t-producing generator
        """
        ...
    def set_dirty(self) -> None:
        r"""Mark the til as modified (TIL_MOD)
        
        """
        ...

class til_type_ref_t:
    @property
    def bf_bitoff(self) -> Any: ...
    @property
    def bucket_start(self) -> Any: ...
    @property
    def cb(self) -> Any: ...
    @property
    def cursor(self) -> Any: ...
    @property
    def edm(self) -> Any: ...
    @property
    def fa(self) -> Any: ...
    @property
    def is_detached(self) -> Any: ...
    @property
    def is_forward(self) -> Any: ...
    @property
    def is_writable(self) -> Any: ...
    @property
    def kind(self) -> Any: ...
    @property
    def last_udm_offset(self) -> Any: ...
    @property
    def memidx(self) -> Any: ...
    @property
    def nmembers(self) -> Any: ...
    @property
    def offset(self) -> Any: ...
    @property
    def ordinal(self) -> Any: ...
    @property
    def tif(self) -> Any: ...
    @property
    def total_size(self) -> Any: ...
    @property
    def udm(self) -> Any: ...
    @property
    def unpadded_size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def is_enum(self) -> bool:
        ...
    def is_func(self) -> bool:
        ...
    def is_struct(self) -> bool:
        ...
    def is_typedef(self) -> bool:
        ...
    def is_udt(self) -> bool:
        ...
    def is_union(self) -> bool:
        ...
    def on_member(self) -> bool:
        ...

class tinfo_t:
    ENUMBM_AUTO: int  # 2
    ENUMBM_OFF: int  # 0
    ENUMBM_ON: int  # 1
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tinfo_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: tinfo_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: tinfo_t) -> bool:
        ...
    def __init__(self, args: Any, ordinal: Any = None, name: Any = None, tid: Any = None, til: Any = None) -> Any:
        r"""Create a type object with the provided argumens.
        
        This constructor has the following signatures:
        
            1. tinfo_t(decl_type: type_t)
            2. tinfo_t(decl: str, til: til_t = None, pt_flags: int = 0)
        
        The latter form will create the type object by parsing the type declaration
        
        Alternatively, you can use a form accepting the following keyword arguments:
        
        * ordinal: int
        * name: str
        * tid: int
        * til: til_t=None # `None` means `get_idati()`
        
        E.g.,
        
        * tinfo_t(ordinal=3)
        * tinfo_t(ordinal=10, til=get_idati())
        * tinfo_t(name="mytype_t")
        * tinfo_t(name="thattype_t", til=my_other_til)
        * tinfo_t(tid=ida_nalt.get_strid(some_address))
        
        The constructor may raise an exception if data was invalid, or if parsing failed.
        
        :param decl_type: A simple type
        :param decl: A valid C declaration
        :param til: A type library, or `None` to use the (`get_idati()`) default
        :param ordinal: An ordinal in the type library
        :param name: A valid type name
        :param pt_flags: Parsing flags
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: tinfo_t) -> bool:
        ...
    def __lt__(self, r: tinfo_t) -> bool:
        ...
    def __ne__(self, r: tinfo_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_edm(self, args: Any) -> Any:
        r"""Add an enumerator to the current enumeration.
        
        When creating a new enumeration from scratch, you might
        want to first call `create_enum()`
        
        This method has the following signatures:
        
            1. add_edm(edm: edm_t, bmask: int = -1, etf_flags: int = 0, idx: int = -1)
            2. add_edm(name: str, value: int, bmask: int = -1, etf_flags: int = 0, idx: int = -1)
        
        If an input argument is incorrect, the constructor may raise an exception
        
        :param edm:       The member, fully initialized (1st form)
        :param name:      Enumerator name - must not be empty
        :param value:     Enumerator value
        :param bmask:     A bitmask to which the enumerator belongs
        :param etf_flags: an OR'ed combination of ETF_ flags
        :param idx:       the index in the edm array where the new udm should be placed.
                          If the specified index cannot be honored because it would spoil
                          the edm sorting order, it is silently ignored.
        """
        ...
    def add_funcarg(self, farg: funcarg_t, etf_flags: uint = 0, idx: ssize_t = -1) -> tinfo_code_t:
        r"""Add a function argument. 
                
        :param farg: argument to add
        :param etf_flags: type changing flags flags
        :param idx: the index in the funcarg array where the new funcarg should be placed. if the specified index cannot be honored because it would spoil the funcarg sorting order, it is silently ignored.
        """
        ...
    def add_udm(self, args: Any) -> Any:
        r"""Add a member to the current structure/union.
        
        When creating a new structure/union from scratch, you might
        want to first call `create_udt()`
        
        This method has the following signatures:
        
            1. add_udm(udm: udm_t, etf_flags: int = 0, times: int = 1, idx: int = -1)
            2. add_udm(name: str, type: type_t | tinfo_t | str, offset: int = 0, etf_flags: int = 0, times: int = 1, idx: int = -1)
        
        In the 2nd form, the 'type' descriptor, can be one of:
        
        * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
        * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
        * str: a C type declaration
        
        If an input argument is incorrect, the constructor may raise an exception
        
        :param udm:       The member, fully initialized (1st form)
        :param name:      Member name - must not be empty
        :param type:      Member type
        :param offset:    the member offset in bits. It is the caller's responsibility
                          to specify correct offsets.
        :param etf_flags: an OR'ed combination of ETF_ flags
        :param times:     how many times to add the new member
        :param idx:       the index in the udm array where the new udm should be placed.
                          If the specified index cannot be honored because it would spoil
                          the udm sorting order, it is silently ignored.
        """
        ...
    def append_covered(self, out: rangeset_t, offset: uint64 = 0) -> bool:
        r"""Calculate set of covered bytes for the type 
                
        :param out: pointer to the output buffer. covered bytes will be appended to it.
        :param offset: delta in bytes to add to all calculations. used internally during recurion.
        """
        ...
    def calc_enum_mask(self) -> uint64:
        ...
    def calc_gaps(self, out: rangeset_t) -> bool:
        r"""Calculate set of padding bytes for the type 
                
        :param out: pointer to the output buffer; old buffer contents will be lost.
        """
        ...
    def calc_purged_bytes(self) -> int:
        r"""BT_FUNC: Calculate number of purged bytes
        
        """
        ...
    def calc_score(self) -> int:
        r"""Calculate the type score (the higher - the nicer is the type)
        
        """
        ...
    def calc_udt_aligns(self, sudt_flags: int = 4) -> bool:
        r"""Calculate the udt alignments using the field offsets/sizes and the total udt size This function does not work on typerefs 
                
        """
        ...
    def change_sign(self, sign: type_sign_t) -> bool:
        r"""Change the type sign. Works only for the types that may have sign.
        
        """
        ...
    def clear(self) -> None:
        r"""Clear contents of this tinfo, and remove from the type system.
        
        """
        ...
    def clr_const(self) -> bool:
        ...
    def clr_const_volatile(self) -> bool:
        ...
    def clr_decl_const_volatile(self) -> None:
        ...
    def clr_volatile(self) -> bool:
        ...
    def compare(self, r: tinfo_t) -> int:
        ...
    def compare_with(self, r: tinfo_t, tcflags: int = 0) -> bool:
        r"""Compare two types, based on given flags (see tinfo_t comparison flags)
        
        """
        ...
    def convert_array_to_ptr(self) -> bool:
        r"""Convert an array into a pointer. type[] => type * 
                
        """
        ...
    def copy(self) -> tinfo_t:
        ...
    def copy_type(self, args: Any) -> tinfo_code_t:
        ...
    def create_array(self, args: Any) -> bool:
        ...
    def create_bitfield(self, args: Any) -> bool:
        ...
    def create_enum(self, args: Any) -> bool:
        r"""Create an empty enum.
        
        """
        ...
    def create_forward_decl(self, til: til_t, decl_type: type_t, name: str, ntf_flags: int = 0) -> tinfo_code_t:
        r"""Create a forward declaration. decl_type: BTF_STRUCT, BTF_UNION, or BTF_ENUM 
                
        """
        ...
    def create_func(self, args: Any) -> bool:
        ...
    def create_ptr(self, args: Any) -> bool:
        ...
    def create_simple_type(self, decl_type: type_t) -> bool:
        ...
    def create_typedef(self, args: Any) -> None:
        ...
    def create_udt(self, args: Any) -> bool:
        r"""Create an empty structure/union.
        
        """
        ...
    def del_attr(self, key: str, make_copy: bool = True) -> bool:
        r"""Del a type attribute. typerefs cannot be modified by this function.
        
        """
        ...
    def del_attrs(self) -> None:
        r"""Del all type attributes. typerefs cannot be modified by this function.
        
        """
        ...
    def del_edm(self, args: Any) -> Any:
        r"""Delete an enumerator with the specified name
        or the specified index, in the specified tinfo_t object.
        
        This method has the following signatures:
        
            1. del_edm(name: str) -> int
            2. del_edm(index: int) -> int
        
        :param name: an enumerator name (1st form)
        :param index: an enumerator index (2nd form)
        :returns: TERR_OK in case of success, or another TERR_* value in case of error
        """
        ...
    def del_edm_by_value(self, value: int, etf_flags: int = 0, bmask: int = 18446744073709551615, serial: int = 0) -> Any:
        r"""Delete an enumerator with the specified value,
        in the specified tinfo_t object.
        
        :param value: the enumerator value
        :returns: TERR_OK in case of success, or another TERR_* value in case of error
        """
        ...
    def del_edms(self, idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Delete enum members 
                
        :param idx1: index in edmvec_t
        :param idx2: index in edmvec_t or size_t(-1)
        :param etf_flags: etf_flag_t Delete enum members in [idx1, idx2)
        """
        ...
    def del_funcarg(self, idx: size_t, etf_flags: uint = 0) -> tinfo_code_t:
        ...
    def del_funcargs(self, idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Delete function arguments 
                
        :param idx1: index in funcargvec_t
        :param idx2: index in funcargvec_t or size_t(-1)
        :param etf_flags: etf_flag_t Delete function arguments in [idx1, idx2)
        """
        ...
    def del_udm(self, index: size_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Delete a structure/union member.
        
        """
        ...
    def del_udms(self, idx1: size_t, idx2: size_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Delete structure/union members in the range [idx1, idx2)
        
        """
        ...
    def deserialize(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool
            1. deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool
        
        # 0: deserialize(til: const til_t *, ptype: const type_t **, pfields: const p_list **=nullptr, pfldcmts: const p_list **=nullptr, cmt: str=nullptr) -> bool
        
        Deserialize a type string into a tinfo_t object.
        
        
        # 1: deserialize(til: const til_t *, ptype: const qtype *, pfields: const qtype *=nullptr, pfldcmts: const qtype *=nullptr, cmt: str=nullptr) -> bool
        
        Deserialize a type string into a tinfo_t object.
        
        
        """
        ...
    def detach(self) -> bool:
        r"""Detach tinfo_t from the underlying type. After calling this finction, tinfo_t will lose its link to the underlying named or numbered type (if any) and will become a reference to a unique type. After that, any modifications to tinfo_t will affect only its type. 
                
        """
        ...
    def dstr(self) -> str:
        r"""Function to facilitate debugging.
        
        """
        ...
    def edit_edm(self, args: Any) -> tinfo_code_t:
        r"""Change constant value and/or bitmask 
                
        :param idx: index in edmvec_t
        :param value: old or new value
        :param bmask: old or new bitmask
        :param etf_flags: etf_flag_t
        """
        ...
    def empty(self) -> bool:
        r"""Was tinfo_t initialized with some type info or not?
        
        """
        ...
    def equals_to(self, r: tinfo_t) -> bool:
        ...
    def expand_udt(self, idx: size_t, delta: adiff_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Expand/shrink a structure by adding/removing a gap before the specified member.
        For regular structures, either the gap can be accommodated by aligning the next member with an alignment directive, or an explicit "gap" member will be inserted. Also note that it is impossible to add a gap at the end of a regular structure.
        When it comes to fixed-layout structures, there is no need to either add new "gap" members or align existing members, since all members have a fixed offset. It is possible to add a gap at the end of a fixed-layout structure, by passing `-1` as index.
        
        :param idx: index of the member
        :param delta: number of bytes to add or remove
        :param etf_flags: etf_flag_t
        """
        ...
    def find_edm(self, args: Any) -> ssize_t:
        ...
    def find_udm(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. find_udm(udm: udm_t *, strmem_flags: int) -> int
            1. find_udm(offset: uint64, strmem_flags: int=0) -> int
            2. find_udm(name: str, strmem_flags: int=0) -> int
        
        # 0: find_udm(udm: udm_t *, strmem_flags: int) -> int
        
        BTF_STRUCT,BTF_UNION: Find a udt member.
        * at the specified offset (STRMEM_OFFSET)
        * with the specified index (STRMEM_INDEX)
        * with the specified type (STRMEM_TYPE)
        * with the specified name (STRMEM_NAME)
        
        
        
        :returns: the index of the found member or -1
        
        # 1: find_udm(offset: uint64, strmem_flags: int=0) -> int
        
        BTF_STRUCT,BTF_UNION: Find an udt member at the specified offset 
                
        :returns: the index of the found member or -1
        
        # 2: find_udm(name: str, strmem_flags: int=0) -> int
        
        BTF_STRUCT,BTF_UNION: Find an udt member by name 
                
        :returns: the index of the found member or -1
        
        """
        ...
    def find_udt_member(self, args: Any) -> int:
        r"""This function has the following signatures:
        
            0. find_udm(udm: udm_t *, strmem_flags: int) -> int
            1. find_udm(offset: uint64, strmem_flags: int=0) -> int
            2. find_udm(name: str, strmem_flags: int=0) -> int
        
        # 0: find_udm(udm: udm_t *, strmem_flags: int) -> int
        
        BTF_STRUCT,BTF_UNION: Find a udt member.
        * at the specified offset (STRMEM_OFFSET)
        * with the specified index (STRMEM_INDEX)
        * with the specified type (STRMEM_TYPE)
        * with the specified name (STRMEM_NAME)
        
        
        
        :returns: the index of the found member or -1
        
        # 1: find_udm(offset: uint64, strmem_flags: int=0) -> int
        
        BTF_STRUCT,BTF_UNION: Find an udt member at the specified offset 
                
        :returns: the index of the found member or -1
        
        # 2: find_udm(name: str, strmem_flags: int=0) -> int
        
        BTF_STRUCT,BTF_UNION: Find an udt member by name 
                
        :returns: the index of the found member or -1
        
        """
        ...
    def force_tid(self) -> tid_t:
        r"""Get the type tid. Create if it does not exist yet. If the type comes from a base til, the type will be copied to the local til and a new tid will be created for it. (if the type comes from a base til, it does not have a tid yet). If the type comes from the local til, this function is equivalent to get_tid() 
                
        :returns: tid or BADADDR
        """
        ...
    def get_alias_target(self) -> int:
        r"""Get type alias If the type has no alias, return 0. 
                
        """
        ...
    def get_alignment(self) -> int:
        r"""Get type alignment This function returns the effective type alignment. Zero means error. 
                
        """
        ...
    def get_array_details(self, ai: array_type_data_t) -> bool:
        r"""Get the array specific info.
        
        """
        ...
    def get_array_element(self) -> tinfo_t:
        r"""BT_ARRAY: get type of array element. See also get_ptrarr_object()
        
        """
        ...
    def get_array_nelems(self) -> int:
        r"""BT_ARRAY: get number of elements (-1 means error)
        
        """
        ...
    def get_attr(self, key: str, all_attrs: bool = True) -> Any:
        r"""Get a type attribute.
        
        """
        ...
    def get_attrs(self, tav: type_attrs_t, all_attrs: bool = False) -> bool:
        r"""Get type attributes (all_attrs: include attributes of referenced types, if any)
        
        """
        ...
    def get_bit_buckets(self, buckets: range64vec_t) -> bool:
        r"""::BT_STRUCT: get bit buckets Bit buckets are used to layout bitfields 
                
        :returns: false if wrong type was passed
        """
        ...
    def get_bitfield_details(self, bi: bitfield_type_data_t) -> bool:
        r"""Get the bitfield specific info.
        
        """
        ...
    def get_by_edm_name(self, mname: str, til: til_t = None) -> ssize_t:
        r"""Retrieve enum tinfo using enum member name 
                
        :param mname: enum type member name
        :param til: type library
        :returns: member index, otherwise returns -1. If the function fails, THIS object becomes empty.
        """
        ...
    def get_declalign(self) -> uchar:
        r"""Get declared alignment of the type.
        
        """
        ...
    def get_decltype(self) -> type_t:
        r"""Get declared type (without resolving type references; they are returned as is). Obviously this is a very fast function and should be used instead of get_realtype() if possible. Please note that for typerefs this function will return BTF_TYPEDEF. To determine if a typeref is a typedef, use is_typedef() 
                
        """
        ...
    def get_edm(self, args: Any) -> Any:
        r"""Retrieve an enumerator with either the specified name
        or the specified index, in the specified tinfo_t object.
        
        This function has the following signatures:
        
            1. get_edm(index: int)
            2. get_edm(name: str)
        
        :param index: an enumerator index (1st form).
        :param name: an enumerator name (2nd form).
        :returns: a tuple (int, edm_t), or (-1, None) if member not found
        """
        ...
    def get_edm_by_name(self, mname: str, til: til_t = None) -> ssize_t:
        r"""Retrieve enum tinfo using enum member name 
                
        :param mname: enum type member name
        :param til: type library
        :returns: member index, otherwise returns -1. If the function fails, THIS object becomes empty.
        """
        ...
    def get_edm_by_tid(self, edm: edm_t, tid: tid_t) -> ssize_t:
        ...
    def get_edm_by_value(self, value: int, bmask: int = 18446744073709551615, serial: int = 0) -> Any:
        r"""Retrieve an enumerator with the specified value,
        in the specified tinfo_t object.
        
        :param value: the enumerator value
        :returns: a tuple (int, edm_t), or (-1, None) if member not found
        """
        ...
    def get_edm_tid(self, idx: size_t) -> tid_t:
        r"""Get enum member TID 
                
        :param idx: enum member index
        :returns: tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.
        """
        ...
    def get_enum_base_type(self) -> type_t:
        r"""Get enum base type (convert enum to integer type) Returns BT_UNK if failed to convert 
                
        """
        ...
    def get_enum_details(self, ei: enum_type_data_t) -> bool:
        r"""Get the enum specific info.
        
        """
        ...
    def get_enum_nmembers(self) -> int:
        r"""Get number of enum members. 
                
        :returns: BADSIZE if error
        """
        ...
    def get_enum_radix(self) -> int:
        r"""Get enum constant radix 
                
        :returns: radix or 1 for BTE_CHAR enum_type_data_t::get_enum_radix()
        """
        ...
    def get_enum_repr(self, repr: value_repr_t) -> tinfo_code_t:
        r"""Set the representation of enum members. 
                
        :param repr: value_repr_t
        """
        ...
    def get_enum_width(self) -> int:
        r"""Get enum width 
                
        :returns: width of enum base type in bytes, 0 - unspecified, or -1 enum_type_data_t::calc_nbytes()
        """
        ...
    def get_final_element(self) -> tinfo_t:
        r"""repeat recursively: if an array, return the type of its element; else return the type itself.
        
        """
        ...
    def get_final_ordinal(self) -> int:
        r"""Get final type ordinal (0 if none)
        
        """
        ...
    def get_final_type_name(self) -> bool:
        r"""Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
                
        :returns: the name of the last type in the chain (TYPEn). if there is no chain, returns TYPE1
        """
        ...
    def get_forward_type(self) -> type_t:
        r"""Get type of a forward declaration. For a forward declaration this function returns its base type. In other cases it returns BT_UNK 
                
        """
        ...
    def get_frame_func(self) -> ida_idaapi.ea_t:
        r"""Get function address for the frame.
        
        """
        ...
    def get_func_details(self, fi: func_type_data_t, gtd: gtd_func_t = 0) -> bool:
        r"""Get only the function specific info for this tinfo_t.
        
        """
        ...
    def get_func_frame(self, pfn: func_t) -> bool:
        r"""Create a tinfo_t object for the function frame 
                
        :param pfn: function
        """
        ...
    def get_innermost_member_type(self, bitoffset: uint64) -> tinfo_t:
        r"""Get the innermost member type at the given offset 
                
        :param bitoffset: bit offset into the structure
        :returns: the: innermost member type
        """
        ...
    def get_innermost_udm(self, bitoffset: uint64) -> tinfo_t:
        r"""Get the innermost member at the given offset 
                
        :param bitoffset: bit offset into the structure
        :returns: udt: with the innermost member
        :returns: empty: type if it is not a struct type or OFFSET could not be found
        """
        ...
    def get_methods(self, methods: udtmembervec_t) -> bool:
        r"""BT_COMPLEX: get a list of member functions declared in this udt. 
                
        :returns: false if no member functions exist
        """
        ...
    def get_modifiers(self) -> type_t:
        ...
    def get_named_type(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
            1. get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
        
        # 0: get_named_type(til: const til_t *, name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
        
        Create a tinfo_t object for an existing named type. 
                
        
        # 1: get_named_type(name: str, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true, try_ordinal: bool=true) -> bool
        
        
        """
        ...
    def get_nargs(self) -> int:
        r"""BT_FUNC or BT_PTR BT_FUNC: Calculate number of arguments (-1 - error)
        
        """
        ...
    def get_next_type_name(self) -> bool:
        r"""Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn). 
                
        :returns: the name of the next type in the chain (TYPE2). if there is no chain, returns failure
        """
        ...
    def get_nice_type_name(self) -> bool:
        r"""Get the beautified type name. Get the referenced name and apply regular expressions from goodname.cfg to beautify the name 
                
        """
        ...
    def get_nth_arg(self, n: int) -> tinfo_t:
        r"""BT_FUNC or BT_PTR BT_FUNC: Get type of n-th arg (-1 means return type, see get_rettype())
        
        """
        ...
    def get_numbered_type(self, args: Any) -> bool:
        r"""This function has the following signatures:
        
            0. get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
            1. get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
        
        # 0: get_numbered_type(til: const til_t *, ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
        
        Create a tinfo_t object for an existing ordinal type. 
                
        
        # 1: get_numbered_type(ordinal: int, decl_type: type_t=BTF_TYPEDEF, resolve: bool=true) -> bool
        
        
        """
        ...
    def get_onemember_type(self) -> tinfo_t:
        r"""For objects consisting of one member entirely: return type of the member.
        
        """
        ...
    def get_ordinal(self) -> int:
        r"""Get type ordinal (only if the type was created as a numbered type, 0 if none)
        
        """
        ...
    def get_pointed_object(self) -> tinfo_t:
        r"""BT_PTR: get type of pointed object. If the current type is not a pointer, return empty type info. See also get_ptrarr_object() and remove_pointer() 
                
        """
        ...
    def get_ptr_details(self, pi: ptr_type_data_t) -> bool:
        r"""Get the pointer info.
        
        """
        ...
    def get_ptrarr_object(self) -> tinfo_t:
        r"""BT_PTR & BT_ARRAY: get the pointed object or array element. If the current type is not a pointer or array, return empty type info. 
                
        """
        ...
    def get_ptrarr_objsize(self) -> int:
        r"""BT_PTR & BT_ARRAY: get size of pointed object or array element. On error returns -1
        
        """
        ...
    def get_realtype(self, full: bool = False) -> type_t:
        r"""Get the resolved base type. Deserialization options:
        * if full=true, the referenced type will be deserialized fully, this may not always be desirable (slows down things)
        * if full=false, we just return the base type, the referenced type will be resolved again later if necessary (this may lead to multiple resolvings of the same type) imho full=false is a better approach because it does not perform unnecessary actions just in case. however, in some cases the caller knows that it is very likely that full type info will be required. in those cases full=true makes sense 
        
        
                
        """
        ...
    def get_rettype(self) -> tinfo_t:
        r"""BT_FUNC or BT_PTR BT_FUNC: Get the function's return type
        
        """
        ...
    def get_sign(self) -> type_sign_t:
        r"""Get type sign.
        
        """
        ...
    def get_size(self, p_effalign: uint32 = None, gts_code: int = 0) -> int:
        r"""Get the type size in bytes. 
                
        :param p_effalign: buffer for the alignment value
        :param gts_code: combination of GTS_... constants
        :returns: BADSIZE in case of problems
        """
        ...
    def get_stkvar(self, insn: insn_t, x: op_t, v: int) -> ssize_t:
        r"""Retrieve frame tinfo for a stack variable 
                
        :param insn: the instruction
        :param x: reference to instruction operand, may be nullptr
        :param v: immediate value in the operand (usually x.addr)
        :returns: returns the member index, otherwise returns -1. if the function fails, THIS object becomes empty.
        """
        ...
    def get_stock(self, id: stock_type_id_t) -> tinfo_t:
        r"""Get stock type information. This function can be used to get tinfo_t for some common types. The same tinfo_t will be returned for the same id, thus saving memory and increasing the speed Please note that retrieving the STI_SIZE_T or STI_SSIZE_T stock type, will also have the side-effect of adding that type to the 'idati' TIL, under the well-known name 'size_t' or 'ssize_t' (respectively). The same is valid for STI_COMPLEX64 and STI_COMPLEX64 stock types with names 'complex64_t' and 'complex128_t' (respectively). 
                
        """
        ...
    def get_tid(self) -> tid_t:
        r"""Get the type tid Each type in the local type library has a so-called `tid` associated with it. The tid is used to collect xrefs to the type. The tid is created when the type is created in the local type library and does not change afterwards. It can be passed to xref-related functions instead of the address. 
                
        :returns: tid or BADADDR
        """
        ...
    def get_til(self) -> til_t:
        r"""Get the type library for tinfo_t.
        
        """
        ...
    def get_type_by_tid(self, tid: tid_t) -> bool:
        ...
    def get_type_cmt(self) -> int:
        r"""Get type comment 
                
        :returns: 0-failed, 1-returned regular comment, 2-returned repeatable comment
        """
        ...
    def get_type_name(self) -> bool:
        r"""Does a type refer to a name?. If yes, fill the provided buffer with the type name and return true. Names are returned for numbered types too: either a user-defined nice name or, if a user-provided name does not exist, an ordinal name (like #xx, see create_numbered_type_name()). 
                
        """
        ...
    def get_type_rptcmt(self) -> bool:
        r"""Get type comment only if it is repeatable.
        
        """
        ...
    def get_udm(self, args: Any) -> Any:
        r"""Retrieve a structure/union member with either the specified name
        or the specified index, in the specified tinfo_t object.
        
        This function has the following signatures:
        
            1. get_udm(index: int)
            2. get_udm(name: str)
        
        :param index: a member index (1st form)
        :param name: a member name (2nd form)
        :returns: a tuple (int, udm_t), or (-1, None) if member not found
        """
        ...
    def get_udm_by_offset(self, offset: int) -> Any:
        r"""Retrieve a structure/union member with the specified offset,
        in the specified tinfo_t object.
        
        :param offset: the member offset
        :returns: a tuple (int, udm_t), or (-1, None) if member not found
        """
        ...
    def get_udm_by_tid(self, udm: udm_t, tid: tid_t) -> ssize_t:
        ...
    def get_udm_tid(self, idx: size_t) -> tid_t:
        r"""Get udt member TID 
                
        :param idx: the index of udt the member
        :returns: tid or BADADDR The tid is used to collect xrefs to the member, it can be passed to xref-related functions instead of the address.
        """
        ...
    def get_udt_details(self, udt: udt_type_data_t, gtd: gtd_udt_t = 0) -> bool:
        r"""Get the udt specific info.
        
        """
        ...
    def get_udt_nmembers(self) -> int:
        r"""Get number of udt members. -1-error.
        
        """
        ...
    def get_udt_taudt_bits(self) -> int:
        r"""Get udt_type_data_t::taudt_bits.
        
        """
        ...
    def get_unpadded_size(self) -> int:
        r"""Get the type size in bytes without the final padding, in bytes. For some UDTs get_unpadded_size() != get_size() 
                
        """
        ...
    def has_details(self) -> bool:
        r"""Does this type refer to a nontrivial type?
        
        """
        ...
    def has_union(self) -> bool:
        r"""Has a member of type "union"?
        
        """
        ...
    def has_vftable(self) -> bool:
        r"""Has a vftable?
        
        """
        ...
    def is_aliased(self) -> bool:
        ...
    def is_anonymous_udt(self) -> bool:
        r"""Is an anonymous struct/union? We assume that types with names are anonymous if the name starts with $ 
                
        """
        ...
    def is_arithmetic(self) -> bool:
        r"""is_type_arithmetic(get_realtype())
        
        """
        ...
    def is_array(self) -> bool:
        r"""is_type_array(get_realtype())
        
        """
        ...
    def is_bitfield(self) -> bool:
        r"""is_type_bitfld(get_realtype())
        
        """
        ...
    def is_bitmask_enum(self) -> bool:
        r"""Is bitmask enum? 
                
        :returns: true for bitmask enum and false in other cases enum_type_data_t::is_bf()
        """
        ...
    def is_bool(self) -> bool:
        r"""is_type_bool(get_realtype())
        
        """
        ...
    def is_castable_to(self, target: tinfo_t) -> bool:
        ...
    def is_char(self) -> bool:
        r"""is_type_char(get_realtype())
        
        """
        ...
    def is_complex(self) -> bool:
        r"""is_type_complex(get_realtype())
        
        """
        ...
    def is_const(self) -> bool:
        r"""is_type_const(get_realtype())
        
        """
        ...
    def is_correct(self) -> bool:
        r"""Is the type object correct?. It is possible to create incorrect types. For example, we can define a function that returns an enum and then delete the enum type. If this function returns false, the type should not be used in disassembly. Please note that this function does not verify all involved types: for example, pointers to undefined types are permitted. 
                
        """
        ...
    def is_cpp_struct(self) -> bool:
        r"""Is a c++ object, not simple pod type.
        
        """
        ...
    def is_decl_array(self) -> bool:
        r"""is_type_array(get_decltype())
        
        """
        ...
    def is_decl_bitfield(self) -> bool:
        r"""is_type_bitfld(get_decltype())
        
        """
        ...
    def is_decl_bool(self) -> bool:
        r"""is_type_bool(get_decltype())
        
        """
        ...
    def is_decl_char(self) -> bool:
        r"""is_type_char(get_decltype())
        
        """
        ...
    def is_decl_complex(self) -> bool:
        r"""is_type_complex(get_decltype())
        
        """
        ...
    def is_decl_const(self) -> bool:
        r"""is_type_const(get_decltype())
        
        """
        ...
    def is_decl_double(self) -> bool:
        r"""is_type_double(get_decltype())
        
        """
        ...
    def is_decl_enum(self) -> bool:
        r"""is_type_enum(get_decltype())
        
        """
        ...
    def is_decl_float(self) -> bool:
        r"""is_type_float(get_decltype())
        
        """
        ...
    def is_decl_floating(self) -> bool:
        r"""is_type_floating(get_decltype())
        
        """
        ...
    def is_decl_func(self) -> bool:
        r"""is_type_func(get_decltype())
        
        """
        ...
    def is_decl_int(self) -> bool:
        r"""is_type_int(get_decltype())
        
        """
        ...
    def is_decl_int128(self) -> bool:
        r"""is_type_int128(get_decltype())
        
        """
        ...
    def is_decl_int16(self) -> bool:
        r"""is_type_int16(get_decltype())
        
        """
        ...
    def is_decl_int32(self) -> bool:
        r"""is_type_int32(get_decltype())
        
        """
        ...
    def is_decl_int64(self) -> bool:
        r"""is_type_int64(get_decltype())
        
        """
        ...
    def is_decl_last(self) -> bool:
        r"""is_typeid_last(get_decltype())
        
        """
        ...
    def is_decl_ldouble(self) -> bool:
        r"""is_type_ldouble(get_decltype())
        
        """
        ...
    def is_decl_paf(self) -> bool:
        r"""is_type_paf(get_decltype())
        
        """
        ...
    def is_decl_partial(self) -> bool:
        r"""is_type_partial(get_decltype())
        
        """
        ...
    def is_decl_ptr(self) -> bool:
        r"""is_type_ptr(get_decltype())
        
        """
        ...
    def is_decl_struct(self) -> bool:
        r"""is_type_struct(get_decltype())
        
        """
        ...
    def is_decl_sue(self) -> bool:
        r"""is_type_sue(get_decltype())
        
        """
        ...
    def is_decl_tbyte(self) -> bool:
        r"""is_type_tbyte(get_decltype())
        
        """
        ...
    def is_decl_typedef(self) -> bool:
        r"""is_type_typedef(get_decltype())
        
        """
        ...
    def is_decl_uchar(self) -> bool:
        r"""is_type_uchar(get_decltype())
        
        """
        ...
    def is_decl_udt(self) -> bool:
        r"""is_type_struni(get_decltype())
        
        """
        ...
    def is_decl_uint(self) -> bool:
        r"""is_type_uint(get_decltype())
        
        """
        ...
    def is_decl_uint128(self) -> bool:
        r"""is_type_uint128(get_decltype())
        
        """
        ...
    def is_decl_uint16(self) -> bool:
        r"""is_type_uint16(get_decltype())
        
        """
        ...
    def is_decl_uint32(self) -> bool:
        r"""is_type_uint32(get_decltype())
        
        """
        ...
    def is_decl_uint64(self) -> bool:
        r"""is_type_uint64(get_decltype())
        
        """
        ...
    def is_decl_union(self) -> bool:
        r"""is_type_union(get_decltype())
        
        """
        ...
    def is_decl_unknown(self) -> bool:
        r"""is_type_unknown(get_decltype())
        
        """
        ...
    def is_decl_void(self) -> bool:
        r"""is_type_void(get_decltype())
        
        """
        ...
    def is_decl_volatile(self) -> bool:
        r"""is_type_volatile(get_decltype())
        
        """
        ...
    def is_double(self) -> bool:
        r"""is_type_double(get_realtype())
        
        """
        ...
    def is_empty_enum(self) -> bool:
        r"""Is an empty enum? (has no constants)
        
        """
        ...
    def is_empty_udt(self) -> bool:
        r"""Is an empty struct/union? (has no fields)
        
        """
        ...
    def is_enum(self) -> bool:
        r"""is_type_enum(get_realtype())
        
        """
        ...
    def is_ext_arithmetic(self) -> bool:
        r"""is_type_ext_arithmetic(get_realtype()) 
                
        """
        ...
    def is_ext_integral(self) -> bool:
        r"""is_type_ext_integral(get_realtype())
        
        """
        ...
    def is_fixed_struct(self) -> bool:
        r"""Is a structure with fixed offsets?
        
        """
        ...
    def is_float(self) -> bool:
        r"""is_type_float(get_realtype())
        
        """
        ...
    def is_floating(self) -> bool:
        r"""is_type_floating(get_realtype())
        
        """
        ...
    def is_forward_decl(self) -> bool:
        r"""Is this a forward declaration?. Forward declarations are placeholders: the type definition does not exist 
                
        """
        ...
    def is_forward_enum(self) -> bool:
        ...
    def is_forward_struct(self) -> bool:
        ...
    def is_forward_union(self) -> bool:
        ...
    def is_frame(self) -> bool:
        r"""Is a function frame?
        
        """
        ...
    def is_from_subtil(self) -> bool:
        r"""Was the named type found in some base type library (not the top level type library)?. If yes, it usually means that the type comes from some loaded type library, not the local type library for the database 
                
        """
        ...
    def is_func(self) -> bool:
        r"""is_type_func(get_realtype())
        
        """
        ...
    def is_funcptr(self) -> bool:
        r"""Is this pointer to a function?
        
        """
        ...
    def is_high_func(self) -> bool:
        r"""BT_FUNC: Is high level type?
        
        """
        ...
    def is_int(self) -> bool:
        r"""is_type_int(get_realtype())
        
        """
        ...
    def is_int128(self) -> bool:
        r"""is_type_int128(get_realtype())
        
        """
        ...
    def is_int16(self) -> bool:
        r"""is_type_int16(get_realtype())
        
        """
        ...
    def is_int32(self) -> bool:
        r"""is_type_int32(get_realtype())
        
        """
        ...
    def is_int64(self) -> bool:
        r"""is_type_int64(get_realtype())
        
        """
        ...
    def is_integral(self) -> bool:
        r"""is_type_integral(get_realtype())
        
        """
        ...
    def is_ldouble(self) -> bool:
        r"""is_type_ldouble(get_realtype())
        
        """
        ...
    def is_manually_castable_to(self, target: tinfo_t) -> bool:
        ...
    def is_msstruct(self) -> bool:
        r"""Is gcc msstruct attribute applied.
        
        """
        ...
    def is_one_fpval(self) -> bool:
        r"""Floating value or an object consisting of one floating member entirely.
        
        """
        ...
    def is_paf(self) -> bool:
        r"""is_type_paf(get_realtype())
        
        """
        ...
    def is_partial(self) -> bool:
        r"""is_type_partial(get_realtype())
        
        """
        ...
    def is_ptr(self) -> bool:
        r"""is_type_ptr(get_realtype())
        
        """
        ...
    def is_ptr_or_array(self) -> bool:
        r"""is_type_ptr_or_array(get_realtype())
        
        """
        ...
    def is_punknown(self) -> bool:
        r"""Is "_UNKNOWN *"?. This function does not check the pointer attributes and type modifiers.
        
        """
        ...
    def is_purging_cc(self) -> bool:
        r"""is_purging_cc(get_cc())
        
        """
        ...
    def is_pvoid(self) -> bool:
        r"""Is "void *"?. This function does not check the pointer attributes and type modifiers.
        
        """
        ...
    def is_scalar(self) -> bool:
        r"""Does the type represent a single number?
        
        """
        ...
    def is_shifted_ptr(self) -> bool:
        r"""Is a shifted pointer?
        
        """
        ...
    def is_signed(self) -> bool:
        r"""Is this a signed type?
        
        """
        ...
    def is_small_udt(self) -> bool:
        r"""Is a small udt? (can fit a register or a pair of registers)
        
        """
        ...
    def is_sse_type(self) -> bool:
        r"""Is a SSE vector type?
        
        """
        ...
    def is_struct(self) -> bool:
        r"""is_type_struct(get_realtype())
        
        """
        ...
    def is_sue(self) -> bool:
        r"""is_type_sue(get_realtype())
        
        """
        ...
    def is_tbyte(self) -> bool:
        r"""is_type_tbyte(get_realtype())
        
        """
        ...
    def is_tuple(self) -> bool:
        r"""Is a tuple?
        
        """
        ...
    def is_typedef(self) -> bool:
        r"""Is this a typedef?. This function will return true for a reference to a local type that is declared as a typedef. 
                
        """
        ...
    def is_typeref(self) -> bool:
        r"""Is this type a type reference?.
        
        """
        ...
    def is_uchar(self) -> bool:
        r"""is_type_uchar(get_realtype())
        
        """
        ...
    def is_udm_by_til(self, idx: size_t) -> bool:
        r"""Was the member created due to the type system 
                
        :param idx: index of the member
        """
        ...
    def is_udt(self) -> bool:
        r"""is_type_struni(get_realtype())
        
        """
        ...
    def is_uint(self) -> bool:
        r"""is_type_uint(get_realtype())
        
        """
        ...
    def is_uint128(self) -> bool:
        r"""is_type_uint128(get_realtype())
        
        """
        ...
    def is_uint16(self) -> bool:
        r"""is_type_uint16(get_realtype())
        
        """
        ...
    def is_uint32(self) -> bool:
        r"""is_type_uint32(get_realtype())
        
        """
        ...
    def is_uint64(self) -> bool:
        r"""is_type_uint64(get_realtype())
        
        """
        ...
    def is_unaligned_struct(self) -> bool:
        r"""Is an unaligned struct.
        
        """
        ...
    def is_union(self) -> bool:
        r"""is_type_union(get_realtype())
        
        """
        ...
    def is_unknown(self) -> bool:
        r"""is_type_unknown(get_realtype())
        
        """
        ...
    def is_unsigned(self) -> bool:
        r"""Is this an unsigned type?
        
        """
        ...
    def is_user_cc(self) -> bool:
        r"""is_user_cc(get_cc())
        
        """
        ...
    def is_vararg_cc(self) -> bool:
        r"""is_vararg_cc(get_cc())
        
        """
        ...
    def is_varmember(self) -> bool:
        r"""Can the type be of a variable struct member? This function checks for: is_array() && array.nelems==0 Such a member can be only the very last member of a structure 
                
        """
        ...
    def is_varstruct(self) -> bool:
        r"""Is a variable-size structure?
        
        """
        ...
    def is_vftable(self) -> bool:
        r"""Is a vftable type?
        
        """
        ...
    def is_void(self) -> bool:
        r"""is_type_void(get_realtype())
        
        """
        ...
    def is_volatile(self) -> bool:
        r"""is_type_volatile(get_realtype())
        
        """
        ...
    def is_well_defined(self) -> bool:
        r"""!(empty()) && !(is_decl_partial()) && !(is_punknown())
        
        """
        ...
    def iter_enum(self) -> Any:
        r"""Iterate on the members composing this enumeration.
        
        Example:
        
            til = ida_typeinf.get_idati()
            tif = til.get_named_type("my_enum")
            for edm in tif.iter_enum():
                print(f"{edm.name} = {edm.value}")
        
        Will raise an exception if this type is not an enumeration
        
        :returns: a edm_t-producing generator
        """
        ...
    def iter_func(self) -> Any:
        r"""Iterate on the arguments contained in this function prototype
        
        Example:
        
            address = ...
            func = ida_funcs.get_func(address)
            func_type = func.prototype
            for arg in func_type.iter_func():
                print(f"{arg.name}, of type {arg.type}")
        
        Will raise an exception if this type is not a function
        
        :returns: a funcarg_t-producing generator
        """
        ...
    def iter_struct(self) -> Any:
        r"""Iterate on the members composing this structure.
        
        Example:
        
            til = ida_typeinf.get_idati()
            tif = til.get_named_type("my_struc")
            for udm in tif.iter_struct():
                print(f"{udm.name} at bit offset {udm.offset}")
        
        Will raise an exception if this type is not a structure.
        
        :returns: a udm_t-producing generator
        """
        ...
    def iter_udt(self) -> Any:
        r"""Iterate on the members composing this structure, or union.
        
        Example:
        
            til = ida_typeinf.get_idati()
            tif = til.get_named_type("my_type")
            for udm in tif.iter_udt():
                print(f"{udm.name} at bit offset {udm.offset} with type {udm.type}")
        
        Will raise an exception if this type is not a structure, or union
        
        :returns: a udm_t-producing generator
        """
        ...
    def iter_union(self) -> Any:
        r"""Iterate on the members composing this union.
        
        Example:
        
            til = ida_typeinf.get_idati()
            tif = til.get_named_type("my_union")
            for udm in tif.iter_union():
                print(f"{udm.name}, with type {udm.type}")
        
        Will raise an exception if this type is not a union.
        
        :returns: a udm_t-producing generator
        """
        ...
    def parse(self, decl: str, til: til_t = None, pt_flags: int = 0) -> bool:
        r"""Convenience function to parse a string with a type declaration 
                
        :param decl: a type declaration
        :param til: type library to use
        :param pt_flags: combination of Type parsing flags bits
        """
        ...
    def present(self) -> bool:
        r"""Is the type really present? (not a reference to a missing type, for example)
        
        """
        ...
    def read_bitfield_value(self, v: uint64, bitoff: int) -> uint64:
        ...
    def remove_ptr_or_array(self) -> bool:
        r"""Replace the current type with the ptr obj or array element. This function performs one of the following conversions:
        * type[] => type
        * type* => type If the conversion is performed successfully, return true 
        
        
                
        """
        ...
    def rename_edm(self, idx: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Rename a enum member 
                
        :param idx: index in edmvec_t
        :param name: new name
        :param etf_flags: etf_flag_t ETF_FORCENAME may be used in case of TERR_ALIEN_NAME
        """
        ...
    def rename_funcarg(self, index: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Rename a function argument. The new name must be unique. 
                
        :param index: argument index in the function array
        :param name: new name
        :param etf_flags: etf_flag_t
        """
        ...
    def rename_type(self, name: str, ntf_flags: int = 0) -> tinfo_code_t:
        r"""Rename a type 
                
        :param name: new type name
        :param ntf_flags: Flags for named types
        """
        ...
    def rename_udm(self, index: size_t, name: str, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Rename a structure/union member. The new name must be unique. 
                
        """
        ...
    def requires_qualifier(self, name: str, offset: uint64) -> bool:
        r"""Requires full qualifier? (name is not unique) 
                
        :param name: field name
        :param offset: field offset in bits
        :returns: if the name is not unique, returns true
        """
        ...
    def save_type(self, args: Any) -> tinfo_code_t:
        ...
    def serialize(self, args: Any) -> Any:
        r"""Serialize tinfo_t object into a type string.
        
        """
        ...
    def set_attr(self, ta: type_attr_t, may_overwrite: bool = True) -> bool:
        r"""Set a type attribute. If necessary, a new typid will be created.
        
        """
        ...
    def set_attrs(self, tav: type_attrs_t) -> bool:
        r"""Set type attributes. If necessary, a new typid will be created. this function modifies tav! (returns old attributes, if any) 
                
        :returns: false: bad attributes
        """
        ...
    def set_const(self) -> None:
        ...
    def set_declalign(self, declalign: uchar) -> bool:
        ...
    def set_edm_cmt(self, idx: size_t, cmt: str, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set a comment for an enum member. Such comments are always considered as repeatable. 
                
        :param idx: index in edmvec_t
        :param cmt: comment
        :param etf_flags: etf_flag_t
        """
        ...
    def set_enum_is_bitmask(self, args: Any) -> tinfo_code_t:
        ...
    def set_enum_radix(self, radix: int, sign: bool, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set enum radix to display constants 
                
        :param radix: radix 2, 4, 8, 16, with the special case 1 to display as character
        :param sign: display as signed or unsigned
        :param etf_flags: etf_flag_t
        """
        ...
    def set_enum_repr(self, repr: value_repr_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set the representation of enum members. 
                
        :param repr: value_repr_t
        :param etf_flags: etf_flag_t
        """
        ...
    def set_enum_sign(self, sign: type_sign_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set enum sign 
                
        :param sign: type_sign_t
        :param etf_flags: etf_flag_t
        """
        ...
    def set_enum_width(self, nbytes: int, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set the width of enum base type 
                
        :param nbytes: width of enum base type, allowed values: 0 (unspecified),1,2,4,8,16,32,64
        :param etf_flags: etf_flag_t
        """
        ...
    def set_fixed_struct(self, on: bool = True) -> tinfo_code_t:
        r"""Declare struct member offsets as fixed. For such structures, IDA will not recalculate the member offsets. If a member does not fit into its place anymore, it will be deleted. This function works only with structures (not unions). 
                
        """
        ...
    def set_func_cc(self, cc: callcnv_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set function calling convention.
        
        """
        ...
    def set_func_retloc(self, argloc: argloc_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set location of function return value. 
                
        :param argloc: new location for the return value
        :param etf_flags: etf_flag_t
        :returns: tinfo_code_t
        """
        ...
    def set_func_rettype(self, tif: tinfo_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set function return type . 
                
        :param tif: new type for the return type
        :param etf_flags: etf_flag_t
        :returns: tinfo_code_t
        """
        ...
    def set_funcarg_loc(self, index: size_t, argloc: argloc_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set location of a function argument. 
                
        :param index: argument index in the function array
        :param argloc: new location for the argument
        :param etf_flags: etf_flag_t
        :returns: tinfo_code_t
        """
        ...
    def set_funcarg_type(self, index: size_t, tif: tinfo_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set type of a function argument. 
                
        :param index: argument index in the function array
        :param tif: new type for the argument
        :param etf_flags: etf_flag_t
        :returns: tinfo_code_t
        """
        ...
    def set_methods(self, methods: udtmembervec_t) -> bool:
        r"""BT_COMPLEX: set the list of member functions. This function consumes 'methods' (makes it empty). 
                
        :returns: false if this type is not a udt, or if the given list is empty
        """
        ...
    def set_modifiers(self, mod: type_t) -> None:
        ...
    def set_named_type(self, til: til_t, name: str, ntf_flags: int = 0) -> tinfo_code_t:
        ...
    def set_numbered_type(self, til: til_t, ord: int, ntf_flags: int = 0, name: str = None) -> tinfo_code_t:
        ...
    def set_struct_size(self, new_size: size_t) -> tinfo_code_t:
        r"""Explicitly specify the struct size. This function works only with fixed structures. The new struct size can be equal or higher the unpadded struct size (IOW, all existing members should fit into the specified size). 
                
        :param new_size: new structure size in bytes
        """
        ...
    def set_symbol_type(self, til: til_t, name: str, ntf_flags: int = 0) -> tinfo_code_t:
        ...
    def set_tuple(self, on: bool = True) -> tinfo_code_t:
        r"""Declare struct as a tuple. Currently, tuples in IDA behave the same way as structures but they are returned in a different manner from functions. Also, 2 different tuples having the same members are considered to be equal. This function works only with structures (not unions). 
                
        """
        ...
    def set_type_alias(self, dest_ord: int) -> bool:
        r"""Set type alias Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
                
        """
        ...
    def set_type_alignment(self, declalign: uchar, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set type alignment.
        
        """
        ...
    def set_type_cmt(self, cmt: str, is_regcmt: bool = False, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set type comment This function works only for non-trivial types 
                
        """
        ...
    def set_udm_by_til(self, idx: size_t, on: bool = True, etf_flags: uint = 0) -> tinfo_code_t:
        r"""The member is created due to the type system 
                
        :param idx: index of the member
        :param etf_flags: etf_flag_t
        """
        ...
    def set_udm_cmt(self, index: size_t, cmt: str, is_regcmt: bool = False, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set a comment for a structure/union member. A member may have just one comment, and it is either repeatable or regular. 
                
        """
        ...
    def set_udm_repr(self, index: size_t, repr: value_repr_t, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set the representation of a structure/union member.
        
        """
        ...
    def set_udm_type(self, index: size_t, tif: tinfo_t, etf_flags: uint = 0, repr: value_repr_t = None) -> tinfo_code_t:
        r"""Set type of a structure/union member. 
                
        :param index: member index in the udm array
        :param tif: new type for the member
        :param etf_flags: etf_flag_t
        :param repr: new representation for the member (optional)
        :returns: tinfo_code_t
        """
        ...
    def set_udt_alignment(self, sda: int, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set declared structure alignment (sda) This alignment supersedes the alignment returned by get_declalign() and is really used when calculating the struct layout. However, the effective structure alignment may differ from `sda` because of packing. The type editing functions (they accept etf_flags) may overwrite this attribute. 
                
        """
        ...
    def set_udt_pack(self, pack: int, etf_flags: uint = 0) -> tinfo_code_t:
        r"""Set structure packing. The value controls how little a structure member alignment can be. Example: if pack=1, then it is possible to align a double to a byte. __attribute__((aligned(1))) double x; However, if pack=3, a double will be aligned to 8 (2**3) even if requested to be aligned to a byte. pack==0 will have the same effect. The type editing functions (they accept etf_flags) may overwrite this attribute. 
                
        """
        ...
    def set_volatile(self) -> None:
        ...
    def swap(self, r: tinfo_t) -> None:
        r"""Assign this = r and r = this.
        
        """
        ...
    def write_bitfield_value(self, dst: uint64, v: uint64, bitoff: int) -> uint64:
        ...

class tinfo_visitor_t:
    @property
    def state(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, s: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply_to(self, tif: tinfo_t, out: type_mods_t = None, name: str = None, cmt: str = None) -> int:
        r"""Call this function to initiate the traversal.
        
        """
        ...
    def prune_now(self) -> None:
        r"""To refuse to visit children of the current type, use this:
        
        """
        ...
    def visit_type(self, out: type_mods_t, tif: tinfo_t, name: str, cmt: str) -> int:
        r"""Visit a subtype. this function must be implemented in the derived class. it may optionally fill out with the new type info. this can be used to modify types (in this case the 'out' argument of apply_to() may not be nullptr) return 0 to continue the traversal. return !=0 to stop the traversal. 
                
        """
        ...

class tiplace_t(place_t):
    @property
    def cursor(self) -> Any: ...
    @property
    def lnnum(self) -> Any: ...
    @property
    def ordinal(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def adjust(self, ud: void) -> None:
        r"""Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def as_idaplace_t(self, p: place_t) -> idaplace_t:
        ...
    def as_simpleline_place_t(self, p: place_t) -> simpleline_place_t:
        ...
    def as_tiplace_t(self, p: place_t) -> tiplace_t:
        ...
    def beginning(self, ud: void) -> bool:
        r"""Are we at the first displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the first displayable object
        """
        ...
    def calc_udm_offset(self, ud: void, p_udmidx: ssize_t = None, p_bitoff: int = None) -> uint64:
        r"""for structs: calculate the offset that corresponds to the tiplace. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param p_udmidx: place to return the index of the current udt member, if any. if there is no member at the current offset, return -1
        :param p_bitoff: place to return the bit offset of the item from the beginning of the bit bucket if there no bitfields, return -1
        :returns: the current offset or uint64(-1)
        """
        ...
    def clone(self) -> place_t:
        r"""Clone the location. 
                
        :returns: a pointer to a copy of the current location in dynamic memory
        """
        ...
    def compare(self, t2: place_t) -> int:
        r"""Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        """
        ...
    def compare2(self, t2: place_t, arg3: void) -> int:
        r"""Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
                
        :param t2: the place to compare this one to.
        :returns: -1: if the current location is less than 't2'
        :returns: 0: if the current location is equal to than 't2'
        :returns: 1: if the current location is greater than 't2'
        """
        ...
    def copyfrom(self, _from: place_t) -> None:
        r"""Copy the specified location object to the current object.
        
        """
        ...
    def deserialize(self, _in: bytevec_t) -> bool:
        r"""De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
                
        :returns: whether de-serialization was successful
        """
        ...
    def ending(self, ud: void) -> bool:
        r"""Are we at the last displayable object?. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: true if the current location points to the last displayable object
        """
        ...
    def enter(self, arg2: uint32) -> place_t:
        r"""Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
                
        :returns: a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it.
        """
        ...
    def equals(self, t2: place_t, ud: void) -> bool:
        r"""Compare two places for equality, ignoring line numbers (lnnum). This is semantically different than `compare2`, although by default it is implemented in terms of it for backwards-compatibility. `compare2` implements a three-way comparison to see if two places *sort* less than, equal to, or grater than. This method actually looks for equality. Thus, `t1->equals(t2, ud)` implies `t1->compare2(t2, ud) == 0`, but the reverse is not always true. An example of this is for adjustable places that are sensitive to the x-cursor position, and need to compare differently as a result.
        
        :returns: true if the two places match / are equal.
        """
        ...
    def fill_type_ref(self, out: til_type_ref_t, ud: void) -> bool:
        r"""fill the type information for use in actions 
                
        :param out: pointer to storage
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def generate(self, ud: Any, maxsize: int) -> Any:
        r"""Generate text lines for the current location.
        
        :param ud: The user data object
        :param maxsize: The maximum number of lines to generate
        :returns: a tuple (lines-of-text, default-line-number, prefix-color, background-color)
        """
        ...
    def get_kind(self, ud: void) -> type_t:
        r"""get the kind of type this place represents 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK
        """
        ...
    def id(self) -> int:
        r"""Get the place's ID (i.e., the value returned by register_place_class()) 
                
        :returns: the id
        """
        ...
    def is_footer(self) -> bool:
        ...
    def is_header(self) -> bool:
        ...
    def is_index(self) -> bool:
        ...
    def leave(self, arg2: int) -> None:
        r"""Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
                
        """
        ...
    def makeplace(self, ud: void, x: int, lnnum: int) -> place_t:
        r"""Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param x: number to map
        :param lnnum: line number to initialize 'lnnum'
        :returns: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        ...
    def name(self) -> str:
        r"""Get this place type name. All instances of a given class must return the same string. 
                
        :returns: the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t".
        """
        ...
    def next(self, ud: void) -> bool:
        r"""Move to the next displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def prev(self, ud: void) -> bool:
        r"""Move to the previous displayable location. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :returns: success
        """
        ...
    def rebase(self, arg2: segm_move_infos_t) -> bool:
        r"""Rebase the place instance 
                
        :returns: true if place was rebased, false otherwise
        """
        ...
    def reset(self) -> None:
        ...
    def serialize(self) -> None:
        r"""Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
                
        """
        ...
    def set_footer(self) -> None:
        ...
    def set_header(self) -> None:
        ...
    def set_index_by_offset(self, ud: void, offset: uint64) -> None:
        r"""for structs: calculate the index that corresponds to the offset and set it. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        :param offset: offset of udt member
        """
        ...
    def toea(self) -> ida_idaapi.ea_t:
        r"""Map the location to an ea_t. 
                
        :returns: the corresponding ea_t, or BADADDR;
        """
        ...
    def touval(self, ud: void) -> int:
        r"""Map the location to a number. This mapping is used to draw the vertical scrollbar. 
                
        :param ud: pointer to user-defined context data. Is supplied by linearray_t
        """
        ...
    def valid_ord(self) -> bool:
        ...

class treeloc_t:
    @property
    def ea(self) -> Any: ...
    @property
    def itp(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: treeloc_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: treeloc_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class try_handler_t(rangevec_t, rangevec_base_t):
    @property
    def disp(self) -> Any: ...
    @property
    def fpreg(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tryblk_t(rangevec_t, rangevec_base_t):
    @property
    def level(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: rangevec_base_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> range_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: rangevec_base_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: range_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: range_t) -> bool:
        ...
    def append(self, x: range_t) -> None:
        ...
    def at(self, _idx: size_t) -> range_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def cpp(self) -> catchvec_t:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: rangevec_base_t) -> None:
        ...
    def extract(self) -> range_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def get_kind(self) -> uchar:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: range_t) -> bool:
        ...
    def inject(self, s: range_t, len: size_t) -> None:
        ...
    def insert(self, it: range_t, x: range_t) -> iterator:
        ...
    def is_cpp(self) -> bool:
        ...
    def is_seh(self) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> range_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def seh(self) -> seh_t:
        ...
    def set_cpp(self) -> catchvec_t:
        ...
    def set_seh(self) -> seh_t:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: rangevec_base_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class tryblks_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: tryblks_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> tryblk_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: tryblks_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: tryblk_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: tryblk_t) -> bool:
        ...
    def append(self, x: tryblk_t) -> None:
        ...
    def at(self, _idx: size_t) -> tryblk_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: tryblks_t) -> None:
        ...
    def extract(self) -> tryblk_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: tryblk_t) -> bool:
        ...
    def inject(self, s: tryblk_t, len: size_t) -> None:
        ...
    def insert(self, it: tryblk_t, x: tryblk_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> tryblk_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: tryblks_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class twinline_t:
    @property
    def at(self) -> Any: ...
    @property
    def bg_color(self) -> Any: ...
    @property
    def is_default(self) -> Any: ...
    @property
    def line(self) -> Any: ...
    @property
    def prefix_color(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class twinpos_t:
    @property
    def at(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, t: place_t = None, x0: int = 0) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def place(self, view: Any) -> Any:
        ...
    def place_as_idaplace_t(self) -> Any:
        ...
    def place_as_simpleline_place_t(self) -> Any:
        ...
    def place_as_tiplace_t(self) -> Any:
        ...

class type_attr_t:
    @property
    def key(self) -> Any: ...
    @property
    def value(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: type_attr_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: type_attr_t) -> bool:
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class type_attrs_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> type_attr_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: type_attr_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: type_attr_t) -> None:
        ...
    def at(self, _idx: size_t) -> type_attr_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: type_attrs_t) -> None:
        ...
    def extract(self) -> type_attr_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: type_attr_t, len: size_t) -> None:
        ...
    def insert(self, it: type_attr_t, x: type_attr_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> type_attr_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: type_attrs_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class type_mods_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def has_cmt(self) -> bool:
        ...
    def has_info(self) -> bool:
        ...
    def has_name(self) -> bool:
        ...
    def has_type(self) -> bool:
        ...
    def is_rptcmt(self) -> bool:
        ...
    def set_new_cmt(self, c: str, rptcmt: bool) -> None:
        ...
    def set_new_name(self, n: str) -> None:
        ...
    def set_new_type(self, t: tinfo_t) -> None:
        r"""The visit_type() function may optionally save the modified type info. Use the following functions for that. The new name and comment will be applied only if the current tinfo element has storage for them. 
                
        """
        ...

class typedef_type_data_t:
    @property
    def is_ordref(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def ordinal(self) -> Any: ...
    @property
    def resolve(self) -> Any: ...
    @property
    def til(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def swap(self, r: typedef_type_data_t) -> None:
        ...

class uchar_array:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: size_t) -> uchar:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nelements: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, index: size_t, value: uchar) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cast(self) -> uchar:
        ...
    def frompointer(self, t: uchar) -> uchar_array:
        ...

class uchar_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: uchar) -> None:
        ...
    def cast(self) -> uchar:
        ...
    def frompointer(self, t: uchar) -> uchar_pointer:
        ...
    def value(self) -> uchar:
        ...

class udc_filter_t(microcode_filter_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply(self, cdg: codegen_t) -> merror_t:
        r"""generate microcode for an instruction 
                
        :returns: MERR_... code: MERR_OK - user-defined microcode generated, go to the next instruction MERR_INSN - not generated - the caller should try the standard way else - error
        """
        ...
    def cleanup(self) -> None:
        r"""Cleanup the filter This function properly clears type information associated to this filter. 
                
        """
        ...
    def empty(self) -> bool:
        ...
    def init(self, decl: str) -> bool:
        ...
    def install(self) -> None:
        ...
    def match(self, cdg: codegen_t) -> bool:
        r"""return true if the filter object should be applied to given instruction
        
        """
        ...
    def remove(self) -> bool:
        ...

class udcall_map_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: udcall_map_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: udcall_map_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class udcall_t:
    @property
    def name(self) -> Any: ...
    @property
    def tif(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udcall_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: udcall_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: udcall_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: udcall_t) -> bool:
        ...
    def __lt__(self, r: udcall_t) -> bool:
        ...
    def __ne__(self, r: udcall_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: udcall_t) -> int:
        ...
    def empty(self) -> bool:
        ...

class udm_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def effalign(self) -> Any: ...
    @property
    def fda(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def offset(self) -> Any: ...
    @property
    def repr(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def tafld_bits(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udm_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        r"""Create a structure/union member, with the specified name and type.
        
        This constructor has the following signatures:
        
            1. udm_t(udm: udm_t)
            2. udm_t(name: str, type, offset: int)
        
        The 'type' descriptor, can be one of:
        
        * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
        * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
        * str: a C type declaration
        
        If an input argument is incorrect, the constructor may raise an exception
        The size will be computed automatically.
        
        :param udm: a source udm_t
        :param name: a valid member name. Must not be empty.
        :param type: the member type
        :param offset: the member offset in bits. It is the caller's responsibility
               to specify correct offsets.
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: udm_t) -> bool:
        ...
    def __ne__(self, r: udm_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> uint64:
        ...
    def can_be_dtor(self) -> bool:
        ...
    def can_rename(self) -> bool:
        ...
    def clr_baseclass(self) -> None:
        ...
    def clr_method(self) -> None:
        ...
    def clr_unaligned(self) -> None:
        ...
    def clr_vftable(self) -> None:
        ...
    def clr_virtbase(self) -> None:
        ...
    def compare_with(self, r: udm_t, tcflags: int) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> uint64:
        ...
    def is_anonymous_udm(self) -> bool:
        ...
    def is_baseclass(self) -> bool:
        ...
    def is_bitfield(self) -> bool:
        ...
    def is_by_til(self) -> bool:
        ...
    def is_gap(self) -> bool:
        ...
    def is_method(self) -> bool:
        ...
    def is_regcmt(self) -> bool:
        ...
    def is_retaddr(self) -> bool:
        ...
    def is_savregs(self) -> bool:
        ...
    def is_special_member(self) -> bool:
        ...
    def is_unaligned(self) -> bool:
        ...
    def is_vftable(self) -> bool:
        ...
    def is_virtbase(self) -> bool:
        ...
    def is_zero_bitfield(self) -> bool:
        ...
    def set_baseclass(self, on: bool = True) -> None:
        ...
    def set_by_til(self, on: bool = True) -> None:
        ...
    def set_method(self, on: bool = True) -> None:
        ...
    def set_regcmt(self, on: bool = True) -> None:
        ...
    def set_retaddr(self, on: bool = True) -> None:
        ...
    def set_savregs(self, on: bool = True) -> None:
        ...
    def set_unaligned(self, on: bool = True) -> None:
        ...
    def set_value_repr(self, r: value_repr_t) -> None:
        ...
    def set_vftable(self, on: bool = True) -> None:
        ...
    def set_virtbase(self, on: bool = True) -> None:
        ...
    def swap(self, r: udm_t) -> None:
        ...

class udm_visitor_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def visit_udm(self, tid: tid_t, tif: tinfo_t, udt: udt_type_data_t, idx: ssize_t) -> int:
        r""":param tid: udt tid
        :param tif: udt type info (may be nullptr for corrupted idbs)
        :param udt: udt type data (may be nullptr for corrupted idbs)
        :param idx: the index of udt the member (may be -1 if udm was not found)
        """
        ...

class udt_member_t:
    @property
    def cmt(self) -> Any: ...
    @property
    def effalign(self) -> Any: ...
    @property
    def fda(self) -> Any: ...
    @property
    def name(self) -> Any: ...
    @property
    def offset(self) -> Any: ...
    @property
    def repr(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def tafld_bits(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udm_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        r"""Create a structure/union member, with the specified name and type.
        
        This constructor has the following signatures:
        
            1. udm_t(udm: udm_t)
            2. udm_t(name: str, type, offset: int)
        
        The 'type' descriptor, can be one of:
        
        * type_t: if the type is simple (integral/floating/bool). E.g., `BTF_INT`
        * tinfo_t: can handle more complex types (structures, pointers, arrays, ...)
        * str: a C type declaration
        
        If an input argument is incorrect, the constructor may raise an exception
        The size will be computed automatically.
        
        :param udm: a source udm_t
        :param name: a valid member name. Must not be empty.
        :param type: the member type
        :param offset: the member offset in bits. It is the caller's responsibility
               to specify correct offsets.
        """
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, r: udm_t) -> bool:
        ...
    def __ne__(self, r: udm_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def begin(self) -> uint64:
        ...
    def can_be_dtor(self) -> bool:
        ...
    def can_rename(self) -> bool:
        ...
    def clr_baseclass(self) -> None:
        ...
    def clr_method(self) -> None:
        ...
    def clr_unaligned(self) -> None:
        ...
    def clr_vftable(self) -> None:
        ...
    def clr_virtbase(self) -> None:
        ...
    def compare_with(self, r: udm_t, tcflags: int) -> bool:
        ...
    def empty(self) -> bool:
        ...
    def end(self) -> uint64:
        ...
    def is_anonymous_udm(self) -> bool:
        ...
    def is_baseclass(self) -> bool:
        ...
    def is_bitfield(self) -> bool:
        ...
    def is_by_til(self) -> bool:
        ...
    def is_gap(self) -> bool:
        ...
    def is_method(self) -> bool:
        ...
    def is_regcmt(self) -> bool:
        ...
    def is_retaddr(self) -> bool:
        ...
    def is_savregs(self) -> bool:
        ...
    def is_special_member(self) -> bool:
        ...
    def is_unaligned(self) -> bool:
        ...
    def is_vftable(self) -> bool:
        ...
    def is_virtbase(self) -> bool:
        ...
    def is_zero_bitfield(self) -> bool:
        ...
    def set_baseclass(self, on: bool = True) -> None:
        ...
    def set_by_til(self, on: bool = True) -> None:
        ...
    def set_method(self, on: bool = True) -> None:
        ...
    def set_regcmt(self, on: bool = True) -> None:
        ...
    def set_retaddr(self, on: bool = True) -> None:
        ...
    def set_savregs(self, on: bool = True) -> None:
        ...
    def set_unaligned(self, on: bool = True) -> None:
        ...
    def set_value_repr(self, r: value_repr_t) -> None:
        ...
    def set_vftable(self, on: bool = True) -> None:
        ...
    def set_virtbase(self, on: bool = True) -> None:
        ...
    def swap(self, r: udm_t) -> None:
        ...

class udt_type_data_t(udtmembervec_t, udtmembervec_template_t):
    @property
    def effalign(self) -> Any: ...
    @property
    def is_union(self) -> Any: ...
    @property
    def pack(self) -> Any: ...
    @property
    def sda(self) -> Any: ...
    @property
    def taudt_bits(self) -> Any: ...
    @property
    def total_size(self) -> Any: ...
    @property
    def unpadded_size(self) -> Any: ...
    @property
    def version(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> udm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: udm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_member(self, _name: str, _type: tinfo_t, _offset: uint64 = 0) -> udm_t:
        r"""Add a new member to a structure or union. This function just pushes a new member to the back of the structure/union member vector.
        
        :param _name: Member name. Must not be nullptr.
        :param _type: Member type. Must not be empty.
        :param _offset: Member offset in bits. It is the caller's responsibility to specify correct offsets.
        :returns: { Reference to the newly added member }
        """
        ...
    def add_unique(self, x: udm_t) -> bool:
        ...
    def append(self, x: udm_t) -> None:
        ...
    def at(self, _idx: size_t) -> udm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: udtmembervec_template_t) -> None:
        ...
    def extract(self) -> udm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def find_member(self, args: Any) -> ssize_t:
        r"""This function has the following signatures:
        
            0. find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t
            1. find_member(name: str) -> ssize_t
            2. find_member(bit_offset: uint64) -> ssize_t
        
        # 0: find_member(pattern_udm: udm_t *, strmem_flags: int) -> ssize_t
        
        tinfo_t::find_udm 
                
        :returns: the index of the found member or -1
        
        # 1: find_member(name: str) -> ssize_t
        
        
        # 2: find_member(bit_offset: uint64) -> ssize_t
        
        
        """
        ...
    def front(self) -> Any:
        ...
    def get_best_fit_member(self, disp: Any) -> Any:
        r"""Get the member that is most likely referenced by the specified offset.
        
        :param disp: the byte offset
        :returns: a tuple (int, udm_t), or (-1, None) if member not found
        """
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: udm_t) -> bool:
        ...
    def inject(self, s: udm_t, len: size_t) -> None:
        ...
    def insert(self, it: udm_t, x: udm_t) -> iterator:
        ...
    def is_cppobj(self) -> bool:
        ...
    def is_fixed(self) -> bool:
        ...
    def is_last_baseclass(self, idx: size_t) -> bool:
        ...
    def is_msstruct(self) -> bool:
        ...
    def is_tuple(self) -> bool:
        ...
    def is_unaligned(self) -> bool:
        ...
    def is_vftable(self) -> bool:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> udm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def set_fixed(self, on: bool = True) -> None:
        ...
    def set_tuple(self, on: bool = True) -> None:
        ...
    def set_vftable(self, on: bool = True) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: udt_type_data_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class udtmembervec_t(udtmembervec_template_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> udm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: udm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: udm_t) -> bool:
        ...
    def append(self, x: udm_t) -> None:
        ...
    def at(self, _idx: size_t) -> udm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: udtmembervec_template_t) -> None:
        ...
    def extract(self) -> udm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: udm_t) -> bool:
        ...
    def inject(self, s: udm_t, len: size_t) -> None:
        ...
    def insert(self, it: udm_t, x: udm_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> udm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: udtmembervec_template_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class udtmembervec_template_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> udm_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: udtmembervec_template_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: udm_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: udm_t) -> bool:
        ...
    def append(self, x: udm_t) -> None:
        ...
    def at(self, _idx: size_t) -> udm_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: udtmembervec_template_t) -> None:
        ...
    def extract(self) -> udm_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: udm_t) -> bool:
        ...
    def inject(self, s: udm_t, len: size_t) -> None:
        ...
    def insert(self, it: udm_t, x: udm_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> udm_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: udtmembervec_template_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ui_requests_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ui_stroff_applicator_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def apply(self, opnum: size_t, path: intvec_t, top_tif: tinfo_t, spath: str) -> bool:
        r""":param opnum: operand ordinal number, see below
        :param path: path describing the union selection, maybe empty
        :param top_tif: tinfo_t of the selected toplevel UDT
        :param spath: selected path
        """
        ...

class ui_stroff_op_t:
    @property
    def offset(self) -> Any: ...
    @property
    def text(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ui_stroff_op_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: ui_stroff_op_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class ui_stroff_ops_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: ui_stroff_ops_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> ui_stroff_op_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: ui_stroff_ops_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: ui_stroff_op_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: ui_stroff_op_t) -> bool:
        ...
    def append(self, args: Any) -> ui_stroff_op_t:
        ...
    def at(self, i: size_t) -> ui_stroff_op_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: ui_stroff_ops_t) -> None:
        ...
    def extract(self) -> ui_stroff_op_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: ui_stroff_op_t) -> bool:
        ...
    def inject(self, s: ui_stroff_op_t, len: size_t) -> None:
        ...
    def insert(self, it: ui_stroff_op_t, x: ui_stroff_op_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> ui_stroff_op_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: ui_stroff_ops_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class uint16_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: uint16) -> None:
        ...
    def cast(self) -> uint16:
        ...
    def frompointer(self, t: uint16) -> uint16_pointer:
        ...
    def value(self) -> uint16:
        ...

class uint32_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int) -> None:
        ...
    def cast(self) -> uint32:
        ...
    def frompointer(self, t: uint32) -> uint32_pointer:
        ...
    def value(self) -> int:
        ...

class uint64_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: uint64) -> None:
        ...
    def cast(self) -> uint64:
        ...
    def frompointer(self, t: uint64) -> uint64_pointer:
        ...
    def value(self) -> uint64:
        ...

class uint64vec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: uint64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: uint64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uint64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uint64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class uint8_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: uint8) -> None:
        ...
    def cast(self) -> uint8:
        ...
    def frompointer(self, t: uint8) -> uint8_pointer:
        ...
    def value(self) -> uint8:
        ...

class uint_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: uint) -> None:
        ...
    def cast(self) -> uint:
        ...
    def frompointer(self, t: uint) -> uint_pointer:
        ...
    def value(self) -> uint:
        ...

class uintvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: uintvec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: uintvec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uintvec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uintvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class ulonglongvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: uint64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: uint64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uint64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uint64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class user_cmts_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: user_cmts_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: user_cmts_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class user_cmts_t:
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: treeloc_t) -> citem_cmt_t:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def keytype(self) -> Any:
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, args: Any) -> Any:
        ...

class user_defined_prefix_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def get_user_defined_prefix(self, ea: ida_idaapi.ea_t, insn: insn_t, lnnum: int, indent: int, line: str) -> None:
        r"""This callback must be overridden by the derived class. 
                
        :param ea: the current address
        :param insn: the current instruction. if the current item is not an instruction, then insn.itype is zero.
        :param lnnum: number of the current line (each address may have several listing lines for it). 0 means the very first line for the current address.
        :param indent: see explanations for gen_printf()
        :param line: the line to be generated. the line usually contains color tags. this argument can be examined to decide whether to generate the prefix.
        """
        ...

class user_graph_place_t:
    @property
    def node(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...

class user_iflags_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: user_iflags_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: user_iflags_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class user_iflags_t:
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: citem_locator_t) -> int:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def keytype(self, args: Any) -> Any:
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, *args: Any, **kwargs: Any) -> Any:
        r"""int([x]) -> integer
        int(x, base=10) -> integer
        
        Convert a number or string to an integer, or return 0 if no arguments
        are given.  If x is a number, return x.__int__().  For floating-point
        numbers, this truncates towards zero.
        
        If x is not a number or if base is given, then x must be a string,
        bytes, or bytearray instance representing an integer literal in the
        given base.  The literal can be preceded by '+' or '-' and be surrounded
        by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
        Base 0 means to interpret the base from the string as an integer literal.
        >>> int('0b100', base=0)
        4
        """
        ...

class user_labels_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: user_labels_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: user_labels_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class user_labels_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: int) -> _qstring:
        ...
    def size(self) -> int:
        ...

class user_lvar_modifier_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def modify_lvars(self, lvinf: lvar_uservec_t) -> bool:
        r"""Modify lvar settings. Returns: true-modified 
                
        """
        ...

class user_numforms_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: user_numforms_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: user_numforms_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class user_numforms_t:
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: operand_locator_t) -> number_format_t:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def keytype(self, _ea: ida_idaapi.ea_t, _opnum: int) -> Any:
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, _opnum: int = 0) -> Any:
        ...

class user_unions_iterator_t:
    @property
    def x(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, p: user_unions_iterator_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, p: user_unions_iterator_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class user_unions_t:
    keytype: tuple  # (<class 'int'>,)
    def __begin(self, object: Any) -> Any:
        ...
    def __clear(self, object: Any) -> Any:
        ...
    def __contains__(self, key: Any) -> Any:
        r"""Returns true if the specified key exists in the . """
        ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __delitem__(self, key: Any) -> Any:
        r"""Removes the value associated with the provided key. """
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __end(self, object: Any) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __erase(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __find(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __first(self, object: Any) -> Any:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, key: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __insert(self, *args: Any, **kwargs: Any) -> Any:
        ...
    def __iter__(self) -> Any:
        r"""Iterate over dictionary keys. """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __next(self, object: Any) -> Any:
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __second(self, object: Any) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, key: Any, value: Any) -> Any:
        r"""Returns the value associated with the provided key. """
        ...
    def __size(self, object: Any) -> Any:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def at(self, _Keyval: int) -> qvector:
        ...
    def begin(self, args: Any) -> Any:
        ...
    def clear(self) -> Any:
        ...
    def copy(self) -> Any:
        ...
    def end(self, args: Any) -> Any:
        ...
    def erase(self, args: Any) -> Any:
        ...
    def find(self, args: Any) -> Any:
        ...
    def first(self, args: Any) -> Any:
        ...
    def get(self, key: Any, default: Any = None) -> Any:
        ...
    def has_key(self, key: Any) -> Any:
        ...
    def insert(self, args: Any) -> Any:
        ...
    def items(self) -> Any:
        ...
    def iteritems(self) -> Any:
        ...
    def iterkeys(self) -> Any:
        ...
    def itervalues(self) -> Any:
        ...
    def keys(self) -> Any:
        ...
    def next(self, args: Any) -> Any:
        ...
    def pop(self, key: Any) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def popitem(self) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def second(self, args: Any) -> Any:
        ...
    def setdefault(self, key: Any, default: Any = None) -> Any:
        r"""Sets the value associated with the provided key. """
        ...
    def size(self, args: Any) -> Any:
        ...
    def values(self) -> Any:
        ...
    def valuetype(self, args: Any) -> Any:
        ...

class ushort_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: ushort) -> None:
        ...
    def cast(self) -> ushort:
        ...
    def frompointer(self, t: ushort) -> ushort_pointer:
        ...
    def value(self) -> ushort:
        ...

class uval_array:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, index: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, nelements: size_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, index: size_t, value: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def cast(self) -> uval_t:
        ...
    def frompointer(self, t: uval_t) -> uval_array:
        ...

class uval_ivl_ivlset_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, v: ivl_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, v: ivl_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def all_values(self) -> bool:
        ...
    def begin(self, args: Any) -> iterator:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> iterator:
        ...
    def getivl(self, idx: int) -> ivl_t:
        ...
    def lastivl(self) -> ivl_t:
        ...
    def nivls(self) -> int:
        ...
    def qclear(self) -> None:
        ...
    def set_all_values(self) -> None:
        ...
    def single_value(self, args: Any) -> bool:
        ...
    def swap(self, r: uval_ivl_ivlset_t) -> None:
        ...

class uval_ivl_t:
    @property
    def off(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, _off: int, _size: int) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def end(self) -> int:
        ...
    def last(self) -> int:
        ...
    def valid(self) -> bool:
        ...

class uval_pointer:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def assign(self, value: int) -> None:
        ...
    def cast(self) -> uval_t:
        ...
    def frompointer(self, t: uval_t) -> uval_pointer:
        ...
    def value(self) -> int:
        ...

class uvalvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: uint64vec_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> int:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: uint64vec_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: int) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: int) -> bool:
        ...
    def append(self, args: Any) -> int:
        ...
    def at(self, i: size_t) -> int:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: uint64vec_t) -> None:
        ...
    def extract(self) -> int:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def has(self, x: int) -> bool:
        ...
    def inject(self, s: int, len: size_t) -> None:
        ...
    def insert(self, it: iterator, x: int) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> int:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: uint64vec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class valrng_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: valrng_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: valrng_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: valrng_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: valrng_t) -> bool:
        ...
    def __lt__(self, r: valrng_t) -> bool:
        ...
    def __ne__(self, r: valrng_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def all_values(self) -> bool:
        ...
    def compare(self, r: valrng_t) -> int:
        ...
    def cvt_to_cmp(self) -> bool:
        ...
    def cvt_to_single_value(self) -> bool:
        ...
    def dstr(self) -> str:
        ...
    def empty(self) -> bool:
        ...
    def get_size(self) -> int:
        ...
    def has(self, v: uvlr_t) -> bool:
        ...
    def intersect_with(self, r: valrng_t) -> bool:
        ...
    def inverse(self) -> None:
        ...
    def is_unknown(self) -> bool:
        ...
    def max_svalue(self) -> uvlr_t:
        ...
    def max_value(self) -> uvlr_t:
        ...
    def min_svalue(self) -> uvlr_t:
        ...
    def reduce_size(self, new_size: int) -> bool:
        ...
    def set_all(self) -> None:
        ...
    def set_cmp(self, cmp: cmpop_t, _value: uvlr_t) -> None:
        ...
    def set_eq(self, v: uvlr_t) -> None:
        ...
    def set_none(self) -> None:
        ...
    def set_unk(self) -> None:
        ...
    def swap(self, r: valrng_t) -> None:
        ...
    def unite_with(self, r: valrng_t) -> bool:
        ...

class valstr_t:
    @property
    def info(self) -> Any: ...
    @property
    def length(self) -> Any: ...
    @property
    def members(self) -> Any: ...
    @property
    def oneline(self) -> Any: ...
    @property
    def props(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class valstrs_t(valstrvec_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> valstr_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: valstr_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: valstr_t) -> None:
        ...
    def at(self, _idx: size_t) -> valstr_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: valstrvec_t) -> None:
        ...
    def extract(self) -> valstr_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: valstr_t, len: size_t) -> None:
        ...
    def insert(self, it: valstr_t, x: valstr_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> valstr_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: valstrvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class valstrvec_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> valstr_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: valstr_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def append(self, x: valstr_t) -> None:
        ...
    def at(self, _idx: size_t) -> valstr_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: valstrvec_t) -> None:
        ...
    def extract(self) -> valstr_t:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def inject(self, s: valstr_t, len: size_t) -> None:
        ...
    def insert(self, it: valstr_t, x: valstr_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> valstr_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: valstrvec_t) -> None:
        ...
    def truncate(self) -> None:
        ...

class value_repr_t:
    @property
    def ap(self) -> Any: ...
    @property
    def bits(self) -> Any: ...
    @property
    def cd(self) -> Any: ...
    @property
    def delta(self) -> Any: ...
    @property
    def ri(self) -> Any: ...
    @property
    def strtype(self) -> Any: ...
    @property
    def type_ordinal(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> str:
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def from_opinfo(self, flags: flags64_t, afl: aflags_t, opinfo: opinfo_t, _ap: array_parameters_t) -> bool:
        ...
    def get_vtype(self) -> uint64:
        ...
    def has_lzeroes(self) -> bool:
        ...
    def has_tabform(self) -> bool:
        ...
    def init_ap(self, _ap: array_parameters_t) -> None:
        ...
    def is_custom(self) -> bool:
        ...
    def is_enum(self) -> bool:
        ...
    def is_offset(self) -> bool:
        ...
    def is_signed(self) -> bool:
        ...
    def is_strlit(self) -> bool:
        ...
    def is_stroff(self) -> bool:
        ...
    def is_typref(self) -> bool:
        ...
    def parse_value_repr(self, args: Any) -> bool:
        ...
    def set_ap(self, _ap: array_parameters_t) -> None:
        ...
    def set_lzeroes(self, on: bool) -> None:
        ...
    def set_signed(self, on: bool) -> None:
        ...
    def set_tabform(self, on: bool) -> None:
        ...
    def set_vtype(self, vt: uint64) -> None:
        ...
    def swap(self, r: value_repr_t) -> None:
        ...

class var_ref_t:
    @property
    def idx(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: var_ref_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: var_ref_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: var_ref_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: var_ref_t) -> bool:
        ...
    def __lt__(self, r: var_ref_t) -> bool:
        ...
    def __ne__(self, r: var_ref_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: var_ref_t) -> int:
        ...
    def getv(self) -> lvar_t:
        ...

class vc_printer_t(vd_printer_t):
    @property
    def func(self) -> Any: ...
    @property
    def hdrlines(self) -> Any: ...
    @property
    def lastchar(self) -> Any: ...
    @property
    def tmpbuf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, f: cfunc_t) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def oneliner(self) -> bool:
        r"""Are we generating one-line text representation? 
                
        :returns: `true` if the output will occupy one line without line breaks
        """
        ...

class vd_failure_t:
    @property
    def hf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def desc(self) -> str:
        ...

class vd_interr_t(vd_failure_t):
    @property
    def hf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, ea: ida_idaapi.ea_t, buf: str) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def desc(self) -> str:
        ...

class vd_printer_t:
    @property
    def hdrlines(self) -> Any: ...
    @property
    def tmpbuf(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __disown__(self) -> Any:
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class vdloc_t(argloc_t):
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: vdloc_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: vdloc_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: vdloc_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: vdloc_t) -> bool:
        ...
    def __lt__(self, r: vdloc_t) -> bool:
        ...
    def __ne__(self, r: vdloc_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def advance(self, delta: int) -> bool:
        r"""Move the location to point 'delta' bytes further.
        
        """
        ...
    def align_reg_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set register offset to align it to the upper part of _SLOTSIZE.
        
        """
        ...
    def align_stkoff_high(self, size: size_t, _slotsize: size_t) -> None:
        r"""Set stack offset to align to the upper part of _SLOTSIZE.
        
        """
        ...
    def atype(self) -> argloc_type_t:
        r"""Get type (Argument location types)
        
        """
        ...
    def calc_offset(self) -> int:
        r"""Calculate offset that can be used to compare 2 similar arglocs.
        
        """
        ...
    def compare(self, r: vdloc_t) -> int:
        ...
    def consume_rrel(self, p: rrel_t) -> None:
        r"""Set register-relative location - can't be nullptr.
        
        """
        ...
    def consume_scattered(self, p: scattered_aloc_t) -> None:
        r"""Set distributed argument location.
        
        """
        ...
    def get_biggest(self) -> biggest_t:
        r"""Get largest element in internal union.
        
        """
        ...
    def get_custom(self) -> None:
        r"""Get custom argloc info. Use if atype() == ALOC_CUSTOM 
                
        """
        ...
    def get_ea(self) -> ida_idaapi.ea_t:
        r"""Get the global address. Use when atype() == ALOC_STATIC 
                
        """
        ...
    def get_reginfo(self) -> int:
        r"""Get all register info. Use when atype() == ALOC_REG1 or ALOC_REG2 
                
        """
        ...
    def get_rrel(self) -> rrel_t:
        r"""Get register-relative info. Use when atype() == ALOC_RREL 
                
        """
        ...
    def has_reg(self) -> bool:
        r"""TRUE if argloc has a register part.
        
        """
        ...
    def has_stkoff(self) -> bool:
        r"""TRUE if argloc has a stack part.
        
        """
        ...
    def in_stack(self) -> bool:
        r"""TRUE if argloc is in stack entirely.
        
        """
        ...
    def is_aliasable(self, mb: mba_t, size: int) -> bool:
        ...
    def is_badloc(self) -> bool:
        r"""See ALOC_NONE.
        
        """
        ...
    def is_custom(self) -> bool:
        r"""See ALOC_CUSTOM.
        
        """
        ...
    def is_ea(self) -> bool:
        r"""See ALOC_STATIC.
        
        """
        ...
    def is_fragmented(self) -> bool:
        r"""is_scattered() || is_reg2()
        
        """
        ...
    def is_mixed_scattered(self) -> bool:
        r"""mixed scattered: consists of register and stack parts
        
        """
        ...
    def is_reg(self) -> bool:
        r"""is_reg1() || is_reg2()
        
        """
        ...
    def is_reg1(self) -> bool:
        r"""See ALOC_REG1.
        
        """
        ...
    def is_reg2(self) -> bool:
        r"""See ALOC_REG2.
        
        """
        ...
    def is_rrel(self) -> bool:
        r"""See ALOC_RREL.
        
        """
        ...
    def is_scattered(self) -> bool:
        r"""See ALOC_DIST.
        
        """
        ...
    def is_stkoff(self) -> bool:
        r"""See ALOC_STACK.
        
        """
        ...
    def reg1(self) -> int:
        ...
    def reg2(self) -> int:
        r"""Get info for the second register. Use when atype() == ALOC_REG2 
                
        """
        ...
    def regoff(self) -> int:
        r"""Get offset from the beginning of the register in bytes. Use when atype() == ALOC_REG1 
                
        """
        ...
    def scattered(self) -> scattered_aloc_t:
        r"""Get scattered argument info. Use when atype() == ALOC_DIST 
                
        """
        ...
    def set_badloc(self) -> None:
        r"""Set to invalid location.
        
        """
        ...
    def set_ea(self, _ea: ida_idaapi.ea_t) -> None:
        r"""Set static ea location.
        
        """
        ...
    def set_reg1(self, r1: int) -> None:
        ...
    def set_reg2(self, _reg1: int, _reg2: int) -> None:
        r"""Set secondary register location.
        
        """
        ...
    def set_stkoff(self, off: int) -> None:
        r"""Set stack offset location.
        
        """
        ...
    def stkoff(self) -> int:
        r"""Get the stack offset. Use if atype() == ALOC_STACK 
                
        """
        ...
    def swap(self, r: argloc_t) -> None:
        r"""Assign this == r and r == this.
        
        """
        ...

class vdui_t:
    @property
    def cfunc(self) -> Any: ...
    @property
    def cpos(self) -> Any: ...
    @property
    def ct(self) -> Any: ...
    @property
    def flags(self) -> Any: ...
    @property
    def head(self) -> Any: ...
    @property
    def item(self) -> Any: ...
    @property
    def last_code(self) -> Any: ...
    @property
    def mba(self) -> Any: ...
    @property
    def tail(self) -> Any: ...
    @property
    def toplevel(self) -> Any: ...
    @property
    def view_idx(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self, args: Any, kwargs: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def calc_cmt_type(self, lnnum: size_t, cmttype: cmt_type_t) -> cmt_type_t:
        r"""Check if the specified line can have a comment. Due to the coordinate system for comments: ([https://hex-rays.com/blog/coordinate-system-for-hex-rays](https://hex-rays.com/blog/coordinate-system-for-hex-rays)) some function lines cannot have comments. This function checks if a comment can be attached to the specified line. 
                
        :param lnnum: line number (0 based)
        :param cmttype: comment types to check
        :returns: possible comment types
        """
        ...
    def clear(self) -> None:
        r"""Clear the pseudocode window. It deletes the current function and microcode. 
                
        """
        ...
    def collapse_item(self, hide: bool) -> bool:
        r"""Collapse/uncollapse item. This function collapses the current item. 
                
        :returns: false if failed.
        """
        ...
    def collapse_lvars(self, hide: bool) -> bool:
        r"""Collapse/uncollapse local variable declarations. 
                
        :returns: false if failed.
        """
        ...
    def ctree_to_disasm(self) -> bool:
        r"""Jump to disassembly. This function jumps to the address in the disassembly window which corresponds to the current item. The current item is determined based on the current keyboard cursor position. 
                
        :returns: false if failed
        """
        ...
    def del_orphan_cmts(self) -> bool:
        r"""Delete all orphan comments. Delete all orphan comments and refresh the screen. 
                
        :returns: true
        """
        ...
    def edit_cmt(self, loc: treeloc_t) -> bool:
        r"""Edit an indented comment. This function displays a dialog box and allows the user to edit the comment for the specified ctree location. 
                
        :param loc: comment location
        :returns: false if failed or cancelled
        """
        ...
    def edit_func_cmt(self) -> bool:
        r"""Edit a function comment. This function displays a dialog box and allows the user to edit the function comment. 
                
        :returns: false if failed or cancelled
        """
        ...
    def get_current_item(self, idv: input_device_t) -> bool:
        r"""Get current item. This function refreshes the cpos, item, tail fields. 
                
        :param idv: keyboard or mouse
        :returns: false if failed
        """
        ...
    def get_current_label(self) -> int:
        r"""Get current label. If there is a label under the cursor, return its number. 
                
        :returns: -1 if there is no label under the cursor. prereq: get_current_item() has been called
        """
        ...
    def get_number(self) -> cnumber_t:
        r"""Get current number. If the current item is a number, return pointer to it. 
                
        :returns: nullptr if the current item is not a number This function returns non-null for the cases of a 'switch' statement Also, if the current item is a casted number, then this function will succeed.
        """
        ...
    def in_ctree(self) -> bool:
        r"""Is the current item a statement?
        
        :returns: false if the cursor is in the local variable/type declaration area
         true if the cursor is in the statement area
        """
        ...
    def invert_bits(self) -> bool:
        r"""Bitwise negate a number. This function inverts all bits of the current number. 
                
        :returns: false if failed.
        """
        ...
    def invert_sign(self) -> bool:
        r"""Negate a number. This function negates the current number. 
                
        :returns: false if failed.
        """
        ...
    def jump_enter(self, idv: input_device_t, omflags: int) -> bool:
        r"""Process the Enter key. This function jumps to the definition of the item under the cursor. If the current item is a function, it will be decompiled. If the current item is a global data, its disassemly text will be displayed. 
                
        :param idv: what cursor must be used, the keyboard or the mouse
        :param omflags: OM_NEWWIN: new pseudocode window will open, 0: reuse the existing window
        :returns: false if failed
        """
        ...
    def locked(self) -> bool:
        r"""Does the pseudocode window contain valid code? We lock windows before modifying them, to avoid recursion due to the events generated by the IDA kernel. 
                
        :returns: true: The window is locked and may have stale info
        """
        ...
    def map_lvar(self, frm: lvar_t, to: lvar_t) -> bool:
        r"""Map a local variable to another. This function permanently maps one lvar to another. All occurrences of the mapped variable are replaced by the new variable 
                
        :param to: the variable to map to. if nullptr, unmaps the variable
        :returns: false if failed
        """
        ...
    def refresh_cpos(self, idv: input_device_t) -> bool:
        r"""Refresh the current position. This function refreshes the cpos field. 
                
        :param idv: keyboard or mouse
        :returns: false if failed
        """
        ...
    def refresh_ctext(self, activate: bool = True) -> None:
        r"""Refresh pseudocode window. This function refreshes the pseudocode window by regenerating its text from cfunc_t. Instead of this function use refresh_func_ctext(), which refreshes all pseudocode windows for the function. 
                
        """
        ...
    def refresh_view(self, redo_mba: bool) -> None:
        r"""Refresh pseudocode window. This is the highest level refresh function. It causes the most profound refresh possible and can lead to redecompilation of the current function. Please consider using refresh_ctext() if you need a more superficial refresh. 
                
        :param redo_mba: true means to redecompile the current function
         false means to rebuild ctree without regenerating microcode
        """
        ...
    def rename_global(self, ea: ida_idaapi.ea_t) -> bool:
        r"""Rename global item. This function displays a dialog box and allows the user to rename a global item (data or function). 
                
        :param ea: address of the global item
        :returns: false if failed or cancelled
        """
        ...
    def rename_label(self, label: int) -> bool:
        r"""Rename a label. This function displays a dialog box and allows the user to rename a statement label. 
                
        :param label: label number
        :returns: false if failed or cancelled
        """
        ...
    def rename_lvar(self, v: lvar_t, name: str, is_user_name: bool) -> bool:
        r"""Rename local variable. This function permanently renames a local variable. 
                
        :param v: pointer to local variable
        :param name: new variable name
        :param is_user_name: use true to save the new name into the database. use false to delete the saved name.
        :returns: false if failed
        """
        ...
    def rename_udm(self, udt_type: tinfo_t, udm_idx: int) -> bool:
        r"""Rename structure field. This function displays a dialog box and allows the user to rename a structure field. 
                
        :param udt_type: structure/union type
        :param udm_idx: index of the structure/union member
        :returns: false if failed or cancelled
        """
        ...
    def set_global_type(self, ea: ida_idaapi.ea_t) -> bool:
        r"""Set global item type. This function displays a dialog box and allows the user to change the type of a global item (data or function). 
                
        :param ea: address of the global item
        :returns: false if failed or cancelled
        """
        ...
    def set_locked(self, v: bool) -> bool:
        ...
    def set_lvar_cmt(self, v: lvar_t, cmt: str) -> bool:
        r"""Set local variable comment. This function permanently sets a variable comment. 
                
        :param v: pointer to local variable
        :param cmt: new comment
        :returns: false if failed
        """
        ...
    def set_lvar_type(self, v: lvar_t, type: tinfo_t) -> bool:
        r"""Set local variable type. This function permanently sets a local variable type and clears NOPTR flag if it was set before by function 'set_noptr_lvar' 
                
        :param v: pointer to local variable
        :param type: new variable type
        :returns: false if failed
        """
        ...
    def set_noptr_lvar(self, v: lvar_t) -> bool:
        r"""Inform that local variable should have a non-pointer type This function permanently sets a corresponding variable flag (NOPTR) and removes type if it was set before by function 'set_lvar_type' 
                
        :param v: pointer to local variable
        :returns: false if failed
        """
        ...
    def set_num_enum(self) -> bool:
        r"""Convert number to symbolic constant. This function displays a dialog box and allows the user to select a symbolic constant to represent the number. 
                
        :returns: false if failed or cancelled
        """
        ...
    def set_num_radix(self, base: int) -> bool:
        r"""Change number base. This function changes the current number representation. 
                
        :param base: number radix (10 or 16)
         0 means a character constant
        :returns: false if failed
        """
        ...
    def set_num_stroff(self) -> bool:
        r"""Convert number to structure field offset. Currently not implemented. 
                
        :returns: false if failed or cancelled
        """
        ...
    def set_udm_type(self, udt_type: tinfo_t, udm_idx: int) -> bool:
        r"""Set structure field type. This function displays a dialog box and allows the user to change the type of a structure field. 
                
        :param udt_type: structure/union type
        :param udm_idx: index of the structure/union member
        :returns: false if failed or cancelled
        """
        ...
    def set_valid(self, v: bool) -> None:
        ...
    def set_visible(self, v: bool) -> None:
        ...
    def split_item(self, split: bool) -> bool:
        r"""Split/unsplit item. This function splits the current assignment expression. 
                
        :returns: false if failed.
        """
        ...
    def switch_to(self, f: cfuncptr_t, activate: bool) -> None:
        r"""Display the specified pseudocode. This function replaces the pseudocode window contents with the specified cfunc_t. 
                
        :param f: pointer to the function to display.
        :param activate: should the pseudocode window get focus?
        """
        ...
    def ui_edit_lvar_cmt(self, v: lvar_t) -> bool:
        r"""Set local variable comment. This function displays a dialog box and allows the user to edit the comment of a local variable. 
                
        :param v: pointer to local variable
        :returns: false if failed or cancelled
        """
        ...
    def ui_map_lvar(self, v: lvar_t) -> bool:
        r"""Map a local variable to another. This function displays a variable list and allows the user to select mapping. 
                
        :param v: pointer to local variable
        :returns: false if failed or cancelled
        """
        ...
    def ui_rename_lvar(self, v: lvar_t) -> bool:
        r"""Rename local variable. This function displays a dialog box and allows the user to rename a local variable. 
                
        :param v: pointer to local variable
        :returns: false if failed or cancelled
        """
        ...
    def ui_set_call_type(self, e: cexpr_t) -> bool:
        r"""Set type of a function call This function displays a dialog box and allows the user to change the type of a function call 
                
        :param e: pointer to call expression
        :returns: false if failed or cancelled
        """
        ...
    def ui_set_lvar_type(self, v: lvar_t) -> bool:
        r"""Set local variable type. This function displays a dialog box and allows the user to change the type of a local variable. 
                
        :param v: pointer to local variable
        :returns: false if failed or cancelled
        """
        ...
    def ui_unmap_lvar(self, v: lvar_t) -> bool:
        r"""Unmap a local variable. This function displays list of variables mapped to the specified variable and allows the user to select a variable to unmap. 
                
        :param v: pointer to local variable
        :returns: false if failed or cancelled
        """
        ...
    def valid(self) -> bool:
        r"""Does the pseudocode window contain valid code? It can become invalid if the function type gets changed in IDA. 
                
        """
        ...
    def visible(self) -> bool:
        r"""Is the pseudocode window visible? if not, it might be invisible or destroyed 
                
        """
        ...

class view_mouse_event_location_t:
    @property
    def ea(self) -> Any: ...
    @property
    def item(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class view_mouse_event_t:
    @property
    def button(self) -> Any: ...
    @property
    def location(self) -> Any: ...
    @property
    def renderer_pos(self) -> Any: ...
    @property
    def rtype(self) -> Any: ...
    @property
    def state(self) -> Any: ...
    @property
    def x(self) -> Any: ...
    @property
    def y(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...

class vivl_t(voff_t):
    @property
    def off(self) -> Any: ...
    @property
    def size(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, args: Any) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: vivl_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: vivl_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: vivl_t) -> bool:
        ...
    def __lt__(self, r: vivl_t) -> bool:
        ...
    def __ne__(self, r: vivl_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, width: int) -> voff_t:
        ...
    def compare(self, r: vivl_t) -> int:
        ...
    def contains(self, voff2: voff_t) -> bool:
        r"""Does our value interval contain the specified value offset?
        
        """
        ...
    def defined(self) -> bool:
        ...
    def diff(self, r: voff_t) -> int:
        ...
    def dstr(self) -> str:
        ...
    def extend_to_cover(self, r: vivl_t) -> bool:
        r"""Extend a value interval using another value interval of the same type 
                
        :returns: success
        """
        ...
    def get_reg(self) -> mreg_t:
        ...
    def get_stkoff(self) -> int:
        ...
    def inc(self, delta: int) -> None:
        ...
    def includes(self, r: vivl_t) -> bool:
        r"""Does our value interval include another?
        
        """
        ...
    def intersect(self, r: vivl_t) -> int:
        r"""Intersect value intervals the same type 
                
        :returns: size of the resulting intersection
        """
        ...
    def is_reg(self) -> bool:
        ...
    def is_stkoff(self) -> bool:
        ...
    def overlap(self, r: vivl_t) -> bool:
        r"""Do two value intervals overlap?
        
        """
        ...
    def set(self, args: Any) -> None:
        r"""This function has the following signatures:
        
            0. set(_type: mopt_t, _off: int, _size: int=0) -> None
            1. set(voff: const voff_t &, _size: int) -> None
        
        # 0: set(_type: mopt_t, _off: int, _size: int=0) -> None
        
        
        # 1: set(voff: const voff_t &, _size: int) -> None
        
        
        """
        ...
    def set_reg(self, mreg: mreg_t, sz: int = 0) -> None:
        ...
    def set_stkoff(self, stkoff: int, sz: int = 0) -> None:
        ...
    def undef(self) -> None:
        ...

class voff_t:
    @property
    def off(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: voff_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: voff_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: voff_t) -> bool:
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: voff_t) -> bool:
        ...
    def __lt__(self, r: voff_t) -> bool:
        ...
    def __ne__(self, r: voff_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add(self, width: int) -> voff_t:
        ...
    def compare(self, r: voff_t) -> int:
        ...
    def defined(self) -> bool:
        ...
    def diff(self, r: voff_t) -> int:
        ...
    def get_reg(self) -> mreg_t:
        ...
    def get_stkoff(self) -> int:
        ...
    def inc(self, delta: int) -> None:
        ...
    def is_reg(self) -> bool:
        ...
    def is_stkoff(self) -> bool:
        ...
    def set(self, _type: mopt_t, _off: int) -> None:
        ...
    def set_reg(self, mreg: mreg_t) -> None:
        ...
    def set_stkoff(self, stkoff: int) -> None:
        ...
    def undef(self) -> None:
        ...

class xrefblk_t:
    @property
    def frm(self) -> Any: ...
    @property
    def iscode(self) -> Any: ...
    @property
    def to(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    @property
    def user(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, value: Any) -> Any:
        r"""Return self==value."""
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __hash__(self) -> Any:
        r"""Return hash(self)."""
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, value: Any) -> Any:
        r"""Return self!=value."""
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def crefs_from(self, ea: Any) -> Any:
        r"""
        Provide an iterator on code references from ea including flow references
        
        """
        ...
    def crefs_to(self, ea: Any) -> Any:
        r"""
        Provide an iterator on code references to ea including flow references
        
        """
        ...
    def drefs_from(self, ea: Any) -> Any:
        r"""
        Provide an iterator on data references from ea
        
        """
        ...
    def drefs_to(self, ea: Any) -> Any:
        r"""
        Provide an iterator on data references to ea
        
        """
        ...
    def fcrefs_from(self, ea: Any) -> Any:
        r"""
        Provide an iterator on code references from ea
        
        """
        ...
    def fcrefs_to(self, ea: Any) -> Any:
        r"""
        Provide an iterator on code references to ea
        
        """
        ...
    def first_from(self, _from: ida_idaapi.ea_t, flags: int = 0) -> bool:
        ...
    def first_to(self, _to: ida_idaapi.ea_t, flags: int = 0) -> bool:
        ...
    def next_from(self, args: Any) -> bool:
        ...
    def next_to(self, args: Any) -> bool:
        ...
    def refs_from(self, ea: Any, flag: Any) -> Any:
        r"""
        Provide an iterator on from reference represented by flag
        
        """
        ...
    def refs_to(self, ea: Any, flag: Any) -> Any:
        r"""
        Provide an iterator on to reference represented by flag
        
        """
        ...

class xreflist_entry_t:
    @property
    def ea(self) -> Any: ...
    @property
    def opnum(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: xreflist_entry_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, r: xreflist_entry_t) -> bool:
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, r: xreflist_entry_t) -> bool:
        ...
    def __init__(self) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __le__(self, r: xreflist_entry_t) -> bool:
        ...
    def __lt__(self, r: xreflist_entry_t) -> bool:
        ...
    def __ne__(self, r: xreflist_entry_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def compare(self, r: xreflist_entry_t) -> int:
        ...

class xreflist_t:
    def __delattr__(self, name: Any) -> Any:
        r"""Implement delattr(self, name)."""
        ...
    def __dir__(self) -> Any:
        r"""Default dir() implementation."""
        ...
    def __eq__(self, r: xreflist_t) -> bool:
        ...
    def __format__(self, format_spec: Any) -> Any:
        r"""Default object formatter.
        
        Return str(self) if format_spec is empty. Raise TypeError otherwise.
        """
        ...
    def __ge__(self, value: Any) -> Any:
        r"""Return self>=value."""
        ...
    def __getattribute__(self, name: Any) -> Any:
        r"""Return getattr(self, name)."""
        ...
    def __getitem__(self, i: size_t) -> xreflist_entry_t:
        ...
    def __getstate__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __gt__(self, value: Any) -> Any:
        r"""Return self>value."""
        ...
    def __init__(self, args: Any) -> Any:
        ...
    def __init_subclass__(self) -> Any:
        r"""This method is called when a class is subclassed.
        
        The default implementation does nothing. It may be
        overridden to extend subclasses.
        
        """
        ...
    def __iter__(self) -> Any:
        r"""Helper function, to be set as __iter__ method for qvector-, or array-based classes."""
        ...
    def __le__(self, value: Any) -> Any:
        r"""Return self<=value."""
        ...
    def __len__(self) -> int:
        ...
    def __lt__(self, value: Any) -> Any:
        r"""Return self<value."""
        ...
    def __ne__(self, r: xreflist_t) -> bool:
        ...
    def __new__(self, args: Any, kwargs: Any) -> Any:
        r"""Create and return a new object.  See help(type) for accurate signature."""
        ...
    def __reduce__(self) -> Any:
        r"""Helper for pickle."""
        ...
    def __reduce_ex__(self, protocol: Any) -> Any:
        r"""Helper for pickle."""
        ...
    def __repr__(self) -> Any:
        ...
    def __setattr__(self, name: Any, value: Any) -> Any:
        r"""Implement setattr(self, name, value)."""
        ...
    def __setitem__(self, i: size_t, v: xreflist_entry_t) -> None:
        ...
    def __sizeof__(self) -> Any:
        r"""Size of object in memory, in bytes."""
        ...
    def __str__(self) -> Any:
        r"""Return str(self)."""
        ...
    def __subclasshook__(self, object: Any) -> Any:
        r"""Abstract classes can override this to customize issubclass().
        
        This is invoked early on by abc.ABCMeta.__subclasscheck__().
        It should return True, False or NotImplemented.  If it returns
        NotImplemented, the normal algorithm is used.  Otherwise, it
        overrides the normal algorithm (and the outcome is cached).
        
        """
        ...
    def __swig_destroy__(self, object: Any) -> Any:
        ...
    def add_unique(self, x: xreflist_entry_t) -> bool:
        ...
    def append(self, x: xreflist_entry_t) -> None:
        ...
    def at(self, _idx: size_t) -> xreflist_entry_t:
        ...
    def back(self) -> Any:
        ...
    def begin(self, args: Any) -> const_iterator:
        ...
    def capacity(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def end(self, args: Any) -> const_iterator:
        ...
    def erase(self, args: Any) -> iterator:
        ...
    def extend(self, x: xreflist_t) -> None:
        ...
    def extract(self) -> xreflist_entry_t:
        ...
    def find(self, args: Any) -> const_iterator:
        ...
    def front(self) -> Any:
        ...
    def grow(self, args: Any) -> None:
        ...
    def has(self, x: xreflist_entry_t) -> bool:
        ...
    def inject(self, s: xreflist_entry_t, len: size_t) -> None:
        ...
    def insert(self, it: xreflist_entry_t, x: xreflist_entry_t) -> iterator:
        ...
    def pop_back(self) -> None:
        ...
    def push_back(self, args: Any) -> xreflist_entry_t:
        ...
    def qclear(self) -> None:
        ...
    def reserve(self, cnt: size_t) -> None:
        ...
    def resize(self, args: Any) -> None:
        ...
    def size(self) -> int:
        ...
    def swap(self, r: xreflist_t) -> None:
        ...
    def truncate(self) -> None:
        ...

def AssembleLine(ea: Any, cs: Any, ip: Any, use32: Any, line: Any) -> Any:
    r"""Assemble an instruction to a string (display a warning if an error is found)
    
    :param ea: linear address of instruction
    :param cs:  cs of instruction
    :param ip:  ip of instruction
    :param use32: is 32bit segment
    :param line: line to assemble
    :returns: a string containing the assembled instruction, or None on failure
    """
    ...

def COLSTR(str: Any, tag: Any) -> Any:
    r"""
    Utility function to create a colored line
    :param str: The string
    :param tag: Color tag constant. One of SCOLOR_XXXX
    
    """
    ...

def IDAPython_Completion(line: Any, x: Any) -> Any:
    r"""Internal utility class for auto-completion support"""
    ...

def IDAPython_ExecScript(path: Any, g: Any, print_error: Any = True) -> Any:
    r"""
    Run the specified script.
    
    This function is used by the low-level plugin code.
    
    """
    ...

def IDAPython_ExecSystem(cmd: Any) -> Any:
    r"""
    Executes a command with popen().
    
    """
    ...

def IDAPython_FormatExc(etype: Any, value: Any = None, tb: Any = None, limit: Any = None) -> Any:
    r"""
    This function is used to format an exception given the
    values returned by a PyErr_Fetch()
    
    """
    ...

def IDAPython_GetDocstrings(obj: Any) -> Any:
    ...

def IDAPython_LoadProcMod(path: Any, g: Any, print_error: Any = True) -> Any:
    r"""
    Load processor module.
    
    """
    ...

def IDAPython_UnLoadProcMod(script: Any, g: Any, print_error: Any = True) -> Any:
    r"""
    Unload processor module.
    
    """
    ...

def TRUNC(ea: Any) -> Any:
    r"""Truncate EA for the current application bitness"""
    ...

def TWidget__from_ptrval__(ptrval: size_t) -> TWidget:
    ...

def accepts_small_udts(op: ctype_t) -> bool:
    r"""Is the operator allowed on small structure or union?
    
    """
    ...

def accepts_udts(op: ctype_t) -> bool:
    ...

def activate_widget(widget: TWidget, take_focus: bool) -> None:
    r"""Activate widget (only gui version) (ui_activate_widget). 
            
    :param widget: existing widget to display
    :param take_focus: give focus to given widget
    """
    ...

def add_auto_stkpnt(pfn: func_t, ea: ida_idaapi.ea_t, delta: int) -> bool:
    r"""Add automatic SP register change point. 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address where SP changes. usually this is the end of the instruction which modifies the stack pointer ( insn_t::ea+ insn_t::size)
    :param delta: difference between old and new values of SP
    :returns: success
    """
    ...

def add_bpt(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
        1. add_bpt(bpt: const bpt_t &) -> bool
    
    # 0: add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    # 1: add_bpt(bpt: const bpt_t &) -> bool
    
    Add a new breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    """
    ...

def add_byte(ea: ida_idaapi.ea_t, value: int) -> None:
    r"""Add a value to one byte of the program. This function works for wide byte processors too. 
            
    :param ea: linear address
    :param value: byte value
    """
    ...

def add_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: cref_t) -> bool:
    r"""Create a code cross-reference. 
            
    :param to: linear address of referenced instruction
    :param type: cross-reference type
    :returns: success
    """
    ...

def add_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, type: dref_t) -> bool:
    r"""Create a data cross-reference. 
            
    :param to: linear address of referenced data
    :param type: cross-reference type
    :returns: success (may fail if user-defined xref exists from->to)
    """
    ...

def add_dword(ea: ida_idaapi.ea_t, value: uint64) -> None:
    r"""Add a value to one dword of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :param ea: linear address
    :param value: byte value
    """
    ...

def add_encoding(encname: str) -> int:
    ...

def add_entry(ord: int, ea: ida_idaapi.ea_t, name: str, makecode: bool, flags: int = 0) -> bool:
    r"""Add an entry point to the list of entry points. 
            
    :param ord: ordinal number if ordinal number is equal to 'ea' then ordinal is not used
    :param ea: linear address
    :param name: name of entry point. If the specified location already has a name, the old name will be appended to the regular comment.
    :param makecode: should the kernel convert bytes at the entry point to instruction(s)
    :param flags: See AEF_*
    :returns: success (currently always true)
    """
    ...

def add_extra_cmt(args: Any) -> bool:
    ...

def add_extra_line(args: Any) -> bool:
    ...

def add_frame(pfn: func_t, frsize: int, frregs: ushort, argsize: asize_t) -> bool:
    r"""Add function frame. 
            
    :param pfn: pointer to function structure
    :param frsize: size of function local variables
    :param frregs: size of saved registers
    :param argsize: size of function arguments range which will be purged upon return. this parameter is used for __stdcall and __pascal calling conventions. for other calling conventions please pass 0.
    :returns: 1: ok
    :returns: 0: failed (no function, frame already exists)
    """
    ...

def add_frame_member(pfn: func_t, name: str, offset: int, tif: tinfo_t, repr: value_repr_t = None, etf_flags: uint = 0) -> bool:
    r"""Add member to the frame type 
            
    :param pfn: pointer to function
    :param name: variable name, nullptr means autogenerate a name
    :param offset: member offset in the frame structure, in bytes
    :param tif: variable type
    :param repr: variable representation
    :returns: success
    """
    ...

def add_func(args: Any) -> bool:
    r"""Add a new function. If the function end address is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
            
    :param ea1: start address
    :param ea2: end address
    :returns: success
    """
    ...

def add_func_ex(pfn: func_t) -> bool:
    r"""Add a new function. If the fn->end_ea is BADADDR, then IDA will try to determine the function bounds by calling find_func_bounds(..., FIND_FUNC_DEFINE). 
            
    :param pfn: ptr to filled function structure
    :returns: success
    """
    ...

def add_hidden_range(args: Any) -> bool:
    r"""Mark a range of addresses as hidden. The range will be created in the invisible state with the default color 
            
    :param ea1: linear address of start of the address range
    :param ea2: linear address of end of the address range
    :param description: range parameters
    :param header: range parameters
    :param footer: range parameters
    :param color: the range color
    :returns: success
    """
    ...

def add_hotkey(hotkey: Any, callable: Any) -> Any:
    r"""Associates a function call with a hotkey.
    Callable 'callable' will be called each time the hotkey is pressed
    
    :param hotkey: The hotkey
    :param callable: Callable
    
    :returns: Context object on success or None on failure.
    """
    ...

def add_idc_class(name: str, super: idc_class_t = None) -> idc_class_t:
    r"""Create a new IDC class. 
            
    :param name: name of the new class
    :param super: the base class for the new class. if the new class is not based on any other class, pass nullptr
    :returns: pointer to the created class. If such a class already exists, a pointer to it will be returned. Pointers to other existing classes may be invalidated by this call.
    """
    ...

def add_idc_func(name: Any, fp: Any, args: Any, defvals: Any = ..., flags: Any = 0) -> Any:
    r"""Add an IDC function. This function does not modify the predefined kernel functions. Example: 
         error_t idaapi myfunc5(idc_value_t *argv, idc_value_t *res)
        
          msg("myfunc is called with arg0=%a and arg1=%s\n", argv[0].num, argv[1].str);
          res->num = 5;     // let's return 5
          return eOk;
        
         const char myfunc5_args[] = { VT_LONG, VT_STR, 0 };
         const ext_idcfunc_t myfunc_desc = { "MyFunc5", myfunc5, myfunc5_args, nullptr, 0, EXTFUN_BASE };
        
         after this:
        
        
         there is a new IDC function which can be called like this:
         "test");
    
    
            
    :returns: success
    """
    ...

def add_idc_gvar(name: str) -> idc_value_t:
    r"""Add global IDC variable. 
            
    :param name: name of the global variable
    :returns: pointer to the created variable or existing variable. NB: the returned pointer is valid until a new global var is added.
    """
    ...

def add_idc_hotkey(hotkey: str, idcfunc: str) -> int:
    r"""Add hotkey for IDC function (ui_add_idckey). 
            
    :param hotkey: hotkey name
    :param idcfunc: IDC function name
    :returns: IDC hotkey error codes
    """
    ...

def add_mapping(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t) -> bool:
    r"""IDA supports memory mapping. References to the addresses from the mapped range use data and meta-data from the mapping range. 
            
    :param to: start of the mapping range (existent address)
    :param size: size of the range
    :returns: success
    """
    ...

def add_path_mapping(src: str, dst: str) -> None:
    ...

def add_pgm_cmt(args: Any) -> bool:
    ...

def add_qword(ea: ida_idaapi.ea_t, value: uint64) -> None:
    r"""Add a value to one qword of the program. This function does not work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :param ea: linear address
    :param value: byte value
    """
    ...

def add_refinfo_dref(insn: insn_t, _from: ida_idaapi.ea_t, ri: refinfo_t, opval: adiff_t, type: dref_t, opoff: int) -> ida_idaapi.ea_t:
    r"""Add xrefs for a reference from the given instruction ( insn_t::ea). This function creates a cross references to the target and the base. insn_t::add_off_drefs() calls this function to create xrefs for 'offset' operand. 
            
    :param insn: the referencing instruction
    :param ri: reference info block from the database
    :param opval: operand value (usually op_t::value or op_t::addr)
    :param type: type of xref
    :param opoff: offset of the operand from the start of instruction
    :returns: the target address of the reference
    """
    ...

def add_regarg(pfn: func_t, reg: int, tif: tinfo_t, name: str) -> None:
    ...

def add_regvar(pfn: func_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str, cmt: str) -> int:
    r"""Define a register variable. 
            
    :param pfn: function in which the definition will be created
    :param ea1: range of addresses within the function where the definition will be used
    :param ea2: range of addresses within the function where the definition will be used
    :param canon: name of a general register
    :param user: user-defined name for the register
    :param cmt: comment for the definition
    :returns: Register variable error codes
    """
    ...

def add_segm(para: ida_idaapi.ea_t, start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, name: str, sclass: str, flags: int = 0) -> bool:
    r"""Add a new segment, second form. Segment alignment is set to saRelByte. Segment combination is "public" or "stack" (if segment class is "STACK"). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to BADSEL. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
            
    :param para: segment base paragraph. if paragraph can't fit in 16bit, then a new selector is allocated and mapped to the paragraph.
    :param start: start address of the segment. if start==BADADDR then start <- to_ea(para,0).
    :param end: end address of the segment. end address should be higher than start address. For emulate empty segments, use SEG_NULL segment type. If the end address is lower than start address, then fail. If end==BADADDR, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created). If 'end' is too high and the new segment would overlap the next segment, 'end' is adjusted properly.
    :param name: name of new segment. may be nullptr
    :param sclass: class of the segment. may be nullptr. type of the new segment is modified if class is one of predefined names:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "CONST" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * "XTRN" -> SEG_XTRN
    * "COMM" -> SEG_COMM
    * "ABS" -> SEG_ABSSYM
    :param flags: Add segment flags
    :returns: 1: ok
    :returns: 0: failed, a warning message is displayed
    """
    ...

def add_segm_ex(NONNULL_s: segment_t, name: str, sclass: str, flags: int) -> bool:
    r"""Add a new segment. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. 
            
    :param name: name of new segment. may be nullptr. if specified, the segment is immediately renamed
    :param sclass: class of the segment. may be nullptr. if specified, the segment class is immediately changed
    :param flags: Add segment flags
    :returns: 1: ok
    :returns: 0: failed, a warning message is displayed
    """
    ...

def add_segment_translation(segstart: ida_idaapi.ea_t, mappedseg: ida_idaapi.ea_t) -> bool:
    r"""Add segment translation. 
            
    :param segstart: start address of the segment to add translation to
    :param mappedseg: start address of the overlayed segment
    :returns: 1: ok
    :returns: 0: too many translations or bad segstart
    """
    ...

def add_sourcefile(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, filename: str) -> bool:
    ...

def add_spaces(s: str, len: size_t) -> str:
    r"""Add space characters to the colored string so that its length will be at least 'len' characters. Don't trim the string if it is longer than 'len'. 
            
    :param len: the desired length of the string
    :returns: pointer to the end of input string
    """
    ...

def add_til(name: str, flags: int) -> int:
    r"""Load a til file and add it the database type libraries list. IDA will also apply function prototypes for matching function names. 
            
    :param name: til name
    :param flags: combination of Load TIL flags
    :returns: one of Load TIL result codes
    """
    ...

def add_tryblk(tb: tryblk_t) -> int:
    r"""Add one try block information. 
            
    :param tb: try block to add.
    :returns: error code; 0 means good
    """
    ...

def add_user_stkpnt(ea: ida_idaapi.ea_t, delta: int) -> bool:
    r"""Add user-defined SP register change point. 
            
    :param ea: linear address where SP changes
    :param delta: difference between old and new values of SP
    :returns: success
    """
    ...

def add_virt_module(mod: modinfo_t) -> bool:
    ...

def add_word(ea: ida_idaapi.ea_t, value: uint64) -> None:
    r"""Add a value to one word of the program. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :param ea: linear address
    :param value: byte value
    """
    ...

def addon_count() -> int:
    r"""Get number of installed addons.
    
    """
    ...

def align_flag() -> flags64_t:
    r"""Get a flags64_t representing an alignment directive.
    
    """
    ...

def alloc_type_ordinal(ti: til_t) -> int:
    r"""alloc_type_ordinals(ti, 1)
    
    """
    ...

def alloc_type_ordinals(ti: til_t, qty: int) -> int:
    r"""Allocate a range of ordinal numbers for new types. 
            
    :param ti: type library
    :param qty: number of ordinals to allocate
    :returns: the first ordinal. 0 means failure.
    """
    ...

def allocate_selector(segbase: ida_idaapi.ea_t) -> sel_t:
    r"""Allocate a selector for a segment unconditionally. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a new free selector and setup its mapping using find_free_selector() and set_selector() functions. 
            
    :param segbase: a new segment base paragraph
    :returns: the allocated selector number
    """
    ...

def analyzer_options() -> None:
    r"""Allow the user to set analyzer options. (show a dialog box) (ui_analyzer_options)
    
    """
    ...

def appcall(func_ea: ida_idaapi.ea_t, tid: thid_t, _type_or_none: bytevec_t, _fields: bytevec_t, arg_list: Any) -> Any:
    ...

def append_abi_opts(abi_opts: str, user_level: bool = False) -> bool:
    r"""Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-... or -opt1-opt2-... 
            
    :param abi_opts: - ABI options to add/remove in form opt1-opt2-...
    :param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
    :returns: success
    """
    ...

def append_argloc(out: qtype, vloc: argloc_t) -> bool:
    r"""Serialize argument location 
            
    """
    ...

def append_cmt(ea: ida_idaapi.ea_t, str: str, rptble: bool) -> bool:
    r"""Append to an indented comment. Creates a new comment if none exists. Appends a newline character and the specified string otherwise. 
            
    :param ea: linear address
    :param str: comment string to append
    :param rptble: append to repeatable comment?
    :returns: success
    """
    ...

def append_func_tail(pfn: func_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool:
    r"""Append a new tail chunk to the function definition. If the tail already exists, then it will simply be added to the function tail list Otherwise a new tail will be created and its owner will be set to be our function If a new tail cannot be created, then this function will fail. 
            
    :param pfn: pointer to the function
    :param ea1: start of the tail. If a tail already exists at the specified address it must start at 'ea1'
    :param ea2: end of the tail. If a tail already exists at the specified address it must end at 'ea2'. If specified as BADADDR, IDA will determine the end address itself.
    """
    ...

def append_struct_fields(disp: adiff_t, n: int, path: tid_t, flags: flags64_t, delta: adiff_t, appzero: bool) -> str:
    r"""Append names of struct fields to a name if the name is a struct name. 
            
    :param disp: displacement from the name
    :param n: operand number in which the name appears
    :param path: path in the struct. path is an array of id's. maximal length of array is MAXSTRUCPATH. the first element of the array is the structure id. consecutive elements are id's of used union members (if any).
    :param flags: the input flags. they will be returned if the struct cannot be found.
    :param delta: delta to add to displacement
    :param appzero: should append a struct field name if the displacement is zero?
    :returns: flags of the innermost struct member or the input flags
    """
    ...

def append_tinfo_covered(out: rangeset_t, typid: typid_t, offset: uint64) -> bool:
    ...

def apply_callee_tinfo(caller: ida_idaapi.ea_t, tif: tinfo_t) -> bool:
    r"""Apply the type of the called function to the calling instruction. This function will append parameter comments and rename the local variables of the calling function. It also stores information about the instructions that initialize call arguments in the database. Use get_arg_addrs() to retrieve it if necessary. Alternatively it is possible to hook to processor_t::arg_addrs_ready event. 
            
    :param caller: linear address of the calling instruction. must belong to a function.
    :param tif: type info
    :returns: success
    """
    ...

def apply_cdecl(til: til_t, ea: ida_idaapi.ea_t, decl: str, flags: int = 0) -> bool:
    r"""Apply the specified type to the address. This function parses the declaration and calls apply_tinfo() 
            
    :param til: type library
    :param ea: linear address
    :param decl: type declaration in C form
    :param flags: flags to pass to apply_tinfo (TINFO_DEFINITE is always passed)
    :returns: success
    """
    ...

def apply_idasgn_to(signame: str, ea: ida_idaapi.ea_t, is_startup: bool) -> int:
    r"""Apply a signature file to the specified address. 
            
    :param signame: short name of signature file (the file name without path)
    :param ea: address to apply the signature
    :param is_startup: if set, then the signature is treated as a startup one for startup signature ida doesn't rename the first function of the applied module.
    :returns: Library function codes
    """
    ...

def apply_named_type(ea: ida_idaapi.ea_t, name: str) -> bool:
    r"""Apply the specified named type to the address. 
            
    :param ea: linear address
    :param name: the type name, e.g. "FILE"
    :returns: success
    """
    ...

def apply_once_tinfo_and_name(dea: ida_idaapi.ea_t, tif: tinfo_t, name: str) -> bool:
    r"""Apply the specified type and name to the address. This function checks if the address already has a type. If the old type 
    does not exist or the new type is 'better' than the old type, then the 
    new type will be applied. A type is considered better if it has more 
    information (e.g. BTMT_STRUCT is better than BT_INT). 
    The same logic is with the name: if the address already have a meaningful 
    name, it will be preserved. Only if the old name does not exist or it 
    is a dummy name like byte_123, it will be replaced by the new name. 
            
    :param dea: linear address
    :param tif: new type
    :param name: new name for the address
    :returns: success
    """
    ...

def apply_startup_sig(ea: ida_idaapi.ea_t, startup: str) -> bool:
    r"""Apply a startup signature file to the specified address. 
            
    :param ea: address to apply the signature to; usually idainfo::start_ea
    :param startup: the name of the signature file without path and extension
    :returns: true if successfully applied the signature
    """
    ...

def apply_tinfo(ea: ida_idaapi.ea_t, tif: tinfo_t, flags: int) -> bool:
    r"""Apply the specified type to the specified address. This function sets the type and tries to convert the item at the specified address to conform the type. 
            
    :param ea: linear address
    :param tif: new type
    :param flags: combination of Apply tinfo flags
    :returns: success
    """
    ...

def apply_tinfo_to_stkarg(insn: insn_t, x: op_t, v: int, tif: tinfo_t, name: str) -> bool:
    r"""Helper function for the processor modules. to be called from processor_t::use_stkarg_type 
            
    """
    ...

def apply_type(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, flags: int) -> bool:
    r"""Apply the specified type to the address
    
    :param til: Type info library. 'None' can be used.
    :param type: type string
    :param fields: fields string (may be empty or None)
    :param ea: the address of the object
    :param flags: combination of TINFO_... constants or 0
    :returns: Boolean
    """
    ...

def arglocs_overlap(loc1: vdloc_t, w1: size_t, loc2: vdloc_t, w2: size_t) -> bool:
    r"""Do two arglocs overlap?
    
    """
    ...

def as_UTF16(s: Any) -> Any:
    r"""Convenience function to convert a string into appropriate unicode format"""
    ...

def as_cstr(val: Any) -> Any:
    r"""
    Returns a C str from the passed value. The passed value can be of type refclass (returned by a call to buffer() or byref())
    It scans for the first \x00 and returns the string value up to that point.
    
    """
    ...

def as_int32(v: Any) -> Any:
    r"""Returns a number as a signed int32 number"""
    ...

def as_signed(v: Any, nbits: Any = 32) -> Any:
    r"""
    Returns a number as signed. The number of bits are specified by the user.
    The MSB holds the sign.
    
    """
    ...

def as_uint32(v: Any) -> Any:
    r"""Returns a number as an unsigned int32 number"""
    ...

def as_unicode(s: Any) -> Any:
    r"""Convenience function to convert a string into appropriate unicode format"""
    ...

def asgop(cop: ctype_t) -> ctype_t:
    r"""Convert plain operator into assignment operator. For example, cot_add returns cot_asgadd.
    
    """
    ...

def asgop_revert(cop: ctype_t) -> ctype_t:
    r"""Convert assignment operator into plain operator. For example, cot_asgadd returns cot_add 
            
    :returns: cot_empty is the input operator is not an assignment operator.
    """
    ...

def ask_addr(defval: ida_idaapi.ea_t, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input an address
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the address entered by the user, or None if the dialog was canceled
    """
    ...

def ask_buttons(args: Any) -> int:
    r"""Display a dialog box and get choice from maximum three possibilities (ui_ask_buttons). 
            
    :param Yes: text for the first button
    :param No: text for the second button
    :param Cancel: text for the third button
    :param deflt: default choice: one of Button IDs
    :param format: printf-style format string for question. It may have some prefixes, see below.
    :returns: one of Button IDs specifying the selected button (Esc key returns Cancel/3rd button value)
    """
    ...

def ask_file(args: Any) -> char:
    ...

def ask_for_feedback(args: Any) -> None:
    r"""Show a message box asking to send the input file to [support@hex-rays.com](mailto:support@hex-rays.com). 
            
    :param format: the reason why the input file is bad
    """
    ...

def ask_form(args: Any) -> Any:
    r"""Display a dialog box and wait for the user. If the form contains the "BUTTON NO <title>" keyword, then the return values are the same as in the ask_yn() function (Button IDs) 
            
    :param form: dialog box as a string. see ask_form()/open_form()
    :returns: 0: no memory to display or form syntax error (a warning is displayed in this case). the user pressed the 'No' button (if the form has it) or the user cancelled the dialog otherwise. all variables retain their original values.
    :returns: 1: ok, all input fields are filled and validated.
    :returns: -1: the form has the 'No' button and the user cancelled the dialog
    """
    ...

def ask_ident(defval: str, prompt: str) -> bool:
    r"""Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are usually forbidden. 
            
    :returns: false if the user cancelled the dialog, otherwise returns true.
    """
    ...

def ask_ident2(args: Any) -> bool:
    r"""Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are permitted. 
            
    :param str: qstring to fill. Can contain the default value. Cannot be nullptr.
    :param format: printf() style format string with the question
    :returns: false if the user cancelled the dialog, otherwise returns true.
    """
    ...

def ask_long(defval: int, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input a number
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the number entered by the user, or None if the dialog was canceled
    """
    ...

def ask_seg(defval: int, prompt: str) -> Any:
    r"""Display a dialog box and wait for the user to input an segment name.
    This function allows to enter segment register names, segment base
    paragraphs, segment names to denote a segment.
    
    :param defval: The placeholder value
    :param prompt: The prompt to show
    :returns: the selector of the segment entered by the user, or None if the dialog was canceled
    """
    ...

def ask_str(defval: Any, hist: Any, prompt: Any) -> Any:
    r"""Asks for a long text
    
    :param defval: The default value
    :param hist:   history id
    :param prompt: The prompt value
    :returns: None or the entered string
    """
    ...

def ask_text(max_size: int, defval: str, prompt: str) -> Any:
    r"""Asks for a long text
    
    :param max_size: Maximum text length, 0 for unlimited
    :param defval: The default value
    :param prompt: The prompt value
    :returns: None or the entered string
    """
    ...

def ask_yn(args: Any) -> int:
    r"""Display a dialog box and get choice from "Yes", "No", "Cancel". 
            
    :param deflt: default choice: one of Button IDs
    :param format: The question in printf() style format
    :returns: the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL.
    """
    ...

def assemble(ea: Any, cs: Any, ip: Any, use32: Any, line: Any) -> Any:
    r"""Assemble an instruction into the database (display a warning if an error is found)
    
    :param ea: linear address of instruction
    :param cs: cs of instruction
    :param ip: ip of instruction
    :param use32: is 32bit segment?
    :param line: line to assemble
    
    :returns: Boolean. True on success.
    """
    ...

def atoea(str: str) -> uint64:
    r"""Convert a number in C notation to an address. decimal: 1234 
    octal: 0123 
    hexadecimal: 0xabcd 
    binary: 0b00101010 
            
    :param str: the string to parse
    """
    ...

def attach_action_to_menu(menupath: str, name: str, flags: int = 0) -> bool:
    r"""Attach a previously-registered action to the menu (ui_attach_action_to_menu). 
            
    :param menupath: path to the menu item after or before which the insertion will take place. 
    
    * Example: Debug/StartProcess
    * Whitespace, punctuation are ignored.
    * It is allowed to specify only the prefix of the menu item.
    * Comparison is case insensitive.
    * menupath may start with the following prefixes:
    * [S] - modify the main menu of the structure window
    * [E] - modify the main menu of the enum window
    :param name: the action name
    :param flags: a combination of Set menu flags, to determine menu item position
    :returns: success
    """
    ...

def attach_action_to_popup(widget: TWidget, popup_handle: TPopupMenu, name: str, popuppath: str = None, flags: int = 0) -> bool:
    r"""Insert a previously-registered action into the widget's popup menu (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and 'permanent'. 
            
    :param widget: target widget
    :param popup_handle: target popup menu
    * if non-nullptr, the action is added to this popup menu invocation (i.e., 'single-shot')
    * if nullptr, the action is added to a list of actions that should always be present in context menus for this widget (i.e., 'permanent'.)
    :param name: action name
    :param popuppath: can be nullptr
    :param flags: a combination of SETMENU_ flags (see Set menu flags)
    :returns: success
    """
    ...

def attach_action_to_toolbar(toolbar_name: str, name: str) -> bool:
    r"""Attach an action to an existing toolbar (ui_attach_action_to_toolbar). 
            
    :param toolbar_name: the name of the toolbar
    :param name: the action name
    :returns: success
    """
    ...

def attach_custom_data_format(dtid: int, dfid: int) -> bool:
    r"""Attach the data format to the data type. 
            
    :param dtid: data type id that can use the data format. 0 means all standard data types. Such data formats can be applied to any data item or instruction operands. For instruction operands, the data_format_t::value_size check is not performed by the kernel.
    :param dfid: data format id
    :returns: true: ok
    :returns: false: no such `dtid`, or no such `dfid', or the data format has already been attached to the data type
    """
    ...

def attach_dynamic_action_to_popup(unused: Any, popup_handle: Any, desc: Any, popuppath: Any = None, flags: Any = 0) -> Any:
    r"""Create & insert an action into the widget's popup menu
    (::ui_attach_dynamic_action_to_popup).
    Note: The action description in the 'desc' parameter is modified by
          this call so you should prepare a new description for each call.
    For example:
        desc = ida_kernwin.action_desc_t(None, 'Dynamic popup action', Handler())
        ida_kernwin.attach_dynamic_action_to_popup(form, popup, desc)
    
    :param unused:       deprecated; should be None
    :param popup_handle: target popup
    :param desc:         action description of type action_desc_t
    :param popuppath:    can be None
    :param flags:        a combination of SETMENU_ constants
    :returns: success
    """
    ...

def attach_process(args: Any) -> int:
    r"""Attach the debugger to a running process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_attach} 
            
    :param pid: PID of the process to attach to. If NO_PROCESS, a dialog box will interactively ask the user for the process to attach to.
    :param event_id: event to trigger upon attaching
    :returns: -4: debugger was not inited
    :returns: -3: the attaching is not supported
    :returns: -2: impossible to find a compatible process
    :returns: -1: impossible to attach to the given process (process died, privilege needed, not supported by the debugger plugin, ...)
    :returns: 0: the user cancelled the attaching to the process
    :returns: 1: the debugger properly attached to the process
    """
    ...

def auto_apply_tail(tail_ea: ida_idaapi.ea_t, parent_ea: ida_idaapi.ea_t) -> None:
    r"""Plan to apply the tail_ea chunk to the parent 
            
    :param tail_ea: linear address of start of tail
    :param parent_ea: linear address within parent. If BADADDR, automatically try to find parent via xrefs.
    """
    ...

def auto_apply_type(caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None:
    r"""Plan to apply the callee's type to the calling point.
    
    """
    ...

def auto_cancel(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None:
    r"""Remove an address range (ea1..ea2) from queues AU_CODE, AU_PROC, AU_USED. To remove an address range from other queues use auto_unmark() function. 'ea1' may be higher than 'ea2', the kernel will swap them in this case. 'ea2' doesn't belong to the range. 
            
    """
    ...

def auto_get(type: atype_t, lowEA: ida_idaapi.ea_t, highEA: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Retrieve an address from queues regarding their priority. Returns BADADDR if no addresses not lower than 'lowEA' and less than 'highEA' are found in the queues. Otherwise *type will have queue type. 
            
    """
    ...

def auto_is_ok() -> bool:
    r"""Are all queues empty? (i.e. has autoanalysis finished?). 
            
    """
    ...

def auto_make_code(ea: ida_idaapi.ea_t) -> None:
    r"""Plan to make code.
    
    """
    ...

def auto_make_proc(ea: ida_idaapi.ea_t) -> None:
    r"""Plan to make code&function.
    
    """
    ...

def auto_make_step(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool:
    r"""Analyze one address in the specified range and return true. 
            
    :returns: if processed anything. false means that there is nothing to process in the specified range.
    """
    ...

def auto_mark(ea: ida_idaapi.ea_t, type: atype_t) -> None:
    r"""Put single address into a queue. Queues keep addresses sorted.
    
    """
    ...

def auto_mark_range(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: atype_t) -> None:
    r"""Put range of addresses into a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
            
    """
    ...

def auto_postpone_analysis(ea: ida_idaapi.ea_t) -> bool:
    r"""Plan to reanalyze on the second pass The typical usage of this function in emu.cpp is: if ( !auto_postpone_analysis(ea) ) op_offset(ea, 0, ...); (we make an offset only on the second pass) 
            
    """
    ...

def auto_recreate_insn(ea: ida_idaapi.ea_t) -> int:
    r"""Try to create instruction 
            
    :param ea: linear address of callee
    :returns: the length of the instruction or 0
    """
    ...

def auto_unmark(start: ida_idaapi.ea_t, end: ida_idaapi.ea_t, type: atype_t) -> None:
    r"""Remove range of addresses from a queue. 'start' may be higher than 'end', the kernel will swap them in this case. 'end' doesn't belong to the range. 
            
    """
    ...

def auto_wait() -> bool:
    r"""Process everything in the queues and return true. 
            
    :returns: false if the user clicked cancel. (the wait box must be displayed by the caller if desired)
    """
    ...

def auto_wait_range(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> ssize_t:
    r"""Process everything in the specified range and return true. 
            
    :returns: number of autoanalysis steps made. -1 if the user clicked cancel. (the wait box must be displayed by the caller if desired)
    """
    ...

def banner(wait: int) -> bool:
    r"""Show a banner dialog box (ui_banner). 
            
    :param wait: time to wait before closing
    :returns: 1: ok
    :returns: 0: esc was pressed
    """
    ...

def base2file(fp: FILE, pos: qoff64_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> int:
    r"""Unload database to a binary file. This function works for wide byte processors too. 
            
    :param fp: pointer to file
    :param pos: position in the file
    :param ea1: range of source linear addresses
    :param ea2: range of source linear addresses
    :returns: 1-ok(always), write error leads to immediate exit
    """
    ...

def beep(beep_type: beep_t = 0) -> None:
    r"""Issue a beeping sound (ui_beep). 
            
    :param beep_type: beep_t
    """
    ...

def begin_type_updating(utp: update_type_t) -> None:
    r"""Mark the beginning of a large update operation on the types. Can be used with add_enum_member(), add_struc_member, etc... Also see end_type_updating() 
            
    """
    ...

def bin_flag() -> flags64_t:
    r"""Get number flag of the base, regardless of current processor - better to use num_flag()
    
    """
    ...

def bin_search(args: Any) -> Any:
    r"""Search for a set of bytes in the program
    
    This function has the following signatures:
    
        1. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t, flags: int) -> Tuple[ida_idaapi.ea_t, int]
        2. bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, image: bytes, mask: bytes, len: int, flags: int) -> ida_idaapi.ea_t
    
    The return value type will differ depending on the form:
    
        1. a tuple `(matched-address, index-in-compiled_binpat_vec_t)` (1st form)
        2. the address of a match, or ida_idaapi.BADADDR if not found (2nd form)
    
    This is a low-level function; more user-friendly alternatives
    are available. Please see 'find_bytes' and 'find_string'.
    
    :param start_ea: linear address, start of range to search
    :param end_ea: linear address, end of range to search (exclusive)
    :param data: (1st form) the prepared data to search for (see parse_binpat_str())
    :param bytes: (2nd form) a set of bytes to match
    :param mask: (2nd form) a mask to apply to the set of bytes
    :param flags: combination of BIN_SEARCH_* flags
    :returns: either a tuple holding both the address of the match and the index of the compiled pattern that matched, or the address of a match (ida_idaapi.BADADDR if not found)
    """
    ...

def bitcountr_zero(x: uint64) -> int:
    r"""count the number of consecutive trailing zero bits (line C++20 std::countr_zero()) 
            
    """
    ...

def block_chains_begin(set: block_chains_t) -> block_chains_iterator_t:
    r"""Get iterator pointing to the beginning of block_chains_t.
    
    """
    ...

def block_chains_clear(set: block_chains_t) -> None:
    r"""Clear block_chains_t.
    
    """
    ...

def block_chains_end(set: block_chains_t) -> block_chains_iterator_t:
    r"""Get iterator pointing to the end of block_chains_t.
    
    """
    ...

def block_chains_erase(set: block_chains_t, p: block_chains_iterator_t) -> None:
    r"""Erase current element from block_chains_t.
    
    """
    ...

def block_chains_find(set: block_chains_t, val: chain_t) -> block_chains_iterator_t:
    r"""Find the specified key in set block_chains_t.
    
    """
    ...

def block_chains_free(set: block_chains_t) -> None:
    r"""Delete block_chains_t instance.
    
    """
    ...

def block_chains_get(p: block_chains_iterator_t) -> chain_t:
    r"""Get reference to the current set value.
    
    """
    ...

def block_chains_insert(set: block_chains_t, val: chain_t) -> block_chains_iterator_t:
    r"""Insert new (chain_t) into set block_chains_t.
    
    """
    ...

def block_chains_new() -> block_chains_t:
    r"""Create a new block_chains_t instance.
    
    """
    ...

def block_chains_next(p: block_chains_iterator_t) -> block_chains_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def block_chains_prev(p: block_chains_iterator_t) -> block_chains_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def block_chains_size(set: block_chains_t) -> int:
    r"""Get size of block_chains_t.
    
    """
    ...

def bookmarks_t_erase(e: lochist_entry_t, index: int, ud: void) -> bool:
    ...

def bookmarks_t_find_index(e: lochist_entry_t, ud: void) -> int:
    ...

def bookmarks_t_get(out: lochist_entry_t, _index: int, ud: void) -> Any:
    ...

def bookmarks_t_get_desc(e: lochist_entry_t, index: int, ud: void) -> str:
    ...

def bookmarks_t_get_dirtree_id(e: lochist_entry_t, ud: void) -> dirtree_id_t:
    ...

def bookmarks_t_mark(e: lochist_entry_t, index: int, title: str, desc: str, ud: void) -> int:
    ...

def bookmarks_t_size(e: lochist_entry_t, ud: void) -> int:
    ...

def boundaries_begin(map: boundaries_t) -> boundaries_iterator_t:
    r"""Get iterator pointing to the beginning of boundaries_t.
    
    """
    ...

def boundaries_clear(map: boundaries_t) -> None:
    r"""Clear boundaries_t.
    
    """
    ...

def boundaries_end(map: boundaries_t) -> boundaries_iterator_t:
    r"""Get iterator pointing to the end of boundaries_t.
    
    """
    ...

def boundaries_erase(map: boundaries_t, p: boundaries_iterator_t) -> None:
    r"""Erase current element from boundaries_t.
    
    """
    ...

def boundaries_find(map: boundaries_t, key: cinsn_t) -> boundaries_iterator_t:
    r"""Find the specified key in boundaries_t.
    
    """
    ...

def boundaries_first(p: boundaries_iterator_t) -> Any:
    r"""Get reference to the current map key.
    
    """
    ...

def boundaries_free(map: boundaries_t) -> None:
    r"""Delete boundaries_t instance.
    
    """
    ...

def boundaries_insert(map: boundaries_t, key: cinsn_t, val: rangeset_t) -> boundaries_iterator_t:
    r"""Insert new (cinsn_t *, rangeset_t) pair into boundaries_t.
    
    """
    ...

def boundaries_new() -> boundaries_t:
    r"""Create a new boundaries_t instance.
    
    """
    ...

def boundaries_next(p: boundaries_iterator_t) -> boundaries_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def boundaries_prev(p: boundaries_iterator_t) -> boundaries_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def boundaries_second(p: boundaries_iterator_t) -> rangeset_t:
    r"""Get reference to the current map value.
    
    """
    ...

def boundaries_size(map: boundaries_t) -> int:
    r"""Get size of boundaries_t.
    
    """
    ...

def bring_debugger_to_front() -> None:
    ...

def build_snapshot_tree(root: snapshot_t) -> bool:
    r"""Build the snapshot tree. 
            
    :param root: snapshot root that will contain the snapshot tree elements.
    :returns: success
    """
    ...

def build_stkvar_name(pfn: func_t, v: int) -> str:
    r"""Build automatic stack variable name. 
            
    :param pfn: pointer to function (can't be nullptr!)
    :param v: value of variable offset
    :returns: length of stack variable name or -1
    """
    ...

def build_stkvar_xrefs(out: xreflist_t, pfn: func_t, start_offset: int, end_offset: int) -> None:
    r"""Fill 'out' with a list of all the xrefs made from function 'pfn' to specified range of the pfn's stack frame. 
            
    :param out: the list of xrefs to fill.
    :param pfn: the function to scan.
    :param start_offset: start frame structure offset, in bytes
    :param end_offset: end frame structure offset, in bytes
    """
    ...

def build_strlist() -> None:
    r"""Rebuild the string list.
    
    """
    ...

def byte_flag() -> flags64_t:
    r"""Get a flags64_t representing a byte.
    
    """
    ...

def bytesize(ea: ida_idaapi.ea_t) -> int:
    r"""Get number of bytes required to store a byte at the given address.
    
    """
    ...

def calc_arglocs(fti: func_type_data_t) -> bool:
    ...

def calc_basevalue(target: ida_idaapi.ea_t, base: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Calculate the value of the reference base.
    
    """
    ...

def calc_bg_color(ea: ida_idaapi.ea_t) -> bgcolor_t:
    r"""Get background color for line at 'ea' 
            
    :returns: RGB color
    """
    ...

def calc_c_cpp_name(name: str, type: tinfo_t, ccn_flags: int) -> str:
    r"""Get C or C++ form of the name. 
            
    :param name: original (mangled or decorated) name
    :param type: name type if known, otherwise nullptr
    :param ccn_flags: one of C/C++ naming flags
    """
    ...

def calc_dataseg(insn: insn_t, n: int = -1, rgnum: int = -1) -> ida_idaapi.ea_t:
    ...

def calc_def_align(ea: ida_idaapi.ea_t, mina: int, maxa: int) -> int:
    r"""Calculate the default alignment exponent. 
            
    :param ea: linear address
    :param mina: minimal possible alignment exponent.
    :param maxa: minimal possible alignment exponent.
    """
    ...

def calc_default_idaplace_flags() -> int:
    r"""Get default disassembly line options.
    
    """
    ...

def calc_dflags(f: flags64_t, force: bool) -> flags64_t:
    ...

def calc_dist(p: point_t, q: point_t) -> double:
    r"""Calculate distance between p and q.
    
    """
    ...

def calc_fixup_size(type: fixup_type_t) -> int:
    r"""Calculate size of fixup in bytes (the number of bytes the fixup patches) 
            
    :returns: -1: means error
    """
    ...

def calc_frame_offset(pfn: func_t, off: int, insn: insn_t = None, op: op_t = None) -> int:
    r"""Calculate the offset of stack variable in the frame. 
            
    :param pfn: pointer to function (cannot be nullptr)
    :param off: the offset relative to stack pointer or frame pointer
    :param insn: the instruction
    :param op: the operand
    :returns: the offset in the frame
    """
    ...

def calc_func_size(pfn: func_t) -> int:
    r"""Calculate function size. This function takes into account all fragments of the function. 
            
    :param pfn: ptr to function structure
    """
    ...

def calc_gtn_flags(fromaddr: Any, ea: Any) -> Any:
    r"""
    Calculate flags for get_ea_name() function
    
    :param fromaddr: the referring address. May be BADADDR.
    :param ea: linear address
    
    :returns: flags
    
    """
    ...

def calc_idasgn_state(n: int) -> int:
    r"""Get state of a signature in the list of planned signatures 
            
    :param n: number of signature in the list (0..get_idasgn_qty()-1)
    :returns: state of signature or IDASGN_BADARG
    """
    ...

def calc_max_align(endea: ida_idaapi.ea_t) -> int:
    r"""Calculate the maximal possible alignment exponent. 
            
    :param endea: end address of the alignment item.
    :returns: a value in the 0..32 range
    """
    ...

def calc_max_item_end(ea: ida_idaapi.ea_t, how: int = 15) -> ida_idaapi.ea_t:
    r"""Calculate maximal reasonable end address of a new item. This function will limit the item with the current segment bounds. 
            
    :param ea: linear address
    :param how: when to stop the search. A combination of Item end search flags
    :returns: end of new item. If it is not possible to create an item, it will return 'ea'. If operation was cancelled by user, it will return 'ea'
    """
    ...

def calc_min_align(length: asize_t) -> int:
    r"""Calculate the minimal possible alignment exponent. 
            
    :param length: size of the item in bytes.
    :returns: a value in the 1..32 range
    """
    ...

def calc_number_of_children(loc: argloc_t, tif: tinfo_t, dont_deref_ptr: bool = False) -> int:
    r"""Calculate max number of lines of a formatted c data, when expanded (PTV_EXPAND). 
            
    :param loc: location of the data (ALOC_STATIC or ALOC_CUSTOM)
    :param tif: type info
    :param dont_deref_ptr: consider 'ea' as the ptr value
    :returns: 0: data is not expandable
    :returns: -1: error, see qerrno
    :returns: else: the max number of lines
    """
    ...

def calc_offset_base(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t:
    r"""Try to calculate the offset base This function takes into account the fixup information, current ds and cs values. 
            
    :param ea: the referencing instruction/data address
    :param n: operand number
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    :returns: output base address or BADADDR
    """
    ...

def calc_prefix_color(ea: ida_idaapi.ea_t) -> color_t:
    r"""Get prefix color for line at 'ea' 
            
    :returns: Line prefix colors
    """
    ...

def calc_probable_base_by_value(ea: ida_idaapi.ea_t, off: int) -> ida_idaapi.ea_t:
    r"""Try to calculate the offset base. 2 bases are checked: current ds and cs. If fails, return BADADDR 
            
    """
    ...

def calc_reference_data(target: ea_t, base: ea_t, _from: ida_idaapi.ea_t, ri: refinfo_t, opval: adiff_t) -> bool:
    r"""Calculate the target and base addresses of an offset expression. The calculated target and base addresses are returned in the locations pointed by 'base' and 'target'. In case 'ri.base' is BADADDR, the function calculates the offset base address from the referencing instruction/data address. The target address is copied from ri.target. If ri.target is BADADDR then the target is calculated using the base address and 'opval'. This function also checks if 'opval' matches the full value of the reference and takes in account the memory-mapping. 
            
    :param target: output target address
    :param base: output base address
    :param ri: reference info block from the database
    :param opval: operand value (usually op_t::value or op_t::addr)
    :returns: success
    """
    ...

def calc_retloc(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. calc_retloc(fti: func_type_data_t *) -> bool
        1. calc_retloc(retloc: argloc_t *, rettype: const tinfo_t &, cc: callcnv_t) -> bool
    
    # 0: calc_retloc(fti: func_type_data_t *) -> bool
    
    
    # 1: calc_retloc(retloc: argloc_t *, rettype: const tinfo_t &, cc: callcnv_t) -> bool
    
    
    """
    ...

def calc_stkvar_struc_offset(pfn: func_t, insn: insn_t, n: int) -> ida_idaapi.ea_t:
    r"""Calculate offset of stack variable in the frame structure. 
            
    :param pfn: pointer to function (cannot be nullptr)
    :param insn: the instruction
    :param n: 0..UA_MAXOP-1 operand number -1 if error, return BADADDR
    :returns: BADADDR if some error (issue a warning if stack frame is bad)
    """
    ...

def calc_switch_cases(ea: Any, si: Any) -> Any:
    r"""Get information about a switch's cases.
    
    The returned information can be used as follows:
    
        for idx in range(len(results.cases)):
            cur_case = results.cases[idx]
            for cidx in range(len(cur_case)):
                print("case: %d" % cur_case[cidx])
            print("  goto 0x%x" % results.targets[idx])
    
    :param ea: address of the 'indirect jump' instruction
    :param si: switch information
    
    :returns: a structure with 2 members: 'cases', and 'targets'.
    """
    ...

def calc_target(args: Any) -> ida_idaapi.ea_t:
    r"""This function has the following signatures:
    
        0. calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t
        1. calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t
    
    # 0: calc_target(from: ida_idaapi.ea_t, opval: adiff_t, ri: const refinfo_t &) -> ida_idaapi.ea_t
    
    Calculate the target using the provided refinfo_t.
    
    
    # 1: calc_target(from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t, n: int, opval: adiff_t) -> ida_idaapi.ea_t
    
    Retrieve refinfo_t structure and calculate the target.
    
    
    """
    ...

def calc_thunk_func_target(args: Any) -> Any:
    r"""Calculate target of a thunk function. 
            
    :param pfn: pointer to function (may not be nullptr)
    :returns: the target function or BADADDR
    """
    ...

def calc_tinfo_gaps(out: rangeset_t, typid: typid_t) -> bool:
    ...

def calc_type_size(til: til_t, type: bytes) -> Any:
    r"""Returns the size of a type
    :param til: Type info library. 'None' can be passed.
    :param type: serialized type byte string
    :returns: The size of the type (None on failure)
    """
    ...

def calc_varglocs(fti: func_type_data_t, regs: regobjs_t, stkargs: relobj_t, nfixed: int) -> bool:
    ...

def call_helper(rettype: Any, args: Any, rest: Any) -> Any:
    r"""Create a helper call.
    
    """
    ...

def call_idc_func__(args: Any, kwargs: Any) -> Any:
    ...

def call_nav_colorizer(colorizer: Any, ea: ida_idaapi.ea_t, nbytes: int) -> Any:
    r"""To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    
    :param colorizer: the Python colorizer to call
    :param ea: the address to colorize
    :param nbytes: the size of the range to colorize
    """
    ...

def can_be_off32(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Does the specified address contain a valid OFF32 value?. For symbols in special segments the displacement is not taken into account. If yes, then the target address of OFF32 will be returned. If not, then BADADDR is returned. 
            
    """
    ...

def can_decode(ea: ida_idaapi.ea_t) -> bool:
    r"""Can the bytes at address 'ea' be decoded as instruction? 
            
    :param ea: linear address
    :returns: whether or not the contents at that address could be a valid instruction
    """
    ...

def can_define_item(ea: ida_idaapi.ea_t, length: asize_t, flags: flags64_t) -> bool:
    r"""Can define item (instruction/data) of the specified 'length', starting at 'ea'? 
    * a new item would cross segment boundaries
    * a new item would overlap with existing items (except items specified by 'flags') 
    
    
            
    :param ea: start of the range for the new item
    :param length: length of the new item in bytes
    :param flags: if not 0, then the kernel will ignore the data types specified by the flags and destroy them. For example: 
                     1000 dw 5
                     1002 db 5 ; undef
                     1003 db 5 ; undef
                     1004 dw 5
                     1006 dd 5
                      can_define_item(1000, 6, 0) - false because of dw at 1004 
     can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed
    :returns: 1-yes, 0-no
    """
    ...

def can_exc_continue(ev: debug_event_t) -> bool:
    ...

def cancel_exec_request(req_id: int) -> bool:
    r"""Try to cancel an asynchronous exec request (::ui_cancel_exec_request). 
            
    :param req_id: request id
    :returns: true: successfully canceled
    :returns: false: request has already been processed.
    """
    ...

def cancel_thread_exec_requests(tid: __qthread_t) -> int:
    r"""Try to cancel asynchronous exec requests created by the specified thread. 
            
    :param tid: thread id
    :returns: number of the canceled requests.
    """
    ...

def cexpr_operands(self: Any) -> Any:
    r"""return a dictionary with the operands of a cexpr_t. """
    ...

def cfg_get_cc_header_path(compid: comp_t) -> str:
    ...

def cfg_get_cc_parm(compid: comp_t, name: str) -> str:
    ...

def cfg_get_cc_predefined_macros(compid: comp_t) -> str:
    ...

def cfunc_type(self: Any) -> Any:
    r"""Get the function's return type tinfo_t object. """
    ...

def change_hexrays_config(directive: str) -> bool:
    r"""Parse DIRECTIVE and update the current configuration variables. For the syntax see hexrays.cfg 
            
    """
    ...

def change_segment_status(s: segment_t, is_deb_segm: bool) -> int:
    r"""Convert a debugger segment to a regular segment and vice versa. When converting debug->regular, the memory contents will be copied to the database. 
            
    :param s: segment to modify
    :param is_deb_segm: new status of the segment
    :returns: Change segment status result codes
    """
    ...

def change_storage_type(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: storage_type_t) -> error_t:
    r"""Change flag storage type for address range. 
            
    :param start_ea: should be lower than end_ea.
    :param end_ea: does not belong to the range.
    :param stt: storage_type_t
    :returns: error code
    """
    ...

def char_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def check_bpt(ea: ida_idaapi.ea_t) -> int:
    r"""Check the breakpoint at the specified address. 
            
    :returns: one of Breakpoint status codes
    """
    ...

def check_process_exit(handle: void, exit_code: int, msecs: int = -1) -> int:
    r"""Check whether process has terminated or not. 
            
    :param handle: process handle to wait for
    :param exit_code: pointer to the buffer for the exit code
    :returns: 0: process has exited, and the exit code is available. if *exit_code < 0: the process was killed with a signal -*exit_code
    :returns: 1: process has not exited yet
    :returns: -1: error happened, see error code for winerr() in *exit_code
    """
    ...

def choose_activate(_self: Any) -> None:
    ...

def choose_choose(_self: Any) -> Any:
    ...

def choose_close(_self: Any) -> None:
    ...

def choose_create_embedded_chobj(_self: Any) -> Any:
    ...

def choose_entry(title: str) -> ida_idaapi.ea_t:
    r"""Choose an entry point (ui_choose, chtype_entry). 
            
    :param title: chooser title
    :returns: ea of selected entry point, BADADDR if none selected
    """
    ...

def choose_enum(out: tinfo_t, title: str, default_ord: int) -> bool:
    r"""Choose an enum (ui_choose, chtype_enum). 
            
    :param out: the selected enum type
    :param title: chooser title
    :param default_ord: ordinal of enum to select by default
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_enum_by_value(out: tinfo_t, title: str, default_ord: int, value: uint64, nbytes: int) -> uchar:
    r"""Choose an enum, restricted by value & size (ui_choose, chtype_enum_by_value_and_size). If the given value cannot be found initially, this function will ask if the user would like to import a standard enum. 
            
    :param out: the selected enum type
    :param title: chooser title
    :param default_ord: ordinal of enum to select by default
    :param value: value to search for
    :param nbytes: size of value
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_find(title: str) -> Any:
    r"""Retrieve the chooser object by title
    
    :param title: the chooser title
    :returns: the chooser, or None
    """
    ...

def choose_func(title: str, default_ea: ida_idaapi.ea_t) -> func_t:
    r"""Choose a function (ui_choose, chtype_func). 
            
    :param title: chooser title
    :param default_ea: ea of function to select by default
    :returns: pointer to function that was selected, nullptr if none selected
    """
    ...

def choose_get_widget(_self: Any) -> TWidget:
    ...

def choose_idasgn() -> Any:
    r"""Opens the signature chooser
    
    :returns: None or the selected signature name
    """
    ...

def choose_ioport_device2(_device: str, file: str, parse_params: choose_ioport_parser_t) -> bool:
    ...

def choose_local_tinfo(ti: til_t, title: str, func: local_tinfo_predicate_t = None, def_ord: int = 0, ud: void = None) -> int:
    r"""Choose a type from the local type library. 
            
    :param ti: pointer to til
    :param title: title of listbox to display
    :param func: predicate to select types to display (maybe nullptr)
    :param def_ord: ordinal to position cursor before choose
    :param ud: user data
    :returns: == 0 means nothing is chosen, otherwise an ordinal number
    """
    ...

def choose_local_tinfo_and_delta(delta: int32, ti: til_t, title: str, func: local_tinfo_predicate_t = None, def_ord: int = 0, ud: void = None) -> int:
    r"""Choose a type from the local type library and specify the pointer shift value. 
            
    :param delta: pointer shift value
    :param ti: pointer to til
    :param title: title of listbox to display
    :param func: predicate to select types to display (maybe nullptr)
    :param def_ord: ordinal to position cursor before choose
    :param ud: user data
    :returns: == 0 means nothing is chosen, otherwise an ordinal number
    """
    ...

def choose_name(title: str) -> ida_idaapi.ea_t:
    r"""Choose a name (ui_choose, chtype_name). 
            
    :param title: chooser title
    :returns: ea of selected name, BADADDR if none selected
    """
    ...

def choose_named_type(out_sym: til_symbol_t, root_til: til_t, title: str, ntf_flags: int, predicate: predicate_t = None) -> bool:
    r"""Choose a type from a type library. 
            
    :param out_sym: pointer to be filled with the chosen type
    :param root_til: pointer to starting til (the function will inspect the base tils if allowed by flags)
    :param title: title of listbox to display
    :param ntf_flags: combination of Flags for named types
    :param predicate: predicate to select types to display (maybe nullptr)
    :returns: false if nothing is chosen, otherwise true
    """
    ...

def choose_refresh(_self: Any) -> None:
    ...

def choose_segm(title: str, default_ea: ida_idaapi.ea_t) -> segment_t:
    r"""Choose a segment (ui_choose, chtype_segm). 
            
    :param title: chooser title
    :param default_ea: ea of segment to select by default
    :returns: pointer to segment that was selected, nullptr if none selected
    """
    ...

def choose_srcp(title: str) -> sreg_range_t:
    r"""Choose a segment register change point (ui_choose, chtype_srcp). 
            
    :param title: chooser title
    :returns: pointer to segment register range of selected change point, nullptr if none selected
    """
    ...

def choose_stkvar_xref(pfn: func_t, srkvar_tid: tid_t) -> ida_idaapi.ea_t:
    r"""Choose an xref to a stack variable (ui_choose, chtype_name). 
            
    :param pfn: function
    :param srkvar_tid: frame variable TID
    :returns: ea of the selected xref, BADADDR if none selected
    """
    ...

def choose_struct(out: tinfo_t, title: str) -> bool:
    r"""Choose a structure (ui_choose, chtype_struct). 
            
    :param out: the selected structure type
    :param title: chooser title
    :returns: true: the selected type is in OUT
    :returns: false: nothing was selected
    """
    ...

def choose_til() -> str:
    r"""Choose a type library (ui_choose, chtype_idatil). 
            
    :returns: true: 'buf' was filled with the name of the selected til
    :returns: false: otherwise
    """
    ...

def choose_trace_file() -> str:
    r"""Show the choose trace dialog.
    
    """
    ...

def choose_xref(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Choose an xref to an address (ui_choose, chtype_xref). 
            
    :param to: referenced address
    :returns: ea of selected xref, BADADDR if none selected
    """
    ...

def chunk_size(ea: ida_idaapi.ea_t) -> int:
    r"""Get size of the contiguous address block containing 'ea'. 
            
    :returns: 0 if 'ea' doesn't belong to the program.
    """
    ...

def chunk_start(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get start of the contiguous address block containing 'ea'. 
            
    :returns: BADADDR if 'ea' doesn't belong to the program.
    """
    ...

def cinsn_details(self: Any) -> Any:
    r"""
    return the details pointer for the cinsn_t object depending on the value of its op member.     this is one of the cblock_t, cif_t, etc. objects.
    
    """
    ...

def citem_to_specific_type(self: Any) -> Any:
    r"""cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. """
    ...

def cleanup_appcall(tid: thid_t) -> error_t:
    r"""Cleanup after manual appcall. 
            
    :param tid: thread to use. NO_THREAD means to use the current thread The application state is restored as it was before calling the last appcall(). Nested appcalls are supported.
    :returns: eOk if successful, otherwise an error code
    """
    ...

def cleanup_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> str:
    ...

def clear_cached_cfuncs() -> None:
    r"""Flush all cached decompilation results.
    
    """
    ...

def clear_refresh_request(mask: uint64) -> None:
    ...

def clear_requests_queue() -> None:
    r"""Clear the queue of waiting requests. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def clear_strlist() -> None:
    r"""Clear the string list.
    
    """
    ...

def clear_tinfo_t(_this: tinfo_t) -> None:
    ...

def clear_trace() -> None:
    r"""Clear all events in the trace buffer. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    """
    ...

def close_chooser(title: str) -> bool:
    r"""Close a non-modal chooser (ui_close_chooser). 
            
    :param title: window title of chooser to close
    :returns: success
    """
    ...

def close_hexrays_waitbox() -> None:
    r"""Close the waitbox displayed by the decompiler. Useful if DECOMP_NO_HIDE was used during decompilation. 
            
    """
    ...

def close_linput(li: linput_t) -> None:
    ...

def close_pseudocode(f: TWidget) -> bool:
    r"""Close pseudocode window. 
            
    :param f: pointer to window
    :returns: false if failed
    """
    ...

def close_widget(widget: TWidget, options: int) -> None:
    r"""Close widget (ui_close_widget, only gui version). 
            
    :param widget: pointer to the widget to close
    :param options: Form close flags
    """
    ...

def clr__bnot0(ea: ida_idaapi.ea_t) -> None:
    ...

def clr__bnot1(ea: ida_idaapi.ea_t) -> None:
    ...

def clr__invsign0(ea: ida_idaapi.ea_t) -> None:
    ...

def clr__invsign1(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_abits(ea: ida_idaapi.ea_t, bits: aflags_t) -> None:
    ...

def clr_align_flow(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_cancelled() -> None:
    r"""Clear "Cancelled" flag (ui_clr_cancelled)
    
    """
    ...

def clr_colored_item(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_database_flag(dbfl: int) -> None:
    ...

def clr_fixed_spd(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_has_lname(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_has_ti(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_has_ti0(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_has_ti1(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_libitem(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_lzero(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Clear toggle lzero bit. This function reset the display of leading zeroes for the specified operand to the default. If the default is not to display leading zeroes, leading zeroes will not be displayed, as vice versa. 
            
    :param ea: the item (insn/data) address
    :param n: the operand number (0-first operand, 1-other operands)
    :returns: success
    """
    ...

def clr_lzero0(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_lzero1(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_node_info(gid: graph_id_t, node: int, flags: int) -> None:
    r"""Clear node info for the given node. 
            
    :param gid: id of desired graph
    :param node: node number
    :param flags: combination of Node info flags, identifying which fields of node_info_t will be cleared
    """
    ...

def clr_noret(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_notcode(ea: ida_idaapi.ea_t) -> None:
    r"""Clear not-code mark.
    
    """
    ...

def clr_notproc(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_op_type(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Remove operand representation information. (set operand representation to be 'undefined') 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :returns: success
    """
    ...

def clr_retfp(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_terse_struc(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_tilcmt(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_usemodsp(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_usersp(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_userti(ea: ida_idaapi.ea_t) -> None:
    ...

def clr_zstroff(ea: ida_idaapi.ea_t) -> None:
    ...

def code_flag() -> flags64_t:
    r"""FF_CODE
    
    """
    ...

def collect_stack_trace(tid: thid_t, trace: call_stack_t) -> bool:
    ...

def combine_flags(F: flags64_t) -> flags64_t:
    ...

def compact_til(ti: til_t) -> bool:
    r"""Collect garbage in til. Must be called before storing the til. 
            
    :returns: true if any memory was freed
    """
    ...

def compare_tinfo(t1: typid_t, t2: typid_t, tcflags: int) -> bool:
    ...

def compile_idc_file(nonnul_line: str) -> str:
    ...

def compile_idc_snippet(func: str, text: str, resolver: idc_resolver_t = None, only_safe_funcs: bool = False) -> str:
    r"""Compile text with IDC statements. 
            
    :param func: name of the function to create out of the snippet
    :param text: text to compile
    :param resolver: callback object to get values of undefined variables This object will be called if IDC function contains references to undefined variables. May be nullptr.
    :param only_safe_funcs: if true, any calls to functions without EXTFUN_SAFE flag will lead to a compilation error.
    :returns: true: ok
    :returns: false: error, see errbuf
    """
    ...

def compile_idc_text(nonnul_line: str) -> str:
    ...

def construct_macro(args: Any) -> Any:
    r"""See ua.hpp's construct_macro().
    
    This function has the following signatures
    
        1. construct_macro(insn: insn_t, enable: bool, build_macro: callable) -> bool
        2. construct_macro(constuctor: macro_constructor_t, insn: insn_t, enable: bool) -> bool
    
    :param insn: the instruction to build the macro for
    :param enable: enable macro generation
    :param build_macro: a callable with 2 arguments: an insn_t, and
                        whether it is ok to consider the next instruction
                        for the macro
    :param constructor: a macro_constructor_t implementation
    :returns: success
    """
    ...

def contains_fixups(ea: ida_idaapi.ea_t, size: asize_t) -> bool:
    r"""Does the specified address range contain any fixup information?
    
    """
    ...

def continue_backwards() -> bool:
    r"""Continue the execution of the process in the debugger backwards. Can only be used with debuggers that support time-travel debugging. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
            
    """
    ...

def continue_process() -> bool:
    r"""Continue the execution of the process in the debugger. \sq{Type, Synchronous function - available as Request, Notification, none (synchronous function)} 
            
    """
    ...

def convert_pt_flags_to_hti(pt_flags: int) -> int:
    r"""Convert Type parsing flags to Type formatting flags. Type parsing flags lesser than 0x10 don't have stable meaning and will be ignored (more on these flags can be seen in idc.idc) 
            
    """
    ...

def convert_to_user_call(udc: udcall_t, cdg: codegen_t) -> merror_t:
    r"""try to generate user-defined call for an instruction 
            
    :returns: Microcode error code code: MERR_OK - user-defined call generated else - error (MERR_INSN == inacceptable udc.tif)
    """
    ...

def copy_bits(v: Any, s: Any, e: Any = -1) -> Any:
    r"""
    Copy bits from a value
    :param v: the value
    :param s: starting bit (0-based)
    :param e: ending bit
    
    """
    ...

def copy_idcv(dst: idc_value_t, src: idc_value_t) -> error_t:
    r"""Copy 'src' to 'dst'. For idc objects only a reference is copied. 
            
    """
    ...

def copy_named_type(dsttil: til_t, srctil: til_t, name: str) -> int:
    r"""Copy a named type from one til to another. This function will copy the specified type and all dependent types from the source type library to the destination library. 
            
    :param dsttil: Destination til. It must have original types enabled
    :param srctil: Source til.
    :param name: name of the type to copy
    :returns: ordinal number of the copied type. 0 means error
    """
    ...

def copy_sreg_ranges(dst_rg: int, src_rg: int, map_selector: bool = False) -> None:
    r"""Duplicate segment register ranges. 
            
    :param dst_rg: number of destination segment register
    :param src_rg: copy ranges from
    :param map_selector: map selectors to linear addresses using sel2ea()
    """
    ...

def copy_tinfo_t(_this: tinfo_t, r: tinfo_t) -> None:
    ...

def cpu2ieee(ieee_out: fpvalue_t, cpu_fpval: void, size: int) -> int:
    r"""Convert a floating point number in CPU native format to IDA's internal format. 
            
    :param ieee_out: output buffer
    :param cpu_fpval: floating point number in CPU native format
    :param size: size of cpu_fpval in bytes (size of the input buffer)
    :returns: Floating point/IEEE Conversion codes
    """
    ...

def create_16bit_data(ea: ida_idaapi.ea_t, length: asize_t) -> bool:
    r"""Convert to 16-bit quantity (take the byte size into account)
    
    """
    ...

def create_32bit_data(ea: ida_idaapi.ea_t, length: asize_t) -> bool:
    r"""Convert to 32-bit quantity (take the byte size into account)
    
    """
    ...

def create_align(ea: ida_idaapi.ea_t, length: asize_t, alignment: int) -> bool:
    r"""Create an alignment item. 
            
    :param ea: linear address
    :param length: size of the item in bytes. 0 means to infer from ALIGNMENT
    :param alignment: alignment exponent. Example: 3 means align to 8 bytes. 0 means to infer from LENGTH It is forbidden to specify both LENGTH and ALIGNMENT as 0.
    :returns: success
    """
    ...

def create_byte(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to byte.
    
    """
    ...

def create_bytearray_linput(s: str) -> linput_t:
    ...

def create_cfunc(mba: mba_t) -> cfuncptr_t:
    r"""Create a new cfunc_t object. 
            
    :param mba: microcode object. After creating the cfunc object it takes the ownership of MBA.
    """
    ...

def create_code_viewer(custview: TWidget, flags: int = 0, parent: TWidget = None) -> TWidget:
    r"""Create a code viewer (ui_create_code_viewer). A code viewer contains on the left side a widget representing the line numbers, and on the right side, the child widget passed as parameter. It will inherit its title from the child widget.
    
    :param custview: the custom view to be added
    :param flags: Code viewer flags
    :param parent: widget to contain the new code viewer
    """
    ...

def create_custdata(ea: ida_idaapi.ea_t, length: asize_t, dtid: int, fid: int, force: bool = False) -> bool:
    r"""Convert to custom data type.
    
    """
    ...

def create_data(ea: ida_idaapi.ea_t, dataflag: flags64_t, size: asize_t, tid: tid_t) -> bool:
    r"""Convert to data (byte, word, dword, etc). This function may be used to create arrays. 
            
    :param ea: linear address
    :param dataflag: type of data. Value of function byte_flag(), word_flag(), etc.
    :param size: size of array in bytes. should be divisible by the size of one item of the specified type. for variable sized items it can be specified as 0, and the kernel will try to calculate the size.
    :param tid: type id. If the specified type is a structure, then tid is structure id. Otherwise should be BADNODE.
    :returns: success
    """
    ...

def create_disasm_graph(args: Any) -> interactive_graph_t:
    r"""This function has the following signatures:
    
        0. create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
        1. create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    # 0: create_disasm_graph(ea: ida_idaapi.ea_t) -> interactive_graph_t *
    
    Create a graph for the function that contains 'ea'.
    
    
    # 1: create_disasm_graph(ranges: const rangevec_t &) -> interactive_graph_t *
    
    Create a graph using an arbitrary set of ranges.
    
    
    """
    ...

def create_double(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to double.
    
    """
    ...

def create_dword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to dword.
    
    """
    ...

def create_empty_mba(mbr: mba_ranges_t, hf: hexrays_failure_t = None) -> mba_t:
    r"""Create an empty microcode object.
    
    """
    ...

def create_empty_widget(title: str, icon: int = -1) -> TWidget:
    r"""Create an empty widget, serving as a container for custom user widgets 
            
    """
    ...

def create_encoding_helper(args: Any) -> encoder_t:
    ...

def create_enum_type(enum_name: str, ei: enum_type_data_t, enum_width: int, sign: type_sign_t, convert_to_bitmask: bool, enum_cmt: str = None) -> tid_t:
    r"""Create type enum 
            
    :param enum_name: type name
    :param ei: enum type data
    :param enum_width: the width of an enum element allowed values: 0 (unspecified),1,2,4,8,16,32,64
    :param sign: enum sign
    :param convert_to_bitmask: try convert enum to bitmask enum
    :param enum_cmt: enum type comment
    :returns: enum TID
    """
    ...

def create_field_name(args: Any) -> str:
    ...

def create_float(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to float.
    
    """
    ...

def create_generic_linput(gl: generic_linput_t) -> linput_t:
    ...

def create_graph_viewer(title: str, id: int, callback: hook_cb_t, ud: void, title_height: int, parent: TWidget = None) -> graph_viewer_t:
    r"""Create a custom graph viewer. 
            
    :param title: the widget title
    :param id: graph id
    :param callback: callback to handle graph notifications (graph_notification_t)
    :param ud: user data passed to callback
    :param title_height: node title height
    :param parent: the parent widget of the graph viewer
    :returns: new viewer
    """
    ...

def create_helper(args: Any) -> Any:
    r"""Create a helper object..
    
    """
    ...

def create_idcv_ref(ref: idc_value_t, v: idc_value_t) -> bool:
    r"""Create a variable reference. Currently only references to global variables can be created. 
            
    :param ref: ptr to the result
    :param v: variable to reference
    :returns: success
    """
    ...

def create_insn(ea: ida_idaapi.ea_t, out: insn_t = None) -> int:
    r"""Create an instruction at the specified address. This function checks if an instruction is present at the specified address and will try to create one if there is none. It will fail if there is a data item or other items hindering the creation of the new instruction. This function will also fill the 'out' structure. 
            
    :param ea: linear address
    :param out: the resulting instruction
    :returns: the length of the instruction or 0
    """
    ...

def create_interactive_graph(id: int) -> interactive_graph_t:
    r"""Create a new empty graph with given id.
    
    """
    ...

def create_memory_linput(start: ida_idaapi.ea_t, size: asize_t) -> linput_t:
    ...

def create_menu(name: str, label: str, menupath: str = None) -> bool:
    r"""Create a menu with the given name, label and optional position, either in the menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information about where the menu should be positioned. First, IDA will try and resolve the corresponding menu by its name. If such an existing menu is found and is present in the menubar, then the new menu will be inserted in the menubar before it. Otherwise, IDA will try to resolve 'menupath' as it would for attach_action_to_menu() and, if found, add the new menu like so: 
         The new 'My menu' submenu will appear in the 'Comments' submenu
         before the 'Enter comment..." command
         "My menu", "Edit/Comments/Enter comment...");
    
    
         The new 'My menu' submenu will appear at the end of the
         'Comments' submenu.
         "My menu", "Edit/Comments/");
    
    
            
    :param name: name of menu (must be unique)
    :param label: label of menu
    :param menupath: where should the menu be inserted
    :returns: success
    """
    ...

def create_mutable_graph(id: int) -> interactive_graph_t:
    r"""Create a new empty graph with given id.
    
    """
    ...

def create_nodeval_merge_handler(mhp: merge_handler_params_t, label: str, nodename: str, tag: uchar, nds_flags: int, node_helper: merge_node_helper_t = None, skip_empty_nodes: bool = True) -> merge_handler_t:
    r"""Create a merge handler for netnode scalar/string values 
            
    :param mhp: merging parameters
    :param label: handler short name (to be be appended to mhp.label)
    :param nodename: netnode name
    :param tag: a tag used to access values in the netnode
    :param nds_flags: netnode value attributes (a combination of nds_flags_t)
    :param skip_empty_nodes: do not create handler in case of empty netnode
    :returns: diff source object (normally should be attahced to a merge handler)
    """
    ...

def create_nodeval_merge_handlers(out: merge_handlers_t, mhp: merge_handler_params_t, nodename: str, valdesc: merge_node_info_t, skip_empty_nodes: bool = True) -> None:
    r"""Create a serie of merge handlers for netnode scalar/string values (call create_nodeval_merge_handler() for each member of VALDESC) 
            
    :param out: [out] created handlers will be placed here
    :param mhp: merging parameters
    :param nodename: netnode name
    :param valdesc: array of handler descriptions
    :param skip_empty_nodes: do not create handlers for empty netnodes
    :returns: diff source object (normally should be attahced to a merge handler)
    """
    ...

def create_numbered_type_name(ord: int) -> str:
    r"""Create anonymous name for numbered type. This name can be used to reference a numbered type by its ordinal Ordinal names have the following format: '#' + set_de(ord) Returns: -1 if error, otherwise the name length 
            
    """
    ...

def create_outctx(ea: ida_idaapi.ea_t, F: flags64_t = 0, suspop: int = 0) -> outctx_base_t:
    r"""Create a new output context. To delete it, just use "delete pctx" 
            
    """
    ...

def create_oword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to octaword/xmm word.
    
    """
    ...

def create_packed_real(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to packed decimal real.
    
    """
    ...

def create_qword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to quadword.
    
    """
    ...

def create_source_viewer(out_ccv: TWidget, parent: TWidget, custview: TWidget, sf: source_file_ptr, lines: strvec_t, lnnum: int, colnum: int, flags: int) -> source_view_t:
    r"""Create a source code view.
    
    """
    ...

def create_std_modmerge_handlers(mhp: merge_handler_params_t, helper: moddata_diff_helper_t, merge_node_info: merge_node_info2_t = None) -> None:
    r"""convinience function to create merge handlers for modules/plugins
    
    """
    ...

def create_strlit(start: ida_idaapi.ea_t, len: size_t, strtype: int) -> bool:
    r"""Convert to string literal and give a meaningful name. 'start' may be higher than 'end', the kernel will swap them in this case 
            
    :param start: starting address
    :param len: length of the string in bytes. if 0, then get_max_strlit_length() will be used to determine the length
    :param strtype: string type. one of String type codes
    :returns: success
    """
    ...

def create_struct(ea: ida_idaapi.ea_t, length: asize_t, tid: tid_t, force: bool = False) -> bool:
    r"""Convert to struct.
    
    """
    ...

def create_switch_table(ea: Any, si: Any) -> Any:
    r"""Create switch table from the switch information
    
    :param ea: address of the 'indirect jump' instruction
    :param si: switch information
    
    :returns: Boolean
    """
    ...

def create_switch_xrefs(ea: Any, si: Any) -> Any:
    r"""This function creates xrefs from the indirect jump.
    
    Usually there is no need to call this function directly because the kernel
    will call it for switch tables
    
    Note: Custom switch information are not supported yet.
    
    :param ea: address of the 'indirect jump' instruction
    :param si: switch information
    
    :returns: Boolean
    """
    ...

def create_tbyte(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to tbyte.
    
    """
    ...

def create_tinfo(_this: tinfo_t, bt: type_t, bt2: type_t, ptr: void) -> bool:
    ...

def create_toolbar(name: str, label: str, before: str = None, flags: int = 0) -> bool:
    r"""Create a toolbar with the given name, label and optional position 
            
    :param name: name of toolbar (must be unique)
    :param label: label of toolbar
    :param before: if non-nullptr, the toolbar before which the new toolbar will be inserted
    :param flags: a combination of create toolbar flags, to determine toolbar position
    :returns: success
    """
    ...

def create_typedef(args: Any) -> tinfo_t:
    r"""This function has the following signatures:
    
        0. create_typedef(name: str) -> tinfo_t
        1. create_typedef(n: int) -> tinfo_t
    
    # 0: create_typedef(name: str) -> tinfo_t
    
    Create a reference to a named type. 
            
    :returns: type which refers to the specified name. For example, if name is "DWORD", the type info which refers to "DWORD" is created.
    
    # 1: create_typedef(n: int) -> tinfo_t
    
    Create a reference to an ordinal type. 
            
    :returns: type which refers to the specified ordinal. For example, if n is 1, the type info which refers to ordinal type 1 is created.
    
    """
    ...

def create_undo_point(args: Any) -> bool:
    r"""Create a new restore point. The user can undo to this point in the future. 
            
    :param bytes: body of the record for UNDO_ACTION_START
    :param size: size of the record for UNDO_ACTION_START
    :returns: success; fails if undo is disabled
    """
    ...

def create_user_graph_place(node: int, lnnum: int) -> user_graph_place_t:
    r"""Get a copy of a user_graph_place_t (returns a pointer to static storage)
    
    """
    ...

def create_word(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to word.
    
    """
    ...

def create_yword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to ymm word.
    
    """
    ...

def create_zword(ea: ida_idaapi.ea_t, length: asize_t, force: bool = False) -> bool:
    r"""Convert to zmm word.
    
    """
    ...

def cust_flag() -> flags64_t:
    r"""Get a flags64_t representing custom type data.
    
    """
    ...

def custfmt_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def custom_viewer_jump(v: TWidget, loc: lochist_entry_t, flags: int = 0) -> bool:
    r"""Append 'loc' to the viewer's history, and cause the viewer to display it. 
            
    :param v: (TWidget *)
    :param loc: (const lochist_entry_t &)
    :param flags: (uint32) or'ed combination of CVNF_* values
    :returns: success
    """
    ...

def dbg_add_bpt_tev(tid: thid_t, ea: ida_idaapi.ea_t, bp: ida_idaapi.ea_t) -> bool:
    r"""Add a new breakpoint trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: false if the operation failed, true otherwise
    """
    ...

def dbg_add_call_tev(tid: thid_t, caller: ida_idaapi.ea_t, callee: ida_idaapi.ea_t) -> None:
    r"""Add a new call trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_add_debug_event(event: debug_event_t) -> None:
    r"""Add a new debug event to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_add_insn_tev(tid: thid_t, ea: ida_idaapi.ea_t, save: save_reg_values_t = 1) -> bool:
    r"""Add a new instruction trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: false if the operation failed, true otherwise
    """
    ...

def dbg_add_many_tevs(new_tevs: tevinforeg_vec_t) -> bool:
    r"""Add many new trace elements to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: false if the operation failed for any tev_info_t object
    """
    ...

def dbg_add_ret_tev(tid: thid_t, ret_insn: ida_idaapi.ea_t, return_to: ida_idaapi.ea_t) -> None:
    r"""Add a new return trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_add_tev(type: tev_type_t, tid: thid_t, address: ida_idaapi.ea_t) -> None:
    r"""Add a new trace element to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_add_thread(tid: thid_t) -> None:
    r"""Add a thread to the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_appcall(retval: idc_value_t, func_ea: ida_idaapi.ea_t, tid: thid_t, ptif: tinfo_t, argv: idc_value_t, argnum: size_t) -> error_t:
    r"""Call a function from the debugged application. 
            
    :param retval: function return value
    * for APPCALL_MANUAL, r will hold the new stack point value
    * for APPCALL_DEBEV, r will hold the exception information upon failure and the return code will be eExecThrow
    :param func_ea: address to call
    :param tid: thread to use. NO_THREAD means to use the current thread
    :param ptif: pointer to type of the function to call
    :param argv: array of arguments
    :param argnum: number of actual arguments
    :returns: eOk if successful, otherwise an error code
    """
    ...

def dbg_bin_search(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, data: compiled_binpat_vec_t, srch_flags: int) -> str:
    ...

def dbg_can_query() -> Any:
    r"""This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    
    :returns: Boolean
    """
    ...

def dbg_del_thread(tid: thid_t) -> None:
    r"""Delete a thread from the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def dbg_get_input_path() -> str:
    r"""Get debugger input file name/path (see LFLG_DBG_NOPATH)
    
    """
    ...

def dbg_get_memory_info() -> Any:
    r"""This function returns the memory configuration of a debugged process.
    
    :returns: tuple(start_ea, end_ea, name, sclass, sbase, bitness, perm), or None if no debugger is active
    """
    ...

def dbg_get_name() -> Any:
    r"""This function returns the current debugger's name.
    
    :returns: Debugger name or None if no debugger is active
    """
    ...

def dbg_get_registers() -> Any:
    r"""This function returns the register definition from the currently loaded debugger.
    Basically, it returns an array of structure similar to to idd.hpp / register_info_t
    
    :returns: None if no debugger is loaded
    :returns: tuple(name, flags, class, dtype, bit_strings, default_bit_strings_mask)
              The bit_strings can be a tuple of strings or None (if the register does not have bit_strings)
    """
    ...

def dbg_get_thread_sreg_base(tid: Any, sreg_value: Any) -> Any:
    r"""Returns the segment register base value
    
    :param tid: thread id
    :param sreg_value: segment register (selector) value
    :returns: The base as an 'ea', or None on failure
    """
    ...

def dbg_is_loaded() -> Any:
    r"""Checks if a debugger is loaded
    
    :returns: Boolean
    """
    ...

def dbg_read_memory(ea: Any, sz: Any) -> Any:
    r"""Reads from the debugee's memory at the specified ea
    
    :param ea: the debuggee's memory address
    :param sz: the amount of data to read
    :returns: The read buffer (as bytes), or None on failure
    """
    ...

def dbg_write_memory(ea: Any, buffer: Any) -> Any:
    r"""Writes a buffer to the debugee's memory
    
    :param ea: the debuggee's memory address
    :param buf: a bytes object to write
    :returns: Boolean
    """
    ...

def debug_hexrays_ctree(level: int, msg: str) -> None:
    ...

def dec_flag() -> flags64_t:
    r"""Get number flag of the base, regardless of current processor - better to use num_flag()
    
    """
    ...

def decode_insn(out: insn_t, ea: ida_idaapi.ea_t) -> int:
    r"""Analyze the specified address and fill 'out'. This function does not modify the database. It just tries to interpret the specified address as an instruction and fills the 'out' structure. 
            
    :param out: the resulting instruction
    :param ea: linear address
    :returns: the length of the (possible) instruction or 0
    """
    ...

def decode_preceding_insn(out: insn_t, ea: ida_idaapi.ea_t) -> Any:
    r"""Decodes the preceding instruction.
    
    :param out: instruction storage
    :param ea: current ea
    :returns: tuple(preceeding_ea or BADADDR, farref = Boolean)
    """
    ...

def decode_prev_insn(out: insn_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Decode previous instruction if it exists, fill 'out'. 
            
    :param out: the resulting instruction
    :param ea: the address to decode the previous instruction from
    :returns: the previous instruction address (BADADDR-no such insn)
    """
    ...

def decompile(ea: Any, hf: Any = None, flags: Any = 0) -> Any:
    r"""Decompile a snippet or a function. 
            
    :param hf: extended error information (if failed)
    :returns: pointer to the decompilation result (a reference counted pointer). nullptr if failed.
    """
    ...

def decompile_func(pfn: func_t, hf: hexrays_failure_t = None, decomp_flags: int = 0) -> cfuncptr_t:
    r"""Decompile a function. Multiple decompilations of the same function return the same object. 
            
    :param pfn: pointer to function to decompile
    :param hf: extended error information (if failed)
    :param decomp_flags: bitwise combination of decompile() flags... bits
    :returns: pointer to the decompilation result (a reference counted pointer). nullptr if failed.
    """
    ...

def decompile_many(outfile: str, funcaddrs: uint64vec_t, flags: int) -> bool:
    r"""Batch decompilation. Decompile all or the specified functions 
            
    :param outfile: name of the output file
    :param funcaddrs: list of functions to decompile. If nullptr or empty, then decompile all nonlib functions
    :param flags: Batch decompilation bits
    :returns: true if no internal error occurred and the user has not cancelled decompilation
    """
    ...

def decorate_name(args: Any) -> str:
    r"""Decorate/undecorate a C symbol name. 
            
    :param out: output buffer
    :param name: name of symbol
    :param should_decorate: true-decorate name, false-undecorate
    :param cc: calling convention
    :param type: name type (nullptr-unknown)
    :returns: success
    """
    ...

def deep_copy_idcv(dst: idc_value_t, src: idc_value_t) -> error_t:
    r"""Deep copy an IDC object. This function performs deep copy of idc objects. If 'src' is not an object, copy_idcv() will be called 
            
    """
    ...

def default_compiler() -> comp_t:
    r"""Get compiler specified by inf.cc.
    
    """
    ...

def define_exception(code: uint, name: str, desc: str, flags: int) -> str:
    r"""Convenience function: define new exception code. 
            
    :param code: exception code (cannot be 0)
    :param name: exception name (cannot be empty or nullptr)
    :param desc: exception description (maybe nullptr)
    :param flags: combination of Exception info flags
    :returns: failure message or nullptr. You must call store_exceptions() if this function succeeds
    """
    ...

def define_stkvar(pfn: func_t, name: str, off: int, tif: tinfo_t, repr: value_repr_t = None) -> bool:
    r"""Define/redefine a stack variable. 
            
    :param pfn: pointer to function
    :param name: variable name, nullptr means autogenerate a name
    :param off: offset of the stack variable in the frame. negative values denote local variables, positive - function arguments.
    :param tif: variable type
    :param repr: variable representation
    :returns: success
    """
    ...

def del_absbase(ea: ida_idaapi.ea_t) -> None:
    ...

def del_aflags(ea: ida_idaapi.ea_t) -> None:
    ...

def del_alignment(ea: ida_idaapi.ea_t) -> None:
    ...

def del_array_parameters(ea: ida_idaapi.ea_t) -> None:
    ...

def del_bpt(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. del_bpt(ea: ida_idaapi.ea_t) -> bool
        1. del_bpt(bptloc: const bpt_location_t &) -> bool
    
    # 0: del_bpt(ea: ida_idaapi.ea_t) -> bool
    
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    # 1: del_bpt(bptloc: const bpt_location_t &) -> bool
    
    Delete an existing breakpoint in the debugged process. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    
    """
    ...

def del_bptgrp(name: str) -> bool:
    r"""Delete a folder, bpt that were part of this folder are moved to the root folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param name: full path to the folder to be deleted
    :returns: success
    """
    ...

def del_cref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t, expand: bool) -> bool:
    r"""Delete a code cross-reference. 
            
    :param to: linear address of referenced instruction
    :param expand: policy to delete the referenced instruction
    * 1: plan to delete the referenced instruction if it has no more references.
    * 0: don't delete the referenced instruction even if no more cross-references point to it
    :returns: true: if the referenced instruction will be deleted
    """
    ...

def del_custom_data_type_ids(ea: ida_idaapi.ea_t) -> None:
    ...

def del_debug_names(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None:
    ...

def del_dref(frm: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> None:
    r"""Delete a data cross-reference. 
            
    :param to: linear address of referenced data
    """
    ...

def del_encoding(idx: int) -> bool:
    ...

def del_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> bool:
    ...

def del_fixup(source: ida_idaapi.ea_t) -> None:
    r"""Delete fixup information.
    
    """
    ...

def del_frame(pfn: func_t) -> bool:
    r"""Delete a function frame. 
            
    :param pfn: pointer to function structure
    :returns: success
    """
    ...

def del_func(ea: ida_idaapi.ea_t) -> bool:
    r"""Delete a function. 
            
    :param ea: any address in the function entry chunk
    :returns: success
    """
    ...

def del_global_name(ea: ida_idaapi.ea_t) -> bool:
    ...

def del_hidden_range(ea: ida_idaapi.ea_t) -> bool:
    r"""Delete hidden range. 
            
    :param ea: any address in the hidden range
    :returns: success
    """
    ...

def del_hotkey(ctx: Any) -> Any:
    r"""Deletes a previously registered function hotkey
    
    :param ctx: Hotkey context previously returned by add_hotkey()
    
    :returns: Boolean.
    """
    ...

def del_idasgn(n: int) -> int:
    r"""Remove signature from the list of planned signatures. 
            
    :param n: number of signature in the list (0..get_idasgn_qty()-1)
    :returns: IDASGN_OK, IDASGN_BADARG, IDASGN_APPLIED
    """
    ...

def del_idc_func(name: Any) -> Any:
    r"""Delete an IDC function 
            
    """
    ...

def del_idc_hotkey(hotkey: str) -> bool:
    ...

def del_idcv_attr(obj: idc_value_t, attr: str) -> error_t:
    r"""Delete an object attribute. 
            
    :param obj: variable that holds an object reference
    :param attr: attribute name
    :returns: error code, eOk on success
    """
    ...

def del_ind_purged(ea: ida_idaapi.ea_t) -> None:
    ...

def del_item_color(ea: ida_idaapi.ea_t) -> bool:
    ...

def del_items(ea: ida_idaapi.ea_t, flags: int = 0, nbytes: asize_t = 1, may_destroy: may_destroy_cb_t = None) -> bool:
    r"""Convert item (instruction/data) to unexplored bytes. The whole item (including the head and tail bytes) will be destroyed. It is allowed to pass any address in the item to this function 
            
    :param ea: any address within the first item to delete
    :param flags: combination of Unexplored byte conversion flags
    :param nbytes: number of bytes in the range to be undefined
    :param may_destroy: optional routine invoked before deleting a head item. If callback returns false then item is not to be deleted and operation fails
    :returns: true on sucessful operation, otherwise false
    """
    ...

def del_local_name(ea: ida_idaapi.ea_t) -> bool:
    ...

def del_mapping(ea: ida_idaapi.ea_t) -> None:
    r"""Delete memory mapping range. 
            
    :param ea: any address in the mapped range
    """
    ...

def del_named_type(ti: til_t, name: str, ntf_flags: int) -> bool:
    r"""Delete information about a symbol. 
            
    :param ti: type library
    :param name: name of symbol
    :param ntf_flags: combination of Flags for named types
    :returns: success
    """
    ...

def del_node_info(gid: graph_id_t, node: int) -> None:
    r"""Delete the node_info_t for the given node.
    
    """
    ...

def del_numbered_type(ti: til_t, ordinal: int) -> bool:
    r"""Delete a numbered type.
    
    """
    ...

def del_op_tinfo(ea: ida_idaapi.ea_t, n: int) -> None:
    ...

def del_refinfo(ea: ida_idaapi.ea_t, n: int) -> bool:
    ...

def del_regvar(pfn: func_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str) -> int:
    r"""Delete a register variable definition. 
            
    :param pfn: function in question
    :param ea1: range of addresses within the function where the definition holds
    :param ea2: range of addresses within the function where the definition holds
    :param canon: name of a general register
    :returns: Register variable error codes
    """
    ...

def del_segm(ea: ida_idaapi.ea_t, flags: int) -> bool:
    r"""Delete a segment. 
            
    :param ea: any address belonging to the segment
    :param flags: Segment modification flags
    :returns: 1: ok
    :returns: 0: failed, no segment at 'ea'.
    """
    ...

def del_segment_translations(segstart: ida_idaapi.ea_t) -> None:
    r"""Delete the translation list 
            
    :param segstart: start address of the segment to delete translation list
    """
    ...

def del_selector(selector: sel_t) -> None:
    r"""Delete mapping of a selector. Be wary of deleting selectors that are being used in the program, this can make a mess in the segments. 
            
    :param selector: number of selector to remove from the translation table
    """
    ...

def del_source_linnum(ea: ida_idaapi.ea_t) -> None:
    ...

def del_sourcefile(ea: ida_idaapi.ea_t) -> bool:
    ...

def del_sreg_range(ea: ida_idaapi.ea_t, rg: int) -> bool:
    r"""Delete segment register range started at ea. When a segment register range is deleted, the previous range is extended to cover the empty space. The segment register range at the beginning of a segment cannot be deleted. 
            
    :param ea: start_ea of the deleted range
    :param rg: the segment register number
    :returns: success
    """
    ...

def del_stkpnt(pfn: func_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Delete SP register change point. 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address
    :returns: success
    """
    ...

def del_str_type(ea: ida_idaapi.ea_t) -> None:
    ...

def del_switch_info(ea: ida_idaapi.ea_t) -> None:
    ...

def del_switch_parent(ea: ida_idaapi.ea_t) -> None:
    ...

def del_til(name: str) -> bool:
    r"""Unload a til file.
    
    """
    ...

def del_tinfo(ea: ida_idaapi.ea_t) -> None:
    ...

def del_tinfo_attr(tif: tinfo_t, key: str, make_copy: bool) -> bool:
    ...

def del_tryblks(range: range_t) -> None:
    r"""Delete try block information in the specified range. 
            
    :param range: the range to be cleared
    """
    ...

def del_value(ea: ida_idaapi.ea_t) -> None:
    r"""Delete byte value from flags. The corresponding byte becomes uninitialized. 
            
    """
    ...

def del_vftable_ea(ordinal: int) -> bool:
    r"""Delete the address of a vftable instance for a vftable type. 
            
    :param ordinal: ordinal number of a vftable type.
    :returns: success
    """
    ...

def del_virt_module(base: ea_t) -> bool:
    ...

def delay_slot_insn(ea: ea_t, bexec: bool, fexec: bool) -> bool:
    ...

def delete_extra_cmts(ea: ida_idaapi.ea_t, what: int) -> None:
    ...

def delete_frame_members(pfn: func_t, start_offset: int, end_offset: int) -> bool:
    r"""Delete frame members 
            
    :param pfn: pointer to function
    :param start_offset: member offset to start deletion from, in bytes
    :param end_offset: member offset which not included in the deletion, in bytes
    :returns: success
    """
    ...

def delete_imports() -> None:
    ...

def delete_interactive_graph(g: interactive_graph_t) -> None:
    r"""Delete graph object. 
            
    """
    ...

def delete_menu(name: str) -> bool:
    r"""Delete an existing menu 
            
    :param name: name of menu
    :returns: success
    """
    ...

def delete_mutable_graph(g: interactive_graph_t) -> None:
    r"""Delete graph object. 
            
    """
    ...

def delete_switch_table(jump_ea: ida_idaapi.ea_t, si: switch_info_t) -> None:
    ...

def delete_toolbar(name: str) -> bool:
    r"""Delete an existing toolbar 
            
    :param name: name of toolbar
    :returns: success
    """
    ...

def delinf(tag: inftag_t) -> bool:
    r"""Undefine a program specific information 
            
    :param tag: one of inftag_t constants
    :returns: success
    """
    ...

def demangle_name(name: str, disable_mask: int, demreq: demreq_type_t = 2) -> str:
    r"""Demangle a name. 
            
    :param name: name to demangle
    :param disable_mask: bits to inhibit parts of demangled name (see MNG_). by the M_COMPILER bits a specific compiler can be selected (see MT_).
    :param demreq: the request type demreq_type_t
    :returns: ME_... or MT__ bitmasks from demangle.hpp
    """
    ...

def deref_idcv(v: idc_value_t, vref_flags: int) -> idc_value_t:
    r"""Dereference a VT_REF variable. 
            
    :param v: variable to dereference
    :param vref_flags: Dereference IDC variable flags
    :returns: pointer to the dereference result or nullptr. If returns nullptr, qerrno is set to eExecBadRef "Illegal variable reference"
    """
    ...

def deref_ptr(ptr_ea: ea_t, tif: tinfo_t, closure_obj: ea_t = None) -> bool:
    r"""Dereference a pointer. 
            
    :param ptr_ea: in/out parameter
    * in: address of the pointer
    * out: the pointed address
    :param tif: type of the pointer
    :param closure_obj: closure object (not used yet)
    :returns: success
    """
    ...

def dereference(e: Any, ptrsize: Any, is_float: Any = False) -> Any:
    r"""Dereference a pointer. This function dereferences a pointer expression. It performs the following conversion: "ptr" => "*ptr" It can handle discrepancies in the pointer type and the access size. 
            
    :param e: expression to deference
    :param ptrsize: access size
    :returns: dereferenced expression
    """
    ...

def deserialize_tinfo(tif: tinfo_t, til: til_t, ptype: type_t, pfields: p_list, pfldcmts: p_list, cmt: str = None) -> bool:
    ...

def destroy_moddata_merge_handlers(data_id: int) -> None:
    ...

def detach_action_from_menu(menupath: str, name: str) -> bool:
    r"""Detach an action from the menu (ui_detach_action_from_menu). 
            
    :param menupath: path to the menu item
    :param name: the action name
    :returns: success
    """
    ...

def detach_action_from_popup(widget: TWidget, name: str) -> bool:
    r"""Remove a previously-registered action, from the list of 'permanent' context menu actions for this widget (ui_detach_action_from_popup). This only makes sense if the action has been added to 'widget's list of permanent popup actions by calling attach_action_to_popup in 'permanent' mode. 
            
    :param widget: target widget
    :param name: action name
    """
    ...

def detach_action_from_toolbar(toolbar_name: str, name: str) -> bool:
    r"""Detach an action from the toolbar (ui_detach_action_from_toolbar). 
            
    :param toolbar_name: the name of the toolbar
    :param name: the action name
    :returns: success
    """
    ...

def detach_custom_data_format(dtid: int, dfid: int) -> bool:
    r"""Detach the data format from the data type. Unregistering a custom data type detaches all attached data formats, no need to detach them explicitly. You still need unregister them. Unregistering a custom data format detaches it from all attached data types. 
            
    :param dtid: data type id to detach data format from
    :param dfid: data format id to detach
    :returns: true: ok
    :returns: false: no such `dtid`, or no such `dfid', or the data format was not attached to the data type
    """
    ...

def detach_process() -> bool:
    r"""Detach the debugger from the debugged process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_detach} 
            
    """
    ...

def detach_tinfo_t(_this: tinfo_t) -> bool:
    ...

def diff_trace_file(NONNULL_filename: str) -> bool:
    r"""Show difference between the current trace and the one from 'filename'.
    
    """
    ...

def disable_bblk_trace() -> bool:
    ...

def disable_bpt(args: Any) -> bool:
    ...

def disable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t) -> error_t:
    r"""Deallocate flags for address range. Exit with an error message if not enough disk space (this may occur too). 
            
    :param start_ea: should be lower than end_ea.
    :param end_ea: does not belong to the range.
    :returns: 0 if ok, otherwise return error code
    """
    ...

def disable_func_trace() -> bool:
    ...

def disable_insn_trace() -> bool:
    ...

def disable_script_timeout() -> Any:
    r"""Disables the script timeout and hides the script wait box.
    Calling L{set_script_timeout} will not have any effects until the script is compiled and executed again
    
    :returns: None
    """
    ...

def disable_step_trace() -> bool:
    ...

def display_copyright_warning() -> bool:
    r"""Display copyright warning (ui_copywarn). 
            
    :returns: yes/no
    """
    ...

def display_gdl(fname: str) -> int:
    r"""Display GDL file by calling wingraph32. The exact name of the grapher is taken from the configuration file and set up by setup_graph_subsystem(). The path should point to a temporary file: when wingraph32 succeeds showing the graph, the input file will be deleted. 
            
    :returns: error code from os, 0 if ok
    """
    ...

def display_widget(widget: TWidget, options: int, dest_ctrl: str = None) -> None:
    r"""Display a widget, dock it if not done before 
            
    :param widget: widget to display
    :param options: Widget open flags
    :param dest_ctrl: where to dock: if nullptr or invalid then use the active docker if there is not create a new tab relative to current active tab
    """
    ...

def double_flag() -> flags64_t:
    r"""Get a flags64_t representing a double.
    
    """
    ...

def dstr(tif: tinfo_t) -> str:
    r"""Print the specified type info. This function can be used from a debugger by typing "tif->dstr()" 
            
    """
    ...

def dstr_tinfo(tif: tinfo_t) -> str:
    ...

def dummy_ptrtype(ptrsize: int, isfp: bool) -> tinfo_t:
    r"""Generate a dummy pointer type 
            
    :param ptrsize: size of pointed object
    :param isfp: is floating point object?
    """
    ...

def dump_func_type_data(fti: func_type_data_t, praloc_bits: int) -> str:
    r"""Use func_type_data_t::dump()
    
    """
    ...

def dword_flag() -> flags64_t:
    r"""Get a flags64_t representing a double word.
    
    """
    ...

def ea2node(ea: ida_idaapi.ea_t) -> nodeidx_t:
    r"""Get netnode for the specified address.
    
    """
    ...

def ea2str(ea: ida_idaapi.ea_t) -> str:
    r"""Convert linear address to UTF-8 string.
    
    """
    ...

def ea_viewer_history_push_and_jump(v: TWidget, ea: ida_idaapi.ea_t, x: int, y: int, lnnum: int) -> bool:
    r"""Push current location in the history and jump to the given location (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and also in other synchronized views. 
            
    :param v: ea viewer
    :param ea: jump destination
    :param x: coords on screen
    :param y: coords on screen
    :param lnnum: desired line number of given address
    """
    ...

def eamap_begin(map: eamap_t) -> eamap_iterator_t:
    r"""Get iterator pointing to the beginning of eamap_t.
    
    """
    ...

def eamap_clear(map: eamap_t) -> None:
    r"""Clear eamap_t.
    
    """
    ...

def eamap_end(map: eamap_t) -> eamap_iterator_t:
    r"""Get iterator pointing to the end of eamap_t.
    
    """
    ...

def eamap_erase(map: eamap_t, p: eamap_iterator_t) -> None:
    r"""Erase current element from eamap_t.
    
    """
    ...

def eamap_find(map: eamap_t, key: ea_t) -> eamap_iterator_t:
    r"""Find the specified key in eamap_t.
    
    """
    ...

def eamap_first(p: eamap_iterator_t) -> int:
    r"""Get reference to the current map key.
    
    """
    ...

def eamap_free(map: eamap_t) -> None:
    r"""Delete eamap_t instance.
    
    """
    ...

def eamap_insert(map: eamap_t, key: ea_t, val: cinsnptrvec_t) -> eamap_iterator_t:
    r"""Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
    
    """
    ...

def eamap_new() -> eamap_t:
    r"""Create a new eamap_t instance.
    
    """
    ...

def eamap_next(p: eamap_iterator_t) -> eamap_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def eamap_prev(p: eamap_iterator_t) -> eamap_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def eamap_second(p: eamap_iterator_t) -> cinsnptrvec_t:
    r"""Get reference to the current map value.
    
    """
    ...

def eamap_size(map: eamap_t) -> int:
    r"""Get size of eamap_t.
    
    """
    ...

def ecleaz(x: eNI) -> None:
    ...

def edit_manual_regions() -> None:
    ...

def enable_auto(enable: bool) -> bool:
    r"""Temporarily enable/disable autoanalyzer. Not user-facing, but rather because IDA sometimes need to turn AA on/off regardless of inf.s_genflags:INFFL_AUTO 
            
    :returns: old state
    """
    ...

def enable_bblk_trace(enable: bool = True) -> bool:
    ...

def enable_bpt(args: Any) -> bool:
    ...

def enable_bptgrp(bptgrp_name: str, enable: bool = True) -> int:
    r"""Enable (or disable) all bpts in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bptgrp_name: absolute path to the folder
    :param enable: by default true, enable bpts, false disable bpts
    :returns: -1: an error occured
    :returns: 0: no changes
    :returns: >0: nubmers of bpts udpated
    """
    ...

def enable_chooser_item_attrs(chooser_caption: str, enable: bool) -> bool:
    r"""Enable item-specific attributes for chooser items (ui_enable_chooser_item_attrs). For example: color list items differently depending on a criterium. 
    If enabled, the chooser will generate ui_get_chooser_item_attrs 
    events that can be intercepted by a plugin to modify the item attributes. 
    This event is generated only in the GUI version of IDA. 
    Specifying CH_ATTRS bit at the chooser creation time has the same effect. 
            
    :returns: success
    """
    ...

def enable_extlang_python(enable: Any) -> Any:
    r"""Enables or disables Python extlang.
    When enabled, all expressions will be evaluated by Python.
    
    :param enable: Set to True to enable, False otherwise
    """
    ...

def enable_flags(start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, stt: storage_type_t) -> error_t:
    r"""Allocate flags for address range. This function does not change the storage type of existing ranges. Exit with an error message if not enough disk space. 
            
    :param start_ea: should be lower than end_ea.
    :param end_ea: does not belong to the range.
    :param stt: storage_type_t
    :returns: 0 if ok, otherwise an error code
    """
    ...

def enable_func_trace(enable: bool = True) -> bool:
    ...

def enable_insn_trace(enable: bool = True) -> bool:
    ...

def enable_manual_regions(enable: bool) -> None:
    ...

def enable_numbered_types(ti: til_t, enable: bool) -> bool:
    r"""Enable the use of numbered types in til. Currently it is impossible to disable numbered types once they are enabled 
            
    """
    ...

def enable_python_cli(enable: bool) -> None:
    ...

def enable_step_trace(enable: int = 1) -> bool:
    ...

def encoding_from_strtype(strtype: int) -> str:
    ...

def end_ea2node(ea: ida_idaapi.ea_t) -> nodeidx_t:
    ...

def end_type_updating(utp: update_type_t) -> None:
    r"""Mark the end of a large update operation on the types (see begin_type_updating())
    
    """
    ...

def enum_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def enum_import_names(mod_index: Any, callback: Any) -> Any:
    r"""Enumerate imports from a specific module.
    Please refer to list_imports.py example.
    
    :param mod_index: The module index
    :param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    :returns: 1-finished ok, -1 on error, otherwise callback return value (<=0)
    """
    ...

def enumerate_files(path: Any, fname: Any, callback: Any) -> Any:
    r"""Enumerate files in the specified directory while the callback returns 0.
    
    :param path: directory to enumerate files in
    :param fname: mask of file names to enumerate
    :param callback: a callable object that takes the filename as
                     its first argument and it returns 0 to continue
                     enumeration or non-zero to stop enumeration.
    :returns: tuple(code, fname) : If the callback returns non-zero, or None in case of script errors
    """
    ...

def equal_bytes(ea: ida_idaapi.ea_t, image: uchar, mask: uchar, len: size_t, bin_search_flags: int) -> bool:
    r"""Compare 'len' bytes of the program starting from 'ea' with 'image'. 
            
    :param ea: linear address
    :param image: bytes to compare with
    :param mask: array of mask bytes, it's length is 'len'. if the flag BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if not; 1 means to perform the comparison of the corresponding byte. 0 means not to perform. if mask == nullptr, then all bytes of 'image' will be compared. if mask == SKIP_FF_MASK then 0xFF bytes will be skipped
    :param len: length of block to compare in bytes.
    :param bin_search_flags: combination of Search flags
    :returns: 1: equal
    :returns: 0: not equal
    """
    ...

def error(message: Any) -> Any:
    r"""Display a fatal message in a message box and quit IDA
    
    :param format: message to print
    """
    ...

def eval_expr(rv: idc_value_t, where: ida_idaapi.ea_t, line: str) -> str:
    r"""Compile and calculate an expression. 
            
    :param rv: pointer to the result
    :param where: the current linear address in the addressing space of the program being disassembled. If will be used to resolve names of local variables etc. if not applicable, then should be BADADDR.
    :param line: the expression to evaluate
    :returns: true: ok
    :returns: false: error, see errbuf
    """
    ...

def eval_idc_expr(rv: idc_value_t, where: ida_idaapi.ea_t, line: str) -> str:
    r"""Same as eval_expr(), but will always use the IDC interpreter regardless of the currently installed extlang. 
            
    """
    ...

def exec_idc_script(result: idc_value_t, path: str, func: str, args: idc_value_t, argsnum: size_t) -> str:
    r"""Compile and execute IDC function(s) from file. 
            
    :param result: ptr to idc_value_t to hold result of the function. If execution fails, this variable will contain the exception information. You may pass nullptr if you are not interested in the returned value.
    :param path: text file containing text of IDC functions
    :param func: function name to execute
    :param args: array of parameters
    :param argsnum: number of parameters to pass to 'fname' This number should be equal to number of parameters the function expects.
    :returns: true: ok
    :returns: false: error, see errbuf
    """
    ...

def exec_system_script(file: str, complain_if_no_file: bool = True) -> bool:
    r"""Compile and execute "main" function from system file. 
            
    :param file: file name with IDC function(s). The file will be searched using get_idc_filename().
    :param complain_if_no_file: * 1: display warning if the file is not found
    * 0: don't complain if file doesn't exist
    :returns: 1: ok, file is compiled and executed
    :returns: 0: failure, compilation or execution error, warning is displayed
    """
    ...

def execute_sync(callable: Any, reqf: Any) -> Any:
    r"""Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    :param callable: A python callable object, must return an integer value
    :param reqf: one of MFF_ flags
    :returns: -1 or the return value of the callable
    """
    ...

def execute_ui_requests(callable_list: Any) -> Any:
    r"""Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    NOTE: A callable should return True if it wants to be called more than once.
    
    :param callable_list: A list of python callable objects.
    :returns: Boolean. False if the list contains a non callable item
    """
    ...

def exist(n: netnode) -> bool:
    ...

def exist_bpt(ea: ida_idaapi.ea_t) -> bool:
    r"""Does a breakpoint exist at the given location?
    
    """
    ...

def exists_fixup(source: ida_idaapi.ea_t) -> bool:
    r"""Check that a fixup exists at the given address.
    
    """
    ...

def exit_process() -> bool:
    r"""Terminate the debugging of the current process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_exit} 
            
    """
    ...

def extend_sign(v: uint64, nbytes: int, sign_extend: bool) -> uint64:
    r"""Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v' is considered to be of size 'nbytes'. 
            
    """
    ...

def extract_argloc(vloc: argloc_t, ptype: type_t, forbid_stkoff: bool) -> bool:
    r"""Deserialize an argument location. Argument FORBID_STKOFF checks location type. It can be used, for example, to check the return location of a function that cannot return a value in the stack 
            
    """
    ...

def extract_module_from_archive(fname: str, is_remote: bool = False) -> Any:
    r"""Extract a module for an archive file. Parse an archive file, show the list of modules to the user, allow him to select a module, extract the selected module to a file (if the extract module is an archive, repeat the process). This function can handle ZIP, AR, AIXAR, OMFLIB files. The temporary file will be automatically deleted by IDA at the end. 
            
    :param is_remote: is the input file remote?
    :returns: true: ok
    :returns: false: something bad happened (error message has been displayed to the user)
    """
    ...

def extract_name(line: str, x: int) -> str:
    r"""Extract a name or address from the specified string. 
            
    :param line: input string
    :param x: x coordinate of cursor
    :returns: -1 if cannot extract. otherwise length of the name
    """
    ...

def f_any(arg1: flags64_t, arg2: void) -> bool:
    r"""Helper function to accept any address.
    
    """
    ...

def f_has_cmt(f: flags64_t, arg2: void) -> bool:
    ...

def f_has_dummy_name(f: flags64_t, arg2: void) -> bool:
    r"""Does the current byte have dummy (auto-generated, with special prefix) name?
    
    """
    ...

def f_has_extra_cmts(f: flags64_t, arg2: void) -> bool:
    ...

def f_has_name(f: flags64_t, arg2: void) -> bool:
    r"""Does the current byte have non-trivial (non-dummy) name?
    
    """
    ...

def f_has_user_name(F: flags64_t, arg2: void) -> bool:
    r"""Does the current byte have user-specified name?
    
    """
    ...

def f_has_xref(f: flags64_t, arg2: void) -> bool:
    r"""Does the current byte have cross-references to it?
    
    """
    ...

def f_is_align(F: flags64_t, arg2: void) -> bool:
    r"""See is_align()
    
    """
    ...

def f_is_byte(F: flags64_t, arg2: void) -> bool:
    r"""See is_byte()
    
    """
    ...

def f_is_code(F: flags64_t, arg2: void) -> bool:
    r"""Does flag denote start of an instruction?
    
    """
    ...

def f_is_custom(F: flags64_t, arg2: void) -> bool:
    r"""See is_custom()
    
    """
    ...

def f_is_data(F: flags64_t, arg2: void) -> bool:
    r"""Does flag denote start of data?
    
    """
    ...

def f_is_double(F: flags64_t, arg2: void) -> bool:
    r"""See is_double()
    
    """
    ...

def f_is_dword(F: flags64_t, arg2: void) -> bool:
    r"""See is_dword()
    
    """
    ...

def f_is_float(F: flags64_t, arg2: void) -> bool:
    r"""See is_float()
    
    """
    ...

def f_is_head(F: flags64_t, arg2: void) -> bool:
    r"""Does flag denote start of instruction OR data?
    
    """
    ...

def f_is_not_tail(F: flags64_t, arg2: void) -> bool:
    r"""Does flag denote tail byte?
    
    """
    ...

def f_is_oword(F: flags64_t, arg2: void) -> bool:
    r"""See is_oword()
    
    """
    ...

def f_is_pack_real(F: flags64_t, arg2: void) -> bool:
    r"""See is_pack_real()
    
    """
    ...

def f_is_qword(F: flags64_t, arg2: void) -> bool:
    r"""See is_qword()
    
    """
    ...

def f_is_strlit(F: flags64_t, arg2: void) -> bool:
    r"""See is_strlit()
    
    """
    ...

def f_is_struct(F: flags64_t, arg2: void) -> bool:
    r"""See is_struct()
    
    """
    ...

def f_is_tail(F: flags64_t, arg2: void) -> bool:
    r"""Does flag denote tail byte?
    
    """
    ...

def f_is_tbyte(F: flags64_t, arg2: void) -> bool:
    r"""See is_tbyte()
    
    """
    ...

def f_is_word(F: flags64_t, arg2: void) -> bool:
    r"""See is_word()
    
    """
    ...

def f_is_yword(F: flags64_t, arg2: void) -> bool:
    r"""See is_yword()
    
    """
    ...

def file2base(li: linput_t, pos: qoff64_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, patchable: int) -> int:
    r"""Load portion of file into the database. This function will include (ea1..ea2) into the addressing space of the program (make it enabled). 
            
    :param li: pointer of input source
    :param pos: position in the file
    :param ea1: range of destination linear addresses
    :param ea2: range of destination linear addresses
    :param patchable: should the kernel remember correspondence of file offsets to linear addresses.
    :returns: 1: ok
    :returns: 0: read error, a warning is displayed
    """
    ...

def find_bpt(bptloc: bpt_location_t, bpt: bpt_t) -> bool:
    r"""Find a breakpoint by location. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    :param bptloc: Breakpoint location
    :param bpt: bpt is filled if the breakpoint was found
    """
    ...

def find_byte(sEA: ida_idaapi.ea_t, size: asize_t, value: uchar, bin_search_flags: int) -> ida_idaapi.ea_t:
    r"""Find forward a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6 
            
    :param sEA: linear address
    :param size: number of bytes to inspect
    :param value: value to find
    :param bin_search_flags: combination of Search flags
    :returns: address of byte or BADADDR
    """
    ...

def find_byter(sEA: ida_idaapi.ea_t, size: asize_t, value: uchar, bin_search_flags: int) -> ida_idaapi.ea_t:
    r"""Find reverse a byte with the specified value (only 8-bit value from the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4 
            
    :param sEA: the lower address of the search range
    :param size: number of bytes to inspect
    :param value: value to find
    :param bin_search_flags: combination of Search flags
    :returns: address of byte or BADADDR
    """
    ...

def find_bytes(bs: Any, range_start: int, range_size: typing.Optional[int] = None, range_end: typing.Optional[int] = 18446744073709551615, mask: Any = None, flags: typing.Optional[int] = 8, radix: typing.Optional[int] = 16, strlit_encoding: Any = 0) -> int:
    ...

def find_code(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_custom_callcnv(name: str) -> callcnv_t:
    r"""Find a calling convention by its name 
            
    :returns: CM_CC_INVALID is not found
    """
    ...

def find_custom_data_format(name: str) -> int:
    r"""Get id of a custom data format. 
            
    :param name: name of the custom data format
    :returns: id or -1
    """
    ...

def find_custom_data_type(name: str) -> int:
    r"""Get id of a custom data type. 
            
    :param name: name of the custom data type
    :returns: id or -1
    """
    ...

def find_custom_fixup(name: str) -> fixup_type_t:
    ...

def find_custom_refinfo(name: str) -> int:
    r"""Get id of a custom refinfo type.
    
    """
    ...

def find_data(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_defined(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_error(ea: ida_idaapi.ea_t, sflag: int) -> int:
    ...

def find_free_chunk(start: ida_idaapi.ea_t, size: asize_t, alignment: asize_t) -> ida_idaapi.ea_t:
    r"""Search for a hole in the addressing space of the program. 
            
    :param start: Address to start searching from
    :param size: Size of the desired empty range
    :param alignment: Alignment bitmask, must be a pow2-1. (for example, 0xF would align the returned range to 16 bytes).
    :returns: Start of the found empty range or BADADDR
    """
    ...

def find_free_selector() -> sel_t:
    r"""Find first unused selector. 
            
    :returns: a number >= 1
    """
    ...

def find_func_bounds(nfn: func_t, flags: int) -> int:
    r"""Determine the boundaries of a new function. This function tries to find the start and end addresses of a new function. It calls the module with processor_t::func_bounds in order to fine tune the function boundaries. 
            
    :param nfn: structure to fill with information \ nfn->start_ea points to the start address of the new function.
    :param flags: Find function bounds flags
    :returns: Find function bounds result codes
    """
    ...

def find_idc_class(name: str) -> idc_class_t:
    r"""Find an existing IDC class by its name. 
            
    :param name: name of the class
    :returns: pointer to the class or nullptr. The returned pointer is valid until a new call to add_idc_class()
    """
    ...

def find_idc_func(prefix: str, n: int = 0) -> str:
    ...

def find_idc_gvar(name: str) -> idc_value_t:
    r"""Find an existing global IDC variable by its name. 
            
    :param name: name of the global variable
    :returns: pointer to the variable or nullptr. NB: the returned pointer is valid until a new global var is added. FIXME: it is difficult to use this function in a thread safe manner
    """
    ...

def find_imm(ea: ida_idaapi.ea_t, sflag: int, search_value: int) -> int:
    ...

def find_nearest_rvi(rvi: reg_value_info_t, ea: ida_idaapi.ea_t, reg: Any) -> int:
    r"""Find the value of any of the two registers using the register tracker. First, this function tries to find the registers in the basic block of EA, and if it could not do this, then it tries to find in the entire function. 
            
    :param rvi: the found value with additional attributes
    :param ea: the address to find a value at
    :param reg: the registers to find
    :returns: the index of the found register or -1
    """
    ...

def find_not_func(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_notype(ea: ida_idaapi.ea_t, sflag: int) -> int:
    ...

def find_plugin(name: str, load_if_needed: bool = False) -> plugin_t:
    r"""Find a user-defined plugin and optionally load it. 
            
    :param name: short plugin name without path and extension, or absolute path to the file name
    :param load_if_needed: if the plugin is not present in the memory, try to load it
    :returns: pointer to plugin description block
    """
    ...

def find_reg_access(out: reg_access_t, start_ea: ida_idaapi.ea_t, end_ea: ida_idaapi.ea_t, regname: str, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_reg_value(ea: ida_idaapi.ea_t, reg: int) -> uint64:
    r"""Find register value using the register tracker. 
            
    :param ea: the address to find a value at
    :param reg: the register to find
    :returns: 0: no value (the value is varying or the find depth is not enough to find a value)
    :returns: 1: the found value is in VAL
    :returns: -1: the processor module does not support a register tracker
    """
    ...

def find_reg_value_info(rvi: reg_value_info_t, ea: ida_idaapi.ea_t, reg: int, max_depth: int = 0) -> bool:
    r"""Find register value using the register tracker. 
            
    :param rvi: the found value with additional attributes
    :param ea: the address to find a value at
    :param reg: the register to find
    :param max_depth: the number of basic blocks to look before aborting the search and returning the unknown value. 0 means the value of REGTRACK_MAX_DEPTH from ida.cfg for ordinal registers or REGTRACK_FUNC_MAX_DEPTH for the function-wide registers, -1 means the value of REGTRACK_FUNC_MAX_DEPTH from ida.cfg.
    :returns: 'false': the processor module does not support a register tracker
    :returns: 'true': the found value is in RVI
    """
    ...

def find_regvar(args: Any) -> regvar_t:
    r"""This function has the following signatures:
    
        0. find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *
        1. find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *
    
    # 0: find_regvar(pfn: func_t *, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, canon: str, user: str) -> regvar_t *
    
    Find a register variable definition (powerful version). One of 'canon' and 'user' should be nullptr. If both 'canon' and 'user' are nullptr it returns the first regvar definition in the range. 
            
    :returns: nullptr-not found, otherwise ptr to regvar_t
    
    # 1: find_regvar(pfn: func_t *, ea: ida_idaapi.ea_t, canon: str) -> regvar_t *
    
    Find a register variable definition. 
            
    :returns: nullptr-not found, otherwise ptr to regvar_t
    
    """
    ...

def find_selector(base: ida_idaapi.ea_t) -> sel_t:
    r"""Find a selector that has mapping to the specified paragraph. 
            
    :param base: paragraph to search in the translation table
    :returns: selector value or base
    """
    ...

def find_sp_value(ea: ida_idaapi.ea_t, reg: int = -1) -> int64:
    r"""Find a value of the SP based register using the register tracker. 
            
    :param ea: the address to find a value at
    :param reg: the register to find. by default the SP register is used.
    :returns: 0: no value (the value is varying or the find depth is not enough to find a value)
    :returns: 1: the found value is in VAL
    :returns: -1: the processor module does not support a register tracker
    """
    ...

def find_string(_str: str, range_start: int, range_end: typing.Optional[int] = 18446744073709551615, range_size: typing.Optional[int] = None, strlit_encoding: Any = 0, flags: typing.Optional[int] = 8) -> int:
    ...

def find_suspop(ea: ida_idaapi.ea_t, sflag: int) -> int:
    ...

def find_syseh(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Find the start address of the system eh region including the argument. 
            
    :param ea: search address
    :returns: start address of surrounding tryblk, otherwise BADADDR
    """
    ...

def find_text(start_ea: ida_idaapi.ea_t, y: int, x: int, ustr: str, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_tinfo_udt_member(udm: udm_t, typid: typid_t, strmem_flags: int) -> int:
    ...

def find_unknown(ea: ida_idaapi.ea_t, sflag: int) -> ida_idaapi.ea_t:
    ...

def find_widget(caption: str) -> TWidget:
    r"""Find widget with the specified caption (only gui version) (ui_find_widget). NB: this callback works only with the tabbed widgets! 
            
    :param caption: title of tab, or window title if widget is not tabbed
    :returns: pointer to the TWidget, nullptr if none is found
    """
    ...

def first_idcv_attr(obj: idc_value_t) -> str:
    ...

def first_named_type(ti: til_t, ntf_flags: int) -> str:
    r"""Enumerate types. 
            
    :param ti: type library. nullptr means the local type library for the current database.
    :param ntf_flags: combination of Flags for named types
    :returns: Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.
    """
    ...

def float_flag() -> flags64_t:
    r"""Get a flags64_t representing a float.
    
    """
    ...

def flt_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def flush_buffers() -> int:
    r"""Flush buffers to the disk.
    
    """
    ...

def fopenA(file: str) -> FILE:
    ...

def fopenM(file: str) -> FILE:
    ...

def fopenRB(file: str) -> FILE:
    ...

def fopenRT(file: str) -> FILE:
    ...

def fopenWB(file: str) -> FILE:
    ...

def fopenWT(file: str) -> FILE:
    ...

def for_all_arglocs(vv: aloc_visitor_t, vloc: argloc_t, size: int, off: int = 0) -> int:
    r"""Compress larger argloc types and initiate the aloc visitor.
    
    """
    ...

def for_all_const_arglocs(vv: const_aloc_visitor_t, vloc: argloc_t, size: int, off: int = 0) -> int:
    r"""See for_all_arglocs()
    
    """
    ...

def force_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool:
    ...

def forget_problem(type: problist_id_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Remove an address from a problem list 
            
    :param type: problem list type
    :param ea: linear address
    :returns: success
    """
    ...

def format_basestring(_in: Any) -> str:
    ...

def formchgcbfa_close(p_fa: size_t, close_normally: int) -> None:
    ...

def formchgcbfa_enable_field(p_fa: size_t, fid: int, enable: bool) -> bool:
    ...

def formchgcbfa_get_field_value(p_fa: size_t, fid: int, ft: int, sz: size_t) -> Any:
    ...

def formchgcbfa_get_focused_field(p_fa: size_t) -> int:
    ...

def formchgcbfa_move_field(p_fa: size_t, fid: int, x: int, y: int, w: int, h: int) -> bool:
    ...

def formchgcbfa_refresh_field(p_fa: size_t, fid: int) -> None:
    ...

def formchgcbfa_set_field_value(p_fa: size_t, fid: int, ft: int, py_val: Any) -> bool:
    ...

def formchgcbfa_set_focused_field(p_fa: size_t, fid: int) -> bool:
    ...

def formchgcbfa_show_field(p_fa: size_t, fid: int, show: bool) -> bool:
    ...

def frame_off_args(pfn: func_t) -> ida_idaapi.ea_t:
    r"""Get starting address of arguments section.
    
    """
    ...

def frame_off_lvars(pfn: func_t) -> ida_idaapi.ea_t:
    r"""Get start address of local variables section.
    
    """
    ...

def frame_off_retaddr(pfn: func_t) -> ida_idaapi.ea_t:
    r"""Get starting address of return address section.
    
    """
    ...

def frame_off_savregs(pfn: func_t) -> ida_idaapi.ea_t:
    r"""Get starting address of saved registers section.
    
    """
    ...

def free_custom_icon(icon_id: Any) -> Any:
    r"""Frees an icon loaded with load_custom_icon()
    
    :param icon_id: The ID of the icon to free
    """
    ...

def free_idcv(v: idc_value_t) -> None:
    r"""Free storage used by VT_STR/VT_OBJ IDC variables. After this call the variable has a numeric value 0 
            
    """
    ...

def free_regarg(v: regarg_t) -> None:
    ...

def free_regvar(v: regvar_t) -> None:
    ...

def free_til(ti: til_t) -> None:
    r"""Free memory allocated by til.
    
    """
    ...

def func_contains(pfn: func_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Does the given function contain the given address?
    
    """
    ...

def func_does_return(callee: ida_idaapi.ea_t) -> bool:
    r"""Does the function return?. To calculate the answer, FUNC_NORET flag and is_noret() are consulted The latter is required for imported functions in the .idata section. Since in .idata we have only function pointers but not functions, we have to introduce a special flag for them. 
            
    """
    ...

def func_has_stkframe_hole(ea: ida_idaapi.ea_t, fti: func_type_data_t) -> bool:
    r"""Looks for a hole at the beginning of the stack arguments. Will make use of the IDB's func_t function at that place (if present) to help determine the presence of such a hole. 
            
    """
    ...

def func_parent_iterator_set(fpi: func_parent_iterator_t, pfn: func_t) -> bool:
    ...

def func_t__from_ptrval__(ptrval: size_t) -> func_t:
    ...

def func_tail_iterator_set(fti: func_tail_iterator_t, pfn: func_t, ea: ida_idaapi.ea_t) -> bool:
    ...

def func_tail_iterator_set_ea(fti: func_tail_iterator_t, ea: ida_idaapi.ea_t) -> bool:
    ...

def gcc_layout() -> bool:
    r"""Should use the struct/union layout as done by gcc?
    
    """
    ...

def gen_complex_call_chart(filename: str, wait: str, title: str, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int, recursion_depth: int = -1) -> bool:
    r"""Build and display a complex xref graph. 
            
    :param filename: output file name. the file extension is not used. maybe nullptr.
    :param wait: message to display during graph building
    :param title: graph title
    :param ea1: address range
    :param ea2: address range
    :param flags: combination of Call chart building flags and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
    :param recursion_depth: optional limit of recursion
    :returns: success. if fails, a warning message is displayed on the screen
    """
    ...

def gen_decorate_name(name: str, should_decorate: bool, cc: callcnv_t, type: tinfo_t) -> str:
    r"""Generic function for decorate_name() (may be used in IDP modules)
    
    """
    ...

def gen_disasm_text(text: disasm_text_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, truncate_lines: bool) -> None:
    r"""Generate disassembly text for a range. 
            
    :param text: result
    :param ea1: start address
    :param ea2: end address
    :param truncate_lines: (on idainfo::margin)
    """
    ...

def gen_exe_file(fp: FILE) -> int:
    r"""Generate an exe file (unload the database in binary form). 
            
    :returns: fp the output file handle. if fp == nullptr then return:
    * 1: can generate an executable file
    * 0: can't generate an executable file
    :returns: 1: ok
    :returns: 0: failed
    """
    ...

def gen_file(otype: ofile_type_t, fp: FILE, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, flags: int) -> int:
    r"""Generate an output file. OFILE_EXE: 
            
    :param otype: type of output file.
    :param fp: the output file handle
    :param ea1: start address. For some file types this argument is ignored
    :param ea2: end address. For some file types this argument is ignored as usual in ida, the end address of the range is not included
    :param flags: Generate file flags
    :returns: number of the generated lines. -1 if an error occurred
    :returns: 0: can't generate exe file
    :returns: 1: ok
    """
    ...

def gen_fix_fixups(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t, size: asize_t) -> None:
    r"""Relocate the bytes with fixup information once more (generic function). This function may be called from loader_t::move_segm() if it suits the goal. If loader_t::move_segm is not defined then this function will be called automatically when moving segments or rebasing the entire program. Special parameter values (from = BADADDR, size = 0, to = delta) are used when the function is called from rebase_program(delta). 
            
    """
    ...

def gen_flow_graph(filename: str, title: str, pfn: func_t, ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, gflags: int) -> bool:
    r"""Build and display a flow graph. 
            
    :param filename: output file name. the file extension is not used. maybe nullptr.
    :param title: graph title
    :param pfn: function to graph
    :param ea1: if pfn == nullptr, then the address range
    :param ea2: if pfn == nullptr, then the address range
    :param gflags: combination of Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false
    :returns: success. if fails, a warning message is displayed on the screen
    """
    ...

def gen_gdl(g: gdl_graph_t, fname: str) -> None:
    r"""Create GDL file for graph.
    
    """
    ...

def gen_idb_event(args: Any) -> None:
    r"""the kernel will use this function to generate idb_events
    
    """
    ...

def gen_microcode(mbr: mba_ranges_t, hf: hexrays_failure_t = None, retlist: mlist_t = None, decomp_flags: int = 0, reqmat: mba_maturity_t = 7) -> mba_t:
    r"""Generate microcode of an arbitrary code snippet 
            
    :param mbr: snippet ranges
    :param hf: extended error information (if failed)
    :param retlist: list of registers the snippet returns
    :param decomp_flags: bitwise combination of decompile() flags... bits
    :param reqmat: required microcode maturity
    :returns: pointer to the microcode, nullptr if failed.
    """
    ...

def gen_simple_call_chart(filename: str, wait: str, title: str, gflags: int) -> bool:
    r"""Build and display a simple function call graph. 
            
    :param filename: output file name. the file extension is not used. maybe nullptr.
    :param wait: message to display during graph building
    :param title: graph title
    :param gflags: combination of CHART_NOLIBFUNCS and Flow graph building flags. if none of CHART_GEN_DOT, CHART_GEN_GDL, CHART_WINGRAPH is specified, the function will return false.
    :returns: success. if fails, a warning message is displayed on the screen
    """
    ...

def gen_use_arg_tinfos(_this: argtinfo_helper_t, caller: ida_idaapi.ea_t, fti: func_type_data_t, rargs: funcargvec_t) -> None:
    r"""Do not call this function directly, use argtinfo_helper_t.
    
    """
    ...

def generate_disasm_line(ea: ida_idaapi.ea_t, flags: int = 0) -> str:
    ...

def generate_disassembly(ea: Any, max_lines: Any, as_stack: Any, notag: Any, include_hidden: Boolean = False) -> Any:
    r"""Generate disassembly lines (many lines) and put them into a buffer
    
    :param ea: address to generate disassembly for
    :param max_lines: how many lines max to generate
    :param as_stack: Display undefined items as 2/4/8 bytes
    :param notag: remove color tags
    :param include_hidden: automatically unhide hidden objects
    :returns: tuple(most_important_line_number, list(lines)) : Returns a tuple containing
              the most important line number and a list of generated lines
    :returns: None on failure
    """
    ...

def get_16bit(ea: ida_idaapi.ea_t) -> int:
    r"""Get 16bits of the program at 'ea'. 
            
    :returns: 1 byte (getFullByte()) if the current processor has 16-bit byte, otherwise return get_word()
    """
    ...

def get_32bit(ea: ida_idaapi.ea_t) -> int:
    r"""Get not more than 32bits of the program at 'ea'. 
            
    :returns: 32 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_dword(ea);
    * if ( nbits <= 16) return get_wide_word(ea);
    * return get_wide_byte(ea);
    """
    ...

def get_64bit(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get not more than 64bits of the program at 'ea'. 
            
    :returns: 64 bit value, depending on processor_t::nbits:
    * if ( nbits <= 8 ) return get_qword(ea);
    * if ( nbits <= 16) return get_wide_dword(ea);
    * return get_wide_byte(ea);
    """
    ...

def get_abi_name() -> str:
    r"""Get ABI name. 
            
    :returns: length of the name (>=0)
    """
    ...

def get_absbase(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_action_checkable(name: str) -> bool:
    r"""Get an action's checkability (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_checked(name: str) -> bool:
    r"""Get an action's checked state (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_icon(name: str) -> int:
    r"""Get an action's icon (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_label(name: str) -> str:
    r"""Get an action's label (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_shortcut(name: str) -> str:
    r"""Get an action's shortcut (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_state(name: str) -> action_state_t:
    r"""Get an action's state (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_tooltip(name: str) -> str:
    r"""Get an action's tooltip (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_action_visibility(name: str) -> bool:
    r"""Get an action's visibility (ui_get_action_attr). 
            
    :param name: the action name
    :returns: success
    """
    ...

def get_active_modal_widget() -> TWidget:
    r"""Get the current, active modal TWidget instance. Note that in this context, the "wait dialog" is not considered: this function will return nullptr even if it is currently shown. 
            
    :returns: TWidget * the active modal widget, or nullptr
    """
    ...

def get_addon_info(id: str, info: addon_info_t) -> bool:
    r"""Get info about a registered addon with a given product code. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    :returns: false if not found
    """
    ...

def get_addon_info_idx(index: int, info: addon_info_t) -> bool:
    r"""Get info about a registered addon with specific index. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
            
    :returns: false if index is out of range
    """
    ...

def get_aflags(ea: ida_idaapi.ea_t) -> aflags_t:
    ...

def get_alias_target(ti: til_t, ordinal: int) -> int:
    r"""Find the final alias destination. If the ordinal has not been aliased, return the specified ordinal itself If failed, returns 0. 
            
    """
    ...

def get_alignment(ea: ida_idaapi.ea_t) -> int:
    ...

def get_archive_path() -> str:
    r"""Get archive file path from which input file was extracted.
    
    """
    ...

def get_arg_addrs(caller: ida_idaapi.ea_t) -> Any:
    r"""Retrieve addresses of argument initialization instructions
    
    :param caller: the address of the call instruction
    :returns: list of instruction addresses
    """
    ...

def get_array_parameters(out: array_parameters_t, ea: ida_idaapi.ea_t) -> ssize_t:
    ...

def get_ash() -> asm_t:
    ...

def get_asm_inc_file() -> str:
    r"""Get name of the include file.
    
    """
    ...

def get_auto_display(auto_display: auto_display_t) -> bool:
    r"""Get structure which holds the autoanalysis indicator contents.
    
    """
    ...

def get_auto_state() -> atype_t:
    r"""Get current state of autoanalyzer. If auto_state == AU_NONE, IDA is currently not running the analysis (it could be temporarily interrupted to perform the user's requests, for example). 
            
    """
    ...

def get_available_core_count() -> int:
    r"""Get the number of logical CPU cores available to the current process if supported by the OS. 
            
    :returns: the logical core count available for the process, or -1 on error
    """
    ...

def get_base_type(t: type_t) -> type_t:
    r"""Get get basic type bits (TYPE_BASE_MASK)
    
    """
    ...

def get_basic_file_type(li: linput_t) -> filetype_t:
    r"""Get the input file type. This function can recognize libraries and zip files. 
            
    """
    ...

def get_bblk_trace_options() -> int:
    r"""Get current basic block tracing options. Also see BT_LOG_INSTS \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_bpt(ea: ida_idaapi.ea_t, bpt: bpt_t) -> bool:
    r"""Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param ea: any address in the breakpoint range
    :param bpt: if not nullptr, is filled with the characteristics.
    :returns: false if no breakpoint exists
    """
    ...

def get_bpt_group(bptloc: bpt_location_t) -> str:
    r"""Retrieve the absolute path to the folder of the bpt based on the bpt_location find_bpt is called to retrieve the bpt \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bptloc: bptlocation of the bpt
    :returns: success
    :returns: true: breakpoint correclty moved to the directory
    """
    ...

def get_bpt_qty() -> int:
    r"""Get number of breakpoints. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_bpt_tev_ea(n: int) -> ida_idaapi.ea_t:
    r"""Get the address associated to a read, read/write or execution trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :returns: BADADDR if not a read, read/write or execution trace event.
    """
    ...

def get_bptloc_string(i: int) -> str:
    ...

def get_byte(ea: ida_idaapi.ea_t) -> uchar:
    r"""Get one byte (8-bit) of the program at 'ea'. This function works only for 8bit byte processors. 
            
    """
    ...

def get_bytes(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = 1) -> Any:
    r"""Get the specified number of bytes of the program.
    
    :param ea: program address
    :param size: number of bytes to return
    :param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
    :returns: the bytes (as bytes object), or None in case of failure
    """
    ...

def get_bytes_and_mask(ea: ida_idaapi.ea_t, size: int, gmb_flags: int = 1) -> Any:
    r"""Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    
    :param ea: program address
    :param size: number of bytes to return
    :param gmb_flags: OR'ed combination of GMB_* values (defaults to GMB_READALL)
    :returns: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.
    """
    ...

def get_c_header_path() -> str:
    r"""Get the include directory path of the target compiler.
    
    """
    ...

def get_c_macros() -> str:
    r"""Get predefined macros for the target compiler.
    
    """
    ...

def get_call_tev_callee(n: int) -> ida_idaapi.ea_t:
    r"""Get the called function from a function call trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :returns: BADADDR if not a function call event.
    """
    ...

def get_chooser_data(title: str, n: int) -> List[str]:
    r"""Get the text corresponding to the index N in the chooser data.
    Use -1 to get the header.
    
    :param title: The chooser title
    :returns: a list of strings, or None
    """
    ...

def get_chooser_obj(chooser_caption: str) -> None:
    r"""Get the underlying object of the specified chooser (ui_get_chooser_obj).
    This attemps to find the choser by its title and, if found, returns the result of calling its chooser_base_t::get_chooser_obj() method.
    
    :returns: the object that was used to create the chooser
    """
    ...

def get_chooser_rows(out: chooser_row_info_vec_t, chooser_caption: str, what: size_t) -> bool:
    r"""Get the chooser contents corresponding to the rows indicated by "what". 
            
    :param out: A vector of chooser_row_info_t, one entry per returned row.
    :param chooser_caption: The caption that identifies the desired chooser.
    :param what: Either one of the GCRF_ flags, or a row index.
    :returns: Success.
    """
    ...

def get_cmt(ea: ida_idaapi.ea_t, rptble: bool) -> str:
    r"""Get an indented comment. 
            
    :param ea: linear address. may point to tail byte, the function will find start of the item
    :param rptble: get repeatable comment?
    :returns: size of comment or -1
    """
    ...

def get_colored_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str:
    ...

def get_colored_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    ...

def get_colored_name(ea: ida_idaapi.ea_t) -> str:
    ...

def get_colored_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    ...

def get_comp(comp: comp_t) -> comp_t:
    r"""Get compiler bits.
    
    """
    ...

def get_compiler_abbr(id: comp_t) -> str:
    r"""Get abbreviated compiler name.
    
    """
    ...

def get_compiler_name(id: comp_t) -> str:
    r"""Get full compiler name.
    
    """
    ...

def get_compilers(ids: compvec_t, names: qstrvec_t, abbrs: qstrvec_t) -> None:
    r"""Get names of all built-in compilers.
    
    """
    ...

def get_config_value(key: str) -> jvalue_t:
    ...

def get_cp_validity(args: Any) -> bool:
    r"""Is the given codepoint (or range) acceptable in the given context? If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
            
    """
    ...

def get_ctype_name(op: ctype_t) -> str:
    ...

def get_curline() -> str:
    r"""Get current line from the disassemble window (ui_get_curline). 
            
    :returns: cptr current line with the color codes (use tag_remove() to remove the color codes)
    """
    ...

def get_current_idasgn() -> int:
    r"""Get number of the the current signature. 
            
    :returns: 0..n-1
    """
    ...

def get_current_operand(out: gco_info_t) -> bool:
    r"""Get the instruction operand under the cursor. This function determines the operand that is under the cursor in the active disassembly listing. If the operand refers to a register or stack variable, it returns true. 
            
    """
    ...

def get_current_source_file() -> str:
    ...

def get_current_source_line() -> int:
    ...

def get_current_thread() -> thid_t:
    r"""Get current thread ID. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_current_viewer() -> TWidget:
    r"""Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)
    
    """
    ...

def get_current_widget() -> TWidget:
    r"""Get a pointer to the current widget (ui_get_current_widget).
    
    """
    ...

def get_cursor() -> Any:
    r"""Get the cursor position on the screen (ui_get_cursor). 
            
    :returns: true: pointers are filled
    :returns: false: no disassembly window open
    """
    ...

def get_custom_callcnv(callcnv: callcnv_t) -> custom_callcnv_t:
    r"""Retrieve custom calling convention details.
    
    """
    ...

def get_custom_callcnvs(names: qstrvec_t, codes: callcnvs_t) -> int:
    r"""Get all custom calling conventions 
            
    :param names: output buffer for the convention names
    :param codes: output buffer for the convention codes The two output buffers correspond to each other.
    :returns: number of the calling conventions added to the output buffers
    """
    ...

def get_custom_data_format(dfid: int) -> data_format_t:
    r"""Get definition of a registered custom data format. 
            
    :param dfid: data format id
    :returns: data format definition or nullptr
    """
    ...

def get_custom_data_formats(out: intvec_t, dtid: int) -> int:
    r"""Get list of attached custom data formats for the specified data type. 
            
    :param out: buffer for the output. may be nullptr
    :param dtid: data type id
    :returns: number of returned custom data formats. if error, returns -1
    """
    ...

def get_custom_data_type(dtid: int) -> data_type_t:
    r"""Get definition of a registered custom data type. 
            
    :param dtid: data type id
    :returns: data type definition or nullptr
    """
    ...

def get_custom_data_type_ids(cdis: custom_data_type_ids_t, ea: ida_idaapi.ea_t) -> int:
    ...

def get_custom_data_types(args: Any) -> int:
    r"""Get list of registered custom data type ids. 
            
    :param out: buffer for the output. may be nullptr
    :param min_size: minimum value size
    :param max_size: maximum value size
    :returns: number of custom data types with the specified size limits
    """
    ...

def get_custom_refinfo(crid: int) -> custom_refinfo_handler_t:
    r"""Get definition of a registered custom refinfo type.
    
    """
    ...

def get_custom_viewer_curline(custom_viewer: TWidget, mouse: bool) -> str:
    r"""Get current line of custom viewer (ui_get_custom_viewer_curline). The returned line contains color codes
    See also the more powerful get_custom_viewer_location()
    
    :param custom_viewer: view
    :param mouse: mouse position (otherwise cursor position)
    :returns: pointer to contents of current line
    """
    ...

def get_custom_viewer_location(args: Any) -> bool:
    r"""Get information about the current location in a listing
    
    This function has the following signatures:
    
        1. get_custom_viewer_location(out_entry: ida_moves.lochist_entry_t, widget: TWidget, mouse: bool=False) -> bool
        2. get_custom_viewer_location(out_entry: ida_kernwin.listing_location_t, widget: TWidget, flags: int=0) -> bool
    
    The 2nd form is a superset of the 1st, and retrieves
    the text (and tags) of the text.
    """
    ...

def get_custom_viewer_place(custom_viewer: TWidget, mouse: bool) -> Any:
    r"""Get current place in a custom viewer (ui_get_curplace).
    See also the more complete get_custom_viewer_location()
    
    :param custom_viewer: view
    :param mouse: mouse position (otherwise cursor position)
    """
    ...

def get_custom_viewer_place_xcoord(custom_viewer: TWidget, pline: place_t, pitem: place_t) -> int:
    r"""Get the X position of the item, in the line 
            
    :param custom_viewer: the widget
    :param pline: a place corresponding to the line
    :param pitem: a place corresponding to the item
    :returns: -1: if 'pitem' is not included in the line
    :returns: -2: if 'pitem' points at the entire line
    :returns: >=: 0 for the X coordinate within the pline, where pitem points
    """
    ...

def get_data_elsize(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None) -> int:
    r"""Get size of data type specified in flags 'F'. 
            
    :param ea: linear address of the item
    :param F: flags
    :param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
    :returns: * byte : 1
    * word : 2
    * etc...
    """
    ...

def get_data_value(v: uval_t, ea: ida_idaapi.ea_t, size: asize_t) -> bool:
    r"""Get the value at of the item at 'ea'. This function works with entities up to sizeof(ea_t) (bytes, word, etc) 
            
    :param v: pointer to the result. may be nullptr
    :param ea: linear address
    :param size: size of data to read. If 0, then the item type at 'ea' will be used
    :returns: success
    """
    ...

def get_db_byte(ea: ida_idaapi.ea_t) -> uchar:
    r"""Get one byte (8-bit) of the program at 'ea' from the database. Works even if the debugger is active. See also get_dbg_byte() to read the process memory directly. This function works only for 8bit byte processors. 
            
    """
    ...

def get_dbctx_id() -> ssize_t:
    r"""Get the current database context ID 
            
    :returns: the database context ID, or -1 if no current database
    """
    ...

def get_dbctx_qty() -> int:
    r"""Get number of database contexts 
            
    :returns: number of database contexts
    """
    ...

def get_dbg() -> debugger_t:
    ...

def get_dbg_byte(ea: ida_idaapi.ea_t) -> uint32:
    r"""Get one byte of the debugged process memory. 
            
    :param ea: linear address
    :returns: success
    :returns: true: success
    :returns: false: address inaccessible or debugger not running
    """
    ...

def get_dbg_memory_info(ranges: meminfo_vec_t) -> int:
    ...

def get_dbg_reg_info(regname: str, ri: register_info_t) -> bool:
    r"""Get register information \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_debug_event() -> debug_event_t:
    r"""Get the current debugger event.
    
    """
    ...

def get_debug_event_name(dev: debug_event_t) -> str:
    r"""get debug event name
    
    """
    ...

def get_debug_name(ea_ptr: ea_t, how: debug_name_how_t) -> str:
    ...

def get_debug_name_ea(name: str) -> ida_idaapi.ea_t:
    ...

def get_debug_names(args: Any) -> Any:
    ...

def get_debugger_event_cond() -> str:
    ...

def get_default_encoding_idx(bpu: int) -> int:
    ...

def get_default_radix() -> int:
    r"""Get default base of number for the current processor. 
            
    :returns: 2, 8, 10, 16
    """
    ...

def get_default_reftype(ea: ida_idaapi.ea_t) -> reftype_t:
    r"""Get default reference type depending on the segment. 
            
    :returns: one of REF_OFF8, REF_OFF16, REF_OFF32, REF_OFF64
    """
    ...

def get_defsr(s: Any, reg: Any) -> Any:
    r"""Deprecated, use instead:
    value = s.defsr[reg]
    """
    ...

def get_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str:
    ...

def get_dtype_by_size(size: asize_t) -> int:
    r"""Get op_t::dtype from size.
    
    """
    ...

def get_dtype_flag(dtype: op_dtype_t) -> flags64_t:
    r"""Get flags for op_t::dtype field.
    
    """
    ...

def get_dtype_size(dtype: op_dtype_t) -> int:
    r"""Get size of opt_::dtype field.
    
    """
    ...

def get_dword(ea: ida_idaapi.ea_t) -> int:
    r"""Get one dword (32-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            
    """
    ...

def get_ea_diffpos_name(ea: ida_idaapi.ea_t) -> str:
    r"""Get nice name for EA diffpos 
            
    :param ea: diffpos
    """
    ...

def get_ea_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    r"""Get name at the specified address. 
            
    :param ea: linear address
    :param gtn_flags: how exactly the name should be retrieved. combination of bits for get_ea_name() function. There is a convenience bits
    :returns: success
    """
    ...

def get_ea_viewer_history_info(nback: int, nfwd: int, v: TWidget) -> bool:
    r"""Get information about what's in the history (ui_ea_viewer_history_info). 
            
    :param nback: number of available back steps
    :param nfwd: number of available forward steps
    :param v: ea viewer
    :returns: false: if the given ea viewer does not exist
    :returns: true: otherwise
    """
    ...

def get_effective_spd(pfn: func_t, ea: ida_idaapi.ea_t) -> int:
    r"""Get effective difference between the initial and current values of ESP. This function returns the sp-diff used by the instruction. The difference between get_spd() and get_effective_spd() is present only for instructions like "pop [esp+N]": they modify sp and use the modified value. 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address
    :returns: 0 or the difference, usually a negative number
    """
    ...

def get_elapsed_secs() -> int:
    r"""Get seconds database stayed open.
    
    """
    ...

def get_elf_debug_file_directory() -> str:
    r"""Get the value of the ELF_DEBUG_FILE_DIRECTORY configuration directive. 
            
    """
    ...

def get_encoding_bpu(idx: int) -> int:
    ...

def get_encoding_bpu_by_name(encname: str) -> int:
    ...

def get_encoding_name(idx: int) -> str:
    ...

def get_encoding_qty() -> int:
    ...

def get_entry(ord: int) -> ida_idaapi.ea_t:
    r"""Get entry point address by its ordinal 
            
    :param ord: ordinal number of entry point
    :returns: address or BADADDR
    """
    ...

def get_entry_forwarder(ord: int) -> str:
    r"""Get forwarder name for the entry point by its ordinal. 
            
    :param ord: ordinal number of entry point
    :returns: size of entry forwarder name or -1
    """
    ...

def get_entry_name(ord: int) -> str:
    r"""Get name of the entry point by its ordinal. 
            
    :param ord: ordinal number of entry point
    :returns: size of entry name or -1
    """
    ...

def get_entry_ordinal(idx: size_t) -> int:
    r"""Get ordinal number of an entry point. 
            
    :param idx: internal number of entry point. Should be in the range 0..get_entry_qty()-1
    :returns: ordinal number or 0.
    """
    ...

def get_entry_qty() -> int:
    r"""Get number of entry points.
    
    """
    ...

def get_enum_id(ea: ida_idaapi.ea_t, n: int) -> uchar:
    r"""Get enum id of 'enum' operand. 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL one of the operands
    :returns: id of enum or BADNODE
    """
    ...

def get_enum_member_expr(tif: tinfo_t, serial: int, value: uint64) -> str:
    r"""Return a C expression that can be used to represent an enum member. If the value does not correspond to any single enum member, this function tries to find a bitwise combination of enum members that correspond to it. If more than half of value bits do not match any enum members, it fails. 
            
    :param tif: enumeration type
    :param serial: which enumeration member to use (0 means the first with the given value)
    :param value: value to search in the enumeration type
    :returns: success
    """
    ...

def get_event_bpt_hea(ev: debug_event_t) -> ida_idaapi.ea_t:
    ...

def get_event_exc_code(ev: debug_event_t) -> uint:
    ...

def get_event_exc_ea(ev: debug_event_t) -> ida_idaapi.ea_t:
    ...

def get_event_exc_info(ev: debug_event_t) -> str:
    ...

def get_event_info(ev: debug_event_t) -> str:
    ...

def get_event_module_base(ev: debug_event_t) -> ida_idaapi.ea_t:
    ...

def get_event_module_name(ev: debug_event_t) -> str:
    ...

def get_event_module_size(ev: debug_event_t) -> int:
    ...

def get_extra_cmt(ea: ida_idaapi.ea_t, what: int) -> int:
    ...

def get_fchunk(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to function chunk structure by address. 
            
    :param ea: any address in a function chunk
    :returns: ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.
    """
    ...

def get_fchunk_num(ea: ida_idaapi.ea_t) -> int:
    r"""Get ordinal number of a function chunk in the global list of function chunks. 
            
    :param ea: any address in the function chunk
    :returns: number of function chunk (0..get_fchunk_qty()-1). -1 means 'no function chunk at the specified address'.
    """
    ...

def get_fchunk_qty() -> int:
    r"""Get total number of function chunks in the program.
    
    """
    ...

def get_fchunk_referer(ea: int, idx: Any) -> Any:
    ...

def get_file_type_name() -> str:
    r"""Get name of the current file type. The current file type is kept in idainfo::filetype. 
            
    :returns: size of answer, this function always succeeds
    """
    ...

def get_fileregion_ea(offset: qoff64_t) -> ida_idaapi.ea_t:
    r"""Get linear address which corresponds to the specified input file offset. If can't be found, return BADADDR 
            
    """
    ...

def get_fileregion_offset(ea: ida_idaapi.ea_t) -> qoff64_t:
    r"""Get offset in the input file which corresponds to the given ea. If the specified ea can't be mapped into the input file offset, return -1. 
            
    """
    ...

def get_first_cref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get first instruction referenced from the specified instruction. If the specified instruction passes execution to the next instruction then the next instruction is returned. Otherwise the lowest referenced address is returned (remember that xrefs are kept sorted!). 
            
    :returns: first referenced address. If the specified instruction doesn't reference to other instructions then returns BADADDR.
    """
    ...

def get_first_cref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get first instruction referencing to the specified instruction. If the specified instruction may be executed immediately after its previous instruction then the previous instruction is returned. Otherwise the lowest referencing address is returned. (remember that xrefs are kept sorted!). 
            
    :param to: linear address of referenced instruction
    :returns: linear address of the first referencing instruction or BADADDR.
    """
    ...

def get_first_dref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get first data referenced from the specified address. 
            
    :returns: linear address of first (lowest) data referenced from the specified address. Return BADADDR if the specified instruction/data doesn't reference to anything.
    """
    ...

def get_first_dref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get address of instruction/data referencing to the specified data. 
            
    :param to: linear address of referencing instruction or data
    :returns: BADADDR if nobody refers to the specified data.
    """
    ...

def get_first_fcref_from(frm: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_first_fcref_to(to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_first_fixup_ea() -> ida_idaapi.ea_t:
    ...

def get_first_free_extra_cmtidx(ea: ida_idaapi.ea_t, start: int) -> int:
    ...

def get_first_hidden_range() -> hidden_range_t:
    r"""Get pointer to the first hidden range. 
            
    :returns: ptr to hidden range or nullptr
    """
    ...

def get_first_module(modinfo: modinfo_t) -> bool:
    ...

def get_first_seg() -> segment_t:
    r"""Get pointer to the first segment.
    
    """
    ...

def get_fixup(fd: fixup_data_t, source: ida_idaapi.ea_t) -> bool:
    r"""Get fixup information.
    
    """
    ...

def get_fixup_desc(source: ida_idaapi.ea_t, fd: fixup_data_t) -> str:
    r"""Get FIXUP description comment.
    
    """
    ...

def get_fixup_handler(type: fixup_type_t) -> fixup_handler_t:
    r"""Get handler of standard or custom fixup.
    
    """
    ...

def get_fixup_value(ea: ida_idaapi.ea_t, type: fixup_type_t) -> int:
    r"""Get the operand value. This function get fixup bytes from data or an instruction at `ea` and convert them to the operand value (maybe partially). It is opposite in meaning to the `patch_fixup_value()`. For example, FIXUP_HI8 read a byte at `ea` and shifts it left by 8 bits, or AArch64's custom fixup BRANCH26 get low 26 bits of the insn at `ea` and shifts it left by 2 bits. This function is mainly used to get a relocation addend. 
            
    :param ea: address to get fixup bytes from, the size of the fixup bytes depends on the fixup type.
    :param type: fixup type
    :returns: operand: value
    """
    ...

def get_fixups(out: fixups_t, ea: ida_idaapi.ea_t, size: asize_t) -> bool:
    ...

def get_flags(ea: ida_idaapi.ea_t) -> flags64_t:
    r"""Get flags value for address 'ea'. The byte value is not included in the flags. This function should be used if the operand types of any operand beyond the first two operands is required. This function is more expensive to use than get_flags32() 
            
    :returns: 0 if address is not present in the program
    """
    ...

def get_flags32(ea: ida_idaapi.ea_t) -> flags64_t:
    r"""Get only 32 low bits of flags. This function returns the most commonly used bits of the flags. However, it does not return the operand info for the operands beyond the first two operands (0,1). If you need to deal with the operands (2..n), then use get_flags(). It is customary to assign the return value to the variable named "F32", to distinguish is from 64-bit flags. 
            
    :returns: 0 if address is not present in the program
    """
    ...

def get_flags_by_size(size: size_t) -> flags64_t:
    r"""Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32. For other sizes returns 0 
            
    """
    ...

def get_flags_ex(ea: ida_idaapi.ea_t, how: int) -> flags64_t:
    r"""Get flags for the specified address, extended form.
    
    """
    ...

def get_float_type(width: int) -> tinfo_t:
    r"""Get a type of a floating point value with the specified width 
            
    :param width: width of the desired type
    :returns: type info object
    """
    ...

def get_forced_operand(ea: ida_idaapi.ea_t, n: int) -> str:
    r"""Get forced operand. 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number
    :returns: size of forced operand or -1
    """
    ...

def get_frame_part(range: range_t, pfn: func_t, part: frame_part_t) -> None:
    r"""Get offsets of the frame part in the frame. 
            
    :param range: pointer to the output buffer with the frame part start/end(exclusive) offsets, can't be nullptr
    :param pfn: pointer to function structure, can't be nullptr
    :param part: frame part
    """
    ...

def get_frame_retsize(pfn: func_t) -> int:
    r"""Get size of function return address. 
            
    :param pfn: pointer to function structure, can't be nullptr
    """
    ...

def get_frame_size(pfn: func_t) -> int:
    r"""Get full size of a function frame. This function takes into account size of local variables + size of saved registers + size of return address + number of purged bytes. The purged bytes correspond to the arguments of the functions with __stdcall and __fastcall calling conventions. 
            
    :param pfn: pointer to function structure, may be nullptr
    :returns: size of frame in bytes or zero
    """
    ...

def get_full_data_elsize(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None) -> int:
    r"""Get full size of data type specified in flags 'F'. takes into account processors with wide bytes e.g. returns 2 for a byte element with 16-bit bytes 
            
    """
    ...

def get_full_flags(ea: ida_idaapi.ea_t) -> flags64_t:
    r"""Get full flags value for address 'ea'. This function returns the byte value in the flags as well. See FF_IVL and MS_VAL. This function is more expensive to use than get_flags() 
            
    :returns: 0 if address is not present in the program
    """
    ...

def get_full_type(t: type_t) -> type_t:
    r"""Get basic type bits + type flags (TYPE_FULL_MASK)
    
    """
    ...

def get_func(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to function structure by address. 
            
    :param ea: any address in a function
    :returns: ptr to a function or nullptr. This function returns a function entry chunk.
    """
    ...

def get_func_bitness(pfn: func_t) -> int:
    r"""Get function bitness (which is equal to the function segment bitness). pfn==nullptr => returns 0 
            
    :returns: 0: 16
    :returns: 1: 32
    :returns: 2: 64
    """
    ...

def get_func_bits(pfn: func_t) -> int:
    r"""Get number of bits in the function addressing.
    
    """
    ...

def get_func_bytes(pfn: func_t) -> int:
    r"""Get number of bytes in the function addressing.
    
    """
    ...

def get_func_chunknum(pfn: func_t, ea: ida_idaapi.ea_t) -> int:
    r"""Get the containing tail chunk of 'ea'. 
            
    :returns: -1: means 'does not contain ea'
    :returns: 0: means the 'pfn' itself contains ea
    :returns: >0: the number of the containing function tail chunk
    """
    ...

def get_func_cmt(pfn: func_t, repeatable: bool) -> str:
    r"""Get function comment. 
            
    :param pfn: ptr to function structure
    :param repeatable: get repeatable comment?
    :returns: size of comment or -1 In fact this function works with function chunks too.
    """
    ...

def get_func_frame(out: tinfo_t, pfn: func_t) -> bool:
    r"""Get type of function frame 
            
    :param out: type info
    :param pfn: pointer to function structure
    :returns: success
    """
    ...

def get_func_name(ea: ida_idaapi.ea_t) -> str:
    r"""Get function name. 
            
    :param ea: any address in the function
    :returns: length of the function name
    """
    ...

def get_func_num(ea: ida_idaapi.ea_t) -> int:
    r"""Get ordinal number of a function. 
            
    :param ea: any address in the function
    :returns: number of function (0..get_func_qty()-1). -1 means 'no function at the specified address'.
    """
    ...

def get_func_qty() -> int:
    r"""Get total number of functions in the program.
    
    """
    ...

def get_func_ranges(ranges: rangeset_t, pfn: func_t) -> ida_idaapi.ea_t:
    r"""Get function ranges. 
            
    :param ranges: buffer to receive the range info
    :param pfn: ptr to function structure
    :returns: end address of the last function range (BADADDR-error)
    """
    ...

def get_func_trace_options() -> int:
    r"""Get current function tracing options. Also see FT_LOG_RET \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_global_var(prov: srcinfo_provider_t, ea: ida_idaapi.ea_t, name: str, out: source_item_ptr) -> bool:
    ...

def get_gotea() -> ida_idaapi.ea_t:
    ...

def get_graph_viewer(parent: TWidget) -> graph_viewer_t:
    r"""Get custom graph viewer for given form.
    
    """
    ...

def get_group_selector(grpsel: sel_t) -> sel_t:
    r"""Get common selector for a group of segments. 
            
    :param grpsel: selector of group segment
    :returns: common selector of the group or 'grpsel' if no such group is found
    """
    ...

def get_grp_bpts(bpts: bpt_vec_t, grp_name: str) -> ssize_t:
    r"""Retrieve a copy the bpts stored in a folder \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bpts: : pointer to a vector where the copy of bpts are stored
    :param grp_name: absolute path to the folder
    :returns: number of bpts present in the vector
    """
    ...

def get_hexdump_ea(hexdump_num: int) -> ida_idaapi.ea_t:
    r"""Get the current address in a hex view. 
            
    :param hexdump_num: number of hexview window
    """
    ...

def get_hexrays_version() -> str:
    r"""Get decompiler version. The returned string is of the form <major>.<minor>.<revision>.<build-date> 
            
    :returns: pointer to version string. For example: "2.0.0.140605"
    """
    ...

def get_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t:
    r"""Get pointer to hidden range structure, in: linear address. 
            
    :param ea: any address in the hidden range
    """
    ...

def get_hidden_range_num(ea: ida_idaapi.ea_t) -> int:
    r"""Get number of a hidden range. 
            
    :param ea: any address in the hidden range
    :returns: number of hidden range (0..get_hidden_range_qty()-1)
    """
    ...

def get_hidden_range_qty() -> int:
    r"""Get number of hidden ranges.
    
    """
    ...

def get_highlight(v: Any, flags: Any = 0) -> Any:
    r"""Returns the currently highlighted identifier and flags
    
    :param v: The UI widget to operate on
    :param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
    :returns: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.
    """
    ...

def get_icon_id_by_name(icon_name: str) -> int:
    r"""Retrieve the id of the icon by name (ui_get_icon_id_by_name). 
            
    :param icon_name: full name of the icon
    :returns: icon id
    """
    ...

def get_ida_notepad_text() -> str:
    r"""Get notepad text.
    
    """
    ...

def get_ida_subdirs(subdir: str, flags: int = 0) -> qstrvec_t:
    r"""Get list of directories in which to find a specific IDA resource (see IDA subdirectories). The order of the resulting list is as follows: 
         [$IDAUSR/subdir (0..N entries)]
         $IDADIR/subdir
    
    
            
    :param subdir: name of the resource to list (can be nullptr)
    :param flags: Subdirectory modification flags bits
    :returns: number of directories appended to 'dirs'
    """
    ...

def get_idainfo_by_type(tif: tinfo_t) -> Any:
    r"""Extract information from a tinfo_t. 
            
    :param tif: the type to inspect
    """
    ...

def get_idainfo_by_udm(args: Any) -> bool:
    r"""Calculate IDA info from udt member 
            
    :param udm: udt member
    :param refinfo_ea: if specified will be used to adjust the refinfo_t data
    """
    ...

def get_idasgn_desc(n: Any) -> Any:
    r"""Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries)
    
    See also: get_idasgn_desc_with_matches
    
    :param n: number of signature in the list (0..get_idasgn_qty()-1)
    :returns: None on failure or tuple(signame, optlibs)
    """
    ...

def get_idasgn_desc_with_matches(n: Any) -> Any:
    r"""Get information about a signature in the list.
    It returns: (name of signature, names of optional libraries, number of matches)
    
    :param n: number of signature in the list (0..get_idasgn_qty()-1)
    :returns: None on failure or tuple(signame, optlibs, nmatches)
    """
    ...

def get_idasgn_header_by_short_name(out_header: idasgn_header_t, name: str) -> str:
    r"""Get idasgn header by a short signature name. 
            
    :param out_header: buffer for the signature file header
    :param name: short name of a signature
    :returns: true in case of success
    """
    ...

def get_idasgn_path_by_short_name(name: str) -> str:
    r"""Get idasgn full path by a short signature name. 
            
    :param name: short name of a signature
    :returns: true in case of success
    """
    ...

def get_idasgn_qty() -> int:
    r"""Get number of signatures in the list of planned and applied signatures. 
            
    :returns: 0..n
    """
    ...

def get_idasgn_title(name: str) -> str:
    r"""Get full description of the signature by its short name. 
            
    :param name: short name of a signature
    :returns: size of signature description or -1
    """
    ...

def get_idati() -> til_t:
    r"""Pointer to the local type library - this til is private for each IDB file Functions that accept til_t* default to `idati` when is nullptr provided. 
            
    """
    ...

def get_idb_ctime() -> time_t:
    r"""Get database creation timestamp.
    
    """
    ...

def get_idb_nopens() -> int:
    r"""Get number of times the database is opened.
    
    """
    ...

def get_idb_notifier_addr(arg1: Any) -> Any:
    ...

def get_idb_notifier_ud_addr(hooks: IDB_Hooks) -> Any:
    ...

def get_idc_filename(file: str) -> str:
    r"""Get full name of IDC file name. Search for file in list of include directories, IDCPATH directory and system directories. 
            
    :param file: file name without full path
    :returns: nullptr is file not found. otherwise returns pointer to buf
    """
    ...

def get_idcv_attr(res: idc_value_t, obj: idc_value_t, attr: str, may_use_getattr: bool = False) -> error_t:
    r"""Get an object attribute. 
            
    :param res: buffer for the attribute value
    :param obj: variable that holds an object reference. if obj is nullptr it searches global variables, then user functions
    :param attr: attribute name
    :param may_use_getattr: may call getattr functions to calculate the attribute if it does not exist
    :returns: error code, eOk on success
    """
    ...

def get_idcv_class_name(obj: idc_value_t) -> str:
    r"""Retrieves the IDC object class name. 
            
    :param obj: class instance variable
    :returns: error code, eOk on success
    """
    ...

def get_idcv_slice(res: idc_value_t, v: idc_value_t, i1: int, i2: int, flags: int = 0) -> error_t:
    r"""Get slice. 
            
    :param res: output variable that will contain the slice
    :param v: input variable (string or object)
    :param i1: slice start index
    :param i2: slice end index (excluded)
    :param flags: IDC variable slice flags or 0
    :returns: eOk if success
    """
    ...

def get_idp_name() -> str:
    r"""Get name of the current processor module. The name is derived from the file name. For example, for IBM PC the module is named "pc.w32" (windows version), then the module name is "PC" (uppercase). If no processor module is loaded, this function will return nullptr 
            
    """
    ...

def get_idp_notifier_addr(arg1: Any) -> Any:
    ...

def get_idp_notifier_ud_addr(hooks: IDP_Hooks) -> Any:
    ...

def get_ids_modnode() -> netnode:
    r"""Get ids modnode.
    
    """
    ...

def get_imagebase() -> ida_idaapi.ea_t:
    r"""Get image base address.
    
    """
    ...

def get_immvals(ea: ida_idaapi.ea_t, n: int, F: flags64_t = 0) -> Any:
    r"""Get immediate values at the specified address. This function decodes instruction at the specified address or inspects the data item. It finds immediate values and copies them to 'out'. This function will store the original value of the operands in 'out', unless the last bits of 'F' are "...0 11111111", in which case the transformed values (as needed for printing) will be stored instead. 
            
    :param ea: address to analyze
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    :param F: flags for the specified address
    :returns: number of immediate values (0..2*UA_MAXOP)
    """
    ...

def get_import_module_name(mod_index: Any) -> Any:
    r"""Returns the name of an imported module given its index
    
    :param mod_index: the module index
    :returns: None or the module name
    """
    ...

def get_import_module_qty() -> uint:
    ...

def get_ind_purged(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_initial_ida_version() -> str:
    r"""Get version of ida which created the database (string format like "7.5")
    
    """
    ...

def get_initial_idb_version() -> ushort:
    r"""Get initial version of the database (numeric format like 700)
    
    """
    ...

def get_initial_version() -> ushort:
    r"""Get initial version of the database (numeric format like 700)
    
    """
    ...

def get_input_file_path() -> str:
    r"""Get full path of the input file.
    
    """
    ...

def get_insn_tev_reg_mem(n: int, memmap: memreg_infos_t) -> bool:
    r"""Read the memory pointed by register values from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param memmap: result
    :returns: false if not an instruction event or no memory is available
    """
    ...

def get_insn_tev_reg_result(n: int, regname: str, regval: regval_t) -> bool:
    r"""Read the resulting register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param regname: name of desired register
    :param regval: result
    :returns: false if not an instruction trace event or register wasn't modified.
    """
    ...

def get_insn_tev_reg_val(n: int, regname: str, regval: regval_t) -> bool:
    r"""Read a register value from an instruction trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param regname: name of desired register
    :param regval: result
    :returns: false if not an instruction event.
    """
    ...

def get_insn_trace_options() -> int:
    r"""Get current instruction tracing options. Also see IT_LOG_SAME_IP \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_int_type_by_width_and_sign(srcwidth: int, sign: type_sign_t) -> tinfo_t:
    r"""Create a type info by width and sign. Returns a simple type (examples: int, short) with the given width and sign. 
            
    :param srcwidth: size of the type in bytes
    :param sign: sign of the type
    """
    ...

def get_ip_val() -> uint64:
    r"""Get value of the IP (program counter) register for the current thread. Requires a suspended debugger. 
            
    """
    ...

def get_item_color(ea: ida_idaapi.ea_t) -> bgcolor_t:
    ...

def get_item_end(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get the end address of the item at 'ea'. The returned address doesn't belong to the current item. Unexplored bytes are counted as 1 byte entities. 
            
    """
    ...

def get_item_flag(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, appzero: bool) -> flags64_t:
    r"""Get flag of the item at 'ea' even if it is a tail byte of some array or structure. This function is used to get flags of structure members or array elements. 
            
    :param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
    :param ea: the referenced address
    :param appzero: append a struct field name if the field offset is zero? meaningful only if the name refers to a structure.
    :returns: flags or 0 (if failed)
    """
    ...

def get_item_head(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get the start address of the item at 'ea'. If there is no current item, then 'ea' will be returned (see definition at the end of bytes.hpp source) 
            
    """
    ...

def get_item_refinfo(ri: refinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Get refinfo of the item at 'ea'. This function works for a regular offset operand as well as for a tail byte of a structure variable (in this case refinfo to corresponding structure member will be returned) 
            
    :param ri: refinfo holder
    :param ea: the item address
    :param n: operand number which refers to 'ea' or OPND_ALL for one of the operands
    :returns: success
    """
    ...

def get_item_size(ea: ida_idaapi.ea_t) -> int:
    r"""Get size of item (instruction/data) in bytes. Unexplored bytes have length of 1 byte. This function returns 0 only for BADADDR. 
            
    """
    ...

def get_kernel_version() -> str:
    r"""Get IDA kernel version (in a string like "5.1").
    
    """
    ...

def get_key_code(keyname: str) -> ushort:
    r"""Get keyboard key code by its name (ui_get_key_code)
    
    """
    ...

def get_last_hidden_range() -> hidden_range_t:
    r"""Get pointer to the last hidden range. 
            
    :returns: ptr to hidden range or nullptr
    """
    ...

def get_last_seg() -> segment_t:
    r"""Get pointer to the last segment.
    
    """
    ...

def get_last_widget(args: Any) -> TWidget:
    r"""Get last ida viewer (idaview or custom viewer) (ui_get_last_widget) 
            
    :param mask: an OR'ed set of IWID_* to limit the search to
    :returns: the viewer, if found
    """
    ...

def get_linput_type(li: linput_t) -> linput_type_t:
    ...

def get_loader_format_name() -> str:
    r"""Get file format name for loader modules.
    
    """
    ...

def get_local_var(prov: srcinfo_provider_t, ea: ida_idaapi.ea_t, name: str, out: source_item_ptr) -> bool:
    ...

def get_local_vars(prov: srcinfo_provider_t, ea: ida_idaapi.ea_t, out: source_items_t) -> bool:
    ...

def get_logical_core_count() -> int:
    r"""Get the total CPU logical core count 
            
    :returns: the logical core count, or -1 on error
    """
    ...

def get_login_name() -> str:
    r"""Get the user name for the current desktop session 
            
    :returns: success
    """
    ...

def get_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    ...

def get_lookback() -> int:
    r"""Number of instructions to look back. This variable is not used by the kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>. IDP may use it as you like it. (TMS module uses it) 
            
    """
    ...

def get_mangled_name_type(name: str) -> mangled_name_type_t:
    ...

def get_manual_insn(ea: ida_idaapi.ea_t) -> str:
    r"""Retrieve the user-specified string for the manual instruction. 
            
    :param ea: linear address of the instruction or data item
    :returns: size of manual instruction or -1
    """
    ...

def get_manual_regions(args: Any) -> Any:
    r"""Returns the manual memory regions
    
    This function has the following signatures:
    
        1. get_manual_regions() -> List[Tuple(ida_idaapi.ea_t, ida_idaapi.ea_t, str, str, ida_idaapi.ea_t, int, int)]
           Where each tuple holds (start_ea, end_ea, name, sclass, sbase, bitness, perm)
        2. get_manual_regions(storage: meminfo_vec_t) -> None
    """
    ...

def get_mapping(n: size_t) -> Any:
    r"""Get memory mapping range by its number. 
            
    :param n: number of mapping range (0..get_mappings_qty()-1)
    :returns: false if the specified range doesn't exist, otherwise returns `from`, `to`, `size`
    """
    ...

def get_mappings_qty() -> int:
    r"""Get number of mappings.
    
    """
    ...

def get_mark_comment(slot: int) -> Any:
    ...

def get_marked_pos(slot: int) -> ida_idaapi.ea_t:
    ...

def get_max_strlit_length(ea: ida_idaapi.ea_t, strtype: int, options: int = 0) -> int:
    r"""Determine maximum length of string literal.
    If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the length of that prefix (i.e., 2) will be part of the returned value.
    
    :param ea: starting address
    :param strtype: string type. one of String type codes
    :param options: combination of string literal length options
    :returns: length of the string in octets (octet==8bit)
    """
    ...

def get_merror_desc(code: merror_t, mba: mba_t) -> str:
    r"""Get textual description of an error code 
            
    :param code: Microcode error code
    :param mba: the microcode array
    :returns: the error address
    """
    ...

def get_module_info(ea: ida_idaapi.ea_t, modinfo: modinfo_t) -> bool:
    ...

def get_mreg_name(reg: mreg_t, width: int, ud: void = None) -> str:
    r"""Get the microregister name. 
            
    :param reg: microregister number
    :param width: size of microregister in bytes. may be bigger than the real register size.
    :param ud: reserved, must be nullptr
    :returns: width of the printed register. this value may be less than the WIDTH argument.
    """
    ...

def get_name(ea: ida_idaapi.ea_t) -> str:
    ...

def get_name_base_ea(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get address of the name used in the expression for the address 
            
    :param to: the referenced address
    :returns: address of the name used to represent the operand
    """
    ...

def get_name_color(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> color_t:
    r"""Calculate flags for get_ea_name() function.
    
    Get name color. 
            
    :param ea: linear address
    """
    ...

def get_name_ea(_from: ida_idaapi.ea_t, name: str) -> ida_idaapi.ea_t:
    r"""Get the address of a name. This function resolves a name into an address. It can handle regular global and local names, as well as debugger names. 
            
    :param name: any name in the program or nullptr
    :returns: address of the name or BADADDR
    """
    ...

def get_name_expr(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, off: int, flags: int = 1) -> str:
    r"""Convert address to name expression (name with a displacement). This function takes into account fixup information and returns a colored name expression (in the form <name> +/- <offset>). It also knows about structure members and arrays. If the specified address doesn't have a name, a dummy name is generated. 
            
    :param n: number of referencing operand. for data items specify 0
    :param ea: address to convert to name expression
    :param off: the value of name expression. this parameter is used only to check that the name expression will have the wanted value. 'off' may be equal to BADADDR but this is discouraged because it prohibits checks.
    :param flags: Name expression flags
    :returns: < 0 if address is not valid, no segment or other failure. otherwise the length of the name expression in characters.
    """
    ...

def get_name_value(_from: ida_idaapi.ea_t, name: str) -> uval_t:
    r"""Get value of the name. This function knows about: regular names, enums, special segments, etc. 
            
    :param name: any name in the program or nullptr
    :returns: Name value result codes
    """
    ...

def get_named_type(til: til_t, name: str, ntf_flags: int) -> Any:
    r"""Get a type data by its name.
    
    :param til: Type library
    :param name: the type name
    :param ntf_flags: a combination of NTF_* constants
    :returns: tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success, or None on failure
    """
    ...

def get_named_type64(til: til_t, name: str, ntf_flags: int = 0) -> Any:
    r"""Get a named type from a type library.
    
    Please use til_t.get_named_type instead.
    """
    ...

def get_named_type_tid(name: str) -> tid_t:
    r"""Get named local type TID 
            
    :param name: type name
    :returns: TID or BADADDR
    """
    ...

def get_navband_ea(pixel: int) -> ida_idaapi.ea_t:
    r"""Translate the pixel position on the navigation band, into an address.
    
    """
    ...

def get_navband_pixel(ea: Any) -> Any:
    r"""Maps an address, onto a pixel coordinate within the navigation band
    
    :param ea: The address to map
    :returns: a list [pixel, is_vertical]
    """
    ...

def get_next_cref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get next instruction referenced from the specified instruction. 
            
    :param current: linear address of current referenced instruction This value is returned by get_first_cref_from() or previous call to get_next_cref_from() functions.
    :returns: next referenced address or BADADDR.
    """
    ...

def get_next_cref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get next instruction referencing to the specified instruction. 
            
    :param to: linear address of referenced instruction
    :param current: linear address of current referenced instruction This value is returned by get_first_cref_to() or previous call to get_next_cref_to() functions.
    :returns: linear address of the next referencing instruction or BADADDR.
    """
    ...

def get_next_dref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get next data referenced from the specified address. 
            
    :param current: linear address of current referenced data. This value is returned by get_first_dref_from() or previous call to get_next_dref_from() functions.
    :returns: linear address of next data or BADADDR.
    """
    ...

def get_next_dref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get address of instruction/data referencing to the specified data 
            
    :param to: linear address of referencing instruction or data
    :param current: current linear address. This value is returned by get_first_dref_to() or previous call to get_next_dref_to() functions.
    :returns: BADADDR if nobody refers to the specified data.
    """
    ...

def get_next_fchunk(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to the next function chunk in the global list. 
            
    :param ea: any address in the program
    :returns: ptr to function chunk or nullptr if next function chunk doesn't exist
    """
    ...

def get_next_fcref_from(frm: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_next_fcref_to(to: ida_idaapi.ea_t, current: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_next_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_next_func(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to the next function. 
            
    :param ea: any address in the program
    :returns: ptr to function or nullptr if next function doesn't exist
    """
    ...

def get_next_func_addr(pfn: func_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_next_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t:
    r"""Get pointer to next hidden range. 
            
    :param ea: any address in the program
    :returns: ptr to hidden range or nullptr if next hidden range doesn't exist
    """
    ...

def get_next_module(modinfo: modinfo_t) -> bool:
    ...

def get_next_seg(ea: ida_idaapi.ea_t) -> segment_t:
    r"""Get pointer to the next segment.
    
    """
    ...

def get_nice_colored_name(ea: ida_idaapi.ea_t, flags: int = 0) -> str:
    r"""Get a nice colored name at the specified address. Ex:
    * segment:sub+offset
    * segment:sub:local_label
    * segment:label
    * segment:address
    * segment:address+offset
    
    
    
    :param ea: linear address
    :param flags: Nice colored name flags
    :returns: the length of the generated name in bytes.
    """
    ...

def get_nlist_ea(idx: size_t) -> ida_idaapi.ea_t:
    ...

def get_nlist_idx(ea: ida_idaapi.ea_t) -> int:
    ...

def get_nlist_name(idx: size_t) -> str:
    ...

def get_nlist_size() -> int:
    ...

def get_node_info(out: node_info_t, gid: graph_id_t, node: int) -> bool:
    r"""Get node info. 
            
    :param out: result
    :param gid: id of desired graph
    :param node: node number
    :returns: success
    """
    ...

def get_numbered_type(til: til_t, ordinal: int) -> Any:
    r"""Get a type from a type library, by its ordinal
    
    Please use til_t.get_numbered_type instead.
    """
    ...

def get_numbered_type_name(ti: til_t, ordinal: int) -> str:
    r"""Get type name (if exists) by its ordinal. If the type is anonymous, returns "". If failed, returns nullptr 
            
    """
    ...

def get_octet(ogen: octet_generator_t) -> uchar:
    ...

def get_offbase(ea: ida_idaapi.ea_t, n: int) -> ida_idaapi.ea_t:
    r"""Get offset base value 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number
    :returns: offset base or BADADDR
    """
    ...

def get_offset_expr(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t, _from: ida_idaapi.ea_t, offset: adiff_t, getn_flags: int = 0) -> str:
    r"""See get_offset_expression()
    
    """
    ...

def get_offset_expression(ea: ida_idaapi.ea_t, n: int, _from: ida_idaapi.ea_t, offset: adiff_t, getn_flags: int = 0) -> str:
    r"""Get offset expression (in the form "offset name+displ"). This function uses offset translation function ( processor_t::translate) if your IDP module has such a function. Translation function is used to map linear addresses in the program (only for offsets).
    Example: suppose we have instruction at linear address 0x00011000: `mov     ax, [bx+7422h] ` and at ds:7422h: `array   dw      ... ` We want to represent the second operand with an offset expression, so then we call: `get_offset_expresion(0x001100, 1, 0x001102, 0x7422, buf);
                         |         |  |         |       |
                         |         |  |         |       +output buffer
                         |         |  |         +value of offset expression
                         |         |  +address offset value in the instruction
                         |         +the second operand
                         +address of instruction` and the function will return a colored string: `offset array ` 
            
    :param ea: start of instruction or data with the offset expression
    :param n: operand number (may be ORed with OPND_OUTER)
    * 0: first operand
    * 1: second operand
    * ...
    * 7: eighth operand
    :param offset: value of operand or its part. The function will return text representation of this value as offset expression.
    :param getn_flags: combination of:
    * GETN_APPZERO: meaningful only if the name refers to a structure. appends the struct field name if the field offset is zero
    * GETN_NODUMMY: do not generate dummy names for the expression but pretend they already exist (useful to verify that the offset expression can be represented)
    :returns: 0: can't convert to offset expression
    :returns: 1: ok, a simple offset expression
    :returns: 2: ok, a complex offset expression
    """
    ...

def get_op_signness(op: ctype_t) -> type_sign_t:
    r"""Get operator sign. Meaningful for sign-dependent operators, like cot_sdiv.
    
    """
    ...

def get_op_tinfo(tif: tinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool:
    ...

def get_operand_flag(typebits: uint8, n: int) -> flags64_t:
    r"""Place operand `n`'s type flag in the right nibble of a 64-bit flags set.
    
    :param typebits: the type bits (one of `FF_N_`)
    :param n: the operand number
    :returns: the shift to the nibble
    """
    ...

def get_operand_type_shift(n: int) -> int:
    r"""Get the shift in `flags64_t` for the nibble representing operand `n`'s type
    Note: n must be < UA_MAXOP, and is not checked
    
    :param n: the operand number
    :returns: the shift to the nibble
    """
    ...

def get_opinfo(buf: opinfo_t, ea: ida_idaapi.ea_t, n: int, flags: flags64_t) -> opinfo_t:
    r"""Get additional information about an operand representation. 
            
    :param buf: buffer to receive the result. may not be nullptr
    :param ea: linear address of item
    :param n: number of operand, 0 or 1
    :param flags: flags of the item
    :returns: nullptr if no additional representation information
    """
    ...

def get_opnum() -> int:
    r"""Get current operand number, -1 means no operand (ui_get_opnum)
    
    """
    ...

def get_optype_flags0(F: flags64_t) -> flags64_t:
    r"""Get flags for first operand.
    
    """
    ...

def get_optype_flags1(F: flags64_t) -> flags64_t:
    r"""Get flags for second operand.
    
    """
    ...

def get_ordinal_count(ti: til_t = None) -> int:
    r"""Get number of allocated ordinals. 
            
    :param ti: type library; nullptr means the local types for the current database.
    :returns: 0 if ordinals have not been enabled for the til.
    """
    ...

def get_ordinal_limit(ti: til_t = None) -> int:
    r"""Get number of allocated ordinals + 1. If there are no allocated ordinals, return 0. To enumerate all ordinals, use: for ( uint32 i = 1; i < limit; ++i ) 
            
    :param ti: type library; nullptr means the local types for the current database.
    :returns: uint32(-1) if ordinals have not been enabled for the til. For local types (idati), ordinals are always enabled.
    """
    ...

def get_original_byte(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get original byte value (that was before patching). This function works for wide byte processors too. 
            
    """
    ...

def get_original_dword(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get original dword (that was before patching) This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    """
    ...

def get_original_qword(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get original qword value (that was before patching) This function DOESN'T work for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    """
    ...

def get_original_word(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get original word value (that was before patching). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    """
    ...

def get_outfile_encoding_idx() -> int:
    ...

def get_output_curline(mouse: bool) -> str:
    r"""Get current line of output window (ui_get_output_curline). 
            
    :param mouse: current for mouse pointer?
    :returns: false if output contains no text
    """
    ...

def get_output_cursor() -> Any:
    r"""Get coordinates of the output window's cursor (ui_get_output_cursor). 
            
    :returns: false: the output window has been destroyed.
    :returns: true: pointers are filled
    """
    ...

def get_output_selected_text() -> str:
    r"""Returns selected text from output window (ui_get_output_selected_text). 
            
    :returns: true if there is a selection
    """
    ...

def get_parser_option(parser_name: str, option_name: str) -> str:
    r"""Get option for the parser with the specified name 
            
    :param parser_name: name of the target parser
    :param option_name: parser option name
    :returns: success
    """
    ...

def get_path(pt: path_type_t) -> str:
    r"""Get the file path 
            
    :param pt: file path type Types of the file pathes
    :returns: file path, never returns nullptr
    """
    ...

def get_ph() -> processor_t:
    ...

def get_physical_core_count() -> int:
    r"""Get the total CPU physical core count 
            
    :returns: the physical core count, or -1 on error
    """
    ...

def get_place_class(out_flags: int, out_sdk_version: int, id: int) -> place_t:
    r"""Get information about a previously-registered place_t class. See also register_place_class(). 
            
    :param out_flags: output flags (can be nullptr)
    :param out_sdk_version: sdk version the place was created with (can be nullptr)
    :param id: place class ID
    :returns: the place_t template, or nullptr if not found
    """
    ...

def get_place_class_id(name: str) -> int:
    r"""Get the place class ID for the place that has been registered as 'name'. 
            
    :param name: the class name
    :returns: the place class ID, or -1 if not found
    """
    ...

def get_place_class_template(id: int) -> place_t:
    r"""See get_place_class()
    
    """
    ...

def get_plugin_options(plugin: str) -> str:
    r"""Get plugin options from the command line. If the user has specified the options in the -Oplugin_name:options format, them this function will return the 'options' part of it The 'plugin' parameter should denote the plugin name Returns nullptr if there we no options specified 
            
    """
    ...

def get_possible_item_varsize(ea: ida_idaapi.ea_t, tif: tinfo_t) -> int:
    r"""Return the possible size of the item at EA of type TIF if TIF is the variable structure. 
            
    :param ea: the linear address of the item
    :param tif: the item type
    :returns: the possible size
    :returns: asize_t(-1): TIF is not a variable structure
    """
    ...

def get_predef_insn_cmt(ins: insn_t) -> str:
    r"""Get predefined comment. 
            
    :param ins: current instruction information
    :returns: size of comment or -1
    """
    ...

def get_prev_fchunk(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to the previous function chunk in the global list. 
            
    :param ea: any address in the program
    :returns: ptr to function chunk or nullptr if previous function chunk doesn't exist
    """
    ...

def get_prev_fixup_ea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_prev_func(ea: ida_idaapi.ea_t) -> func_t:
    r"""Get pointer to the previous function. 
            
    :param ea: any address in the program
    :returns: ptr to function or nullptr if previous function doesn't exist
    """
    ...

def get_prev_func_addr(pfn: func_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_prev_hidden_range(ea: ida_idaapi.ea_t) -> hidden_range_t:
    r"""Get pointer to previous hidden range. 
            
    :param ea: any address in the program
    :returns: ptr to hidden range or nullptr if previous hidden range doesn't exist
    """
    ...

def get_prev_seg(ea: ida_idaapi.ea_t) -> segment_t:
    r"""Get pointer to the previous segment.
    
    """
    ...

def get_prev_sreg_range(out: sreg_range_t, ea: ida_idaapi.ea_t, rg: int) -> bool:
    r"""Get segment register range previous to one with address. 
            
    :param out: segment register range
    :param ea: any linear address in the program
    :param rg: the segment register number
    :returns: success
    """
    ...

def get_printable_immvals(ea: ida_idaapi.ea_t, n: int, F: flags64_t = 0) -> Any:
    r"""Get immediate ready-to-print values at the specified address 
            
    :param ea: address to analyze
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all the operands
    :param F: flags for the specified address
    :returns: number of immediate values (0..2*UA_MAXOP)
    """
    ...

def get_problem(type: problist_id_t, lowea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get an address from the specified problem list. The address is not removed from the list. 
            
    :param type: problem list type
    :param lowea: the returned address will be higher or equal than the specified address
    :returns: linear address or BADADDR
    """
    ...

def get_problem_desc(t: problist_id_t, ea: ida_idaapi.ea_t) -> str:
    r"""Get the human-friendly description of the problem, if one was provided to remember_problem. 
            
    :param t: problem list type.
    :param ea: linear address.
    :returns: the message length or -1 if none
    """
    ...

def get_problem_name(type: problist_id_t, longname: bool = True) -> str:
    r"""Get problem list description.
    
    """
    ...

def get_process_options() -> Any:
    r"""Get process options. Any of the arguments may be nullptr 
            
    """
    ...

def get_process_options2() -> Any:
    ...

def get_process_state() -> int:
    r"""Return the state of the currently debugged process. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: one of Debugged process states
    """
    ...

def get_processes(proclist: procinfo_vec_t) -> ssize_t:
    r"""Take a snapshot of running processes and return their description. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param proclist: array with information about each running process
    :returns: number of processes or -1 on error
    """
    ...

def get_qword(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get one qword (64-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            
    """
    ...

def get_radix(F: flags64_t, n: int) -> int:
    r"""Get radix of the operand, in: flags. If the operand is not a number, returns get_default_radix() 
            
    :param F: flags
    :param n: number of operand (0, 1, -1)
    :returns: 2, 8, 10, 16
    """
    ...

def get_redo_action_label() -> str:
    r"""Get the label of the action that will be redone. This function returns the text that can be displayed in the redo menu 
            
    :returns: success
    """
    ...

def get_refinfo(ri: refinfo_t, ea: ida_idaapi.ea_t, n: int) -> bool:
    ...

def get_reftype_by_size(size: size_t) -> reftype_t:
    r"""Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other sizes returns reftype_t(-1) 
            
    """
    ...

def get_reg_info(regname: str, bitrange: bitrange_t) -> str:
    ...

def get_reg_name(reg: int, width: size_t, reghi: int = -1) -> str:
    r"""Get text representation of a register. For most processors this function will just return processor_t::reg_names[reg]. If the processor module has implemented processor_t::get_reg_name, it will be used instead 
            
    :param reg: internal register number as defined in the processor module
    :param width: register width in bytes
    :param reghi: if specified, then this function will return the register pair
    :returns: length of register name in bytes or -1 if failure
    """
    ...

def get_reg_val(args: Any) -> Any:
    r"""Get a register value.
    
    This function has the following signatures:
    
        1. get_reg_val(name: str) -> Union[int, float, bytes]
        2. get_reg_val(name: str, regval: regval_t) -> bool
    
    The first (and most user-friendly) form will return
    a value whose type is related to the register type.
    I.e., either an integer, a float or, in the case of large
    vector registers, a bytes sequence.
    
    :param name: the register name
    :returns: the register value (1st form)
    """
    ...

def get_reg_vals(tid: int, clsmask: int = -1) -> ida_idd.regvals_t:
    r"""Fetch live registers values for the thread
    
    :param tid: The ID of the thread to read registers for
    :param clsmask: An OR'ed mask of register classes to
           read values for (can be used to speed up the
           retrieval process)
    
    :returns: a list of register values (empty if an error occurs)
    """
    ...

def get_registered_actions() -> List[str]:
    r"""Get a list with the names of all currently-registered actions.
    
    :returns: the list of action names
    """
    ...

def get_ret_tev_return(n: int) -> ida_idaapi.ea_t:
    r"""Get the return address from a function return trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :returns: BADADDR if not a function return event.
    """
    ...

def get_root_filename() -> str:
    r"""Get file name only of the input file.
    
    """
    ...

def get_running_notification() -> dbg_notification_t:
    r"""Get the notification associated (if any) with the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: dbg_null if no running request
    """
    ...

def get_running_request() -> ui_notification_t:
    r"""Get the current running request. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: ui_null if no running request
    """
    ...

def get_scalar_bt(size: int) -> type_t:
    ...

def get_screen_ea() -> ida_idaapi.ea_t:
    r"""Get the address at the screen cursor (ui_screenea)
    
    """
    ...

def get_segm_base(s: segment_t) -> ida_idaapi.ea_t:
    r"""Get segment base linear address. Segment base linear address is used to calculate virtual addresses. The virtual address of the first byte of the segment will be (start address of segment - segment base linear address) 
            
    :param s: pointer to segment
    :returns: 0 if s == nullptr, otherwise segment base linear address
    """
    ...

def get_segm_by_name(name: str) -> segment_t:
    r"""Get pointer to segment by its name. If there are several segments with the same name, returns the first of them. 
            
    :param name: segment name. may be nullptr.
    :returns: nullptr or pointer to segment structure
    """
    ...

def get_segm_by_sel(selector: sel_t) -> segment_t:
    r"""Get pointer to segment structure. This function finds a segment by its selector. If there are several segments with the same selectors, the last one will be returned. 
            
    :param selector: a segment with the specified selector will be returned
    :returns: pointer to segment or nullptr
    """
    ...

def get_segm_class(s: segment_t) -> str:
    r"""Get segment class. Segment class is arbitrary text (max 8 characters). 
            
    :param s: pointer to segment
    :returns: size of segment class (-1 if s==nullptr or bufsize<=0)
    """
    ...

def get_segm_name(s: segment_t, flags: int = 0) -> str:
    r"""Get true segment name by pointer to segment. 
            
    :param s: pointer to segment
    :param flags: 0-return name as is; 1-substitute bad symbols with _ 1 corresponds to GN_VISIBLE
    :returns: size of segment name (-1 if s==nullptr)
    """
    ...

def get_segm_num(ea: ida_idaapi.ea_t) -> int:
    r"""Get number of segment by address. 
            
    :param ea: linear address belonging to the segment
    :returns: -1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..get_segm_qty()-1)
    """
    ...

def get_segm_para(s: segment_t) -> ida_idaapi.ea_t:
    r"""Get segment base paragraph. Segment base paragraph may be converted to segment base linear address using to_ea() function. In fact, to_ea(get_segm_para(s), 0) == get_segm_base(s). 
            
    :param s: pointer to segment
    :returns: 0 if s == nullptr, the segment base paragraph
    """
    ...

def get_segm_qty() -> int:
    r"""Get number of segments.
    
    """
    ...

def get_segment_alignment(align: uchar) -> str:
    r"""Get text representation of segment alignment code. 
            
    :returns: text digestable by IBM PC assembler.
    """
    ...

def get_segment_cmt(s: segment_t, repeatable: bool) -> str:
    r"""Get segment comment. 
            
    :param s: pointer to segment structure
    :param repeatable: 0: get regular comment. 1: get repeatable comment.
    :returns: size of comment or -1
    """
    ...

def get_segment_combination(comb: uchar) -> str:
    r"""Get text representation of segment combination code. 
            
    :returns: text digestable by IBM PC assembler.
    """
    ...

def get_segment_translations(transmap: eavec_t, segstart: ida_idaapi.ea_t) -> ssize_t:
    r"""Get segment translation list. 
            
    :param transmap: vector of segment start addresses for the translation list
    :param segstart: start address of the segment to get information about
    :returns: -1 if no translation list or bad segstart. otherwise returns size of translation list.
    """
    ...

def get_selected_parser_name() -> str:
    r"""Get current parser name. 
            
    :returns: success
    """
    ...

def get_selector_qty() -> int:
    r"""Get number of defined selectors.
    
    """
    ...

def get_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    ...

def get_signed_mcode(code: mcode_t) -> mcode_t:
    ...

def get_source_linnum(ea: ida_idaapi.ea_t) -> int:
    ...

def get_sourcefile(ea: ida_idaapi.ea_t, bounds: range_t = None) -> str:
    ...

def get_sp_delta(pfn: func_t, ea: ida_idaapi.ea_t) -> int:
    r"""Get modification of SP made at the specified location 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address
    :returns: 0 if the specified location doesn't contain a SP change point. otherwise return delta of SP modification.
    """
    ...

def get_sp_val() -> uint64:
    r"""Get value of the SP register for the current thread. Requires a suspended debugger. 
            
    """
    ...

def get_spd(pfn: func_t, ea: ida_idaapi.ea_t) -> int:
    r"""Get difference between the initial and current values of ESP. 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address of the instruction
    :returns: 0 or the difference, usually a negative number. returns the sp-diff before executing the instruction.
    """
    ...

def get_special_folder(csidl: int) -> str:
    r"""Get a folder location by CSIDL (see Common CSIDLs). Path should be of at least MAX_PATH size 
            
    """
    ...

def get_srcdbg_paths() -> str:
    r"""Get source debug paths.
    
    """
    ...

def get_srcdbg_undesired_paths() -> str:
    r"""Get user-closed source files.
    
    """
    ...

def get_srcinfo_provider(name: str) -> srcinfo_provider_t:
    ...

def get_sreg(ea: ida_idaapi.ea_t, rg: int) -> sel_t:
    r"""Get value of a segment register. This function uses segment register range and default segment register values stored in the segment structure. 
            
    :param ea: linear address in the program
    :param rg: number of the segment register
    :returns: value of the segment register, BADSEL if value is unknown or rg is not a segment register.
    """
    ...

def get_sreg_range(out: sreg_range_t, ea: ida_idaapi.ea_t, rg: int) -> bool:
    r"""Get segment register range by linear address. 
            
    :param out: segment register range
    :param ea: any linear address in the program
    :param rg: the segment register number
    :returns: success
    """
    ...

def get_sreg_range_num(ea: ida_idaapi.ea_t, rg: int) -> int:
    r"""Get number of segment register range by address. 
            
    :param ea: any address in the range
    :param rg: the segment register number
    :returns: -1 if no range occupies the specified address. otherwise returns number of the specified range (0..get_srranges_qty()-1)
    """
    ...

def get_sreg_ranges_qty(rg: int) -> int:
    r"""Get number of segment register ranges. 
            
    :param rg: the segment register number
    """
    ...

def get_std_dirtree(id: dirtree_id_t) -> dirtree_t:
    ...

def get_step_trace_options() -> int:
    r"""Get current step tracing options. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: Step trace options
    """
    ...

def get_stkarg_area_info(out: stkarg_area_info_t, cc: callcnv_t) -> bool:
    r"""Some calling conventions foresee special areas on the stack for call arguments. This structure lists their sizes. 
            
    """
    ...

def get_stock_tinfo(tif: tinfo_t, id: stock_type_id_t) -> bool:
    ...

def get_str_encoding_idx(strtype: int) -> uchar:
    ...

def get_str_term1(strtype: int) -> char:
    ...

def get_str_term2(strtype: int) -> char:
    ...

def get_str_type(ea: ida_idaapi.ea_t) -> int:
    ...

def get_str_type_code(strtype: int) -> uchar:
    ...

def get_str_type_prefix_length(strtype: int) -> int:
    ...

def get_strid(ea: ida_idaapi.ea_t) -> tid_t:
    ...

def get_strlist_item(si: string_info_t, n: size_t) -> bool:
    r"""Get nth element of the string list (n=0..get_strlist_qty()-1)
    
    """
    ...

def get_strlist_options() -> strwinsetup_t:
    r"""Get the static string list options.
    
    """
    ...

def get_strlist_qty() -> int:
    r"""Get number of elements in the string list. The list will be loaded from the database (if saved) or built from scratch. 
            
    """
    ...

def get_strlit_contents(ea: ida_idaapi.ea_t, len: int, type: int, flags: int = 0) -> Any:
    r"""Get contents of string literal, as UTF-8-encoded codepoints.
    It works even if the string has not been created in the database yet.
    
    Note that the returned value will be of type 'bytes'; if
    you want auto-conversion to unicode strings (that is: real Python
    strings), you should probably be using the idautils.Strings class.
    
    :param ea: linear address of the string
    :param len: length of the string in bytes (including terminating 0)
    :param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    :param flags: combination of STRCONV_..., to perform output conversion.
    :returns: a bytes-filled str object.
    """
    ...

def get_stroff_path(args: Any) -> Any:
    r"""Get the structure offset path for operand `n`, at the
    specified address.
    
    This function has the following signatures:
    
        1. get_stroff_path(ea: ida_idaapi.ea_t, n : int) -> Tuple[List[int], int]
        2. get_stroff_path(path: tid_array, delta: sval_pointer, ea: ida_idaapi.ea_t, n : int) (backward-compatibility only)
    
    :param ea: address where the operand holds a path to a structure offset (1st form)
    :param n: operand number (1st form)
    :returns: a tuple holding a (list_of_tid_t's, delta_within_the_last_type), or (None, None)
    """
    ...

def get_strtype_bpu(strtype: int) -> int:
    ...

def get_switch_info(args: Any) -> Any:
    ...

def get_switch_parent(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    ...

def get_synced_group(w: TWidget) -> synced_group_t:
    r"""Get the group of widgets/registers this view is synchronized with 
            
    :param w: the widget
    :returns: the group of widgets/registers, or nullptr
    """
    ...

def get_tab_size(path: str) -> int:
    r"""Get the size of a tab in spaces (ui_get_tab_size). 
            
    :param path: the path of the source view for which the tab size is requested.
    * if nullptr, the default size is returned.
    """
    ...

def get_temp_regs() -> mlist_t:
    r"""Get list of temporary registers. Tempregs are temporary registers that are used during code generation. They do not map to regular processor registers. They are used only to store temporary values during execution of one instruction. Tempregs may not be used to pass a value from one block to another. In other words, at the end of a block all tempregs must be dead. 
            
    """
    ...

def get_tev_ea(n: int) -> ida_idaapi.ea_t:
    ...

def get_tev_event(n: int, d: debug_event_t) -> bool:
    r"""Get the corresponding debug event, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param d: result
    :returns: false if the tev_t object doesn't have any associated debug event, true otherwise, with the debug event in "d".
    """
    ...

def get_tev_info(n: int, tev_info: tev_info_t) -> bool:
    r"""Get main information about a trace event. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param tev_info: result
    :returns: success
    """
    ...

def get_tev_memory_info(n: int, mi: meminfo_vec_t) -> bool:
    r"""Get the memory layout, if any, for the specified tev object. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of trace event, is in range 0..get_tev_qty()-1. 0 represents the latest added trace event.
    :param mi: result
    :returns: false if the tev_t object is not of type tev_mem, true otherwise, with the new memory layout in "mi".
    """
    ...

def get_tev_qty() -> int:
    r"""Get number of trace events available in trace buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_tev_reg_mem(tev: Any, idx: Any) -> Any:
    ...

def get_tev_reg_mem_ea(tev: Any, idx: Any) -> Any:
    ...

def get_tev_reg_mem_qty(tev: Any) -> Any:
    ...

def get_tev_reg_val(tev: Any, reg: Any) -> Any:
    ...

def get_tev_tid(n: int) -> int:
    ...

def get_tev_type(n: int) -> int:
    ...

def get_thread_qty() -> int:
    r"""Get number of threads. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def get_tid_name(tid: tid_t) -> str:
    r"""Get a type name for the specified TID 
            
    :param tid: type TID
    :returns: true if there is type with TID
    """
    ...

def get_tid_ordinal(tid: tid_t) -> int:
    r"""Get type ordinal number for TID 
            
    :param tid: type/enum constant/udt member TID
    :returns: type ordinal number or 0
    """
    ...

def get_tinfo(tif: tinfo_t, ea: ida_idaapi.ea_t) -> bool:
    ...

def get_tinfo_attr(typid: typid_t, key: str, bv: bytevec_t, all_attrs: bool) -> bool:
    ...

def get_tinfo_attrs(typid: typid_t, tav: type_attrs_t, include_ref_attrs: bool) -> bool:
    ...

def get_tinfo_by_edm_name(tif: tinfo_t, til: til_t, mname: str) -> ssize_t:
    ...

def get_tinfo_by_flags(out: tinfo_t, flags: flags64_t) -> bool:
    r"""Get tinfo object that corresponds to data flags 
            
    :param out: type info
    :param flags: simple flags (byte, word, ..., zword)
    """
    ...

def get_tinfo_details(typid: typid_t, bt2: type_t, buf: void) -> bool:
    ...

def get_tinfo_pdata(outptr: void, typid: typid_t, what: int) -> int:
    ...

def get_tinfo_property(typid: typid_t, gta_prop: int) -> int:
    ...

def get_tinfo_property4(typid: typid_t, gta_prop: int, p1: size_t, p2: size_t, p3: size_t, p4: size_t) -> int:
    ...

def get_tinfo_size(p_effalign: uint32, typid: typid_t, gts_code: int) -> int:
    ...

def get_trace_base_address() -> ida_idaapi.ea_t:
    r"""Get the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: the base address of the currently loaded trace
    """
    ...

def get_trace_dynamic_register_set(idaregs: dynamic_register_set_t) -> None:
    r"""Get dynamic register set of current trace.
    
    """
    ...

def get_trace_file_desc(filename: str) -> str:
    r"""Get the file header of the specified trace file.
    
    """
    ...

def get_trace_platform() -> str:
    r"""Get platform name of current trace.
    
    """
    ...

def get_tryblks(tbv: tryblks_t, range: range_t) -> int:
    r"""------------------------------------------------------------------------- Retrieve try block information from the specified address range. Try blocks are sorted by starting address and their nest levels calculated. 
            
    :param tbv: output buffer; may be nullptr
    :param range: address range to change
    :returns: number of found try blocks
    """
    ...

def get_type(id: int, tif: tinfo_t, guess: type_source_t) -> bool:
    r"""Get a global type. Global types are types of addressable objects and struct/union/enum types 
            
    :param id: address or id of the object
    :param tif: buffer for the answer
    :param guess: what kind of types to consider
    :returns: success
    """
    ...

def get_type_flags(t: type_t) -> type_t:
    r"""Get type flags (TYPE_FLAGS_MASK)
    
    """
    ...

def get_type_ordinal(ti: til_t, name: str) -> int:
    r"""Get type ordinal by its name.
    
    """
    ...

def get_udm_by_fullname(udm: udm_t, fullname: str) -> ssize_t:
    r"""Get udt member by full name 
            
    :param udm: member, can be NULL
    :param fullname: udt member name in format <udt name>.<member name>
    :returns: member index into udt_type_data_t or -1
    """
    ...

def get_undo_action_label() -> str:
    r"""Get the label of the action that will be undone. This function returns the text that can be displayed in the undo menu 
            
    :returns: success
    """
    ...

def get_unk_type(size: int) -> tinfo_t:
    r"""Create a partial type info by width. Returns a partially defined type (examples: _DWORD, _BYTE) with the given width. 
            
    :param size: size of the type in bytes
    """
    ...

def get_unsigned_mcode(code: mcode_t) -> mcode_t:
    ...

def get_user_idadir() -> str:
    r"""Get user ida related directory. 
    if $IDAUSR is defined:
       - the first element in $IDAUSR
    else
       - default user directory ($HOME/.idapro or %APPDATA%Hex-Rays/IDA Pro)
    
    
       
    """
    ...

def get_user_input_event(out: input_event_t) -> bool:
    r"""Get the current user input event (mouse button press, key press, ...) It is sometimes desirable to be able to tell when a certain situation happens (e.g., 'view_curpos' gets triggered); this function exists to provide that context (GUI version only) 
            
    :param out: the input event data
    :returns: false if we are not currently processing a user input event
    """
    ...

def get_user_strlist_options(out: strwinsetup_t) -> None:
    ...

def get_vftable_ea(ordinal: int) -> ida_idaapi.ea_t:
    r"""Get address of a virtual function table. 
            
    :param ordinal: ordinal number of a vftable type.
    :returns: address of the corresponding virtual function table in the current database.
    """
    ...

def get_vftable_ordinal(vftable_ea: ida_idaapi.ea_t) -> int:
    r"""Get ordinal number of the virtual function table. 
            
    :param vftable_ea: address of a virtual function table.
    :returns: ordinal number of the corresponding vftable type. 0 - failure.
    """
    ...

def get_view_renderer_type(v: TWidget) -> tcc_renderer_type_t:
    r"""Get the type of renderer currently in use in the given view (ui_get_renderer_type)
    
    """
    ...

def get_viewer_graph(gv: graph_viewer_t) -> interactive_graph_t:
    r"""Get graph object for given custom graph viewer.
    
    """
    ...

def get_viewer_place_type(viewer: TWidget) -> tcc_place_type_t:
    r"""Get the type of place_t instances a viewer uses & creates (ui_get_viewer_place_type).
    
    """
    ...

def get_viewer_user_data(viewer: TWidget) -> None:
    r"""Get the user data from a custom viewer (ui_get_viewer_user_data)
    
    """
    ...

def get_visible_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str:
    ...

def get_visible_segm_name(s: segment_t) -> str:
    r"""Get segment name by pointer to segment. 
            
    :param s: pointer to segment
    :returns: size of segment name (-1 if s==nullptr)
    """
    ...

def get_wide_byte(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get one wide byte of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. 
            
    """
    ...

def get_wide_dword(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get two wide words (4 'bytes') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
            
    """
    ...

def get_wide_word(ea: ida_idaapi.ea_t) -> uint64:
    r"""Get one wide word (2 'byte') of the program at 'ea'. Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() 
            
    """
    ...

def get_widget_title(widget: TWidget) -> str:
    r"""Get the TWidget's title (ui_get_widget_title).
    
    """
    ...

def get_widget_type(widget: TWidget) -> twidget_type_t:
    r"""Get the type of the TWidget * (ui_get_widget_type).
    
    """
    ...

def get_widget_vdui(f: TWidget) -> vdui_t:
    r"""Get the vdui_t instance associated to the TWidget 
            
    :param f: pointer to window
    :returns: a vdui_t *, or nullptr
    """
    ...

def get_window_id(name: str = None) -> None:
    r"""Get the system-specific window ID (GUI version only) 
            
    :param name: name of the window (nullptr means the main IDA window)
    :returns: the low-level window ID
    """
    ...

def get_word(ea: ida_idaapi.ea_t) -> ushort:
    r"""Get one word (16-bit) of the program at 'ea'. This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. 
            
    """
    ...

def get_zero_ranges(zranges: rangeset_t, range: range_t) -> bool:
    r"""Return set of ranges with zero initialized bytes. The returned set includes only big zero initialized ranges (at least >1KB). Some zero initialized byte ranges may be not included. Only zero bytes that use the sparse storage method (STT_MM) are reported. 
            
    :param zranges: pointer to the return value. cannot be nullptr
    :param range: the range of addresses to verify. can be nullptr - means all ranges
    :returns: true if the result is a non-empty set
    """
    ...

def getb_reginsn(ins: minsn_t) -> minsn_t:
    r"""Skip assertions backward.
    
    """
    ...

def getf_reginsn(ins: minsn_t) -> minsn_t:
    r"""Skip assertions forward.
    
    """
    ...

def getinf_str(tag: inftag_t) -> str:
    r"""Get program specific information (a non-scalar value) 
            
    :param tag: one of inftag_t constants
    :returns: number of bytes stored in the buffer (<0 - not defined)
    """
    ...

def getn_bpt(n: int, bpt: bpt_t) -> bool:
    r"""Get the characteristics of a breakpoint. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of breakpoint, is in range 0..get_bpt_qty()-1
    :param bpt: filled with the characteristics.
    :returns: false if no breakpoint exists
    """
    ...

def getn_fchunk(n: int) -> func_t:
    r"""Get pointer to function chunk structure by number. 
            
    :param n: number of function chunk, is in range 0..get_fchunk_qty()-1
    :returns: ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail.
    """
    ...

def getn_func(n: size_t) -> func_t:
    r"""Get pointer to function structure by number. 
            
    :param n: number of function, is in range 0..get_func_qty()-1
    :returns: ptr to a function or nullptr. This function returns a function entry chunk.
    """
    ...

def getn_hidden_range(n: int) -> hidden_range_t:
    r"""Get pointer to hidden range structure, in: number of hidden range. 
            
    :param n: number of hidden range, is in range 0..get_hidden_range_qty()-1
    """
    ...

def getn_selector(n: int) -> Any:
    r"""Get description of selector (0..get_selector_qty()-1)
    
    """
    ...

def getn_sreg_range(out: sreg_range_t, rg: int, n: int) -> bool:
    r"""Get segment register range by its number. 
            
    :param out: segment register range
    :param rg: the segment register number
    :param n: number of range (0..qty()-1)
    :returns: success
    """
    ...

def getn_thread(n: int) -> thid_t:
    r"""Get the ID of a thread. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of thread, is in range 0..get_thread_qty()-1
    :returns: NO_THREAD if the thread doesn't exist.
    """
    ...

def getn_thread_name(n: int) -> str:
    r"""Get the NAME of a thread \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param n: number of thread, is in range 0..get_thread_qty()-1 or -1 for the current thread
    :returns: thread name or nullptr if the thread doesn't exist.
    """
    ...

def getnode(ea: ida_idaapi.ea_t) -> netnode:
    ...

def getnseg(n: int) -> segment_t:
    r"""Get pointer to segment by its number. 
            
    :param n: segment number in the range (0..get_segm_qty()-1)
    :returns: nullptr or pointer to segment structure
    """
    ...

def getseg(ea: ida_idaapi.ea_t) -> segment_t:
    r"""Get pointer to segment by linear address. 
            
    :param ea: linear address belonging to the segment
    :returns: nullptr or pointer to segment structure
    """
    ...

def getsysfile(filename: str, subdir: str) -> str:
    r"""Search for IDA system file. This function searches for a file in:
    0. each directory specified by IDAUSR%
    1. ida directory [+ subdir]
    
    
    and returns the first match. 
            
    :param filename: name of file to search
    :param subdir: if specified, the file is looked for in the specified subdirectory of the ida directory first (see IDA subdirectories)
    :returns: nullptr if not found, otherwise a pointer to full file name.
    """
    ...

def graph_trace() -> bool:
    r"""Show the trace callgraph.
    
    """
    ...

def guess_func_cc(fti: func_type_data_t, npurged: int, cc_flags: int) -> callcnv_t:
    r"""Use func_type_data_t::guess_cc()
    
    """
    ...

def guess_tinfo(out: tinfo_t, id: tid_t) -> int:
    r"""Generate a type information about the id from the disassembly. id can be a structure/union/enum id or an address. 
            
    :returns: one of Guess tinfo codes
    """
    ...

def handle_debug_event(ev: debug_event_t, rqflags: int) -> int:
    ...

def handle_fixups_in_macro(ri: refinfo_t, ea: ida_idaapi.ea_t, other: fixup_type_t, macro_reft_and_flags: int) -> bool:
    r"""Handle two fixups in a macro. We often combine two instruction that load parts of a value into one macro instruction. For example: 
           ADRP  X0, #var@PAGE
               ADD   X0, X0, #var@PAGEOFF  --> ADRL X0, var
          lui   $v0, %hi(var)
               addiu $v0, $v0, %lo(var)    --> la   $v0, var
    
    
            
    :returns: success ('false' means that RI was not changed)
    """
    ...

def has_aflag_linnum(flags: aflags_t) -> bool:
    ...

def has_aflag_lname(flags: aflags_t) -> bool:
    ...

def has_aflag_ti(flags: aflags_t) -> bool:
    ...

def has_aflag_ti0(flags: aflags_t) -> bool:
    ...

def has_aflag_ti1(flags: aflags_t) -> bool:
    ...

def has_any_name(F: flags64_t) -> bool:
    r"""Does the current byte have any name?
    
    """
    ...

def has_auto_name(F: flags64_t) -> bool:
    r"""Does the current byte have auto-generated (no special prefix) name?
    
    """
    ...

def has_cached_cfunc(ea: ida_idaapi.ea_t) -> bool:
    r"""Do we have a cached decompilation result for 'ea'?
    
    """
    ...

def has_cf_chg(feature: int, opnum: uint) -> bool:
    r"""Does an instruction with the specified feature modify the i-th operand?
    
    """
    ...

def has_cf_use(feature: int, opnum: uint) -> bool:
    r"""Does an instruction with the specified feature use a value of the i-th operand?
    
    """
    ...

def has_cmt(F: flags64_t) -> bool:
    r"""Does the current byte have an indented comment?
    
    """
    ...

def has_dummy_name(F: flags64_t) -> bool:
    r"""Does the current byte have dummy (auto-generated, with special prefix) name?
    
    """
    ...

def has_external_refs(pfn: func_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Does 'ea' have references from outside of 'pfn'?
    
    """
    ...

def has_extra_cmts(F: flags64_t) -> bool:
    r"""Does the current byte have additional anterior or posterior lines?
    
    """
    ...

def has_immd(F: flags64_t) -> bool:
    r"""Has immediate value?
    
    """
    ...

def has_insn_feature(icode: uint16, bit: int) -> bool:
    r"""Does the specified instruction have the specified feature?
    
    """
    ...

def has_jump_or_flow_xref(ea: ida_idaapi.ea_t) -> bool:
    r"""Are there jump or flow references to EA?
    
    """
    ...

def has_lname(ea: ida_idaapi.ea_t) -> bool:
    ...

def has_mcode_seloff(op: mcode_t) -> bool:
    ...

def has_name(F: flags64_t) -> bool:
    r"""Does the current byte have non-trivial (non-dummy) name?
    
    """
    ...

def has_regvar(pfn: func_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Is there a register variable definition? 
            
    :param pfn: function in question
    :param ea: current address
    """
    ...

def has_ti(ea: ida_idaapi.ea_t) -> bool:
    ...

def has_ti0(ea: ida_idaapi.ea_t) -> bool:
    ...

def has_ti1(ea: ida_idaapi.ea_t) -> bool:
    ...

def has_user_name(F: flags64_t) -> bool:
    r"""Does the current byte have user-specified name?
    
    """
    ...

def has_value(F: flags64_t) -> bool:
    r"""Do flags contain byte value?
    
    """
    ...

def has_xref(F: flags64_t) -> bool:
    r"""Does the current byte have cross-references to it?
    
    """
    ...

def hex_flag() -> flags64_t:
    r"""Get number flag of the base, regardless of current processor - better to use num_flag()
    
    """
    ...

def hexrays_alloc(size: size_t) -> None:
    ...

def hexrays_free(ptr: void) -> None:
    ...

def hide_all_bpts() -> int:
    ...

def hide_border(ea: ida_idaapi.ea_t) -> None:
    ...

def hide_item(ea: ida_idaapi.ea_t) -> None:
    ...

def hide_name(ea: ida_idaapi.ea_t) -> None:
    r"""Remove name from the list of names 
            
    :param ea: address of the name
    """
    ...

def hide_wait_box() -> None:
    r"""Hide the "Please wait dialog box".
    
    """
    ...

def idadir(subdir: str) -> str:
    r"""Get IDA directory (if subdir==nullptr) or the specified subdirectory (see IDA subdirectories) 
            
    """
    ...

def idainfo_big_arg_align(args: Any) -> bool:
    ...

def idainfo_comment_get() -> uchar:
    ...

def idainfo_comment_set(_v: uchar) -> bool:
    ...

def idainfo_gen_lzero() -> bool:
    ...

def idainfo_gen_null() -> bool:
    ...

def idainfo_gen_tryblks() -> bool:
    ...

def idainfo_get_demname_form() -> uchar:
    r"""Get DEMNAM_MASK bits of #demnames.
    
    """
    ...

def idainfo_get_pack_mode() -> int:
    ...

def idainfo_is_32bit() -> Any:
    ...

def idainfo_is_64bit() -> bool:
    ...

def idainfo_is_auto_enabled() -> bool:
    ...

def idainfo_is_be() -> bool:
    ...

def idainfo_is_dll() -> bool:
    ...

def idainfo_is_flat_off32() -> bool:
    ...

def idainfo_is_graph_view() -> bool:
    ...

def idainfo_is_hard_float() -> bool:
    ...

def idainfo_is_kernel_mode() -> bool:
    ...

def idainfo_is_mem_aligned4() -> bool:
    ...

def idainfo_is_snapshot() -> bool:
    ...

def idainfo_is_wide_high_byte_first() -> bool:
    ...

def idainfo_like_binary() -> bool:
    ...

def idainfo_line_pref_with_seg() -> bool:
    ...

def idainfo_loading_idc() -> bool:
    ...

def idainfo_map_stkargs() -> bool:
    ...

def idainfo_pack_stkargs(args: Any) -> bool:
    ...

def idainfo_readonly_idb() -> bool:
    ...

def idainfo_set_64bit(_v: bool = True) -> bool:
    ...

def idainfo_set_auto_enabled(_v: bool = True) -> bool:
    ...

def idainfo_set_be(_v: bool = True) -> bool:
    ...

def idainfo_set_gen_lzero(_v: bool = True) -> bool:
    ...

def idainfo_set_gen_null(_v: bool = True) -> bool:
    ...

def idainfo_set_gen_tryblks(_v: bool = True) -> bool:
    ...

def idainfo_set_graph_view(_v: bool = True) -> bool:
    ...

def idainfo_set_line_pref_with_seg(_v: bool = True) -> bool:
    ...

def idainfo_set_pack_mode(pack_mode: int) -> int:
    ...

def idainfo_set_show_auto(_v: bool = True) -> bool:
    ...

def idainfo_set_show_line_pref(_v: bool = True) -> bool:
    ...

def idainfo_set_show_void(_v: bool = True) -> bool:
    ...

def idainfo_set_store_user_info(args: Any) -> Any:
    ...

def idainfo_set_wide_high_byte_first(_v: bool = True) -> bool:
    ...

def idainfo_show_auto() -> bool:
    ...

def idainfo_show_line_pref() -> bool:
    ...

def idainfo_show_void() -> bool:
    ...

def idainfo_stack_ldbl() -> bool:
    ...

def idainfo_stack_varargs() -> bool:
    ...

def idainfo_use_allasm() -> bool:
    ...

def idainfo_use_gcc_layout() -> bool:
    ...

def idc_get_local_type(ordinal: int, flags: int) -> str:
    ...

def idc_get_local_type_name(ordinal: int) -> str:
    ...

def idc_get_local_type_raw(ordinal: Any) -> Any:
    ...

def idc_get_type(ea: ida_idaapi.ea_t) -> str:
    ...

def idc_get_type_raw(ea: ida_idaapi.ea_t) -> Any:
    ...

def idc_guess_type(ea: ida_idaapi.ea_t) -> str:
    ...

def idc_parse_decl(til: til_t, decl: str, flags: int) -> Any:
    ...

def idc_parse_types(input: str, flags: int) -> int:
    ...

def idc_print_type(type: bytes, fields: bytes, name: str, flags: int) -> str:
    ...

def idc_set_local_type(ordinal: int, dcl: str, flags: int) -> int:
    ...

def idcv_float(v: idc_value_t) -> error_t:
    r"""Convert IDC variable to a floating point.
    
    """
    ...

def idcv_int64(v: idc_value_t) -> error_t:
    r"""Convert IDC variable to a 64bit number. 
            
    :returns: v = 0 if impossible to convert to int64
    """
    ...

def idcv_long(v: idc_value_t) -> error_t:
    r"""Convert IDC variable to a long (32/64bit) number. 
            
    :returns: v = 0 if impossible to convert to long
    """
    ...

def idcv_num(v: idc_value_t) -> error_t:
    r"""Convert IDC variable to a long number. 
            
    :returns: * v = 0 if IDC variable = "false" string
    * v = 1 if IDC variable = "true" string
    * v = number if IDC variable is number or string containing a number
    * eTypeConflict if IDC variable = empty string
    """
    ...

def idcv_object(v: idc_value_t, icls: idc_class_t = None) -> error_t:
    r"""Create an IDC object. The original value of 'v' is discarded (freed). 
            
    :param v: variable to hold the object. any previous value will be cleaned
    :param icls: ptr to the desired class. nullptr means "object" class this ptr must be returned by add_idc_class() or find_idc_class()
    :returns: always eOk
    """
    ...

def idcv_string(v: idc_value_t) -> error_t:
    r"""Convert IDC variable to a text string.
    
    """
    ...

def ieee2cpu(cpu_fpval_out: void, ieee: fpvalue_t, size: int) -> int:
    r"""Convert a floating point number in IDA's internal format to CPU native format. 
            
    :param cpu_fpval_out: output buffer
    :param ieee: floating point number of IDA's internal format
    :param size: size of cpu_fpval in bytes (size of the output buffer)
    :returns: Floating point/IEEE Conversion codes
    """
    ...

def inf_abi_set_by_user() -> bool:
    ...

def inf_allow_non_matched_ops() -> bool:
    ...

def inf_allow_sigmulti() -> bool:
    ...

def inf_append_sigcmt() -> bool:
    ...

def inf_big_arg_align(args: Any) -> bool:
    ...

def inf_check_manual_ops() -> bool:
    ...

def inf_check_unicode_strlits() -> bool:
    ...

def inf_coagulate_code() -> bool:
    ...

def inf_coagulate_data() -> bool:
    ...

def inf_compress_idb() -> bool:
    ...

def inf_create_all_xrefs() -> bool:
    ...

def inf_create_func_from_call() -> bool:
    ...

def inf_create_func_from_ptr() -> bool:
    ...

def inf_create_func_tails() -> bool:
    ...

def inf_create_jump_tables() -> bool:
    ...

def inf_create_off_on_dref() -> bool:
    ...

def inf_create_off_using_fixup() -> bool:
    ...

def inf_create_strlit_on_xref() -> bool:
    ...

def inf_data_offset() -> bool:
    ...

def inf_dbg_no_store_path() -> bool:
    ...

def inf_decode_fpp() -> bool:
    ...

def inf_del_no_xref_insns() -> bool:
    ...

def inf_final_pass() -> bool:
    ...

def inf_full_sp_ana() -> bool:
    ...

def inf_gen_assume() -> bool:
    ...

def inf_gen_lzero() -> bool:
    ...

def inf_gen_null() -> bool:
    ...

def inf_gen_org() -> bool:
    ...

def inf_gen_tryblks() -> bool:
    ...

def inf_get_abibits() -> int:
    ...

def inf_get_af() -> int:
    ...

def inf_get_af2() -> int:
    ...

def inf_get_af2_low() -> ushort:
    r"""Get/set low 16bit half of inf.af2.
    
    """
    ...

def inf_get_af_high() -> ushort:
    ...

def inf_get_af_low() -> ushort:
    r"""Get/set low/high 16bit halves of inf.af.
    
    """
    ...

def inf_get_app_bitness() -> uint:
    ...

def inf_get_appcall_options() -> int:
    ...

def inf_get_apptype() -> ushort:
    ...

def inf_get_asmtype() -> uchar:
    ...

def inf_get_baseaddr() -> int:
    ...

def inf_get_bin_prefix_size() -> short:
    ...

def inf_get_callcnv() -> callcnv_t:
    ...

def inf_get_cc(out: compiler_info_t) -> bool:
    ...

def inf_get_cc_cm() -> cm_t:
    ...

def inf_get_cc_defalign() -> uchar:
    ...

def inf_get_cc_id() -> comp_t:
    ...

def inf_get_cc_size_b() -> uchar:
    ...

def inf_get_cc_size_e() -> uchar:
    ...

def inf_get_cc_size_i() -> uchar:
    ...

def inf_get_cc_size_l() -> uchar:
    ...

def inf_get_cc_size_ldbl() -> uchar:
    ...

def inf_get_cc_size_ll() -> uchar:
    ...

def inf_get_cc_size_s() -> uchar:
    ...

def inf_get_cmt_indent() -> uchar:
    ...

def inf_get_cmtflg() -> uchar:
    ...

def inf_get_comment() -> uchar:
    ...

def inf_get_database_change_count() -> int:
    ...

def inf_get_datatypes() -> int:
    ...

def inf_get_demname_form() -> uchar:
    r"""Get DEMNAM_MASK bits of #demnames.
    
    """
    ...

def inf_get_demnames() -> uchar:
    ...

def inf_get_filetype() -> filetype_t:
    ...

def inf_get_genflags() -> ushort:
    ...

def inf_get_highoff() -> ida_idaapi.ea_t:
    ...

def inf_get_indent() -> uchar:
    ...

def inf_get_lenxref() -> ushort:
    ...

def inf_get_lflags() -> int:
    ...

def inf_get_limiter() -> uchar:
    ...

def inf_get_listnames() -> uchar:
    ...

def inf_get_long_demnames() -> int:
    ...

def inf_get_lowoff() -> ida_idaapi.ea_t:
    ...

def inf_get_main() -> ida_idaapi.ea_t:
    ...

def inf_get_margin() -> ushort:
    ...

def inf_get_max_autoname_len() -> ushort:
    ...

def inf_get_max_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_maxref() -> int:
    ...

def inf_get_min_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_nametype() -> char:
    ...

def inf_get_netdelta() -> int:
    ...

def inf_get_omax_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_omin_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_ostype() -> ushort:
    ...

def inf_get_outflags() -> int:
    ...

def inf_get_pack_mode() -> int:
    ...

def inf_get_prefflag() -> uchar:
    ...

def inf_get_privrange(args: Any) -> range_t:
    r"""This function has the following signatures:
    
        0. inf_get_privrange(out: range_t *) -> bool
        1. inf_get_privrange() -> range_t
    
    # 0: inf_get_privrange(out: range_t *) -> bool
    
    
    # 1: inf_get_privrange() -> range_t
    
    
    """
    ...

def inf_get_privrange_end_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_privrange_start_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_procname() -> str:
    ...

def inf_get_refcmtnum() -> uchar:
    ...

def inf_get_short_demnames() -> int:
    ...

def inf_get_specsegs() -> uchar:
    ...

def inf_get_start_cs() -> sel_t:
    ...

def inf_get_start_ea() -> ida_idaapi.ea_t:
    ...

def inf_get_start_ip() -> ida_idaapi.ea_t:
    ...

def inf_get_start_sp() -> ida_idaapi.ea_t:
    ...

def inf_get_start_ss() -> sel_t:
    ...

def inf_get_strlit_break() -> uchar:
    ...

def inf_get_strlit_flags() -> uchar:
    ...

def inf_get_strlit_pref() -> str:
    ...

def inf_get_strlit_sernum() -> int:
    ...

def inf_get_strlit_zeroes() -> char:
    ...

def inf_get_strtype() -> int:
    ...

def inf_get_type_xrefnum() -> uchar:
    ...

def inf_get_version() -> ushort:
    ...

def inf_get_xrefflag() -> uchar:
    ...

def inf_get_xrefnum() -> uchar:
    ...

def inf_guess_func_type() -> bool:
    ...

def inf_handle_eh() -> bool:
    ...

def inf_handle_rtti() -> bool:
    ...

def inf_hide_comments() -> bool:
    ...

def inf_hide_libfuncs() -> bool:
    ...

def inf_huge_arg_align(args: Any) -> bool:
    ...

def inf_inc_database_change_count(cnt: int = 1) -> None:
    ...

def inf_is_16bit() -> bool:
    ...

def inf_is_32bit_exactly() -> bool:
    ...

def inf_is_32bit_or_higher() -> bool:
    ...

def inf_is_64bit() -> bool:
    ...

def inf_is_auto_enabled() -> bool:
    ...

def inf_is_be() -> bool:
    ...

def inf_is_dll() -> bool:
    ...

def inf_is_flat_off32() -> bool:
    ...

def inf_is_graph_view() -> bool:
    ...

def inf_is_hard_float() -> bool:
    ...

def inf_is_ilp32() -> bool:
    ...

def inf_is_kernel_mode() -> bool:
    ...

def inf_is_limiter_empty() -> bool:
    ...

def inf_is_limiter_thick() -> bool:
    ...

def inf_is_limiter_thin() -> bool:
    ...

def inf_is_mem_aligned4() -> bool:
    ...

def inf_is_snapshot() -> bool:
    ...

def inf_is_wide_high_byte_first() -> bool:
    ...

def inf_like_binary() -> bool:
    ...

def inf_line_pref_with_seg() -> bool:
    ...

def inf_loading_idc() -> bool:
    ...

def inf_macros_enabled() -> bool:
    ...

def inf_map_stkargs() -> bool:
    ...

def inf_mark_code() -> bool:
    ...

def inf_merge_strlits() -> bool:
    ...

def inf_no_store_user_info() -> bool:
    ...

def inf_noflow_to_data() -> bool:
    ...

def inf_noret_ana() -> bool:
    ...

def inf_op_offset() -> bool:
    ...

def inf_pack_idb() -> bool:
    ...

def inf_pack_stkargs(args: Any) -> bool:
    ...

def inf_postinc_strlit_sernum(cnt: int = 1) -> int:
    ...

def inf_prefix_show_funcoff() -> bool:
    ...

def inf_prefix_show_segaddr() -> bool:
    ...

def inf_prefix_show_stack() -> bool:
    ...

def inf_prefix_truncate_opcode_bytes() -> bool:
    ...

def inf_propagate_regargs() -> bool:
    ...

def inf_propagate_stkargs() -> bool:
    ...

def inf_readonly_idb() -> bool:
    ...

def inf_rename_jumpfunc() -> bool:
    ...

def inf_rename_nullsub() -> bool:
    ...

def inf_set_32bit(_v: bool = True) -> bool:
    ...

def inf_set_64bit(_v: bool = True) -> bool:
    ...

def inf_set_abi_set_by_user(_v: bool = True) -> bool:
    ...

def inf_set_abibits(_v: int) -> bool:
    ...

def inf_set_af(_v: int) -> bool:
    ...

def inf_set_af2(_v: int) -> bool:
    ...

def inf_set_af2_low(saf: ushort) -> None:
    ...

def inf_set_af_high(saf2: ushort) -> None:
    ...

def inf_set_af_low(saf: ushort) -> None:
    ...

def inf_set_allow_non_matched_ops(_v: bool = True) -> bool:
    ...

def inf_set_allow_sigmulti(_v: bool = True) -> bool:
    ...

def inf_set_app_bitness(bitness: uint) -> None:
    ...

def inf_set_appcall_options(_v: int) -> bool:
    ...

def inf_set_append_sigcmt(_v: bool = True) -> bool:
    ...

def inf_set_apptype(_v: ushort) -> bool:
    ...

def inf_set_asmtype(_v: uchar) -> bool:
    ...

def inf_set_auto_enabled(_v: bool = True) -> bool:
    ...

def inf_set_baseaddr(_v: int) -> bool:
    ...

def inf_set_be(_v: bool = True) -> bool:
    ...

def inf_set_big_arg_align(_v: bool = True) -> bool:
    ...

def inf_set_bin_prefix_size(_v: short) -> bool:
    ...

def inf_set_callcnv(_v: callcnv_t) -> bool:
    ...

def inf_set_cc(_v: compiler_info_t) -> bool:
    ...

def inf_set_cc_cm(_v: cm_t) -> bool:
    ...

def inf_set_cc_defalign(_v: uchar) -> bool:
    ...

def inf_set_cc_id(_v: comp_t) -> bool:
    ...

def inf_set_cc_size_b(_v: uchar) -> bool:
    ...

def inf_set_cc_size_e(_v: uchar) -> bool:
    ...

def inf_set_cc_size_i(_v: uchar) -> bool:
    ...

def inf_set_cc_size_l(_v: uchar) -> bool:
    ...

def inf_set_cc_size_ldbl(_v: uchar) -> bool:
    ...

def inf_set_cc_size_ll(_v: uchar) -> bool:
    ...

def inf_set_cc_size_s(_v: uchar) -> bool:
    ...

def inf_set_check_manual_ops(_v: bool = True) -> bool:
    ...

def inf_set_check_unicode_strlits(_v: bool = True) -> bool:
    ...

def inf_set_cmt_indent(_v: uchar) -> bool:
    ...

def inf_set_cmtflg(_v: uchar) -> bool:
    ...

def inf_set_coagulate_code(_v: bool = True) -> bool:
    ...

def inf_set_coagulate_data(_v: bool = True) -> bool:
    ...

def inf_set_comment(_v: uchar) -> bool:
    ...

def inf_set_compress_idb(_v: bool = True) -> bool:
    ...

def inf_set_create_all_xrefs(_v: bool = True) -> bool:
    ...

def inf_set_create_func_from_call(_v: bool = True) -> bool:
    ...

def inf_set_create_func_from_ptr(_v: bool = True) -> bool:
    ...

def inf_set_create_func_tails(_v: bool = True) -> bool:
    ...

def inf_set_create_jump_tables(_v: bool = True) -> bool:
    ...

def inf_set_create_off_on_dref(_v: bool = True) -> bool:
    ...

def inf_set_create_off_using_fixup(_v: bool = True) -> bool:
    ...

def inf_set_create_strlit_on_xref(_v: bool = True) -> bool:
    ...

def inf_set_data_offset(_v: bool = True) -> bool:
    ...

def inf_set_database_change_count(_v: int) -> bool:
    ...

def inf_set_datatypes(_v: int) -> bool:
    ...

def inf_set_dbg_no_store_path(_v: bool = True) -> bool:
    ...

def inf_set_decode_fpp(_v: bool = True) -> bool:
    ...

def inf_set_del_no_xref_insns(_v: bool = True) -> bool:
    ...

def inf_set_demnames(_v: uchar) -> bool:
    ...

def inf_set_dll(_v: bool = True) -> bool:
    ...

def inf_set_filetype(_v: filetype_t) -> bool:
    ...

def inf_set_final_pass(_v: bool = True) -> bool:
    ...

def inf_set_flat_off32(_v: bool = True) -> bool:
    ...

def inf_set_full_sp_ana(_v: bool = True) -> bool:
    ...

def inf_set_gen_assume(_v: bool = True) -> bool:
    ...

def inf_set_gen_lzero(_v: bool = True) -> bool:
    ...

def inf_set_gen_null(_v: bool = True) -> bool:
    ...

def inf_set_gen_org(_v: bool = True) -> bool:
    ...

def inf_set_gen_tryblks(_v: bool = True) -> bool:
    ...

def inf_set_genflags(_v: ushort) -> bool:
    ...

def inf_set_graph_view(_v: bool = True) -> bool:
    ...

def inf_set_guess_func_type(_v: bool = True) -> bool:
    ...

def inf_set_handle_eh(_v: bool = True) -> bool:
    ...

def inf_set_handle_rtti(_v: bool = True) -> bool:
    ...

def inf_set_hard_float(_v: bool = True) -> bool:
    ...

def inf_set_hide_comments(_v: bool = True) -> bool:
    ...

def inf_set_hide_libfuncs(_v: bool = True) -> bool:
    ...

def inf_set_highoff(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_huge_arg_align(_v: bool = True) -> bool:
    ...

def inf_set_ilp32(_v: bool = True) -> bool:
    ...

def inf_set_indent(_v: uchar) -> bool:
    ...

def inf_set_kernel_mode(_v: bool = True) -> bool:
    ...

def inf_set_lenxref(_v: ushort) -> bool:
    ...

def inf_set_lflags(_v: int) -> bool:
    ...

def inf_set_limiter(_v: uchar) -> bool:
    ...

def inf_set_limiter_empty(_v: bool = True) -> bool:
    ...

def inf_set_limiter_thick(_v: bool = True) -> bool:
    ...

def inf_set_limiter_thin(_v: bool = True) -> bool:
    ...

def inf_set_line_pref_with_seg(_v: bool = True) -> bool:
    ...

def inf_set_listnames(_v: uchar) -> bool:
    ...

def inf_set_loading_idc(_v: bool = True) -> bool:
    ...

def inf_set_long_demnames(_v: int) -> bool:
    ...

def inf_set_lowoff(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_macros_enabled(_v: bool = True) -> bool:
    ...

def inf_set_main(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_map_stkargs(_v: bool = True) -> bool:
    ...

def inf_set_margin(_v: ushort) -> bool:
    ...

def inf_set_mark_code(_v: bool = True) -> bool:
    ...

def inf_set_max_autoname_len(_v: ushort) -> bool:
    ...

def inf_set_max_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_maxref(_v: int) -> bool:
    ...

def inf_set_mem_aligned4(_v: bool = True) -> bool:
    ...

def inf_set_merge_strlits(_v: bool = True) -> bool:
    ...

def inf_set_min_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_nametype(_v: char) -> bool:
    ...

def inf_set_netdelta(_v: int) -> bool:
    ...

def inf_set_no_store_user_info(_v: bool = True) -> bool:
    ...

def inf_set_noflow_to_data(_v: bool = True) -> bool:
    ...

def inf_set_noret_ana(_v: bool = True) -> bool:
    ...

def inf_set_omax_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_omin_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_op_offset(_v: bool = True) -> bool:
    ...

def inf_set_ostype(_v: ushort) -> bool:
    ...

def inf_set_outflags(_v: int) -> bool:
    ...

def inf_set_pack_idb(_v: bool = True) -> bool:
    ...

def inf_set_pack_mode(pack_mode: int) -> int:
    ...

def inf_set_pack_stkargs(_v: bool = True) -> bool:
    ...

def inf_set_prefflag(_v: uchar) -> bool:
    ...

def inf_set_prefix_show_funcoff(_v: bool = True) -> bool:
    ...

def inf_set_prefix_show_segaddr(_v: bool = True) -> bool:
    ...

def inf_set_prefix_show_stack(_v: bool = True) -> bool:
    ...

def inf_set_prefix_truncate_opcode_bytes(_v: bool = True) -> bool:
    ...

def inf_set_privrange(_v: range_t) -> bool:
    ...

def inf_set_privrange_end_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_privrange_start_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_procname(args: Any) -> bool:
    ...

def inf_set_propagate_regargs(_v: bool = True) -> bool:
    ...

def inf_set_propagate_stkargs(_v: bool = True) -> bool:
    ...

def inf_set_readonly_idb(_v: bool = True) -> bool:
    ...

def inf_set_refcmtnum(_v: uchar) -> bool:
    ...

def inf_set_rename_jumpfunc(_v: bool = True) -> bool:
    ...

def inf_set_rename_nullsub(_v: bool = True) -> bool:
    ...

def inf_set_short_demnames(_v: int) -> bool:
    ...

def inf_set_should_create_stkvars(_v: bool = True) -> bool:
    ...

def inf_set_should_trace_sp(_v: bool = True) -> bool:
    ...

def inf_set_show_all_comments(_v: bool = True) -> bool:
    ...

def inf_set_show_auto(_v: bool = True) -> bool:
    ...

def inf_set_show_hidden_funcs(_v: bool = True) -> bool:
    ...

def inf_set_show_hidden_insns(_v: bool = True) -> bool:
    ...

def inf_set_show_hidden_segms(_v: bool = True) -> bool:
    ...

def inf_set_show_line_pref(_v: bool = True) -> bool:
    ...

def inf_set_show_repeatables(_v: bool = True) -> bool:
    ...

def inf_set_show_src_linnum(_v: bool = True) -> bool:
    ...

def inf_set_show_void(_v: bool = True) -> bool:
    ...

def inf_set_show_xref_fncoff(_v: bool = True) -> bool:
    ...

def inf_set_show_xref_seg(_v: bool = True) -> bool:
    ...

def inf_set_show_xref_tmarks(_v: bool = True) -> bool:
    ...

def inf_set_show_xref_val(_v: bool = True) -> bool:
    ...

def inf_set_snapshot(_v: bool = True) -> bool:
    ...

def inf_set_specsegs(_v: uchar) -> bool:
    ...

def inf_set_stack_ldbl(_v: bool = True) -> bool:
    ...

def inf_set_stack_varargs(_v: bool = True) -> bool:
    ...

def inf_set_start_cs(_v: sel_t) -> bool:
    ...

def inf_set_start_ea(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_start_ip(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_start_sp(_v: ida_idaapi.ea_t) -> bool:
    ...

def inf_set_start_ss(_v: sel_t) -> bool:
    ...

def inf_set_strlit_autocmt(_v: bool = True) -> bool:
    ...

def inf_set_strlit_break(_v: uchar) -> bool:
    ...

def inf_set_strlit_flags(_v: uchar) -> bool:
    ...

def inf_set_strlit_name_bit(_v: bool = True) -> bool:
    ...

def inf_set_strlit_names(_v: bool = True) -> bool:
    ...

def inf_set_strlit_pref(args: Any) -> bool:
    ...

def inf_set_strlit_savecase(_v: bool = True) -> bool:
    ...

def inf_set_strlit_serial_names(_v: bool = True) -> bool:
    ...

def inf_set_strlit_sernum(_v: int) -> bool:
    ...

def inf_set_strlit_zeroes(_v: char) -> bool:
    ...

def inf_set_strtype(_v: int) -> bool:
    ...

def inf_set_trace_flow(_v: bool = True) -> bool:
    ...

def inf_set_truncate_on_del(_v: bool = True) -> bool:
    ...

def inf_set_type_xrefnum(_v: uchar) -> bool:
    ...

def inf_set_unicode_strlits(_v: bool = True) -> bool:
    ...

def inf_set_use_allasm(_v: bool = True) -> bool:
    ...

def inf_set_use_flirt(_v: bool = True) -> bool:
    ...

def inf_set_use_gcc_layout(_v: bool = True) -> bool:
    ...

def inf_set_version(_v: ushort) -> bool:
    ...

def inf_set_wide_high_byte_first(_v: bool = True) -> bool:
    ...

def inf_set_xrefflag(_v: uchar) -> bool:
    ...

def inf_set_xrefnum(_v: uchar) -> bool:
    ...

def inf_should_create_stkvars() -> bool:
    ...

def inf_should_trace_sp() -> bool:
    ...

def inf_show_all_comments() -> bool:
    ...

def inf_show_auto() -> bool:
    ...

def inf_show_hidden_funcs() -> bool:
    ...

def inf_show_hidden_insns() -> bool:
    ...

def inf_show_hidden_segms() -> bool:
    ...

def inf_show_line_pref() -> bool:
    ...

def inf_show_repeatables() -> bool:
    ...

def inf_show_src_linnum() -> bool:
    ...

def inf_show_void() -> bool:
    ...

def inf_show_xref_fncoff() -> bool:
    ...

def inf_show_xref_seg() -> bool:
    ...

def inf_show_xref_tmarks() -> bool:
    ...

def inf_show_xref_val() -> bool:
    ...

def inf_stack_ldbl() -> bool:
    ...

def inf_stack_varargs() -> bool:
    ...

def inf_strlit_autocmt() -> bool:
    ...

def inf_strlit_name_bit() -> bool:
    ...

def inf_strlit_names() -> bool:
    ...

def inf_strlit_savecase() -> bool:
    ...

def inf_strlit_serial_names() -> bool:
    ...

def inf_test_mode() -> bool:
    ...

def inf_trace_flow() -> bool:
    ...

def inf_truncate_on_del() -> bool:
    ...

def inf_unicode_strlits() -> bool:
    ...

def inf_use_allasm() -> bool:
    ...

def inf_use_flirt() -> bool:
    ...

def inf_use_gcc_layout() -> bool:
    ...

def info(args: Any) -> ssize_t:
    ...

def init_hexrays_plugin(flags: int = 0) -> bool:
    r"""Check that your plugin is compatible with hex-rays decompiler. This function must be called before calling any other decompiler function. 
            
    :param flags: reserved, must be 0
    :returns: true if the decompiler exists and is compatible with your plugin
    """
    ...

def insn_add_cref(insn: insn_t, to: ida_idaapi.ea_t, opoff: int, type: cref_t) -> None:
    ...

def insn_add_dref(insn: insn_t, to: ida_idaapi.ea_t, opoff: int, type: dref_t) -> None:
    ...

def insn_add_off_drefs(insn: insn_t, x: op_t, type: dref_t, outf: int) -> ida_idaapi.ea_t:
    ...

def insn_create_stkvar(insn: insn_t, x: op_t, v: adiff_t, flags: int) -> bool:
    ...

def insn_t__from_ptrval__(ptrval: size_t) -> insn_t:
    ...

def install_command_interpreter(py_obj: Any) -> int:
    r"""Install command line interpreter (ui_install_cli)
    
    """
    ...

def install_hexrays_callback(callback: Any) -> Any:
    r"""Install handler for decompiler events. 
            
    :param callback: handler to install
    :returns: false if failed
    """
    ...

def install_microcode_filter(filter: microcode_filter_t, install: bool = True) -> bool:
    r"""register/unregister non-standard microcode generator 
            
    :param filter: - microcode generator object
    :param install: - TRUE - register the object, FALSE - unregister
    :returns: success
    """
    ...

def install_user_defined_prefix(args: Any) -> bool:
    ...

def internal_get_sreg_base(tid: int, sreg_value: int) -> Any:
    r"""Get the sreg base, for the given thread.
    
    :param tid: the thread ID
    :param sreg_value: the sreg value
    :returns: The sreg base, or BADADDR on failure.
    """
    ...

def internal_ioctl(fn: int, buf: void, poutbuf: void, poutsize: ssize_t) -> int:
    ...

def internal_register_place_class(tmplate: place_t, flags: int, owner: plugin_t, sdk_version: int) -> int:
    ...

def invalidate_dbg_state(dbginv: int) -> int:
    r"""Invalidate cached debugger information. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param dbginv: Debugged process invalidation options
    :returns: current debugger state (one of Debugged process states)
    """
    ...

def invalidate_dbgmem_config() -> None:
    r"""Invalidate the debugged process memory configuration. Call this function if the debugged process might have changed its memory layout (allocated more memory, for example) 
            
    """
    ...

def invalidate_dbgmem_contents(ea: ida_idaapi.ea_t, size: asize_t) -> None:
    r"""Invalidate the debugged process memory contents. Call this function each time the process has been stopped or the process memory is modified. If ea == BADADDR, then the whole memory contents will be invalidated 
            
    """
    ...

def invalidate_regfinder_cache(args: Any) -> None:
    r"""The control flow from FROM to TO has removed (CREF==fl_U) or added (CREF!=fl_U). Try to update the register tracker cache after this change. If TO == BADADDR then clear the entire cache. 
            
    """
    ...

def invalidate_regfinder_xrefs_cache(args: Any) -> None:
    r"""The data reference to TO has added (DREF!=dr_O) or removed (DREF==dr_O). Update the regtracker xrefs cache after this change. If TO == BADADDR then clear the entire xrefs cache. 
            
    """
    ...

def is__bnot0(ea: ida_idaapi.ea_t) -> bool:
    ...

def is__bnot1(ea: ida_idaapi.ea_t) -> bool:
    ...

def is__invsign0(ea: ida_idaapi.ea_t) -> bool:
    ...

def is__invsign1(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_action_enabled(s: action_state_t) -> bool:
    r"""Check if the given action state is one of AST_ENABLE*.
    
    """
    ...

def is_additive(op: ctype_t) -> bool:
    r"""Is additive operator?
    
    """
    ...

def is_aflag__bnot0(flags: aflags_t) -> bool:
    ...

def is_aflag__bnot1(flags: aflags_t) -> bool:
    ...

def is_aflag__invsign0(flags: aflags_t) -> bool:
    ...

def is_aflag__invsign1(flags: aflags_t) -> bool:
    ...

def is_aflag_align_flow(flags: aflags_t) -> bool:
    ...

def is_aflag_colored_item(flags: aflags_t) -> bool:
    ...

def is_aflag_data_guessed_by_hexrays(flags: aflags_t) -> bool:
    ...

def is_aflag_fixed_spd(flags: aflags_t) -> bool:
    ...

def is_aflag_func_guessed_by_hexrays(flags: aflags_t) -> bool:
    ...

def is_aflag_hidden_border(flags: aflags_t) -> bool:
    ...

def is_aflag_hidden_item(flags: aflags_t) -> bool:
    ...

def is_aflag_libitem(flags: aflags_t) -> bool:
    ...

def is_aflag_lzero0(flags: aflags_t) -> bool:
    ...

def is_aflag_lzero1(flags: aflags_t) -> bool:
    ...

def is_aflag_manual_insn(flags: aflags_t) -> bool:
    ...

def is_aflag_noret(flags: aflags_t) -> bool:
    ...

def is_aflag_notcode(flags: aflags_t) -> bool:
    ...

def is_aflag_notproc(flags: aflags_t) -> bool:
    ...

def is_aflag_public_name(flags: aflags_t) -> bool:
    ...

def is_aflag_retfp(flags: aflags_t) -> bool:
    ...

def is_aflag_terse_struc(flags: aflags_t) -> bool:
    ...

def is_aflag_tilcmt(flags: aflags_t) -> bool:
    ...

def is_aflag_type_determined_by_hexrays(flags: aflags_t) -> bool:
    ...

def is_aflag_type_guessed_by_hexrays(flags: aflags_t) -> bool:
    ...

def is_aflag_type_guessed_by_ida(flags: aflags_t) -> bool:
    ...

def is_aflag_usersp(flags: aflags_t) -> bool:
    ...

def is_aflag_userti(flags: aflags_t) -> bool:
    ...

def is_aflag_weak_name(flags: aflags_t) -> bool:
    ...

def is_aflag_zstroff(flags: aflags_t) -> bool:
    ...

def is_align(F: flags64_t) -> bool:
    r"""FF_ALIGN
    
    """
    ...

def is_align_flow(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_align_insn(ea: ida_idaapi.ea_t) -> int:
    r"""If the instruction at 'ea' looks like an alignment instruction, return its length in bytes. Otherwise return 0. 
            
    """
    ...

def is_allowed_on_small_struni(op: ctype_t) -> bool:
    r"""Is the operator allowed on small structure or union?
    
    """
    ...

def is_anonymous_member_name(name: str) -> bool:
    r"""Is member name prefixed with "anonymous"?
    
    """
    ...

def is_assignment(op: ctype_t) -> bool:
    r"""Is assignment operator?
    
    """
    ...

def is_attached_custom_data_format(dtid: int, dfid: int) -> bool:
    r"""Is the custom data format attached to the custom data type? 
            
    :param dtid: data type id
    :param dfid: data format id
    :returns: true or false
    """
    ...

def is_auto_enabled() -> bool:
    r"""Get autoanalyzer state.
    
    """
    ...

def is_basic_block_end(insn: insn_t, call_insn_stops_block: bool) -> bool:
    r"""Is the instruction the end of a basic block?
    
    """
    ...

def is_bblk_trace_enabled() -> bool:
    ...

def is_binary(op: ctype_t) -> bool:
    r"""Is binary operator?
    
    """
    ...

def is_bitop(op: ctype_t) -> bool:
    r"""Is bit related operator?
    
    """
    ...

def is_bnot(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool:
    r"""Should we negate the operand?. asm_t::a_bnot should be defined in the idp module in order to work with this function 
            
    """
    ...

def is_bool_type(type: tinfo_t) -> bool:
    r"""Is a boolean type? 
            
    :returns: true if the type is a boolean type
    """
    ...

def is_break_consumer(op: ctype_t) -> bool:
    r"""Does a break statement influence the specified statement code?
    
    """
    ...

def is_byte(F: flags64_t) -> bool:
    r"""FF_BYTE
    
    """
    ...

def is_call_insn(insn: insn_t) -> bool:
    r"""Is the instruction a "call"?
    
    """
    ...

def is_char(F: flags64_t, n: int) -> bool:
    r"""is character constant?
    
    """
    ...

def is_char0(F: flags64_t) -> bool:
    r"""Is the first operand character constant? (example: push 'a')
    
    """
    ...

def is_char1(F: flags64_t) -> bool:
    r"""Is the second operand character constant? (example: mov al, 'a')
    
    """
    ...

def is_chooser_widget(t: twidget_type_t) -> bool:
    r"""Does the given widget type specify a chooser widget?
    
    """
    ...

def is_cmpop_with_eq(cmpop: cmpop_t) -> bool:
    ...

def is_cmpop_without_eq(cmpop: cmpop_t) -> bool:
    ...

def is_code(F: flags64_t) -> bool:
    r"""Does flag denote start of an instruction?
    
    """
    ...

def is_code_far(cm: cm_t) -> bool:
    r"""Does the given model specify far code?.
    
    """
    ...

def is_colored_item(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_commutative(op: ctype_t) -> bool:
    r"""Is commutative operator?
    
    """
    ...

def is_comp_unsure(comp: comp_t) -> comp_t:
    r"""See COMP_UNSURE.
    
    """
    ...

def is_control_tty(fd: int) -> Any:
    r"""Check if the current process is the owner of the TTY specified by 'fd' (typically an opened descriptor to /dev/tty). 
            
    """
    ...

def is_custfmt(F: flags64_t, n: int) -> bool:
    r"""is custom data format?
    
    """
    ...

def is_custfmt0(F: flags64_t) -> bool:
    r"""Does the first operand use a custom data representation?
    
    """
    ...

def is_custfmt1(F: flags64_t) -> bool:
    r"""Does the second operand use a custom data representation?
    
    """
    ...

def is_custom(F: flags64_t) -> bool:
    r"""FF_CUSTOM
    
    """
    ...

def is_custom_callcnv(cc: callcnv_t) -> bool:
    r"""Is custom calling convention?
    
    """
    ...

def is_cvt64() -> bool:
    r"""is IDA converting IDB into I64?
    
    """
    ...

def is_data(F: flags64_t) -> bool:
    r"""Does flag denote start of data?
    
    """
    ...

def is_data_far(cm: cm_t) -> bool:
    r"""Does the given model specify far data?.
    
    """
    ...

def is_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_database_busy() -> bool:
    r"""Check if the database is busy (e.g. performing some critical operations and cannot be safely accessed) 
            
    """
    ...

def is_database_flag(dbfl: int) -> bool:
    r"""Get the current database flag 
            
    :param dbfl: flag Database flags
    :returns: the state of the flag (set or cleared)
    """
    ...

def is_debugger_busy() -> bool:
    r"""Is the debugger busy?. Some debuggers do not accept any commands while the debugged application is running. For such a debugger, it is unsafe to do anything with the database (even simple queries like get_byte may lead to undesired consequences). Returns: true if the debugged application is running under such a debugger 
            
    """
    ...

def is_debugger_memory(ea: ida_idaapi.ea_t) -> bool:
    r"""Is the address mapped to debugger memory?
    
    """
    ...

def is_debugger_on() -> bool:
    r"""Is the debugger currently running?
    
    """
    ...

def is_defarg(F: flags64_t, n: int) -> bool:
    r"""is defined?
    
    """
    ...

def is_defarg0(F: flags64_t) -> bool:
    r"""Is the first operand defined? Initially operand has no defined representation.
    
    """
    ...

def is_defarg1(F: flags64_t) -> bool:
    r"""Is the second operand defined? Initially operand has no defined representation.
    
    """
    ...

def is_diff_merge_mode() -> bool:
    r"""Return TRUE if IDA is running in diff mode (MERGE_POLICY_MDIFF/MERGE_POLICY_VDIFF)
    
    """
    ...

def is_double(F: flags64_t) -> bool:
    r"""FF_DOUBLE
    
    """
    ...

def is_dummy_member_name(name: str) -> bool:
    r"""Is member name an auto-generated name?
    
    """
    ...

def is_dword(F: flags64_t) -> bool:
    r"""FF_DWORD
    
    """
    ...

def is_ea_tryblks(ea: ida_idaapi.ea_t, flags: int) -> bool:
    r"""Check if the given address ea is part of tryblks description. 
            
    :param ea: address to check
    :param flags: combination of flags for is_ea_tryblks()
    """
    ...

def is_enum(F: flags64_t, n: int) -> bool:
    r"""is enum?
    
    """
    ...

def is_enum0(F: flags64_t) -> bool:
    r"""Is the first operand a symbolic constant (enum member)?
    
    """
    ...

def is_enum1(F: flags64_t) -> bool:
    r"""Is the second operand a symbolic constant (enum member)?
    
    """
    ...

def is_filetype_like_binary(ft: filetype_t) -> bool:
    r"""Is unstructured input file?
    
    """
    ...

def is_finally_visible_func(pfn: func_t) -> bool:
    r"""Is the function visible (event after considering SCF_SHHID_FUNC)?
    
    """
    ...

def is_finally_visible_item(ea: ida_idaapi.ea_t) -> bool:
    r"""Is instruction visible?
    
    """
    ...

def is_finally_visible_segm(s: segment_t) -> bool:
    r"""See SFL_HIDDEN, SCF_SHHID_SEGM.
    
    """
    ...

def is_fixed_spd(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_fixup_custom(type: fixup_type_t) -> bool:
    r"""Is fixup processed by processor module?
    
    """
    ...

def is_flag_for_operand(F: flags64_t, typebits: uint8, n: int) -> bool:
    r"""Check that the 64-bit flags set has the expected type for operand `n`.
    
    :param F: the flags
    :param typebits: the type bits (one of `FF_N_`)
    :param n: the operand number
    :returns: success
    """
    ...

def is_float(F: flags64_t) -> bool:
    r"""FF_FLOAT
    
    """
    ...

def is_float0(F: flags64_t) -> bool:
    r"""Is the first operand a floating point number?
    
    """
    ...

def is_float1(F: flags64_t) -> bool:
    r"""Is the second operand a floating point number?
    
    """
    ...

def is_floating_dtype(dtype: op_dtype_t) -> bool:
    r"""Is a floating type operand?
    
    """
    ...

def is_flow(F: flags64_t) -> bool:
    r"""Does the previous instruction exist and pass execution flow to the current byte?
    
    """
    ...

def is_fltnum(F: flags64_t, n: int) -> bool:
    r"""is floating point number?
    
    """
    ...

def is_forced_operand(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Is operand manually defined?. 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number
    """
    ...

def is_func(F: flags64_t) -> bool:
    r"""Is function start?
    
    """
    ...

def is_func_entry(pfn: func_t) -> bool:
    r"""Does function describe a function entry chunk?
    
    """
    ...

def is_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_func_locked(pfn: func_t) -> bool:
    r"""Is the function pointer locked?
    
    """
    ...

def is_func_tail(pfn: func_t) -> bool:
    r"""Does function describe a function tail chunk?
    
    """
    ...

def is_func_trace_enabled() -> bool:
    r"""Get current state of functions tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_funcarg_off(pfn: func_t, frameoff: int) -> bool:
    ...

def is_gcc() -> bool:
    r"""Is the target compiler COMP_GNU?
    
    """
    ...

def is_gcc32() -> bool:
    r"""Is the target compiler 32 bit gcc?
    
    """
    ...

def is_gcc64() -> bool:
    r"""Is the target compiler 64 bit gcc?
    
    """
    ...

def is_golang_cc(cc: callcnv_t) -> bool:
    r"""GO language calling convention (return value in stack)?
    
    """
    ...

def is_head(F: flags64_t) -> bool:
    r"""Does flag denote start of instruction OR data?
    
    """
    ...

def is_hidden_border(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_hidden_item(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_ida_library(path: char = None, pathsize: size_t = 0, handle: void = None) -> bool:
    ...

def is_idaq() -> Any:
    r"""Returns True or False depending if IDAPython is hosted by IDAQ"""
    ...

def is_idaview(v: TWidget) -> bool:
    r"""Is the given custom view an idaview? (ui_is_idaview)
    
    """
    ...

def is_ident(name: str) -> bool:
    r"""Is a valid name? (including ::MangleChars)
    
    """
    ...

def is_ident_cp(cp: wchar32_t) -> bool:
    r"""Can a character appear in a name? (present in ::NameChars or ::MangleChars)
    
    """
    ...

def is_in_nlist(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_indirect_jump_insn(insn: insn_t) -> bool:
    r"""Is the instruction an indirect jump?
    
    """
    ...

def is_inplace_def(type: tinfo_t) -> bool:
    r"""Is struct/union/enum definition (not declaration)?
    
    """
    ...

def is_insn_trace_enabled() -> bool:
    r"""Get current state of instruction tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_invsign(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool:
    r"""Should sign of n-th operand inverted during output?. allowed values of n: 0-first operand, 1-other operands 
            
    """
    ...

def is_kreg(r: mreg_t) -> bool:
    r"""Is a kernel register? Kernel registers are temporary registers that can be used freely. They may be used to store values that cross instruction or basic block boundaries. Kernel registers do not map to regular processor registers. See also mba_t::alloc_kreg() 
            
    """
    ...

def is_libitem(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_loaded(ea: ida_idaapi.ea_t) -> bool:
    r"""Does the specified address have a byte value (is initialized?)
    
    """
    ...

def is_logical(op: ctype_t) -> bool:
    r"""Is logical operator?
    
    """
    ...

def is_loop(op: ctype_t) -> bool:
    r"""Is loop statement code?
    
    """
    ...

def is_lvalue(op: ctype_t) -> bool:
    r"""Is Lvalue operator?
    
    """
    ...

def is_lzero(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Display leading zeroes? Display leading zeroes in operands. The global switch for the leading zeroes is in idainfo::s_genflags Note: the leading zeroes doesn't work if for the target assembler octal numbers start with 0. 
            
    :param ea: the item (insn/data) address
    :param n: the operand number (0-first operand, 1-other operands)
    :returns: success
    """
    ...

def is_lzero0(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_lzero1(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_main_thread() -> bool:
    r"""Are we running in the main thread?
    
    """
    ...

def is_manual(F: flags64_t, n: int) -> bool:
    r"""is forced operand? (use is_forced_operand())
    
    """
    ...

def is_manual_insn(ea: ida_idaapi.ea_t) -> bool:
    r"""Is the instruction overridden? 
            
    :param ea: linear address of the instruction or data item
    """
    ...

def is_mapped(ea: ida_idaapi.ea_t) -> bool:
    r"""Is the specified address 'ea' present in the program?
    
    """
    ...

def is_may_access(maymust: maymust_t) -> bool:
    ...

def is_mcode_addsub(mcode: mcode_t) -> bool:
    ...

def is_mcode_call(mcode: mcode_t) -> bool:
    ...

def is_mcode_commutative(mcode: mcode_t) -> bool:
    ...

def is_mcode_convertible_to_jmp(mcode: mcode_t) -> bool:
    ...

def is_mcode_convertible_to_set(mcode: mcode_t) -> bool:
    ...

def is_mcode_divmod(op: mcode_t) -> bool:
    ...

def is_mcode_fpu(mcode: mcode_t) -> bool:
    ...

def is_mcode_j1(mcode: mcode_t) -> bool:
    ...

def is_mcode_jcond(mcode: mcode_t) -> bool:
    ...

def is_mcode_propagatable(mcode: mcode_t) -> bool:
    r"""May opcode be propagated? Such opcodes can be used in sub-instructions (nested instructions) There is a handful of non-propagatable opcodes, like jumps, ret, nop, etc All other regular opcodes are propagatable and may appear in a nested instruction. 
            
    """
    ...

def is_mcode_set(mcode: mcode_t) -> bool:
    ...

def is_mcode_set1(mcode: mcode_t) -> bool:
    ...

def is_mcode_shift(mcode: mcode_t) -> bool:
    ...

def is_mcode_xdsu(mcode: mcode_t) -> bool:
    ...

def is_miniidb() -> bool:
    r"""Is the database a miniidb created by the debugger?. 
            
    :returns: true if the database contains no segments or only debugger segments
    """
    ...

def is_msg_inited() -> bool:
    r"""Can we use msg() functions?
    
    """
    ...

def is_multiplicative(op: ctype_t) -> bool:
    r"""Is multiplicative operator?
    
    """
    ...

def is_name_defined_locally(args: Any) -> bool:
    r"""Is the name defined locally in the specified function? 
            
    :param pfn: pointer to function
    :param name: name to check
    :param ignore_name_def: which names to ignore when checking
    :param ea1: the starting address of the range inside the function (optional)
    :param ea2: the ending address of the range inside the function (optional)
    :returns: true if the name has been defined
    """
    ...

def is_nonbool_type(type: tinfo_t) -> bool:
    r"""Is definitely a non-boolean type? 
            
    :returns: true if the type is a non-boolean type (non bool and well defined)
    """
    ...

def is_noret(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_noret_block(btype: fc_block_type_t) -> bool:
    r"""Does this block never return?
    
    """
    ...

def is_not_tail(F: flags64_t) -> bool:
    r"""Does flag denote tail byte?
    
    """
    ...

def is_notcode(ea: ida_idaapi.ea_t) -> bool:
    r"""Is the address marked as not-code?
    
    """
    ...

def is_notproc(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_numop(F: flags64_t, n: int) -> bool:
    r"""is number (bin, oct, dec, hex)?
    
    """
    ...

def is_numop0(F: flags64_t) -> bool:
    r"""Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    """
    ...

def is_numop1(F: flags64_t) -> bool:
    r"""Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    """
    ...

def is_off(F: flags64_t, n: int) -> bool:
    r"""is offset?
    
    """
    ...

def is_off0(F: flags64_t) -> bool:
    r"""Is the first operand offset? (example: push offset xxx)
    
    """
    ...

def is_off1(F: flags64_t) -> bool:
    r"""Is the second operand offset? (example: mov ax, offset xxx)
    
    """
    ...

def is_one_bit_mask(mask: int) -> bool:
    r"""Is bitmask one bit?
    
    """
    ...

def is_ordinal_name(name: str, ord: uint32 = None) -> bool:
    r"""Check if the name is an ordinal name. Ordinal names have the following format: '#' + set_de(ord) 
            
    """
    ...

def is_oword(F: flags64_t) -> bool:
    r"""FF_OWORD
    
    """
    ...

def is_pack_real(F: flags64_t) -> bool:
    r"""FF_PACKREAL
    
    """
    ...

def is_paf(t: type_t) -> bool:
    r"""Is a pointer, array, or function type?
    
    """
    ...

def is_pascal(strtype: int) -> bool:
    ...

def is_place_class_ea_capable(id: int) -> bool:
    r"""See get_place_class()
    
    """
    ...

def is_prepost(op: ctype_t) -> bool:
    r"""Is pre/post increment/decrement operator?
    
    """
    ...

def is_problem_present(t: problist_id_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Check if the specified address is present in the problem list.
    
    """
    ...

def is_ptr_or_array(t: type_t) -> bool:
    r"""Is a pointer or array type?
    
    """
    ...

def is_public_name(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_purging_cc(cc: callcnv_t) -> bool:
    r"""Does the calling convention clean the stack arguments upon return?. 
            
    """
    ...

def is_qword(F: flags64_t) -> bool:
    r"""FF_QWORD
    
    """
    ...

def is_refresh_requested(mask: uint64) -> bool:
    r"""Get a refresh request state 
            
    :param mask: Window refresh flags
    :returns: the state (set or cleared)
    """
    ...

def is_reftype_target_optional(type: reftype_t) -> bool:
    r"""Can the target be calculated using operand value?
    
    """
    ...

def is_reg_custom(regname: str) -> bool:
    r"""Does a register contain a value of a custom data type? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_reg_float(regname: str) -> bool:
    r"""Does a register contain a floating point value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_reg_integer(regname: str) -> bool:
    r"""Does a register contain an integer value? \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_relational(op: ctype_t) -> bool:
    r"""Is comparison operator?
    
    """
    ...

def is_request_running() -> bool:
    r"""Is a request currently running?
    
    """
    ...

def is_restype_enum(til: til_t, type: type_t) -> bool:
    ...

def is_restype_struct(til: til_t, type: type_t) -> bool:
    ...

def is_restype_struni(til: til_t, type: type_t) -> bool:
    ...

def is_restype_void(til: til_t, type: type_t) -> bool:
    ...

def is_ret_block(btype: fc_block_type_t) -> bool:
    r"""Does this block return?
    
    """
    ...

def is_ret_insn(args: Any) -> bool:
    ...

def is_retfp(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_same_data_type(F1: flags64_t, F2: flags64_t) -> bool:
    r"""Do the given flags specify the same data type?
    
    """
    ...

def is_same_func(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> bool:
    r"""Do two addresses belong to the same function?
    
    """
    ...

def is_sdacl_byte(t: type_t) -> bool:
    r"""Identify an sdacl byte. The first sdacl byte has the following format: 11xx000x. The sdacl bytes are appended to udt fields. They indicate the start of type attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers instead of the tah-byte. This is done for compatibility with old databases, they were already using sdacl bytes in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in the type bit definitions) 
            
    """
    ...

def is_seg(F: flags64_t, n: int) -> bool:
    r"""is segment?
    
    """
    ...

def is_seg0(F: flags64_t) -> bool:
    r"""Is the first operand segment selector? (example: push seg seg001)
    
    """
    ...

def is_seg1(F: flags64_t) -> bool:
    r"""Is the second operand segment selector? (example: mov dx, seg dseg)
    
    """
    ...

def is_segm_locked(segm: segment_t) -> bool:
    r"""Is a segment pointer locked?
    
    """
    ...

def is_signed_cmpop(cmpop: cmpop_t) -> bool:
    ...

def is_signed_mcode(code: mcode_t) -> bool:
    ...

def is_small_struni(tif: tinfo_t) -> bool:
    r"""Is a small structure or union? 
            
    :returns: true if the type is a small UDT (user defined type). Small UDTs fit into a register (or pair or registers) as a rule.
    """
    ...

def is_small_udt(tif: tinfo_t) -> bool:
    r"""Is a small structure or union? 
            
    :returns: true if the type is a small UDT (user defined type). Small UDTs fit into a register (or pair or registers) as a rule.
    """
    ...

def is_spec_ea(ea: ida_idaapi.ea_t) -> bool:
    r"""Does the address belong to a segment with a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
            
    :param ea: linear address
    """
    ...

def is_spec_segm(seg_type: uchar) -> bool:
    r"""Has segment a special type?. (SEG_XTRN, SEG_GRP, SEG_ABSSYM, SEG_COMM) 
            
    """
    ...

def is_special_frame_member(tid: tid_t) -> bool:
    r"""Is stkvar with TID the return address slot or the saved registers slot ? 
            
    :param tid: frame member type id return address or saved registers member?
    """
    ...

def is_step_trace_enabled() -> bool:
    r"""Get current state of step tracing. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def is_stkvar(F: flags64_t, n: int) -> bool:
    r"""is stack variable?
    
    """
    ...

def is_stkvar0(F: flags64_t) -> bool:
    r"""Is the first operand a stack variable?
    
    """
    ...

def is_stkvar1(F: flags64_t) -> bool:
    r"""Is the second operand a stack variable?
    
    """
    ...

def is_strlit(F: flags64_t) -> bool:
    r"""FF_STRLIT
    
    """
    ...

def is_strlit_cp(cp: wchar32_t, specific_ranges: rangeset_crefvec_t = None) -> bool:
    r"""Can a character appear in a string literal (present in ::StrlitChars) If 'specific_ranges' are specified, those will be used instead of the ones corresponding to the current culture (only if ::StrlitChars is configured to use the current culture) 
            
    """
    ...

def is_stroff(F: flags64_t, n: int) -> bool:
    r"""is struct offset?
    
    """
    ...

def is_stroff0(F: flags64_t) -> bool:
    r"""Is the first operand an offset within a struct?
    
    """
    ...

def is_stroff1(F: flags64_t) -> bool:
    r"""Is the second operand an offset within a struct?
    
    """
    ...

def is_struct(F: flags64_t) -> bool:
    r"""FF_STRUCT
    
    """
    ...

def is_suspop(ea: ida_idaapi.ea_t, F: flags64_t, n: int) -> bool:
    r"""is suspicious operand?
    
    """
    ...

def is_swift_cc(cc: callcnv_t) -> bool:
    r"""Swift calling convention (arguments and return values in registers)?
    
    """
    ...

def is_tah_byte(t: type_t) -> bool:
    r"""The TAH byte (type attribute header byte) denotes the start of type attributes. (see "tah-typeattrs" in the type bit definitions) 
            
    """
    ...

def is_tail(F: flags64_t) -> bool:
    r"""Does flag denote tail byte?
    
    """
    ...

def is_tbyte(F: flags64_t) -> bool:
    r"""FF_TBYTE
    
    """
    ...

def is_terse_struc(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_tif_cursor_footer(c: tif_cursor_t) -> bool:
    ...

def is_tif_cursor_header(c: tif_cursor_t) -> bool:
    ...

def is_tif_cursor_index(c: tif_cursor_t) -> bool:
    ...

def is_tilcmt(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_trusted_idb() -> bool:
    r"""Is the database considered as trusted?
    
    """
    ...

def is_type_arithmetic(t: type_t) -> bool:
    r"""Is the type an arithmetic type? (floating or integral)
    
    """
    ...

def is_type_array(t: type_t) -> bool:
    r"""See BT_ARRAY.
    
    """
    ...

def is_type_bitfld(t: type_t) -> bool:
    r"""See BT_BITFIELD.
    
    """
    ...

def is_type_bool(t: type_t) -> bool:
    r"""See BTF_BOOL.
    
    """
    ...

def is_type_char(t: type_t) -> bool:
    r"""Does the type specify a char value? (signed or unsigned, see Basic type: integer)
    
    """
    ...

def is_type_choosable(ti: til_t, ordinal: int) -> bool:
    r"""Check if a struct/union type is choosable 
            
    :param ti: type library
    :param ordinal: ordinal number of a UDT type
    """
    ...

def is_type_complex(t: type_t) -> bool:
    r"""See BT_COMPLEX.
    
    """
    ...

def is_type_const(t: type_t) -> bool:
    r"""See BTM_CONST.
    
    """
    ...

def is_type_correct(ptr: type_t) -> bool:
    r"""Verify a type string. 
            
    :returns: true if type string is correct
    """
    ...

def is_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_type_double(t: type_t) -> bool:
    r"""See BTF_DOUBLE.
    
    """
    ...

def is_type_enum(t: type_t) -> bool:
    r"""See BTF_ENUM.
    
    """
    ...

def is_type_ext_arithmetic(t: type_t) -> bool:
    r"""Is the type an extended arithmetic type? (arithmetic or enum)
    
    """
    ...

def is_type_ext_integral(t: type_t) -> bool:
    r"""Is the type an extended integral type? (integral or enum)
    
    """
    ...

def is_type_float(t: type_t) -> bool:
    r"""See BTF_FLOAT.
    
    """
    ...

def is_type_floating(t: type_t) -> bool:
    r"""Is the type a floating point type?
    
    """
    ...

def is_type_func(t: type_t) -> bool:
    r"""See BT_FUNC.
    
    """
    ...

def is_type_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_type_int(bt: type_t) -> bool:
    r"""Does the type_t specify one of the basic types in Basic type: integer?
    
    """
    ...

def is_type_int128(t: type_t) -> bool:
    r"""Does the type specify a 128-bit value? (signed or unsigned, see Basic type: integer)
    
    """
    ...

def is_type_int16(t: type_t) -> bool:
    r"""Does the type specify a 16-bit value? (signed or unsigned, see Basic type: integer)
    
    """
    ...

def is_type_int32(t: type_t) -> bool:
    r"""Does the type specify a 32-bit value? (signed or unsigned, see Basic type: integer)
    
    """
    ...

def is_type_int64(t: type_t) -> bool:
    r"""Does the type specify a 64-bit value? (signed or unsigned, see Basic type: integer)
    
    """
    ...

def is_type_integral(t: type_t) -> bool:
    r"""Is the type an integral type (char/short/int/long/bool)?
    
    """
    ...

def is_type_ldouble(t: type_t) -> bool:
    r"""See BTF_LDOUBLE.
    
    """
    ...

def is_type_paf(t: type_t) -> bool:
    r"""Is the type a pointer, array, or function type?
    
    """
    ...

def is_type_partial(t: type_t) -> bool:
    r"""Identifies an unknown or void type with a known size (see Basic type: unknown & void)
    
    """
    ...

def is_type_ptr(t: type_t) -> bool:
    r"""See BT_PTR.
    
    """
    ...

def is_type_ptr_or_array(t: type_t) -> bool:
    r"""Is the type a pointer or array type?
    
    """
    ...

def is_type_struct(t: type_t) -> bool:
    r"""See BTF_STRUCT.
    
    """
    ...

def is_type_struni(t: type_t) -> bool:
    r"""Is the type a struct or union?
    
    """
    ...

def is_type_sue(t: type_t) -> bool:
    r"""Is the type a struct/union/enum?
    
    """
    ...

def is_type_tbyte(t: type_t) -> bool:
    r"""See BTF_FLOAT.
    
    """
    ...

def is_type_typedef(t: type_t) -> bool:
    r"""See BTF_TYPEDEF.
    
    """
    ...

def is_type_uchar(t: type_t) -> bool:
    r"""See BTF_UCHAR.
    
    """
    ...

def is_type_uint(t: type_t) -> bool:
    r"""See BTF_UINT.
    
    """
    ...

def is_type_uint128(t: type_t) -> bool:
    r"""See BTF_UINT128.
    
    """
    ...

def is_type_uint16(t: type_t) -> bool:
    r"""See BTF_UINT16.
    
    """
    ...

def is_type_uint32(t: type_t) -> bool:
    r"""See BTF_UINT32.
    
    """
    ...

def is_type_uint64(t: type_t) -> bool:
    r"""See BTF_UINT64.
    
    """
    ...

def is_type_union(t: type_t) -> bool:
    r"""See BTF_UNION.
    
    """
    ...

def is_type_unknown(t: type_t) -> bool:
    r"""See BT_UNKNOWN.
    
    """
    ...

def is_type_void(t: type_t) -> bool:
    r"""See BTF_VOID.
    
    """
    ...

def is_type_volatile(t: type_t) -> bool:
    r"""See BTM_VOLATILE.
    
    """
    ...

def is_typeid_last(t: type_t) -> bool:
    r"""Is the type_t the last byte of type declaration? (there are no additional bytes after a basic type, see _BT_LAST_BASIC) 
            
    """
    ...

def is_uname(name: str) -> bool:
    r"""Is valid user-specified name? (valid name & !dummy prefix). 
            
    :param name: name to test. may be nullptr.
    :returns: 1: yes
    :returns: 0: no
    """
    ...

def is_unary(op: ctype_t) -> bool:
    r"""Is unary operator?
    
    """
    ...

def is_unknown(F: flags64_t) -> bool:
    r"""Does flag denote unexplored byte?
    
    """
    ...

def is_unsigned_cmpop(cmpop: cmpop_t) -> bool:
    ...

def is_unsigned_mcode(code: mcode_t) -> bool:
    ...

def is_user_cc(cc: callcnv_t) -> bool:
    r"""Does the calling convention specify argument locations explicitly?
    
    """
    ...

def is_usersp(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_userti(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_valid_cp(cp: wchar32_t, kind: nametype_t, data: void = None) -> bool:
    r"""Is the given codepoint acceptable in the given context?
    
    """
    ...

def is_valid_dstate(state: int) -> bool:
    ...

def is_valid_trace_file(filename: str) -> bool:
    r"""Is the specified file a valid trace file for the current database?
    
    """
    ...

def is_valid_typename(name: str) -> bool:
    r"""Is valid type name? 
            
    :param name: name to test. may be nullptr.
    :returns: 1: yes
    :returns: 0: no
    """
    ...

def is_vararg_cc(cc: callcnv_t) -> bool:
    r"""Does the calling convention use ellipsis?
    
    """
    ...

def is_varsize_item(ea: ida_idaapi.ea_t, F: flags64_t, ti: opinfo_t = None, itemsize: asize_t = None) -> int:
    r"""Is the item at 'ea' variable size?. 
            
    :param ea: linear address of the item
    :param F: flags
    :param ti: additional information about the data type. For example, if the current item is a structure instance, then ti->tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database
    :param itemsize: if not nullptr and the item is varsize, itemsize will contain the calculated item size (for struct types, the minimal size is returned)
    :returns: 1: varsize item
    :returns: 0: fixed item
    :returns: -1: error (bad data definition)
    """
    ...

def is_visible_cp(cp: wchar32_t) -> bool:
    r"""Can a character be displayed in a name? (present in ::NameChars)
    
    """
    ...

def is_visible_func(pfn: func_t) -> bool:
    r"""Is the function visible (not hidden)?
    
    """
    ...

def is_visible_item(ea: ida_idaapi.ea_t) -> bool:
    r"""Test visibility of item at given ea.
    
    """
    ...

def is_visible_segm(s: segment_t) -> bool:
    r"""See SFL_HIDDEN.
    
    """
    ...

def is_weak_name(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_word(F: flags64_t) -> bool:
    r"""FF_WORD
    
    """
    ...

def is_yword(F: flags64_t) -> bool:
    r"""FF_YWORD
    
    """
    ...

def is_zstroff(ea: ida_idaapi.ea_t) -> bool:
    ...

def is_zword(F: flags64_t) -> bool:
    r"""FF_ZWORD
    
    """
    ...

def jcnd2set(code: mcode_t) -> mcode_t:
    ...

def jumpto(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
        1. jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    # 0: jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
    
    Jump to the specified address (ui_jumpto). 
            
    :returns: success
    
    # 1: jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool
    
    Set cursor position in custom ida viewer. 
            
    :returns: success
    
    """
    ...

def l_compare2(t1: place_t, t2: place_t, ud: void) -> int:
    ...

def l_equals(t1: place_t, t2: place_t, ud: void) -> bool:
    ...

def last_idcv_attr(obj: idc_value_t) -> str:
    ...

def leading_zero_important(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Check if leading zeroes are important.
    
    """
    ...

def lexcompare(a: mop_t, b: mop_t) -> int:
    ...

def lexcompare_tinfo(t1: typid_t, t2: typid_t, arg3: int) -> int:
    ...

def list_bptgrps() -> List[str]:
    r"""Retrieve the list of absolute path of all folders of bpt dirtree.
    Synchronous function, Notification, none (synchronous function)
    """
    ...

def lnot(e: Any) -> Any:
    r"""Logically negate the specified expression. The specified expression will be logically negated. For example, "x == y" is converted into "x != y" by this function. 
            
    :param e: expression to negate. After the call, e must not be used anymore because it can be changed by the function. The function return value must be used to refer to the expression.
    :returns: logically negated expression.
    """
    ...

def load_and_run_plugin(name: str, arg: size_t) -> bool:
    r"""Load & run a plugin.
    
    """
    ...

def load_binary_file(filename: str, li: linput_t, _neflags: ushort, fileoff: qoff64_t, basepara: ida_idaapi.ea_t, binoff: ida_idaapi.ea_t, nbytes: uint64) -> bool:
    r"""Load a binary file into the database. This function usually is called from ui. 
            
    :param filename: the name of input file as is (if the input file is from library, then this is the name from the library)
    :param li: loader input source
    :param _neflags: Load file flags. For the first file, the flag NEF_FIRST must be set.
    :param fileoff: Offset in the input file
    :param basepara: Load address in paragraphs
    :param binoff: Load offset (load_address=(basepara<<4)+binoff)
    :param nbytes: Number of bytes to load from the file.
    * 0: up to the end of the file
    :returns: true: ok
    :returns: false: failed (couldn't open the file)
    """
    ...

def load_custom_icon(file_name: Any = None, data: Any = None, format: Any = None) -> Any:
    r"""Load an icon from a file (ui_load_custom_icon_file). Also see load_custom_icon(const void *, unsigned int, const char *) 
            
    :param file_name: path to file
    :returns: icon id
    """
    ...

def load_dbg_dbginfo(args: Any) -> bool:
    r"""Load debugging information from a file. 
            
    :param path: path to file
    :param li: loader input. if nullptr, check DBG_NAME_KEY
    :param base: loading address
    :param verbose: dump status to message window
    """
    ...

def load_debugger(dbgname: str, use_remote: bool) -> bool:
    ...

def load_ids_module(fname: char) -> int:
    r"""Load and apply IDS file. This function loads the specified IDS file and applies it to the database. If the program imports functions from a module with the same name as the name of the ids file being loaded, then only functions from this module will be affected. Otherwise (i.e. when the program does not import a module with this name) any function in the program may be affected. 
            
    :param fname: name of file to apply
    :returns: 1: ok
    :returns: 0: some error (a message is displayed). if the ids file does not exist, no message is displayed
    """
    ...

def load_plugin(name: Any) -> Any:
    r"""Loads a plugin
    
    :param name: short plugin name without path and extension,
                 or absolute path to the file name
    :returns: An opaque object representing the loaded plugin, or None if plugin could not be loaded
    """
    ...

def load_til(name: str, tildir: str = None) -> str:
    r"""Load til from a file without adding it to the database list (see also add_til). Failure to load base tils are reported into 'errbuf'. They do not prevent loading of the main til. 
            
    :param name: filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    :param tildir: directory where to load the til from. nullptr means default til subdirectories.
    :returns: pointer to resulting til, nullptr if failed and error message is in errbuf
    """
    ...

def load_til_header(tildir: str, name: str) -> str:
    r"""Get human-readable til description.
    
    """
    ...

def load_trace_file(filename: str) -> str:
    r"""Load a recorded trace file in the 'Tracing' window. If the call succeeds and 'buf' is not null, the description of the trace stored in the binary trace file will be returned in 'buf' 
            
    """
    ...

def locate_lvar(out: lvar_locator_t, func_ea: ida_idaapi.ea_t, varname: str) -> bool:
    r"""Find a variable by name. 
            
    :param out: output buffer for the variable locator
    :param func_ea: function start address
    :param varname: variable name
    :returns: success Since VARNAME is not always enough to find the variable, it may decompile the function.
    """
    ...

def lock_func_range(pfn: func_t, lock: bool) -> None:
    r"""Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
            
    """
    ...

def lock_segm(segm: segment_t, lock: bool) -> None:
    r"""Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked. Ranges with locked pointers cannot be deleted or moved. 
            
    """
    ...

def log2ceil(d64: uint64) -> int:
    r"""calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 == 0 
            
    """
    ...

def log2floor(d64: uint64) -> int:
    ...

def lookup_key_code(key: int, shift: int, is_qt: bool) -> ushort:
    r"""Get shortcut code previously created by ui_get_key_code. 
            
    :param key: key constant
    :param shift: modifiers
    :param is_qt: are we using gui version?
    """
    ...

def lower_type(til: til_t, tif: tinfo_t, name: str = None, _helper: lowertype_helper_t = None) -> int:
    r"""Lower type. Inspect the type and lower all function subtypes using lower_func_type(). 
    We call the prototypes usually encountered in source files "high level" 
    They may have implicit arguments, array arguments, big structure retvals, etc 
    We introduce explicit arguments (i.e. 'this' pointer) and call the result 
    "low level prototype". See FTI_HIGH.
    In order to improve heuristics for recognition of big structure retvals, 
    it is recommended to pass a helper that will be used to make decisions. 
    That helper will be used only for lowering 'tif', and not for the children 
    types walked through by recursion. 
            
    :returns: 1: removed FTI_HIGH,
    :returns: 2: made substantial changes
    :returns: -1: failure
    """
    ...

def lvar_mapping_begin(map: lvar_mapping_t) -> lvar_mapping_iterator_t:
    r"""Get iterator pointing to the beginning of lvar_mapping_t.
    
    """
    ...

def lvar_mapping_clear(map: lvar_mapping_t) -> None:
    r"""Clear lvar_mapping_t.
    
    """
    ...

def lvar_mapping_end(map: lvar_mapping_t) -> lvar_mapping_iterator_t:
    r"""Get iterator pointing to the end of lvar_mapping_t.
    
    """
    ...

def lvar_mapping_erase(map: lvar_mapping_t, p: lvar_mapping_iterator_t) -> None:
    r"""Erase current element from lvar_mapping_t.
    
    """
    ...

def lvar_mapping_find(map: lvar_mapping_t, key: lvar_locator_t) -> lvar_mapping_iterator_t:
    r"""Find the specified key in lvar_mapping_t.
    
    """
    ...

def lvar_mapping_first(p: lvar_mapping_iterator_t) -> lvar_locator_t:
    r"""Get reference to the current map key.
    
    """
    ...

def lvar_mapping_free(map: lvar_mapping_t) -> None:
    r"""Delete lvar_mapping_t instance.
    
    """
    ...

def lvar_mapping_insert(map: lvar_mapping_t, key: lvar_locator_t, val: lvar_locator_t) -> lvar_mapping_iterator_t:
    r"""Insert new (lvar_locator_t, lvar_locator_t) pair into lvar_mapping_t.
    
    """
    ...

def lvar_mapping_new() -> lvar_mapping_t:
    r"""Create a new lvar_mapping_t instance.
    
    """
    ...

def lvar_mapping_next(p: lvar_mapping_iterator_t) -> lvar_mapping_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def lvar_mapping_prev(p: lvar_mapping_iterator_t) -> lvar_mapping_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def lvar_mapping_second(p: lvar_mapping_iterator_t) -> lvar_locator_t:
    r"""Get reference to the current map value.
    
    """
    ...

def lvar_mapping_size(map: lvar_mapping_t) -> int:
    r"""Get size of lvar_mapping_t.
    
    """
    ...

def lvar_off(pfn: func_t, frameoff: int) -> int:
    ...

def macros_enabled() -> bool:
    ...

def make_name_auto(ea: ida_idaapi.ea_t) -> bool:
    ...

def make_name_non_public(ea: ida_idaapi.ea_t) -> None:
    ...

def make_name_non_weak(ea: ida_idaapi.ea_t) -> None:
    ...

def make_name_public(ea: ida_idaapi.ea_t) -> None:
    ...

def make_name_user(ea: ida_idaapi.ea_t) -> bool:
    ...

def make_name_weak(ea: ida_idaapi.ea_t) -> None:
    ...

def make_num(args: Any) -> Any:
    r"""Create a number expression 
            
    :param n: value
    :param func: current function
    :param ea: definition address of the number
    :param opnum: operand number of the number (in the disassembly listing)
    :param sign: number sign
    :param size: size of number in bytes Please note that the type of the resulting expression can be anything because it can be inherited from the disassembly listing or taken from the user specified number representation in the pseudocode view.
    """
    ...

def make_pointer(type: tinfo_t) -> tinfo_t:
    r"""Create a pointer type. This function performs the following conversion: "type" -> "type*" 
            
    :param type: object type.
    :returns: "type*". for example, if 'char' is passed as the argument,
    """
    ...

def make_ref(e: Any) -> Any:
    r"""Create a reference. This function performs the following conversion: "obj" => "&obj". It can handle casts, annihilate "&*", and process other special cases. 
            
    """
    ...

def make_str_type(type_code: uchar, encoding_idx: int, term1: uchar = 0, term2: uchar = 0) -> int:
    ...

def map_code_ea(args: Any) -> ida_idaapi.ea_t:
    ...

def map_data_ea(args: Any) -> ida_idaapi.ea_t:
    ...

def map_ea(args: Any) -> ida_idaapi.ea_t:
    ...

def mark_cfunc_dirty(ea: ida_idaapi.ea_t, close_views: bool = False) -> bool:
    r"""Flush the cached decompilation results. Erases a cache entry for the specified function. 
            
    :param ea: function to erase from the cache
    :param close_views: close pseudocode windows that show the function
    :returns: if a cache entry existed.
    """
    ...

def mark_position(ea: ida_idaapi.ea_t, lnnum: int, x: short, y: short, slot: int, comment: str) -> None:
    ...

def max_vlr_svalue(size: int) -> uvlr_t:
    ...

def max_vlr_value(size: int) -> uvlr_t:
    ...

def may_create_stkvars() -> bool:
    r"""Is it allowed to create stack variables automatically?. This function should be used by IDP modules before creating stack vars. 
            
    """
    ...

def may_trace_sp() -> bool:
    r"""Is it allowed to trace stack pointer automatically?. This function should be used by IDP modules before tracing sp. 
            
    """
    ...

def mcode_modifies_d(mcode: mcode_t) -> bool:
    ...

def mem2base(mem: Any, ea: Any, fpos: Any) -> Any:
    r"""Load database from the memory.
    
    :param mem: the buffer
    :param ea: start linear addresses
    :param fpos: position in the input file the data is taken from.
                 if == -1, then no file position correspond to the data.
    :returns: 1, or 0 in case of failure
    """
    ...

def min_vlr_svalue(size: int) -> uvlr_t:
    ...

def modify_user_lvar_info(func_ea: ida_idaapi.ea_t, mli_flags: uint, info: lvar_saved_info_t) -> bool:
    r"""Modify saved local variable settings of one variable. 
            
    :param func_ea: function start address
    :param mli_flags: bits that specify which attrs defined by INFO are to be set
    :param info: local variable info attrs
    :returns: true if modified, false if invalid MLI_FLAGS passed
    """
    ...

def modify_user_lvars(entry_ea: ida_idaapi.ea_t, mlv: user_lvar_modifier_t) -> bool:
    r"""Modify saved local variable settings. 
            
    :param entry_ea: function start address
    :param mlv: local variable modifier
    :returns: true if modified variables
    """
    ...

def move_bpt_to_grp(bpt: bpt_t, grp_name: str) -> bool:
    r"""Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bpt: bpt that will be moved
    :param grp_name: absolute path to the breakpoint dirtree folder
    :returns: success
    """
    ...

def move_idcv(dst: idc_value_t, src: idc_value_t) -> error_t:
    r"""Move 'src' to 'dst'. This function is more effective than copy_idcv since it never copies big amounts of data. 
            
    """
    ...

def move_privrange(new_privrange_start: ida_idaapi.ea_t) -> bool:
    r"""Move privrange to the specified address 
            
    :param new_privrange_start: new start address of the privrange
    :returns: success
    """
    ...

def move_segm(s: segment_t, to: ida_idaapi.ea_t, flags: int = 0) -> move_segm_code_t:
    r"""This function moves all information to the new address. It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, loader_t::move_segm is called. Also IDB notification event idb_event::segm_moved is called. 
            
    :param s: segment to move
    :param to: new segment start address
    :param flags: Move segment flags
    :returns: Move segment result codes
    """
    ...

def move_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, mode: int) -> bool:
    r"""Move segment start. The main difference between this function and set_segm_start() is that this function may expand the previous segment while set_segm_start() never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. 
            
    :param ea: any address belonging to the segment
    :param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
    :param mode: policy for destroying defined items
    * 0: if it is necessary to destroy defined items, display a dialog box and ask confirmation
    * 1: if it is necessary to destroy defined items, just destroy them without asking the user
    * -1: if it is necessary to destroy defined items, don't destroy them (i.e. function will fail)
    * -2: don't destroy defined items (function will succeed)
    :returns: 1: ok
    :returns: 0: failed, a warning message is displayed
    """
    ...

def move_segm_strerror(code: move_segm_code_t) -> str:
    r"""Return string describing error MOVE_SEGM_... code.
    
    """
    ...

def mreg2reg(reg: mreg_t, width: int) -> int:
    r"""Map a microregister to a processor register. 
            
    :param reg: microregister number
    :param width: size of microregister in bytes
    :returns: processor register id or -1
    """
    ...

def msg(message: Any) -> Any:
    r"""Display a message in the message window
    
    :param message: message to print
    """
    ...

def msg_clear() -> None:
    r"""Clear the "Output" window.
    
    """
    ...

def msg_get_lines(count: int = -1) -> Any:
    r"""Retrieve the last 'count' lines from the output window, in reverse order (from most recent, to least recent) 
            
    :param count: The number of lines to retrieve. -1 means: all
    """
    ...

def msg_save(path: str) -> bool:
    r"""Save the "Output" window contents into a file 
            
    :param path: The path of the file to save the contents into. An empty path means that the user will be prompted for the destination and, if the file already exists, the user will be asked to confirm before overriding its contents. Upon return, 'path' will contain the path that the user chose.
    :returns: success
    """
    ...

def must_mcode_close_block(mcode: mcode_t, including_calls: bool) -> bool:
    r"""Must an instruction with the given opcode be the last one in a block? Such opcodes are called closing opcodes. 
            
    :param mcode: instruction opcode
    :param including_calls: should m_call/m_icall be considered as the closing opcodes? If this function returns true, the opcode cannot appear in the middle of a block. Calls are a special case: unknown calls (is_unknown_call) are considered as closing opcodes.
    """
    ...

def nbits(ea: ida_idaapi.ea_t) -> int:
    r"""Get number of bits in a byte at the given address. 
            
    :returns: processor_t::dnbits() if the address doesn't belong to a segment, otherwise the result depends on the segment type
    """
    ...

def negate_mcode_relation(code: mcode_t) -> mcode_t:
    ...

def negated_relation(op: ctype_t) -> ctype_t:
    r"""Negate a comparison operator. For example, cot_sge becomes cot_slt.
    
    """
    ...

def netnode_exist(_name: str) -> bool:
    r"""Does the netnode with the specified name exist?
    
    """
    ...

def new_block() -> Any:
    r"""Create a new block-statement.
    
    """
    ...

def new_til(name: str, desc: str) -> til_t:
    r"""Initialize a til.
    
    """
    ...

def next_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get next address in the program (i.e. next address which has flags). 
            
    :returns: BADADDR if no such address exist.
    """
    ...

def next_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get the first address of next contiguous chunk in the program. 
            
    :returns: BADADDR if next chunk doesn't exist.
    """
    ...

def next_head(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get start of next defined item. 
            
    :param ea: begin search at this address
    :param maxea: not included in the search range
    :returns: BADADDR if none exists.
    """
    ...

def next_idcv_attr(obj: idc_value_t, attr: str) -> str:
    ...

def next_inited(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Find the next initialized address.
    
    """
    ...

def next_named_type(ti: til_t, name: str, ntf_flags: int) -> str:
    r"""Enumerate types. 
            
    :param ti: type library. nullptr means the local type library for the current database.
    :param name: the current name. the name that follows this one will be returned.
    :param ntf_flags: combination of Flags for named types
    :returns: Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals.
    """
    ...

def next_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get address of next non-tail byte. 
            
    :returns: BADADDR if none exists.
    """
    ...

def next_that(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t, testf: testf_t) -> ida_idaapi.ea_t:
    r"""Find next address with a flag satisfying the function 'testf'. 
            
    :param ea: start searching at this address + 1
    :param maxea: not included in the search range.
    :param testf: test function to find next address
    :returns: the found address or BADADDR.
    """
    ...

def next_unknown(ea: ida_idaapi.ea_t, maxea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Similar to next_that(), but will find the next address that is unexplored.
    
    """
    ...

def next_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get next visible address. 
            
    :returns: BADADDR if none exists.
    """
    ...

def node2ea(ndx: nodeidx_t) -> ida_idaapi.ea_t:
    ...

def nomem(args: Any) -> None:
    ...

def notify_when(when: Any, callback: Any) -> Any:
    r"""
    Register a callback that will be called when an event happens.
    :param when: one of NW_XXXX constants
    :param callback: This callback prototype varies depending on the 'when' parameter:
                     The general callback format:
                         def notify_when_callback(nw_code)
                     In the case of NW_OPENIDB:
                         def notify_when_callback(nw_code, is_old_database)
    :returns: Boolean
    
    """
    ...

def num_flag() -> flags64_t:
    r"""Get number of default base (bin, oct, dec, hex) 
            
    """
    ...

def oct_flag() -> flags64_t:
    r"""Get number flag of the base, regardless of current processor - better to use num_flag()
    
    """
    ...

def off_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def op_adds_xrefs(F: flags64_t, n: int) -> bool:
    r"""Should processor module create xrefs from the operand?. Currently 'offset', 'structure offset', 'stack' and 'enum' operands create xrefs 
            
    """
    ...

def op_based_stroff(insn: insn_t, n: int, opval: adiff_t, base: ida_idaapi.ea_t) -> bool:
    r"""Set operand representation to be 'struct offset' if the operand likely points to a structure member. For example, let's there is a structure at 1000 1000 stru_1000 Elf32_Sym <...> the operand #8 will be represented as '#Elf32_Sym.st_size' after the call of 'op_based_stroff(..., 8, 0x1000)' By the way, after the call of 'op_plain_offset(..., 0x1000)' it will be represented as '#(stru_1000.st_size - 0x1000)' 
            
    :param insn: the instruction
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :param opval: operand value (usually op_t::value or op_t::addr)
    :param base: base reference
    :returns: success
    """
    ...

def op_bin(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to bin_flag()
    
    """
    ...

def op_chr(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to char_flag()
    
    """
    ...

def op_custfmt(ea: ida_idaapi.ea_t, n: int, fid: int) -> bool:
    r"""Set custom data format for operand (fid-custom data format id)
    
    """
    ...

def op_dec(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to dec_flag()
    
    """
    ...

def op_enum(ea: ida_idaapi.ea_t, n: int, id: tid_t, serial: uchar = 0) -> bool:
    r"""Set operand representation to be enum type If applied to unexplored bytes, converts them to 16/32bit word data 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :param id: id of enum
    :param serial: the serial number of the constant in the enumeration, usually 0. the serial numbers are used if the enumeration contains several constants with the same value
    :returns: success
    """
    ...

def op_flt(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to flt_flag()
    
    """
    ...

def op_hex(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to hex_flag()
    
    """
    ...

def op_num(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to num_flag()
    
    """
    ...

def op_oct(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""set op type to oct_flag()
    
    """
    ...

def op_offset(args: Any) -> bool:
    r"""See op_offset_ex()
    
    """
    ...

def op_offset_ex(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t) -> bool:
    r"""Convert operand to a reference. To delete an offset, use clr_op_type() function. 
            
    :param ea: linear address. if 'ea' has unexplored bytes, try to convert them to
    * no segment: fail
    * 16bit segment: to 16bit word data
    * 32bit segment: to dword
    :param n: operand number (may be ORed with OPND_OUTER)
    * 0: first
    * 1: second
    * ...
    * 7: eighth operand
    
    
    * OPND_MASK: all operands
    :param ri: reference information
    :returns: success
    """
    ...

def op_plain_offset(ea: ida_idaapi.ea_t, n: int, base: ida_idaapi.ea_t) -> bool:
    r"""Convert operand to a reference with the default reference type.
    
    """
    ...

def op_seg(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Set operand representation to be 'segment'. If applied to unexplored bytes, converts them to 16/32bit word data 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :returns: success
    """
    ...

def op_stkvar(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Set operand representation to be 'stack variable'. Should be applied to an instruction within a function. Should be applied after creating a stack var using insn_t::create_stkvar(). 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :returns: success
    """
    ...

def op_stroff(args: Any) -> bool:
    r"""Set operand representation to be 'struct offset'.
    
    This function has the following signatures:
    
        1. op_stroff(ins: ida_ua.insn_t, n: int, path: List[int], delta: int)
        2. op_stroff(ins: ida_ua.insn_t, n: int, path: ida_pro.tid_array, path_len: int, delta: int) (backward-compatibility only)
    
    Here is an example using this function:
    
        ins = ida_ua.insn_t()
        if ida_ua.decode_insn(ins, some_address):
            operand = 0
            path = [ida_typeinf.get_named_type_tid("my_stucture_t")] # a one-element path
            ida_bytes.op_stroff(ins, operand, path, 0)
    """
    ...

def op_t__from_ptrval__(ptrval: size_t) -> op_t:
    ...

def op_uses_x(op: ctype_t) -> bool:
    r"""Does operator use the 'x' field of cexpr_t?
    
    """
    ...

def op_uses_y(op: ctype_t) -> bool:
    r"""Does operator use the 'y' field of cexpr_t?
    
    """
    ...

def op_uses_z(op: ctype_t) -> bool:
    r"""Does operator use the 'z' field of cexpr_t?
    
    """
    ...

def open_bookmarks_window(w: TWidget) -> TWidget:
    r"""Open the bookmarks window (ui_open_builtin). 
            
    :param w: The widget for which the bookmarks will open. For example, this can be an IDAView, or Enums view, etc.
    :returns: pointer to resulting window
    """
    ...

def open_bpts_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the breakpoints window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_calls_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the function calls window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_disasm_window(window_title: str, ranges: rangevec_t = None) -> TWidget:
    r"""Open a disassembly view (ui_open_builtin). 
            
    :param window_title: title of view to open
    :param ranges: if != nullptr, then display a flow chart with the specified ranges
    :returns: pointer to resulting window
    """
    ...

def open_exports_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the exports window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_form(args: Any) -> Any:
    r"""Display a dockable modeless dialog box and return a handle to it. The modeless form can be closed in the following ways:
    * by pressing the small 'x' in the window title
    * by calling form_actions_t::close() from the form callback (form_actions_t)
    
    
    
    :param form: dialog box as a string. see ask_form()/open_form()
    :param flags: Widget open flags
    :returns: handle to the form or nullptr. the handle can be used with TWidget functions: close_widget()/activate_widget()/etc
    """
    ...

def open_frame_window(pfn: func_t, offset: int) -> TWidget:
    r"""Open the frame window for the given function (ui_open_builtin). 
            
    :param pfn: function to analyze
    :param offset: offset where the cursor is placed
    :returns: pointer to resulting window if 'pfn' is a valid function and the window was displayed, 
     nullptr otherwise
    """
    ...

def open_funcs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the 'Functions' window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_hexdump_window(window_title: str) -> TWidget:
    r"""Open a hexdump view (ui_open_builtin). 
            
    :param window_title: title of view to open
    :returns: pointer to resulting window
    """
    ...

def open_imports_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the exports window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_linput(file: str, remote: bool) -> linput_t:
    ...

def open_loctypes_window(ordinal: int, cursor: tif_cursor_t = None) -> TWidget:
    r"""Open the local types window (ui_open_builtin2). 
            
    :param ordinal: ordinal of type to select by default
    :param cursor: cursor to the type member
    :returns: pointer to resulting window
    """
    ...

def open_modules_window() -> TWidget:
    r"""Open the modules window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_names_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the names window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_navband_window(ea: ida_idaapi.ea_t, zoom: int) -> TWidget:
    r"""Open the navigation band window (ui_open_builtin). 
            
    :param ea: sets the address of the navband arrow
    :param zoom: sets the navband zoom level
    :returns: pointer to resulting window
    """
    ...

def open_notepad_window() -> TWidget:
    r"""Open the notepad window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_problems_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the problems window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_pseudocode(ea: ida_idaapi.ea_t, flags: int) -> vdui_t:
    r"""Open pseudocode window. The specified function is decompiled and the pseudocode window is opened. 
            
    :param ea: function to decompile
    :param flags: a combination of OPF_ flags
    :returns: false if failed
    """
    ...

def open_segments_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the segments window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_segregs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the segment registers window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def open_selectors_window() -> TWidget:
    r"""Open the selectors window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_signatures_window() -> TWidget:
    r"""Open the signatures window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_stack_window() -> TWidget:
    r"""Open the call stack window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_strings_window(args: Any) -> TWidget:
    r"""Open the 'Strings' window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :param selstart: only display strings that occur within this range
    :param selend: only display strings that occur within this range
    :returns: pointer to resulting window
    """
    ...

def open_threads_window() -> TWidget:
    r"""Open the threads window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_til_view_window(tif: tinfo_t, cursor: tif_cursor_t = None) -> TWidget:
    r"""Open the sub-til window (ui_open_builtin2). 
            
    :param tif: tif to open
    :param cursor: cursor to the type member
    :returns: pointer to resulting window
    """
    ...

def open_tils_window() -> TWidget:
    r"""Open the type libraries window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_trace_window() -> TWidget:
    r"""Open the tracing window (ui_open_builtin). 
            
    :returns: pointer to resulting window
    """
    ...

def open_url(url: str) -> None:
    r"""Open the given url (ui_open_url)
    
    """
    ...

def open_xrefs_window(ea: ida_idaapi.ea_t) -> TWidget:
    r"""Open the cross references window (ui_open_builtin). 
            
    :param ea: index of entry to select by default
    :returns: pointer to resulting window
    """
    ...

def optimize_argloc(vloc: argloc_t, size: int, gaps: rangeset_t) -> bool:
    r"""Verify and optimize scattered argloc into simple form. All new arglocs must be processed by this function. 
            
    :returns: true: success
    :returns: false: the input argloc was illegal
    """
    ...

def outctx_base_t__from_ptrval__(ptrval: size_t) -> outctx_base_t:
    ...

def outctx_t__from_ptrval__(ptrval: size_t) -> outctx_t:
    ...

def oword_flag() -> flags64_t:
    r"""Get a flags64_t representing a octaword.
    
    """
    ...

def pack_idcobj_to_bv(obj: idc_value_t, tif: tinfo_t, bytes: relobj_t, objoff: void, pio_flags: int = 0) -> error_t:
    r"""Write a typed idc object to the byte vector. Byte vector may be non-empty, this function will append data to it 
            
    """
    ...

def pack_idcobj_to_idb(obj: idc_value_t, tif: tinfo_t, ea: ida_idaapi.ea_t, pio_flags: int = 0) -> error_t:
    r"""Write a typed idc object to the database.
    
    """
    ...

def pack_object_to_bv(obj: Any, til: til_t, type: bytes, fields: bytes, base_ea: ida_idaapi.ea_t, pio_flags: int = 0) -> Any:
    r"""Packs a typed object to a string
    
    :param til: Type library. 'None' can be passed.
    :param type: type string
    :param fields: fields string (may be empty or None)
    :param base_ea: base ea used to relocate the pointers in the packed object
    :param pio_flags: flags used while unpacking
    :returns: tuple(1, packed_buf) on success, or tuple(0, err_code) on failure
    """
    ...

def pack_object_to_idb(obj: Any, til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0) -> Any:
    r"""Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    :param til: Type library. 'None' can be passed.
    :param type: type string
    :param fields: fields string (may be empty or None)
    :param ea: ea to be used while packing
    :param pio_flags: flags used while unpacking
    """
    ...

def packreal_flag() -> flags64_t:
    r"""Get a flags64_t representing a packed decimal real.
    
    """
    ...

def parse_binpat_str(out: compiled_binpat_vec_t, ea: ida_idaapi.ea_t, _in: str, radix: int, strlits_encoding: int = 0) -> bool:
    r"""Deprecated.
    
    Please use compiled_binpat_vec_t.from_pattern() instead.
    """
    ...

def parse_command_line3(cmdline: str) -> Any:
    ...

def parse_dbgopts(ido: instant_dbgopts_t, r_switch: str) -> bool:
    r"""Parse the -r command line switch (for instant debugging). r_switch points to the value of the -r switch. Example: win32@localhost+ 
            
    :returns: true-ok, false-parse error
    """
    ...

def parse_decl(out_tif: tinfo_t, til: til_t, decl: str, pt_flags: int) -> str:
    r"""Parse ONE declaration. If the input string contains more than one declaration, the first complete type declaration (PT_TYP) or the last variable declaration (PT_VAR) will be used. 
            
    :param out_tif: type info
    :param til: type library to use. may be nullptr
    :param decl: C declaration to parse
    :param pt_flags: combination of Type parsing flags bits
    :returns: true: ok
    :returns: false: declaration is bad, the error message is displayed if !PT_SIL
    """
    ...

def parse_decls(til: til_t, input: str, printer: printer_t, hti_flags: int) -> int:
    r"""Parse many declarations and store them in a til. If there are any errors, they will be printed using 'printer'. This function uses default include path and predefined macros from the database settings. It always uses the HTI_DCL bit. 
            
    :param til: type library to store the result
    :param input: input string or file name (see hti_flags)
    :param printer: function to output error messages (use msg or nullptr or your own callback)
    :param hti_flags: combination of Type formatting flags
    :returns: number of errors, 0 means ok.
    """
    ...

def parse_decls_for_srclang(lang: srclang_t, til: til_t, input: str, is_path: bool) -> int:
    r"""Parse type declarations in the specified language 
            
    :param lang: the source language(s) expected in the input
    :param til: type library to store the types
    :param input: input source. can be a file path or decl string
    :param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
    :returns: -1: no parser was found that supports the given source language(s)
    :returns: else: the number of errors encountered in the input source
    """
    ...

def parse_decls_with_parser(parser_name: str, til: til_t, input: str, is_path: bool) -> int:
    r"""Parse type declarations using the parser with the specified name 
            
    :param parser_name: name of the target parser
    :param til: type library to store the types
    :param input: input source. can be a file path or decl string
    :param is_path: true if input parameter is a path to a source file, false if the input is an in-memory source snippet
    :returns: -1: no parser was found with the given name
    :returns: else: the number of errors encountered in the input source
    """
    ...

def parse_decls_with_parser_ext(parser_name: str, til: til_t, input: str, hti_flags: int) -> int:
    r"""Parse type declarations using the parser with the specified name 
            
    :param parser_name: name of the target parser
    :param til: type library to store the types
    :param input: input source. can be a file path or decl string
    :param hti_flags: combination of Type formatting flags
    :returns: -1: no parser was found with the given name
    :returns: else: the number of errors encountered in the input source
    """
    ...

def parse_reg_name(ri: reg_info_t, regname: str) -> bool:
    r"""Get register info by name. 
            
    :param ri: result
    :param regname: name of register
    :returns: success
    """
    ...

def parse_tagged_line_sections(out: tagged_line_sections_t, line: str) -> bool:
    r"""Collect tagged sections in a color-tagged line (produced by `place_t::generate`)
    
    :param out: sections storage
    :param line: input line
    :returns: success
    """
    ...

def parse_user_call(udc: udcall_t, decl: str, silent: bool) -> bool:
    r"""Convert function type declaration into internal structure 
            
    :param udc: - pointer to output structure
    :param decl: - function type declaration
    :param silent: - if TRUE: do not show warning in case of incorrect type
    :returns: success
    """
    ...

def partial_type_num(type: tinfo_t) -> int:
    r"""Calculate number of partial subtypes. 
            
    :returns: number of partial subtypes. The bigger is this number, the uglier is the type.
    """
    ...

def patch_byte(ea: ida_idaapi.ea_t, x: uint64) -> bool:
    r"""Patch a byte of the program. The original value of the byte is saved and can be obtained by get_original_byte(). This function works for wide byte processors too. 
            
    :returns: true: the database has been modified,
    :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.
    """
    ...

def patch_bytes(ea: ida_idaapi.ea_t, buf: void) -> None:
    r"""Patch the specified number of bytes of the program. Original values of bytes are saved and are available with get_original...() functions. See also put_bytes(). 
            
    :param ea: linear address
    :param buf: buffer with new values of bytes
    """
    ...

def patch_dword(ea: ida_idaapi.ea_t, x: uint64) -> bool:
    r"""Patch a dword of the program. The original value of the dword is saved and can be obtained by get_original_dword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :returns: true: the database has been modified,
    :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.
    """
    ...

def patch_fixup_value(ea: ida_idaapi.ea_t, fd: fixup_data_t) -> bool:
    r"""Patch the fixup bytes. This function updates data or an instruction at `ea` to the fixup bytes. For example, FIXUP_HI8 updates a byte at `ea` to the high byte of `fd->off`, or AArch64's custom fixup BRANCH26 updates low 26 bits of the insn at `ea` to the value of `fd->off` shifted right by 2. 
            
    :param ea: address where data are changed, the size of the changed data depends on the fixup type.
    :param fd: fixup data
    :returns: false: the fixup bytes do not fit (e.g. `fd->off` is greater than 0xFFFFFFC for BRANCH26). The database is changed even in this case.
    """
    ...

def patch_qword(ea: ida_idaapi.ea_t, x: uint64) -> bool:
    r"""Patch a qword of the program. The original value of the qword is saved and can be obtained by get_original_qword(). This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :returns: true: the database has been modified,
    :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.
    """
    ...

def patch_word(ea: ida_idaapi.ea_t, x: uint64) -> bool:
    r"""Patch a word of the program. The original value of the word is saved and can be obtained by get_original_word(). This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() 
            
    :returns: true: the database has been modified,
    :returns: false: the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already.
    """
    ...

def peek_auto_queue(low_ea: ida_idaapi.ea_t, type: atype_t) -> ida_idaapi.ea_t:
    r"""Peek into a queue 'type' for an address not lower than 'low_ea'. Do not remove address from the queue. 
            
    :returns: the address or BADADDR
    """
    ...

def perform_redo() -> bool:
    r"""Perform redo. 
            
    :returns: success
    """
    ...

def perform_undo() -> bool:
    r"""Perform undo. 
            
    :returns: success
    """
    ...

def ph_calcrel(ea: ida_idaapi.ea_t) -> Any:
    ...

def ph_find_op_value(insn: insn_t, op: int) -> uint64:
    ...

def ph_find_reg_value(insn: insn_t, reg: int) -> uint64:
    ...

def ph_get_abi_info(comp: comp_t) -> Any:
    ...

def ph_get_cnbits() -> Any:
    r"""Returns the 'ph.cnbits'"""
    ...

def ph_get_dnbits() -> Any:
    r"""Returns the 'ph.dnbits'"""
    ...

def ph_get_flag() -> Any:
    r"""Returns the 'ph.flag'"""
    ...

def ph_get_icode_return() -> Any:
    r"""Returns the 'ph.icode_return'"""
    ...

def ph_get_id() -> Any:
    r"""Returns the 'ph.id' field"""
    ...

def ph_get_instruc() -> Any:
    r"""Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module
    """
    ...

def ph_get_instruc_end() -> Any:
    r"""Returns the 'ph.instruc_end'"""
    ...

def ph_get_instruc_start() -> Any:
    r"""Returns the 'ph.instruc_start'"""
    ...

def ph_get_operand_info(ea: ida_idaapi.ea_t, n: int) -> Any:
    r"""Returns the operand information given an ea and operand number.
    
    :param ea: address
    :param n: operand number
    
    :returns: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
              Please refer to idd_opinfo_t structure in the SDK.
    """
    ...

def ph_get_reg_accesses(accvec: reg_accesses_t, insn: insn_t, flags: int) -> ssize_t:
    ...

def ph_get_reg_code_sreg() -> Any:
    r"""Returns the 'ph.reg_code_sreg'"""
    ...

def ph_get_reg_data_sreg() -> Any:
    r"""Returns the 'ph.reg_data_sreg'"""
    ...

def ph_get_reg_first_sreg() -> Any:
    r"""Returns the 'ph.reg_first_sreg'"""
    ...

def ph_get_reg_last_sreg() -> Any:
    r"""Returns the 'ph.reg_last_sreg'"""
    ...

def ph_get_regnames() -> Any:
    r"""Returns the list of register names as defined in the processor module"""
    ...

def ph_get_segreg_size() -> Any:
    r"""Returns the 'ph.segreg_size'"""
    ...

def ph_get_tbyte_size() -> Any:
    r"""Returns the 'ph.tbyte_size' field as defined in he processor module"""
    ...

def ph_get_version() -> Any:
    r"""Returns the 'ph.version'"""
    ...

def place_t_as_idaplace_t(p: place_t) -> idaplace_t:
    ...

def place_t_as_simpleline_place_t(p: place_t) -> simpleline_place_t:
    ...

def place_t_as_tiplace_t(p: place_t) -> tiplace_t:
    ...

def plan_and_wait(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, final_pass: bool = True) -> int:
    r"""Analyze the specified range. Try to create instructions where possible. Make the final pass over the specified range if specified. This function doesn't return until the range is analyzed. 
            
    :returns: 1: ok
    :returns: 0: Ctrl-Break was pressed
    """
    ...

def plan_ea(ea: ida_idaapi.ea_t) -> None:
    r"""Plan to perform reanalysis.
    
    """
    ...

def plan_range(sEA: ida_idaapi.ea_t, eEA: ida_idaapi.ea_t) -> None:
    r"""Plan to perform reanalysis.
    
    """
    ...

def plan_to_apply_idasgn(fname: str) -> int:
    r"""Add a signature file to the list of planned signature files. 
            
    :param fname: file name. should not contain directory part.
    :returns: 0 if failed, otherwise number of planned (and applied) signatures
    """
    ...

def plgform_close(py_link: Any, options: int) -> None:
    ...

def plgform_get_widget(py_link: Any) -> TWidget:
    ...

def plgform_new() -> Any:
    ...

def plgform_show(args: Any) -> bool:
    ...

def prev_addr(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get previous address in the program. 
            
    :returns: BADADDR if no such address exist.
    """
    ...

def prev_chunk(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get the last address of previous contiguous chunk in the program. 
            
    :returns: BADADDR if previous chunk doesn't exist.
    """
    ...

def prev_head(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get start of previous defined item. 
            
    :param ea: begin search at this address
    :param minea: included in the search range
    :returns: BADADDR if none exists.
    """
    ...

def prev_idcv_attr(obj: idc_value_t, attr: str) -> str:
    ...

def prev_inited(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Find the previous initialized address.
    
    """
    ...

def prev_not_tail(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get address of previous non-tail byte. 
            
    :returns: BADADDR if none exists.
    """
    ...

def prev_that(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t, testf: testf_t) -> ida_idaapi.ea_t:
    r"""Find previous address with a flag satisfying the function 'testf'. 
            
    :param ea: start searching from this address - 1.
    :param minea: included in the search range.
    :param testf: test function to find previous address
    :returns: the found address or BADADDR.
    """
    ...

def prev_unknown(ea: ida_idaapi.ea_t, minea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Similar to prev_that(), but will find the previous address that is unexplored.
    
    """
    ...

def prev_visea(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Get previous visible address. 
            
    :returns: BADADDR if none exists.
    """
    ...

def print_argloc(vloc: argloc_t, size: int = 0, vflags: int = 0) -> int:
    r"""Convert an argloc to human readable form.
    
    """
    ...

def print_decls(printer: text_sink_t, til: til_t, ordinals: List[int], flags: int) -> int:
    r"""Print types (and possibly their dependencies) in a format suitable for using in
    a header file. This is the reverse parse_decls().
    
    :param printer: a handler for printing text
    :param til: the type library holding the ordinals
    :param ordinals: a list of ordinals corresponding to the types to print
    :param flags: a combination of PDF_ constants
    :returns:  >0: the number of types exported
    :returns:   0: an error occurred
    :returns:  <0: the negated number of types exported. There were minor errors and
                   the resulting output might not be compilable.
    """
    ...

def print_idcv(v: idc_value_t, name: str = None, indent: int = 0) -> str:
    r"""Get text representation of idc_value_t.
    
    """
    ...

def print_insn_mnem(ea: ida_idaapi.ea_t) -> str:
    r"""Print instruction mnemonics. 
            
    :param ea: linear address of the instruction
    :returns: success
    """
    ...

def print_operand(ea: ida_idaapi.ea_t, n: int, getn_flags: int = 0, newtype: printop_t = None) -> str:
    r"""Generate text representation for operand #n. This function will generate the text representation of the specified operand (includes color codes.) 
            
    :param ea: the item address (instruction or data)
    :param n: 0..UA_MAXOP-1 operand number, meaningful only for instructions
    :param getn_flags: Name expression flags Currently only GETN_NODUMMY is accepted.
    :param newtype: if specified, print the operand using the specified type
    :returns: success
    """
    ...

def print_strlit_type(strtype: int, flags: int = 0) -> Any:
    r"""Get string type information: the string type name (possibly decorated with hotkey markers), and the tooltip.
    
    :param strtype: the string type
    :param flags: or'ed PSTF_* constants
    :returns: length of generated text
    """
    ...

def print_tinfo(prefix: str, indent: int, cmtindent: int, flags: int, tif: tinfo_t, name: str, cmt: str) -> str:
    ...

def print_type(ea: ida_idaapi.ea_t, prtype_flags: int) -> str:
    r"""Get type declaration for the specified address. 
            
    :param ea: address
    :param prtype_flags: combination of Type printing flags
    :returns: success
    """
    ...

def print_vdloc(loc: vdloc_t, nbytes: int) -> str:
    r"""Print vdloc. Since vdloc does not always carry the size info, we pass it as NBYTES.. 
            
    """
    ...

def process_archive(temp_file: str, li: linput_t, module_name: str, neflags: ushort, defmember: str, loader: load_info_t) -> str:
    r"""Calls loader_t::process_archive() For parameters and return value description look at loader_t::process_archive(). Additional parameter 'loader' is a pointer to load_info_t structure. 
            
    """
    ...

def process_config_directive(directive: str, priority: int = 2) -> None:
    ...

def process_ui_action(name: str, flags: int = 0) -> Any:
    r"""Invokes an IDA UI action by name
    
    :param name:  action name
    :param flags: reserved
    :returns: Boolean
    """
    ...

def prompt_function_prototype(out_tif: tinfo_t, pfn: func_t, tif: tinfo_t, name: str) -> str:
    r"""Open function prototype editor to edit function type and create new type. Allows to change the function prototype either in the "old" one-liner mode or in the new multi-line editor, which supports shortcuts, etc. Note: changes will not apply! It is the caller's job to apply the resulting out_tif. Parameters: 
            
    :param out_tif: - (tinfo_t *) tif for created type
    :param pfn: - (func_t *) editing function
    :param tif: - (tinfo_t *) current function type
    :param name: - (const char *) function name
    :returns: true if new type created successfully
    """
    ...

def property_op_to_typename(self: Any) -> Any:
    ...

def put_byte(ea: ida_idaapi.ea_t, x: uint64) -> bool:
    r"""Set value of one byte of the program. This function modifies the database. If the debugger is active then the debugged process memory is patched too. 
            
    :param ea: linear address
    :param x: byte value
    :returns: true if the database has been modified
    """
    ...

def put_bytes(ea: ida_idaapi.ea_t, buf: void) -> None:
    r"""Modify the specified number of bytes of the program. This function does not save the original values of bytes. See also patch_bytes(). 
            
    :param ea: linear address
    :param buf: buffer with new values of bytes
    """
    ...

def put_dbg_byte(ea: ida_idaapi.ea_t, x: int) -> bool:
    r"""Change one byte of the debugged process memory. 
            
    :param ea: linear address
    :param x: byte value
    :returns: true if the process memory has been modified
    """
    ...

def put_dword(ea: ida_idaapi.ea_t, x: uint64) -> None:
    r"""Set value of one dword of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
            
    :param ea: linear address
    :param x: dword value
    """
    ...

def put_qword(ea: ida_idaapi.ea_t, x: uint64) -> None:
    r"""Set value of one qword (8 bytes) of the program. This function takes into account order of bytes specified in idainfo::is_be() This function DOESN'T works for wide byte processors. 
            
    :param ea: linear address
    :param x: qword value
    """
    ...

def put_word(ea: ida_idaapi.ea_t, x: uint64) -> None:
    r"""Set value of one word of the program. This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. 
            
    """
    ...

def py_add_idc_func(name: str, fp_ptr: size_t, args: str, defvals: idc_values_t, flags: int) -> bool:
    ...

def py_chooser_base_t_get_row(chobj: chooser_base_t, n: size_t) -> Any:
    ...

def py_get_ask_form() -> int:
    ...

def py_get_call_idc_func() -> int:
    ...

def py_get_open_form() -> int:
    ...

def py_load_custom_icon_data(data: Any, format: str) -> int:
    ...

def py_load_custom_icon_fn(filename: str) -> int:
    ...

def py_register_compiled_form(py_form: Any) -> None:
    ...

def py_unregister_compiled_form(py_form: Any) -> None:
    ...

def pycim_get_widget(_self: Any) -> TWidget:
    ...

def pycim_view_close(_self: Any) -> None:
    ...

def pyg_close(_self: Any) -> None:
    ...

def pyg_select_node(_self: Any, nid: int) -> None:
    ...

def pyg_show(_self: Any) -> bool:
    ...

def pygc_create_groups(_self: Any, groups_infos: Any) -> Any:
    ...

def pygc_delete_groups(_self: Any, groups: Any, new_current: Any) -> Any:
    ...

def pygc_refresh(_self: Any) -> None:
    ...

def pygc_set_groups_visibility(_self: Any, groups: Any, expand: Any, new_current: Any) -> Any:
    ...

def pyidag_bind(_self: Any) -> bool:
    ...

def pyidag_unbind(_self: Any) -> bool:
    ...

def pyscv_add_line(py_this: Any, py_sl: Any) -> bool:
    ...

def pyscv_clear_lines(py_this: Any) -> Any:
    ...

def pyscv_close(py_this: Any) -> None:
    ...

def pyscv_count(py_this: Any) -> int:
    ...

def pyscv_del_line(py_this: Any, nline: size_t) -> bool:
    ...

def pyscv_edit_line(py_this: Any, nline: size_t, py_sl: Any) -> bool:
    ...

def pyscv_get_current_line(py_this: Any, mouse: bool, notags: bool) -> Any:
    ...

def pyscv_get_current_word(py_this: Any, mouse: bool) -> Any:
    ...

def pyscv_get_line(py_this: Any, nline: size_t) -> Any:
    ...

def pyscv_get_pos(py_this: Any, mouse: bool) -> Any:
    ...

def pyscv_get_selection(py_this: Any) -> Any:
    ...

def pyscv_get_widget(py_this: Any) -> TWidget:
    ...

def pyscv_init(py_link: Any, title: str) -> Any:
    ...

def pyscv_insert_line(py_this: Any, nline: size_t, py_sl: Any) -> bool:
    ...

def pyscv_is_focused(py_this: Any) -> bool:
    ...

def pyscv_jumpto(py_this: Any, ln: size_t, x: int, y: int) -> bool:
    ...

def pyscv_patch_line(py_this: Any, nline: size_t, offs: size_t, value: int) -> bool:
    ...

def pyscv_refresh(py_this: Any) -> bool:
    ...

def pyscv_show(py_this: Any) -> bool:
    ...

def pyw_convert_defvals(out: idc_values_t, py_seq: Any) -> bool:
    ...

def pyw_register_idc_func(name: str, args: str, py_fp: Any) -> int:
    ...

def pyw_unregister_idc_func(ctxptr: size_t) -> bool:
    ...

def qatoll(nptr: str) -> int64:
    ...

def qcleanline(args: Any) -> str:
    r"""Performs some cleanup operations to a line. 
            
    :param buf: string to modify
    :param cmt_char: character that denotes the start of a comment:
    * the entire text is removed if the line begins with this character (ignoring leading spaces)
    * all text after (and including) this character is removed if flag CLNL_FINDCMT is set
    :param flags: a combination of line cleanup flags. defaults to CLNL_TRIM
    :returns: length of line
    """
    ...

def qcontrol_tty() -> None:
    r"""Make the current terminal the controlling terminal of the calling process. 
            
    """
    ...

def qdetach_tty() -> None:
    r"""If the current terminal is the controlling terminal of the calling process, give up this controlling terminal. 
            
    """
    ...

def qexit(code: int) -> None:
    r"""Call qatexit functions, shut down UI and kernel, and exit. 
            
    :param code: exit code
    """
    ...

def qfclose(fp: FILE) -> int:
    ...

def qfile_t_from_capsule(pycapsule: Any) -> qfile_t:
    ...

def qfile_t_from_fp(fp: FILE) -> qfile_t:
    ...

def qfile_t_tmpfile() -> Any:
    r"""A static method to construct an instance using a temporary file"""
    ...

def qlgetz(li: linput_t, fpos: int64) -> str:
    ...

def qstrvec_t_add(_self: Any, s: str) -> bool:
    ...

def qstrvec_t_addressof(_self: Any, idx: size_t) -> Any:
    ...

def qstrvec_t_assign(_self: Any, other: Any) -> bool:
    ...

def qstrvec_t_clear(_self: Any, qclear: bool) -> bool:
    ...

def qstrvec_t_create() -> Any:
    ...

def qstrvec_t_destroy(py_obj: Any) -> bool:
    ...

def qstrvec_t_from_list(_self: Any, py_list: Any) -> bool:
    ...

def qstrvec_t_get(_self: Any, idx: size_t) -> Any:
    ...

def qstrvec_t_get_clink(_self: Any) -> qstrvec_t:
    ...

def qstrvec_t_get_clink_ptr(_self: Any) -> Any:
    ...

def qstrvec_t_insert(_self: Any, idx: size_t, s: str) -> bool:
    ...

def qstrvec_t_remove(_self: Any, idx: size_t) -> bool:
    ...

def qstrvec_t_set(_self: Any, idx: size_t, s: str) -> bool:
    ...

def qstrvec_t_size(_self: Any) -> int:
    ...

def qswap(a: cinsn_t, b: cinsn_t) -> None:
    ...

def qthread_equal(q1: __qthread_t, q2: __qthread_t) -> bool:
    r"""Are two threads equal?
    
    """
    ...

def quote_cmdline_arg(arg: str) -> bool:
    r"""Quote a command line argument if it contains escape characters. For example, *.c will be converted into "*.c" because * may be inadvertently expanded by the shell 
            
    :returns: true: modified 'arg'
    """
    ...

def qvector_reserve(vec: void, old: void, cnt: size_t, elsize: size_t) -> None:
    r"""Change capacity of given qvector. 
            
    :param vec: a pointer to a qvector
    :param old: a pointer to the qvector's array
    :param cnt: number of elements to reserve
    :param elsize: size of each element
    :returns: a pointer to the newly allocated array
    """
    ...

def qword_flag() -> flags64_t:
    r"""Get a flags64_t representing a quad word.
    
    """
    ...

def range_t_print(cb: range_t) -> str:
    r"""Helper function. Should not be called directly!
    
    """
    ...

def read_dbg_memory(ea: ida_idaapi.ea_t, buffer: void, size: size_t) -> ssize_t:
    ...

def read_ioports(ports: ioports_t, device: str, file: str, callback: ioports_fallback_t = None) -> ssize_t:
    ...

def read_range_selection(v: TWidget) -> Any:
    r"""Get the address range for the selected range boundaries, this is the convenient function for read_selection() 
            
    :param v: view, nullptr means the last active window containing addresses
    :returns: 0: no range is selected
    :returns: 1: ok, start ea and end ea are filled
    """
    ...

def read_regargs(pfn: func_t) -> None:
    ...

def read_selection(v: Any, p1: Any, p2: Any) -> Any:
    r"""Read the user selection, and store its information in p1 (from) and p2 (to).
    
    This can be used as follows:
    
    
    >>> p1 = ida_kernwin.twinpos_t()
    p2 = ida_kernwin.twinpos_t()
    view = ida_kernwin.get_current_viewer()
    ida_kernwin.read_selection(view, p1, p2)
    
    
    At that point, p1 and p2 hold information for the selection.
    But, the 'at' property of p1 and p2 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p1.place(view)
    place1 = p2.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    :param v: The view to retrieve the selection for.
    :param p1: Storage for the "from" part of the selection.
    :param p2: Storage for the "to" part of the selection.
    :returns: a bool value indicating success.
    """
    ...

def read_tinfo_bitfield_value(typid: typid_t, v: uint64, bitoff: int) -> uint64:
    ...

def readbytes(h: int, res: uint32, size: int, mf: bool) -> int:
    r"""Read at most 4 bytes from file. 
            
    :param h: file handle
    :param res: value read from file
    :param size: size of value in bytes (1,2,4)
    :param mf: is MSB first?
    :returns: 0 on success, nonzero otherwise
    """
    ...

def reanalyze_callers(ea: ida_idaapi.ea_t, noret: bool) -> None:
    r"""Plan to reanalyze callers of the specified address. This function will add to AU_USED queue all instructions that call (not jump to) the specified address. 
            
    :param ea: linear address of callee
    :param noret: !=0: the callee doesn't return, mark to undefine subsequent instructions in the caller. 0: do nothing.
    """
    ...

def reanalyze_function(args: Any) -> None:
    r"""Reanalyze a function. This function plans to analyzes all chunks of the given function. Optional parameters (ea1, ea2) may be used to narrow the analyzed range. 
            
    :param pfn: pointer to a function
    :param ea1: start of the range to analyze
    :param ea2: end of range to analyze
    :param analyze_parents: meaningful only if pfn points to a function tail. if true, all tail parents will be reanalyzed. if false, only the given tail will be reanalyzed.
    """
    ...

def reanalyze_noret_flag(ea: ida_idaapi.ea_t) -> bool:
    r"""Plan to reanalyze noret flag. This function does not remove FUNC_NORET if it is already present. It just plans to reanalysis. 
            
    """
    ...

def rebase_program(delta: Any, flags: int) -> int:
    r"""Rebase the whole program by 'delta' bytes. 
            
    :param delta: number of bytes to move the program
    :param flags: Move segment flags it is recommended to use MSF_FIXONCE so that the loader takes care of global variables it stored in the database
    :returns: Move segment result codes
    """
    ...

def rebuild_nlist() -> None:
    ...

def recalc_spd(cur_ea: ida_idaapi.ea_t) -> bool:
    r"""Recalculate SP delta for an instruction that stops execution. The next instruction is not reached from the current instruction. We need to recalculate SP for the next instruction.
    This function will create a new automatic SP register change point if necessary. It should be called from the emulator (emu.cpp) when auto_state == AU_USED if the current instruction doesn't pass the execution flow to the next instruction. 
            
    :param cur_ea: linear address of the current instruction
    :returns: 1: new stkpnt is added
    :returns: 0: nothing is changed
    """
    ...

def recalc_spd_for_basic_block(pfn: func_t, cur_ea: ida_idaapi.ea_t) -> bool:
    r"""Recalculate SP delta for the current instruction. The typical code snippet to calculate SP delta in a proc module is:
    
    if ( may_trace_sp() && pfn != nullptr )
      if ( !recalc_spd_for_basic_block(pfn, insn.ea) )
        trace_sp(pfn, insn);
    
    where trace_sp() is a typical name for a function that emulates the SP change of an instruction.
    
    :param pfn: pointer to the function
    :param cur_ea: linear address of the current instruction
    :returns: true: the cumulative SP delta is set
    :returns: false: the instruction at CUR_EA passes flow to the next instruction. SP delta must be set as a result of emulating the current instruction.
    """
    ...

def refresh_chooser(title: str) -> bool:
    r"""Mark a non-modal custom chooser for a refresh (ui_refresh_chooser). 
            
    :param title: title of chooser
    :returns: success
    """
    ...

def refresh_choosers() -> None:
    ...

def refresh_custom_viewer(custom_viewer: TWidget) -> None:
    r"""Refresh custom ida viewer (ui_refresh_custom_viewer)
    
    """
    ...

def refresh_debugger_memory() -> Any:
    r"""Refreshes the debugger memory
    
    :returns: Nothing
    """
    ...

def refresh_idaview() -> None:
    r"""Refresh marked windows (ui_refreshmarked)
    
    """
    ...

def refresh_idaview_anyway() -> None:
    r"""Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please consider request_refresh() instead 
            
    """
    ...

def refresh_navband(force: bool) -> None:
    r"""Refresh navigation band if changed (ui_refresh_navband). 
            
    :param force: refresh regardless
    """
    ...

def refresh_viewer(gv: graph_viewer_t) -> None:
    r"""Redraw the graph in the given view.
    
    """
    ...

def reg2mreg(reg: int) -> mreg_t:
    r"""Map a processor register to a microregister. 
            
    :param reg: processor register number
    :returns: microregister register id or mr_none
    """
    ...

def reg_data_type(name: str, subkey: str = None) -> regval_type_t:
    r"""Get data type of a given value. 
            
    :param name: value name
    :param subkey: key name
    :returns: false if the [key+]value doesn't exist
    """
    ...

def reg_delete(name: str, subkey: str = None) -> bool:
    r"""Delete a value from the registry. 
            
    :param name: value name
    :param subkey: parent key
    :returns: success
    """
    ...

def reg_delete_subkey(name: str) -> bool:
    r"""Delete a key from the registry.
    
    """
    ...

def reg_delete_tree(name: str) -> bool:
    r"""Delete a subtree from the registry.
    
    """
    ...

def reg_exists(name: str, subkey: str = None) -> bool:
    r"""Is there already a value with the given name? 
            
    :param name: value name
    :param subkey: parent key
    """
    ...

def reg_read_binary(name: str, subkey: str = None) -> Any:
    r"""Read binary data from the registry. 
            
    :param name: value name
    :param subkey: key name
    :returns: false if 'data' is not large enough to hold all data present. in this case 'data' is left untouched.
    """
    ...

def reg_read_bool(name: str, defval: bool, subkey: str = None) -> bool:
    r"""Read boolean value from the registry. 
            
    :param name: value name
    :param defval: default value
    :param subkey: key name
    :returns: boolean read from registry, or 'defval' if the read failed
    """
    ...

def reg_read_int(name: str, defval: int, subkey: str = None) -> int:
    r"""Read integer value from the registry. 
            
    :param name: value name
    :param defval: default value
    :param subkey: key name
    :returns: the value read from the registry, or 'defval' if the read failed
    """
    ...

def reg_read_string(name: str, subkey: str = None, _def: str = None) -> Any:
    r"""Read a string from the registry. 
            
    :param name: value name
    :param subkey: key name
    :returns: success
    """
    ...

def reg_read_strlist(subkey: str) -> List[str]:
    r"""Retrieve all string values associated with the given key.
    
    :param subkey: a key from which to read the list of items
    :returns: the list of items
    """
    ...

def reg_subkey_exists(name: str) -> bool:
    r"""Is there already a key with the given name?
    
    """
    ...

def reg_subkey_subkeys(name: str) -> Any:
    r"""Get all subkey names of given key.
    
    """
    ...

def reg_subkey_values(name: str) -> Any:
    r"""Get all value names under given key.
    
    """
    ...

def reg_update_filestrlist(subkey: str, add: str, maxrecs: size_t, rem: str = None) -> None:
    r"""Update registry with a file list. Case sensitivity will vary depending on the target OS. 
            
    """
    ...

def reg_update_strlist(subkey: str, add: Any, maxrecs: int, rem: Any = None, ignorecase: bool = False) -> Any:
    r"""Add and/or remove items from the list, and possibly trim that list.
    
    :param subkey: the key under which the list is located
    :param add: an item to add to the list, or None
    :param maxrecs: the maximum number of items the list should hold
    :param rem: an item to remove from the list, or None
    :param ignorecase: ignore case for 'add' and 'rem'
    """
    ...

def reg_write_binary(name: str, py_bytes: Any, subkey: str = None) -> Any:
    r"""Write binary data to the registry. 
            
    :param name: value name
    :param subkey: key name
    """
    ...

def reg_write_bool(name: str, value: int, subkey: str = None) -> None:
    r"""Write boolean value to the registry. 
            
    :param name: value name
    :param value: boolean to write (nonzero = true)
    :param subkey: key name
    """
    ...

def reg_write_int(name: str, value: int, subkey: str = None) -> None:
    r"""Write integer value to the registry. 
            
    :param name: value name
    :param value: value to write
    :param subkey: key name
    """
    ...

def reg_write_string(name: str, utf8: str, subkey: str = None) -> None:
    r"""Write a string to the registry. 
            
    :param name: value name
    :param utf8: utf8-encoded string
    :param subkey: key name
    """
    ...

def reg_write_strlist(items: List[str], subkey: str) -> Any:
    r"""Write string values associated with the given key.
    
    :param items: the list of items to write
    :param subkey: a key under which to write the list of items
    """
    ...

def register_action(desc: action_desc_t) -> bool:
    r"""Create a new action (ui_register_action). After an action has been created, it is possible to attach it to menu items (attach_action_to_menu()), or to popup menus (attach_action_to_popup()).
    Because the actions will need to call the handler's activate() and update() methods at any time, you shouldn't build your action handler on the stack.
    Please see the SDK's "ht_view" plugin for an example how to register actions. 
            
    :param desc: action to register
    :returns: success
    """
    ...

def register_addon(info: addon_info_t) -> int:
    r"""Register an add-on. Show its info in the About box. For plugins, should be called from init() function (repeated calls with the same product code overwrite previous entries) returns: index of the add-on in the list, or -1 on error 
            
    """
    ...

def register_and_attach_to_menu(menupath: str, name: str, label: str, shortcut: str, flags: int, handler: action_handler_t, owner: void, action_desc_t_flags: int) -> bool:
    r"""Helper.
    You are not encouraged to use this, as it mixes flags for both register_action(), and attach_action_to_menu().
    The only reason for its existence is to make it simpler to port existing plugins to the new actions API. 
            
    """
    ...

def register_cfgopts(opts: Any, nopts: size_t, cb: config_changed_cb_t = None, obj: void = None) -> bool:
    ...

def register_custom_callcnv(cnv_incref: custom_callcnv_t) -> custom_callcnv_t:
    r"""Register a calling convention 
            
    :returns: CM_CC_INVALID means failure:
    * bad ccinf.name
    * ccinf.name already exists
    * the calling convention is special (usercall, purging, vararg) and there are too many of them already
    """
    ...

def register_custom_data_format(df: Any) -> Any:
    r"""Registers a custom data format with a given data type.
    
    :param df: an instance of data_format_t
    :returns: < 0 if failed to register
    :returns: > 0 data format id
    """
    ...

def register_custom_data_type(dt: Any) -> Any:
    r"""Registers a custom data type.
    
    :param dt: an instance of the data_type_t class
    :returns: < 0 if failed to register
    :returns: > 0 data type id
    """
    ...

def register_data_types_and_formats(formats: Any) -> Any:
    r"""
    Registers multiple data types and formats at once.
    To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
    It employs a special table of types and formats described below:
    
    The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
    If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
    many_formats = [
      (pascal_data_type(), pascal_data_format()),
      (simplevm_data_type(), simplevm_data_format()),
      (makedword_data_format(),),
      (simplevm_data_format(),)
    ]
    The first two tuples describe data types and their associated formats.
    The last two tuples describe two data formats to be used with built-in data types.
    The data format may be attached to several data types. The id of the
    data format is stored in the first data_format_t object. For example:
    assert many_formats[1][1] != -1
    assert many_formats[2][0] != -1
    assert many_formats[3][0] == -1
    
    """
    ...

def register_timer(interval: Any, callback: Any) -> Any:
    r"""Register a timer
    
    :param interval: Interval in milliseconds
    :param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    :returns: None or a timer object
    """
    ...

def reload_file(file: str, is_remote: bool) -> bool:
    r"""Reload the input file. This function reloads the byte values from the input file. It doesn't modify the segmentation, names, comments, etc. 
            
    :param file: name of the input file. if file == nullptr then returns:
    * 1: can reload the input file
    * 0: can't reload the input file
    :param is_remote: is the file located on a remote computer with the debugger server?
    :returns: success
    """
    ...

def reloc_value(value: void, size: int, delta: adiff_t, mf: bool) -> None:
    ...

def relocate_relobj(_relobj: relobj_t, ea: ida_idaapi.ea_t, mf: bool) -> bool:
    ...

def remember_problem(type: problist_id_t, ea: ida_idaapi.ea_t, msg: str = None) -> None:
    r"""Insert an address to a list of problems. Display a message saying about the problem (except of PR_ATTN,PR_FINAL) PR_JUMP is temporarily ignored. 
            
    :param type: problem list type
    :param ea: linear address
    :param msg: a user-friendly message to be displayed instead of the default more generic one associated with the type of problem. Defaults to nullptr.
    """
    ...

def remitem(e: citem_t) -> None:
    ...

def remove_abi_opts(abi_opts: str, user_level: bool = False) -> bool:
    ...

def remove_command_interpreter(cli_idx: int) -> None:
    r"""Remove command line interpreter (ui_install_cli)
    
    """
    ...

def remove_func_tail(pfn: func_t, tail_ea: ida_idaapi.ea_t) -> bool:
    r"""Remove a function tail. If the tail belongs only to one function, it will be completely removed. Otherwise if the function was the tail owner, the first function using this tail becomes the owner of the tail. 
            
    :param pfn: pointer to the function
    :param tail_ea: any address inside the tail to remove
    """
    ...

def remove_hexrays_callback(callback: Any) -> Any:
    r"""Uninstall handler for decompiler events. 
            
    :param callback: handler to uninstall
    :returns: number of uninstalled handlers.
    """
    ...

def remove_pointer(tif: tinfo_t) -> tinfo_t:
    r"""BT_PTR: If the current type is a pointer, return the pointed object. If the current type is not a pointer, return the current type. See also get_ptrarr_object() and get_pointed_object() 
            
    """
    ...

def remove_tinfo_pointer(tif: tinfo_t, name: str, til: til_t) -> Any:
    r"""Remove pointer of a type. (i.e. convert "char *" into "char"). Optionally remove
    the "lp" (or similar) prefix of the input name. If the input type is not a
    pointer, then fail.
    
    :param tif: the type info
    :param name: the name of the type to "unpointerify"
    :param til: the type library
    :returns: a tuple (success, new-name)
    """
    ...

def rename_bptgrp(old_name: str, new_name: str) -> bool:
    r"""Rename a folder of bpt dirtree \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param old_name: absolute path to the folder to be renamed
    :param new_name: absolute path of the new folder name
    :returns: success
    """
    ...

def rename_encoding(idx: int, encname: str) -> bool:
    ...

def rename_entry(ord: int, name: str, flags: int = 0) -> bool:
    r"""Rename entry point. 
            
    :param ord: ordinal number of the entry point
    :param name: name of entry point. If the specified location already has a name, the old name will be appended to a repeatable comment.
    :param flags: See AEF_*
    :returns: success
    """
    ...

def rename_lvar(func_ea: ida_idaapi.ea_t, oldname: str, newname: str) -> bool:
    r"""Rename a local variable. 
            
    :param func_ea: function start address
    :param oldname: old name of the variable
    :param newname: new name of the variable
    :returns: success This is a convenience function. For bulk renaming consider using modify_user_lvars.
    """
    ...

def rename_regvar(pfn: func_t, v: regvar_t, user: str) -> int:
    r"""Rename a register variable. 
            
    :param pfn: function in question
    :param v: variable to rename
    :param user: new user-defined name for the register
    :returns: Register variable error codes
    """
    ...

def reorder_dummy_names() -> None:
    r"""Renumber dummy names.
    
    """
    ...

def repaint_custom_viewer(custom_viewer: TWidget) -> None:
    r"""Repaint the given widget immediately (ui_repaint_qwidget)
    
    """
    ...

def replace_ordinal_typerefs(til: til_t, tif: tinfo_t) -> int:
    r"""Replace references to ordinal types by name references. This function 'unties' the type from the current local type library and makes it easier to export it. 
            
    :param til: type library to use. may be nullptr.
    :param tif: type to modify (in/out)
    :returns: number: of replaced subtypes, -1 on failure
    """
    ...

def replace_wait_box(args: Any) -> None:
    r"""Replace the label of "Please wait dialog box".
    
    """
    ...

def replfun(func: Any) -> Any:
    ...

def request_add_bpt(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
        1. request_add_bpt(bpt: const bpt_t &) -> bool
    
    # 0: request_add_bpt(ea: ida_idaapi.ea_t, size: asize_t=0, type: bpttype_t=BPT_DEFAULT) -> bool
    
    Post an add_bpt(ea_t, asize_t, bpttype_t) request.
    
    
    # 1: request_add_bpt(bpt: const bpt_t &) -> bool
    
    Post an add_bpt(const bpt_t &) request.
    
    
    """
    ...

def request_attach_process(pid: pid_t, event_id: int) -> int:
    r"""Post an attach_process() request.
    
    """
    ...

def request_clear_trace() -> None:
    r"""Post a clear_trace() request.
    
    """
    ...

def request_continue_backwards() -> bool:
    r"""Post a continue_backwards() request. 
            
    """
    ...

def request_continue_process() -> bool:
    r"""Post a continue_process() request. 
            
    """
    ...

def request_del_bpt(args: Any) -> bool:
    r"""This function has the following signatures:
    
        0. request_del_bpt(ea: ida_idaapi.ea_t) -> bool
        1. request_del_bpt(bptloc: const bpt_location_t &) -> bool
    
    # 0: request_del_bpt(ea: ida_idaapi.ea_t) -> bool
    
    Post a del_bpt(ea_t) request.
    
    
    # 1: request_del_bpt(bptloc: const bpt_location_t &) -> bool
    
    Post a del_bpt(const bpt_location_t &) request.
    
    
    """
    ...

def request_detach_process() -> bool:
    r"""Post a detach_process() request.
    
    """
    ...

def request_disable_bblk_trace() -> bool:
    ...

def request_disable_bpt(args: Any) -> bool:
    ...

def request_disable_func_trace() -> bool:
    ...

def request_disable_insn_trace() -> bool:
    ...

def request_disable_step_trace() -> bool:
    ...

def request_enable_bblk_trace(enable: bool = True) -> bool:
    ...

def request_enable_bpt(args: Any) -> bool:
    ...

def request_enable_func_trace(enable: bool = True) -> bool:
    ...

def request_enable_insn_trace(enable: bool = True) -> bool:
    ...

def request_enable_step_trace(enable: int = 1) -> bool:
    ...

def request_exit_process() -> bool:
    r"""Post an exit_process() request.
    
    """
    ...

def request_refresh(mask: uint64, cnd: bool = True) -> None:
    r"""Request a refresh of a builtin window. 
            
    :param mask: Window refresh flags
    :param cnd: set if true or clear flag otherwise
    """
    ...

def request_resume_thread(tid: thid_t) -> int:
    r"""Post a resume_thread() request.
    
    """
    ...

def request_run_to(args: Any) -> bool:
    r"""Post a run_to() request.
    
    """
    ...

def request_run_to_backwards(args: Any) -> bool:
    r"""Post a run_to_backwards() request.
    
    """
    ...

def request_select_thread(tid: thid_t) -> bool:
    r"""Post a select_thread() request.
    
    """
    ...

def request_set_bblk_trace_options(options: int) -> None:
    r"""Post a set_bblk_trace_options() request.
    
    """
    ...

def request_set_func_trace_options(options: int) -> None:
    r"""Post a set_func_trace_options() request.
    
    """
    ...

def request_set_insn_trace_options(options: int) -> None:
    r"""Post a set_insn_trace_options() request.
    
    """
    ...

def request_set_reg_val(regname: str, o: Any) -> Any:
    r"""Post a set_reg_val() request.
    
    """
    ...

def request_set_resume_mode(tid: thid_t, mode: resume_mode_t) -> bool:
    r"""Post a set_resume_mode() request.
    
    """
    ...

def request_set_step_trace_options(options: int) -> None:
    r"""Post a set_step_trace_options() request.
    
    """
    ...

def request_start_process(path: str = None, args: str = None, sdir: str = None) -> int:
    r"""Post a start_process() request.
    
    """
    ...

def request_step_into() -> bool:
    r"""Post a step_into() request.
    
    """
    ...

def request_step_into_backwards() -> bool:
    r"""Post a step_into_backwards() request.
    
    """
    ...

def request_step_over() -> bool:
    r"""Post a step_over() request.
    
    """
    ...

def request_step_over_backwards() -> bool:
    r"""Post a step_over_backwards() request.
    
    """
    ...

def request_step_until_ret() -> bool:
    r"""Post a step_until_ret() request.
    
    """
    ...

def request_suspend_process() -> bool:
    r"""Post a suspend_process() request.
    
    """
    ...

def request_suspend_thread(tid: thid_t) -> int:
    r"""Post a suspend_thread() request.
    
    """
    ...

def require(modulename: Any, package: Any = None) -> Any:
    r"""
    Load, or reload a module.
    
    When under heavy development, a user's tool might consist of multiple
    modules. If those are imported using the standard 'import' mechanism,
    there is no guarantee that the Python implementation will re-read
    and re-evaluate the module's Python code. In fact, it usually doesn't.
    What should be done instead is 'reload()'-ing that module.
    
    This is a simple helper function that will do just that: In case the
    module doesn't exist, it 'import's it, and if it does exist,
    'reload()'s it.
    
    The importing module (i.e., the module calling require()) will have
    the loaded module bound to its globals(), under the name 'modulename'.
    (If require() is called from the command line, the importing module
    will be '__main__'.)
    
    For more information, see: <http://www.hexblog.com/?p=749>.
    
    """
    ...

def requires_color_esc(c: Any) -> Any:
    r"""Is the given char a color escape character?
    
    """
    ...

def resolve_typedef(til: til_t, type: type_t) -> type_t:
    ...

def restore_database_snapshot(snapshot: Any, callback: Any, userdata: Any) -> bool:
    r"""Restore a database snapshot.
    
    Note: This call is asynchronous. When it is completed, the callback will be triggered.
    
    :param snapshot: the snapshot object
    :param callback: a callback function
    :param userdata: payload to pass to the callback
    :returns: success
    """
    ...

def restore_user_cmts(func_ea: ida_idaapi.ea_t) -> user_cmts_t:
    r"""Restore user defined comments from the database. 
            
    :param func_ea: the entry address of the function
    :returns: collection of user defined comments. The returned object must be deleted by the caller using delete_user_cmts()
    """
    ...

def restore_user_defined_calls(udcalls: udcall_map_t, func_ea: ida_idaapi.ea_t) -> bool:
    r"""Restore user defined function calls from the database. 
            
    :param udcalls: ptr to output buffer
    :param func_ea: entry address of the function
    :returns: success
    """
    ...

def restore_user_iflags(func_ea: ida_idaapi.ea_t) -> user_iflags_t:
    r"""Restore user defined citem iflags from the database. 
            
    :param func_ea: the entry address of the function
    :returns: collection of user defined iflags. The returned object must be deleted by the caller using delete_user_iflags()
    """
    ...

def restore_user_labels(func_ea: ida_idaapi.ea_t, func: cfunc_t = None) -> user_labels_t:
    r"""Restore user defined labels from the database. 
            
    :param func_ea: the entry address of the function, ignored if FUNC != nullptr
    :param func: pointer to current function
    :returns: collection of user defined labels. The returned object must be deleted by the caller using delete_user_labels()
    """
    ...

def restore_user_lvar_settings(lvinf: lvar_uservec_t, func_ea: ida_idaapi.ea_t) -> bool:
    r"""Restore user defined local variable settings in the database. 
            
    :param lvinf: ptr to output buffer
    :param func_ea: entry address of the function
    :returns: success
    """
    ...

def restore_user_numforms(func_ea: ida_idaapi.ea_t) -> user_numforms_t:
    r"""Restore user defined number formats from the database. 
            
    :param func_ea: the entry address of the function
    :returns: collection of user defined number formats. The returned object must be deleted by the caller using delete_user_numforms()
    """
    ...

def restore_user_unions(func_ea: ida_idaapi.ea_t) -> user_unions_t:
    r"""Restore user defined union field selections from the database. 
            
    :param func_ea: the entry address of the function
    :returns: collection of union field selections The returned object must be deleted by the caller using delete_user_unions()
    """
    ...

def resume_thread(tid: thid_t) -> int:
    r"""Resume thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    :param tid: thread id
    :returns: -1: network error
    :returns: 0: failed
    :returns: 1: ok
    """
    ...

def retrieve_exceptions() -> excvec_t:
    r"""Retrieve the exception information. You may freely modify the returned vector and add/edit/delete exceptions You must call store_exceptions() after any modifications Note: exceptions with code zero, multiple exception codes or names are prohibited 
            
    """
    ...

def retrieve_input_file_crc32() -> int:
    r"""Get input file crc32 stored in the database. it can be used to check that the input file has not been changed. 
            
    """
    ...

def retrieve_input_file_md5() -> bytes:
    r"""Get input file md5.
    
    """
    ...

def retrieve_input_file_sha256() -> bytes:
    r"""Get input file sha256.
    
    """
    ...

def retrieve_input_file_size() -> int:
    r"""Get size of input file in bytes.
    
    """
    ...

def revert_byte(ea: ida_idaapi.ea_t) -> bool:
    r"""Revert patched byte 
            
    :returns: true: byte was patched before and reverted now
    """
    ...

def revert_ida_decisions(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None:
    r"""Delete all analysis info that IDA generated for for the given range.
    
    """
    ...

def run_plugin(plg: Any, arg: Any) -> Any:
    r"""Runs a plugin
    
    :param plg: A plugin object (returned by load_plugin())
    :param arg: the code to pass to the plugin's "run()" function
    :returns: Boolean
    """
    ...

def run_requests() -> bool:
    r"""Execute requests until all requests are processed or an asynchronous function is called. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :returns: false if not all requests could be processed (indicates an asynchronous function was started)
    """
    ...

def run_to(args: Any) -> bool:
    r"""Execute the process until the given address is reached. If no process is active, a new process is started. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. So, all threads continue their execution! \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
            
    :param ea: target address
    :param pid: not used yet. please do not specify this parameter.
    :param tid: not used yet. please do not specify this parameter.
    """
    ...

def run_to_backwards(args: Any) -> bool:
    r"""Execute the process backwards until the given address is reached. Technically, the debugger sets up a temporary breakpoint at the given address, and continues (or starts) the execution of the whole process. \sq{Type, Asynchronous function - available as Request, Notification, dbg_run_to} 
            
    :param ea: target address
    :param pid: not used yet. please do not specify this parameter.
    :param tid: not used yet. please do not specify this parameter.
    """
    ...

def save_database(outfile: str = None, flags: int = -1, root: snapshot_t = None, attr: snapshot_t = None) -> bool:
    r"""Save current database using a new file name. 
            
    :param outfile: output database file name; nullptr means the current path
    :param flags: Database flags; -1 means the current flags
    :param root: optional: snapshot tree root.
    :param attr: optional: snapshot attributes
    :returns: success
    """
    ...

def save_tinfo(tif: tinfo_t, til: til_t, ord: size_t, name: str, ntf_flags: int) -> tinfo_code_t:
    ...

def save_trace_file(filename: str, description: str) -> bool:
    r"""Save the current trace in the specified file.
    
    """
    ...

def save_user_cmts(func_ea: ida_idaapi.ea_t, user_cmts: user_cmts_t) -> None:
    r"""Save user defined comments into the database. 
            
    :param func_ea: the entry address of the function
    :param user_cmts: collection of user defined comments
    """
    ...

def save_user_defined_calls(func_ea: ida_idaapi.ea_t, udcalls: udcall_map_t) -> None:
    r"""Save user defined local function calls into the database. 
            
    :param func_ea: entry address of the function
    :param udcalls: user-specified info about user defined function calls
    """
    ...

def save_user_iflags(func_ea: ida_idaapi.ea_t, iflags: user_iflags_t) -> None:
    r"""Save user defined citem iflags into the database. 
            
    :param func_ea: the entry address of the function
    :param iflags: collection of user defined citem iflags
    """
    ...

def save_user_labels(func_ea: ida_idaapi.ea_t, user_labels: user_labels_t, func: cfunc_t = None) -> None:
    r"""Save user defined labels into the database. 
            
    :param func_ea: the entry address of the function, ignored if FUNC != nullptr
    :param user_labels: collection of user defined labels
    :param func: pointer to current function, if FUNC != nullptr, then save labels using a more stable method that preserves them even when the decompiler output drastically changes
    """
    ...

def save_user_lvar_settings(func_ea: ida_idaapi.ea_t, lvinf: lvar_uservec_t) -> None:
    r"""Save user defined local variable settings into the database. 
            
    :param func_ea: entry address of the function
    :param lvinf: user-specified info about local variables
    """
    ...

def save_user_numforms(func_ea: ida_idaapi.ea_t, numforms: user_numforms_t) -> None:
    r"""Save user defined number formats into the database. 
            
    :param func_ea: the entry address of the function
    :param numforms: collection of user defined comments
    """
    ...

def save_user_unions(func_ea: ida_idaapi.ea_t, unions: user_unions_t) -> None:
    r"""Save user defined union field selections into the database. 
            
    :param func_ea: the entry address of the function
    :param unions: collection of union field selections
    """
    ...

def score_tinfo(tif: tinfo_t) -> int:
    ...

def search_down(sflag: int) -> bool:
    r"""Is the SEARCH_DOWN bit set?
    
    """
    ...

def seg_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def segm_adjust_diff(s: segment_t, delta: adiff_t) -> adiff_t:
    r"""Truncate and sign extend a delta depending on the segment.
    
    """
    ...

def segm_adjust_ea(s: segment_t, ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Truncate an address depending on the segment.
    
    """
    ...

def segtype(ea: ida_idaapi.ea_t) -> uchar:
    r"""Get segment type. 
            
    :param ea: any linear address within the segment
    :returns: Segment types, SEG_UNDF if no segment found at 'ea'
    """
    ...

def sel2ea(selector: sel_t) -> ida_idaapi.ea_t:
    r"""Get mapping of a selector as a linear address. 
            
    :param selector: number of selector to translate to linear address
    :returns: linear address the specified selector is mapped to. if there is no mapping, returns to_ea(selector,0);
    """
    ...

def sel2para(selector: sel_t) -> ida_idaapi.ea_t:
    r"""Get mapping of a selector. 
            
    :param selector: number of selector to translate
    :returns: paragraph the specified selector is mapped to. if there is no mapping, returns 'selector'.
    """
    ...

def select_parser_by_name(name: str) -> bool:
    r"""Set the parser with the given name as the current parser. Pass nullptr or an empty string to select the default parser. 
            
    :returns: false if no parser was found with the given name
    """
    ...

def select_parser_by_srclang(lang: srclang_t) -> bool:
    r"""Set the parser that supports the given language(s) as the current parser. The selected parser must support all languages specified by the given srclang_t. 
            
    :returns: false if no such parser was found
    """
    ...

def select_thread(tid: thid_t) -> bool:
    r"""Select the given thread as the current debugged thread. All thread related execution functions will work on this thread. The process must be suspended to select a new thread. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    :param tid: ID of the thread to select
    :returns: false if the thread doesn't exist.
    """
    ...

def select_udt_by_offset(udts: qvector, ops: ui_stroff_ops_t, applicator: ui_stroff_applicator_t) -> int:
    r"""Select UDT 
            
    :param udts: list of UDT tinfo_t for the selection, if nullptr or empty then UDTs from the "Local types" will be used
    :param ops: operands
    :param applicator: callback will be called to apply the selection for every operand
    """
    ...

def send_database(err: hexrays_failure_t, silent: bool) -> None:
    r"""Send the database to Hex-Rays. This function sends the current database to the Hex-Rays server. The database is sent in the compressed form over an encrypted (SSL) connection. 
            
    :param err: failure description object. Empty hexrays_failure_t object can be used if error information is not available.
    :param silent: if false, a dialog box will be displayed before sending the database.
    """
    ...

def send_dbg_command(command: Any) -> Any:
    r"""
    Send a direct command to the debugger backend, and
    retrieve the result as a string.
    
    Note: any double-quotes in 'command' must be backslash-escaped.
    Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
    Returns: (True, <result string>) on success, or (False, <Error message string>) on failure
    
    """
    ...

def serialize_tinfo(type: qtype, fields: qtype, fldcmts: qtype, tif: tinfo_t, sudt_flags: int) -> bool:
    ...

def set2jcnd(code: mcode_t) -> mcode_t:
    ...

def set__bnot0(ea: ida_idaapi.ea_t) -> None:
    ...

def set__bnot1(ea: ida_idaapi.ea_t) -> None:
    ...

def set__invsign0(ea: ida_idaapi.ea_t) -> None:
    ...

def set__invsign1(ea: ida_idaapi.ea_t) -> None:
    ...

def set_abi_name(abiname: str, user_level: bool = False) -> bool:
    r"""Set abi name (see Compiler IDs)
    
    """
    ...

def set_abits(ea: ida_idaapi.ea_t, bits: aflags_t) -> None:
    ...

def set_absbase(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None:
    ...

def set_aflags(ea: ida_idaapi.ea_t, flags: aflags_t) -> None:
    ...

def set_align_flow(ea: ida_idaapi.ea_t) -> None:
    ...

def set_alignment(ea: ida_idaapi.ea_t, x: int) -> None:
    ...

def set_archive_path(file: str) -> bool:
    r"""Set archive file path from which input file was extracted.
    
    """
    ...

def set_array_parameters(ea: ida_idaapi.ea_t, _in: array_parameters_t) -> None:
    ...

def set_asm_inc_file(file: str) -> bool:
    r"""Set name of the include file.
    
    """
    ...

def set_auto_spd(pfn: func_t, ea: ida_idaapi.ea_t, new_spd: int) -> bool:
    r"""Add such an automatic SP register change point so that at EA the new cumulative SP delta (that is, the difference between the initial and current values of SP) would be equal to NEW_SPD. 
            
    :param pfn: pointer to the function. may be nullptr.
    :param ea: linear address of the instruction
    :param new_spd: new value of the cumulative SP delta
    :returns: success
    """
    ...

def set_auto_state(new_state: atype_t) -> atype_t:
    r"""Set current state of autoanalyzer. 
            
    :param new_state: new state of autoanalyzer
    :returns: previous state
    """
    ...

def set_bblk_trace_options(options: int) -> None:
    r"""Modify basic block tracing options (see BT_LOG_INSTS)
    
    """
    ...

def set_bpt_group(bpt: bpt_t, grp_name: str) -> bool:
    r"""Move a bpt into a folder in the breakpoint dirtree if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bpt: bpt that will be moved
    :param grp_name: absolute path to the breakpoint dirtree folder
    :returns: success
    """
    ...

def set_bptloc_group(bptloc: bpt_location_t, grp_name: str) -> bool:
    r"""Move a bpt into a folder in the breakpoint dirtree based on the bpt_location find_bpt is called to retrieve the bpt and then set_bpt_group if the folder didn't exists, it will be created \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param bptloc: bptlocation of the bpt that will be moved
    :param grp_name: absolute path to the breakpoint dirtree folder
    :returns: success
    """
    ...

def set_bptloc_string(s: str) -> int:
    ...

def set_c_header_path(incdir: str) -> None:
    r"""Set include directory path the target compiler.
    
    """
    ...

def set_c_macros(macros: str) -> None:
    r"""Set predefined macros for the target compiler.
    
    """
    ...

def set_cancelled() -> None:
    r"""Set "Cancelled" flag (ui_set_cancelled)
    
    """
    ...

def set_cmt(ea: ida_idaapi.ea_t, comm: str, rptble: bool) -> bool:
    r"""Set an indented comment. 
            
    :param ea: linear address
    :param comm: comment string
    * nullptr: do nothing (return 0)
    * "" : delete comment
    :param rptble: is repeatable?
    :returns: success
    """
    ...

def set_code_viewer_handler(code_viewer: TWidget, handler_id: custom_viewer_handler_id_t, handler_or_data: void) -> None:
    r"""Set a handler for a code viewer event (ui_set_custom_viewer_handler). 
            
    :param code_viewer: the code viewer
    :param handler_id: one of CDVH_ in custom_viewer_handler_id_t
    :param handler_or_data: can be a handler or data. see examples in Functions: custom viewer handlers
    :returns: old value of the handler or data
    """
    ...

def set_code_viewer_is_source(code_viewer: TWidget) -> bool:
    r"""Specify that the given code viewer is used to display source code (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_line_handlers(code_viewer: TWidget, click_handler: code_viewer_lines_click_t, popup_handler: code_viewer_lines_click_t, dblclick_handler: code_viewer_lines_click_t, drawicon_handler: code_viewer_lines_icon_t, linenum_handler: code_viewer_lines_linenum_t) -> None:
    r"""Set handlers for code viewer line events. Any of these handlers may be nullptr 
            
    """
    ...

def set_code_viewer_lines_alignment(code_viewer: TWidget, align: int) -> bool:
    r"""Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_lines_icon_margin(code_viewer: TWidget, margin: int) -> bool:
    r"""Set space allowed for icons in the margin of a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_lines_radix(code_viewer: TWidget, radix: int) -> bool:
    r"""Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_code_viewer_user_data(code_viewer: TWidget, ud: void) -> bool:
    r"""Set the user data on a code viewer (ui_set_custom_viewer_handler).
    
    """
    ...

def set_colored_item(ea: ida_idaapi.ea_t) -> None:
    ...

def set_compiler(cc: compiler_info_t, flags: int, abiname: str = None) -> bool:
    r"""Change current compiler. 
            
    :param cc: compiler to switch to
    :param flags: Set compiler flags
    :param abiname: ABI name
    :returns: success
    """
    ...

def set_compiler_id(id: comp_t, abiname: str = None) -> bool:
    r"""Set the compiler id (see Compiler IDs)
    
    """
    ...

def set_compiler_string(compstr: str, user_level: bool) -> bool:
    r""":param compstr: - compiler description in form <abbr>:<abiname>
    :param user_level: - initiated by user if TRUE
    :returns: success
    """
    ...

def set_cp_validity(args: Any) -> None:
    r"""Mark the given codepoint (or range) as acceptable or unacceptable in the given context If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range 
            
    """
    ...

def set_custom_data_type_ids(ea: ida_idaapi.ea_t, cdis: custom_data_type_ids_t) -> None:
    ...

def set_custom_viewer_qt_aware(custom_viewer: TWidget) -> bool:
    r"""Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)
    
    """
    ...

def set_data_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None:
    ...

def set_database_flag(dbfl: int, cnd: bool = True) -> None:
    r"""Set or clear database flag 
            
    :param dbfl: flag Database flags
    :param cnd: set if true or clear flag otherwise
    """
    ...

def set_debug_event_code(ev: debug_event_t, id: event_id_t) -> None:
    ...

def set_debug_name(ea: ida_idaapi.ea_t, name: str) -> bool:
    ...

def set_debugger_event_cond(NONNULL_evcond: str) -> None:
    ...

def set_debugger_options(options: uint) -> uint:
    r"""Set debugger options. Replaces debugger options with the specification combination Debugger options 
            
    :returns: the old debugger options
    """
    ...

def set_default_dataseg(ds_sel: sel_t) -> None:
    r"""Set default value of DS register for all segments.
    
    """
    ...

def set_default_encoding_idx(bpu: int, idx: int) -> bool:
    ...

def set_default_sreg_value(sg: segment_t, rg: int, value: sel_t) -> bool:
    r"""Set default value of a segment register for a segment. 
            
    :param sg: pointer to segment structure if nullptr, then set the register for all segments
    :param rg: number of segment register
    :param value: its default value. this value will be used by get_sreg() if value of the register is unknown at the specified address.
    :returns: success
    """
    ...

def set_defsr(s: Any, reg: Any, value: Any) -> Any:
    r"""Deprecated, use instead:
    s.defsr[reg] = value
    """
    ...

def set_dock_pos(src_ctrl: Any, dest_ctrl: Any, orient: Any, left: Any = 0, top: Any = 0, right: Any = 0, bottom: Any = 0) -> Any:
    r"""Sets the dock orientation of a window relatively to another window.
    
    Use the left, top, right, bottom parameters if DP_FLOATING is used,
    or if you want to specify the width of docked windows.
    
    :param src_ctrl: Source docking control
    :param dest_ctrl: Destination docking control
    :param orient: One of DP_XXXX constants
    :returns: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window
    """
    ...

def set_dummy_name(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> bool:
    r"""Give an autogenerated (dummy) name. Autogenerated names have special prefixes (loc_...). 
            
    :param ea: linear address
    :returns: 1: ok, dummy name is generated or the byte already had a name
    :returns: 0: failure, invalid address or tail byte
    """
    ...

def set_entry_forwarder(ord: int, name: str, flags: int = 0) -> bool:
    r"""Set forwarder name for ordinal. 
            
    :param ord: ordinal number of the entry point
    :param name: forwarder name for entry point.
    :param flags: See AEF_*
    :returns: success
    """
    ...

def set_execute_sync_availability(tid: __qthread_t, availability: execute_sync_availability_t) -> execute_sync_availability_t:
    r"""Set the availability of the execute_sync functionality for the given thread
    Setting it to `esa_unavailable` will cause the existing requests for this thread to be cancelled. Setting it to `esa_release` will clear the status for this thread, and should be issued right before a call to `qthread_free` is issued.
    
    :param tid: thread id
    :param availability: the availability
    :returns: the previous availability
    """
    ...

def set_fixed_spd(ea: ida_idaapi.ea_t) -> None:
    ...

def set_fixup(source: ida_idaapi.ea_t, fd: fixup_data_t) -> None:
    r"""Set fixup information. You should fill fixup_data_t and call this function and the kernel will remember information in the database. 
            
    :param source: the fixup source address, i.e. the address modified by the fixup
    :param fd: fixup data
    """
    ...

def set_forced_operand(ea: ida_idaapi.ea_t, n: int, op: str) -> bool:
    r"""Set forced operand. 
            
    :param ea: linear address
    :param n: 0..UA_MAXOP-1 operand number
    :param op: text of operand
    * nullptr: do nothing (return 0)
    * "" : delete forced operand
    :returns: success
    """
    ...

def set_frame_member_type(pfn: func_t, offset: int, tif: tinfo_t, repr: value_repr_t = None, etf_flags: uint = 0) -> bool:
    r"""Change type of the frame member 
            
    :param pfn: pointer to function
    :param offset: member offset in the frame structure, in bytes
    :param tif: variable type
    :param repr: variable representation
    :returns: success
    """
    ...

def set_frame_size(pfn: func_t, frsize: asize_t, frregs: ushort, argsize: asize_t) -> bool:
    r"""Set size of function frame. Note: The returned size may not include all stack arguments. It does so only for __stdcall and __fastcall calling conventions. To get the entire frame size for all cases use frame.get_func_frame(pfn).get_size() 
            
    :param pfn: pointer to function structure
    :param frsize: size of function local variables
    :param frregs: size of saved registers
    :param argsize: size of function arguments that will be purged from the stack upon return
    :returns: success
    """
    ...

def set_func_cmt(pfn: func_t, cmt: str, repeatable: bool) -> bool:
    r"""Set function comment. This function works with function chunks too. 
            
    :param pfn: ptr to function structure
    :param cmt: comment string, may be multiline (with '
    '). Use empty str ("") to delete comment
    :param repeatable: set repeatable comment?
    """
    ...

def set_func_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t) -> bool:
    r"""Move function chunk end address. 
            
    :param ea: any address in the function
    :param newend: new end address of the function
    :returns: success
    """
    ...

def set_func_guessed_by_hexrays(ea: ida_idaapi.ea_t) -> None:
    ...

def set_func_name_if_jumpfunc(pfn: func_t, oldname: str) -> int:
    r"""Give a meaningful name to function if it consists of only 'jump' instruction. 
            
    :param pfn: pointer to function (may be nullptr)
    :param oldname: old name of function. if old name was in "j_..." form, then we may discard it and set a new name. if oldname is not known, you may pass nullptr.
    :returns: success
    """
    ...

def set_func_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t) -> int:
    r"""Move function chunk start address. 
            
    :param ea: any address in the function
    :param newstart: new end address of the function
    :returns: Function move result codes
    """
    ...

def set_func_trace_options(options: int) -> None:
    r"""Modify function tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    """
    ...

def set_gotea(gotea: ida_idaapi.ea_t) -> None:
    ...

def set_group_selector(grp: sel_t, sel: sel_t) -> int:
    r"""Create a new group of segments (used OMF files). 
            
    :param grp: selector of group segment (segment type is SEG_GRP) You should create an 'empty' (1 byte) group segment It won't contain anything and will be used to redirect references to the group of segments to the common selector.
    :param sel: common selector of all segments belonging to the segment You should create all segments within the group with the same selector value.
    :returns: 1: ok
    :returns: 0: too many groups (see MAX_GROUPS)
    """
    ...

def set_has_lname(ea: ida_idaapi.ea_t) -> None:
    ...

def set_has_ti(ea: ida_idaapi.ea_t) -> None:
    ...

def set_has_ti0(ea: ida_idaapi.ea_t) -> None:
    ...

def set_has_ti1(ea: ida_idaapi.ea_t) -> None:
    ...

def set_header_path(path: str, add: bool) -> bool:
    r"""Set or append a header path. IDA looks for the include files in the appended header paths, then in the ida executable directory. 
            
    :param path: list of directories to add (separated by ';') may be nullptr, in this case nothing is added
    :param add: true: append. false: remove old paths.
    :returns: true: success
    :returns: false: no memory
    """
    ...

def set_highlight(viewer: TWidget, str: str, flags: int) -> bool:
    r"""Set the highlighted identifier in the viewer (ui_set_highlight). 
            
    :param viewer: the viewer
    :param str: the text to match, or nullptr to remove current
    :param flags: combination of HIF_... bits (see set_highlight flags)
    :returns: false if an error occurred
    """
    ...

def set_highlight_trace_options(hilight: bool, color: bgcolor_t, diff: bgcolor_t) -> None:
    r"""Set highlight trace parameters.
    
    """
    ...

def set_ida_notepad_text(text: str, size: size_t = 0) -> None:
    r"""Set notepad text.
    
    """
    ...

def set_ida_state(st: idastate_t) -> idastate_t:
    r"""Change IDA status indicator value 
            
    :param st: - new indicator status
    :returns: old indicator status
    """
    ...

def set_idcv_attr(obj: idc_value_t, attr: str, value: idc_value_t, may_use_setattr: bool = False) -> error_t:
    r"""Set an object attribute. 
            
    :param obj: variable that holds an object reference. if obj is nullptr then it tries to modify a global variable with the attribute name
    :param attr: attribute name
    :param value: new attribute value
    :param may_use_setattr: may call setattr functions for the class
    :returns: error code, eOk on success
    """
    ...

def set_idcv_slice(v: idc_value_t, i1: int, i2: int, _in: idc_value_t, flags: int = 0) -> error_t:
    r"""Set slice. 
            
    :param v: variable to modify (string or object)
    :param i1: slice start index
    :param i2: slice end index (excluded)
    :param flags: IDC variable slice flags or 0
    :returns: eOk on success
    """
    ...

def set_ids_modnode(id: netnode) -> None:
    r"""Set ids modnode.
    
    """
    ...

def set_imagebase(base: ida_idaapi.ea_t) -> None:
    r"""Set image base address.
    
    """
    ...

def set_immd(ea: ida_idaapi.ea_t) -> bool:
    r"""Set 'has immediate operand' flag. Returns true if the FF_IMMD bit was not set and now is set 
            
    """
    ...

def set_import_name(modnode: int, ea: ida_idaapi.ea_t, name: str) -> None:
    r"""Set information about the named import entry. This function performs 'modnode.supset_ea(ea, name);' 
            
    :param modnode: node with information about imported entries
    :param ea: linear address of the entry
    :param name: name of the entry
    """
    ...

def set_import_ordinal(modnode: int, ea: ida_idaapi.ea_t, ord: int) -> None:
    r"""Set information about the ordinal import entry. This function performs 'modnode.altset(ord, ea2node(ea));' 
            
    :param modnode: node with information about imported entries
    :param ea: linear address of the entry
    :param ord: ordinal number of the entry
    """
    ...

def set_insn_trace_options(options: int) -> None:
    r"""Modify instruction tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    """
    ...

def set_item_color(ea: ida_idaapi.ea_t, color: bgcolor_t) -> None:
    ...

def set_libitem(ea: ida_idaapi.ea_t) -> None:
    ...

def set_loader_format_name(name: str) -> None:
    r"""Set file format name for loader modules.
    
    """
    ...

def set_lzero(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Set toggle lzero bit. This function changes the display of leading zeroes for the specified operand. If the default is not to display leading zeroes, this function will display them and vice versa. 
            
    :param ea: the item (insn/data) address
    :param n: the operand number (0-first operand, 1-other operands)
    :returns: success
    """
    ...

def set_lzero0(ea: ida_idaapi.ea_t) -> None:
    ...

def set_lzero1(ea: ida_idaapi.ea_t) -> None:
    ...

def set_manual_insn(ea: ida_idaapi.ea_t, manual_insn: str) -> None:
    r"""Set manual instruction string. 
            
    :param ea: linear address of the instruction or data item
    :param manual_insn: "" - delete manual string. nullptr - do nothing
    """
    ...

def set_manual_regions(ranges: meminfo_vec_t) -> None:
    ...

def set_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool:
    r"""Set or delete name of an item at the specified address. An item can be anything: instruction, function, data byte, word, string, structure, etc... Include name into the list of names. 
            
    :param ea: linear address. do nothing if ea is not valid (return 0). tail bytes can't have names.
    :param name: new name.
    * nullptr: do nothing (return 0).
    * "" : delete name.
    * otherwise this is a new name.
    :param flags: Set name flags. If a bit is not specified, then the corresponding action is not performed and the name will retain the same bits as before calling this function. For new names, default is: non-public, non-weak, non-auto.
    :returns: 1: ok, name is changed
    :returns: 0: failure, a warning is displayed
    """
    ...

def set_nav_colorizer(callback: Any) -> Any:
    r"""Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = ida_kernwin.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = ida_kernwin.set_nav_colorizer(my_colorizer)
    
    :param callback: the new colorizer
    """
    ...

def set_node_info(gid: graph_id_t, node: int, ni: node_info_t, flags: int) -> None:
    r"""Set node info. 
            
    :param gid: id of desired graph
    :param node: node number
    :param ni: node info to use
    :param flags: combination of Node info flags, identifying which fields of 'ni' will be used
    """
    ...

def set_noret(ea: ida_idaapi.ea_t) -> None:
    ...

def set_noret_insn(insn_ea: ida_idaapi.ea_t, noret: bool) -> bool:
    r"""Signal a non-returning instruction. This function can be used by the processor module to tell the kernel about non-returning instructions (like call exit). The kernel will perform the global function analysis and find out if the function returns at all. This analysis will be done at the first call to func_does_return() 
            
    :returns: true if the instruction 'noret' flag has been changed
    """
    ...

def set_notcode(ea: ida_idaapi.ea_t) -> None:
    r"""Mark address so that it cannot be converted to instruction.
    
    """
    ...

def set_notproc(ea: ida_idaapi.ea_t) -> None:
    ...

def set_numbered_type(ti: til_t, ordinal: int, ntf_flags: int, name: str, type: type_t, fields: p_list = None, cmt: str = None, fldcmts: p_list = None, sclass: sclass_t = None) -> tinfo_code_t:
    ...

def set_op_tinfo(ea: ida_idaapi.ea_t, n: int, tif: tinfo_t) -> bool:
    ...

def set_op_type(ea: ida_idaapi.ea_t, type: flags64_t, n: int) -> bool:
    r"""(internal function) change representation of operand(s). 
            
    :param ea: linear address
    :param type: new flag value (should be obtained from char_flag(), num_flag() and similar functions)
    :param n: 0..UA_MAXOP-1 operand number, OPND_ALL all operands
    :returns: 1: ok
    :returns: 0: failed (applied to a tail byte)
    """
    ...

def set_opinfo(ea: ida_idaapi.ea_t, n: int, flag: flags64_t, ti: opinfo_t, suppress_events: bool = False) -> bool:
    r"""Set additional information about an operand representation. This function is a low level one. Only the kernel should use it. 
            
    :param ea: linear address of the item
    :param n: number of operand, 0 or 1 (see the note below)
    :param flag: flags of the item
    :param ti: additional representation information
    :param suppress_events: do not generate changing_op_type and op_type_changed events
    :returns: success
    """
    ...

def set_outfile_encoding_idx(idx: int) -> bool:
    ...

def set_parser_argv(parser_name: str, argv: str) -> int:
    r"""Set the command-line args to use for invocations of the parser with the given name 
            
    :param parser_name: name of the target parser
    :param argv: argument list
    :returns: -1: no parser was found with the given name
    :returns: -2: the operation is not supported by the given parser
    :returns: 0: success
    """
    ...

def set_parser_option(parser_name: str, option_name: str, option_value: str) -> bool:
    r"""Set option for the parser with the specified name 
            
    :param parser_name: name of the target parser
    :param option_name: parser option name
    :param option_value: parser option value
    :returns: success
    """
    ...

def set_path(pt: path_type_t, path: str) -> None:
    r"""Set the file path 
            
    :param pt: file path type Types of the file pathes
    :param path: new file path, use nullptr or empty string to clear the file path
    """
    ...

def set_process_options(args: Any) -> None:
    r"""Set process options. Any of the arguments may be nullptr, which means 'do not modify' 
            
    """
    ...

def set_process_state(newstate: int, p_thid: thid_t, dbginv: int) -> int:
    r"""Set new state for the debugged process. Notifies the IDA kernel about the change of the debugged process state. For example, a debugger module could call this function when it knows that the process is suspended for a short period of time. Some IDA API calls can be made only when the process is suspended. The process state is usually restored before returning control to the caller. You must know that it is ok to change the process state, doing it at arbitrary moments may crash the application or IDA. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param newstate: new process state (one of Debugged process states) if DSTATE_NOTASK is passed then the state is not changed
    :param p_thid: ptr to new thread id. may be nullptr or pointer to NO_THREAD. the pointed variable will contain the old thread id upon return
    :param dbginv: Debugged process invalidation options
    :returns: old debugger state (one of Debugged process states)
    """
    ...

def set_processor_type(procname: str, level: setproc_level_t) -> bool:
    r"""Set target processor type. Once a processor module is loaded, it cannot be replaced until we close the idb. 
            
    :param procname: name of processor type (one of names present in processor_t::psnames)
    :param level: SETPROC_
    :returns: success
    """
    ...

def set_purged(ea: ida_idaapi.ea_t, nbytes: int, override_old_value: bool) -> bool:
    r"""Set the number of purged bytes for a function or data item (funcptr). This function will update the database and plan to reanalyze items referencing the specified address. It works only for processors with PR_PURGING bit in 16 and 32 bit modes. 
            
    :param ea: address of the function of item
    :param nbytes: number of purged bytes
    :param override_old_value: may overwrite old information about purged bytes
    :returns: success
    """
    ...

def set_refinfo(args: Any) -> bool:
    ...

def set_refinfo_ex(ea: ida_idaapi.ea_t, n: int, ri: refinfo_t) -> bool:
    ...

def set_reg_val(args: Any) -> bool:
    r"""Set a register value by name
    
    This function has the following signatures:
        1. set_reg_val(name: str, value: Union[int, float, bytes]) -> bool
        1. set_reg_val(tid: int, regidx: int, value: Union[int, float, bytes]) -> bool
    
    Depending on the register type, this will expect
    either an integer, a float or, in the case of large
    vector registers, a bytes sequence.
    
    :param name: (1st form) the register name
    :param tid: (2nd form) the thread ID
    :param regidx: (2nd form) the register index
    :param value: the register value
    :returns: success
    """
    ...

def set_registry_name(name: str) -> bool:
    ...

def set_regvar_cmt(pfn: func_t, v: regvar_t, cmt: str) -> int:
    r"""Set comment for a register variable. 
            
    :param pfn: function in question
    :param v: variable to rename
    :param cmt: new comment
    :returns: Register variable error codes
    """
    ...

def set_remote_debugger(host: str, _pass: str, port: int = -1) -> None:
    r"""Set remote debugging options. Should be used before starting the debugger. 
            
    :param host: If empty, IDA will use local debugger. If nullptr, the host will not be set.
    :param port: If -1, the default port number will be used
    """
    ...

def set_resume_mode(tid: thid_t, mode: resume_mode_t) -> bool:
    r"""How to resume the application. Set resume mode but do not resume process. 
            
    """
    ...

def set_retfp(ea: ida_idaapi.ea_t) -> None:
    ...

def set_root_filename(file: str) -> None:
    r"""Set full path of the input file.
    
    """
    ...

def set_script_timeout(timeout: Any) -> Any:
    r"""Changes the script timeout value. The script wait box dialog will be hidden and shown again when the timeout elapses.
    See also L{disable_script_timeout}.
    
    :param timeout: This value is in seconds.
                    If this value is set to zero then the script will never timeout.
    :returns: Returns the old timeout value
    """
    ...

def set_segm_addressing(s: segment_t, bitness: size_t) -> bool:
    r"""Change segment addressing mode (16, 32, 64 bits). You must use this function to change segment addressing, never change the 'bitness' field directly. This function will delete all instructions, comments and names in the segment 
            
    :param s: pointer to segment
    :param bitness: new addressing mode of segment
    * 2: 64bit segment
    * 1: 32bit segment
    * 0: 16bit segment
    :returns: success
    """
    ...

def set_segm_base(s: segment_t, newbase: ida_idaapi.ea_t) -> bool:
    r"""Internal function.
    
    """
    ...

def set_segm_class(s: segment_t, sclass: str, flags: int = 0) -> int:
    r"""Set segment class. 
            
    :param s: pointer to segment (may be nullptr)
    :param sclass: segment class (may be nullptr). If segment type is SEG_NORM and segment class is one of predefined names, then segment type is changed to:
    * "CODE" -> SEG_CODE
    * "DATA" -> SEG_DATA
    * "STACK" -> SEG_BSS
    * "BSS" -> SEG_BSS
    * if "UNK" then segment type is reset to SEG_NORM.
    :param flags: Add segment flags
    :returns: 1: ok, name is good and segment is renamed
    :returns: 0: failure, name is nullptr or bad or segment is nullptr
    """
    ...

def set_segm_end(ea: ida_idaapi.ea_t, newend: ida_idaapi.ea_t, flags: int) -> bool:
    r"""Set segment end address. The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
            
    :param ea: any address belonging to the segment
    :param newend: new end address of the segment
    :param flags: Segment modification flags
    :returns: 1: ok
    :returns: 0: failed, a warning message is displayed
    """
    ...

def set_segm_name(s: segment_t, name: str, flags: int = 0) -> int:
    r"""Rename segment. The new name is validated (see validate_name). A segment always has a name. If you hadn't specified a name, the kernel will assign it "seg###" name where ### is segment number. 
            
    :param s: pointer to segment (may be nullptr)
    :param name: new segment name
    :param flags: ADDSEG_IDBENC or 0
    :returns: 1: ok, name is good and segment is renamed
    :returns: 0: failure, name is bad or segment is nullptr
    """
    ...

def set_segm_start(ea: ida_idaapi.ea_t, newstart: ida_idaapi.ea_t, flags: int) -> bool:
    r"""Set segment start address. The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. 
            
    :param ea: any address belonging to the segment
    :param newstart: new start address of the segment note that segment start address should be higher than segment base linear address.
    :param flags: Segment modification flags
    :returns: 1: ok
    :returns: 0: failed, a warning message is displayed
    """
    ...

def set_segment_cmt(s: segment_t, cmt: str, repeatable: bool) -> None:
    r"""Set segment comment. 
            
    :param s: pointer to segment structure
    :param cmt: comment string, may be multiline (with '
    '). maximal size is 4096 bytes. Use empty str ("") to delete comment
    :param repeatable: 0: set regular comment. 1: set repeatable comment.
    """
    ...

def set_segment_translations(segstart: ida_idaapi.ea_t, transmap: eavec_t) -> bool:
    r"""Set new translation list. 
            
    :param segstart: start address of the segment to add translation to
    :param transmap: vector of segment start addresses for the translation list. If transmap is empty, the translation list is deleted.
    :returns: 1: ok
    :returns: 0: too many translations or bad segstart
    """
    ...

def set_selector(selector: sel_t, paragraph: ida_idaapi.ea_t) -> int:
    r"""Set mapping of selector to a paragraph. You should call this function _before_ creating a segment which uses the selector, otherwise the creation of the segment will fail. 
            
    :param selector: number of selector to map
    * if selector == BADSEL, then return 0 (fail)
    * if the selector has had a mapping, old mapping is destroyed
    * if the selector number is equal to paragraph value, then the mapping is destroyed because we don't need to keep trivial mappings.
    :param paragraph: paragraph to map selector
    :returns: 1: ok
    :returns: 0: failure (bad selector or too many mappings)
    """
    ...

def set_source_linnum(ea: ida_idaapi.ea_t, lnnum: int) -> None:
    ...

def set_srcdbg_paths(paths: str) -> None:
    r"""Set source debug paths.
    
    """
    ...

def set_srcdbg_undesired_paths(paths: str) -> None:
    r"""Set user-closed source files.
    
    """
    ...

def set_sreg_at_next_code(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, rg: int, value: sel_t) -> None:
    r"""Set the segment register value at the next instruction. This function is designed to be called from idb_event::sgr_changed handler in order to contain the effect of changing a segment register value only until the next instruction.
    It is useful, for example, in the ARM module: the modification of the T register does not affect existing instructions later in the code. 
            
    :param ea1: address to start to search for an instruction
    :param ea2: the maximal address
    :param rg: the segment register number
    :param value: the segment register value
    """
    ...

def set_step_trace_options(options: int) -> None:
    r"""Modify step tracing options. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    """
    ...

def set_str_encoding_idx(strtype: int, encoding_idx: int) -> int:
    ...

def set_str_type(ea: ida_idaapi.ea_t, x: int) -> None:
    ...

def set_switch_info(ea: ida_idaapi.ea_t, _in: switch_info_t) -> None:
    ...

def set_switch_parent(ea: ida_idaapi.ea_t, x: ida_idaapi.ea_t) -> None:
    ...

def set_tail_owner(fnt: func_t, new_owner: ida_idaapi.ea_t) -> bool:
    r"""Set a new owner of a function tail. The new owner function must be already referring to the tail (after append_func_tail). 
            
    :param fnt: pointer to the function tail
    :param new_owner: the entry point of the new owner function
    """
    ...

def set_target_assembler(asmnum: int) -> bool:
    r"""Set target assembler. 
            
    :param asmnum: number of assembler in the current processor module
    :returns: success
    """
    ...

def set_terse_struc(ea: ida_idaapi.ea_t) -> None:
    ...

def set_tilcmt(ea: ida_idaapi.ea_t) -> None:
    ...

def set_tinfo(ea: ida_idaapi.ea_t, tif: tinfo_t) -> bool:
    ...

def set_tinfo_attr(tif: tinfo_t, ta: type_attr_t, may_overwrite: bool) -> bool:
    ...

def set_tinfo_attrs(tif: tinfo_t, ta: type_attrs_t) -> bool:
    ...

def set_tinfo_property(tif: tinfo_t, sta_prop: int, x: size_t) -> int:
    ...

def set_tinfo_property4(tif: tinfo_t, sta_prop: int, p1: size_t, p2: size_t, p3: size_t, p4: size_t) -> int:
    ...

def set_trace_base_address(ea: ida_idaapi.ea_t) -> None:
    r"""Set the base address of the current trace. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def set_trace_dynamic_register_set(idaregs: dynamic_register_set_t) -> None:
    r"""Set dynamic register set of current trace.
    
    """
    ...

def set_trace_file_desc(filename: str, description: str) -> bool:
    r"""Change the description of the specified trace file.
    
    """
    ...

def set_trace_platform(platform: str) -> None:
    r"""Set platform name of current trace.
    
    """
    ...

def set_trace_size(size: int) -> bool:
    r"""Specify the new size of the circular buffer. \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    :param size: if 0, buffer isn't circular and events are never removed. If the new size is smaller than the existing number of trace events, a corresponding number of trace events are removed.
    """
    ...

def set_type(id: int, tif: tinfo_t, source: type_source_t, force: bool = False) -> bool:
    r"""Set a global type. 
            
    :param id: address or id of the object
    :param tif: new type info
    :param source: where the type comes from
    :param force: true means to set the type as is, false means to merge the new type with the possibly existing old type info.
    :returns: success
    """
    ...

def set_type_alias(ti: til_t, src_ordinal: int, dst_ordinal: int) -> bool:
    r"""Create a type alias. Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all references to srctype by dsttype. 
            
    """
    ...

def set_type_choosable(ti: til_t, ordinal: int, value: bool) -> None:
    r"""Enable/disable 'choosability' flag for a struct/union type 
            
    :param ti: type library
    :param ordinal: ordinal number of a UDT type
    :param value: flag value
    """
    ...

def set_type_determined_by_hexrays(ea: ida_idaapi.ea_t) -> None:
    ...

def set_type_guessed_by_ida(ea: ida_idaapi.ea_t) -> None:
    ...

def set_usemodsp(ea: ida_idaapi.ea_t) -> None:
    ...

def set_usersp(ea: ida_idaapi.ea_t) -> None:
    ...

def set_userti(ea: ida_idaapi.ea_t) -> None:
    ...

def set_vftable_ea(ordinal: int, vftable_ea: ida_idaapi.ea_t) -> bool:
    r"""Set the address of a vftable instance for a vftable type. 
            
    :param ordinal: ordinal number of the corresponding vftable type.
    :param vftable_ea: address of a virtual function table.
    :returns: success
    """
    ...

def set_view_renderer_type(v: TWidget, rt: tcc_renderer_type_t) -> None:
    r"""Set the type of renderer to use in a view (ui_set_renderer_type)
    
    """
    ...

def set_viewer_graph(gv: graph_viewer_t, g: interactive_graph_t) -> None:
    r"""Set the underlying graph object for the given viewer.
    
    """
    ...

def set_visible_func(pfn: func_t, visible: bool) -> None:
    r"""Set visibility of function.
    
    """
    ...

def set_visible_item(ea: ida_idaapi.ea_t, visible: bool) -> None:
    r"""Change visibility of item at given ea.
    
    """
    ...

def set_visible_segm(s: segment_t, visible: bool) -> None:
    r"""See SFL_HIDDEN.
    
    """
    ...

def set_zstroff(ea: ida_idaapi.ea_t) -> None:
    ...

def setup_selector(segbase: ida_idaapi.ea_t) -> sel_t:
    r"""Allocate a selector for a segment if necessary. You must call this function before calling add_segm_ex(). add_segm() calls this function itself, so you don't need to allocate a selector. This function will allocate a selector if 'segbase' requires more than 16 bits and the current processor is IBM PC. Otherwise it will return the segbase value. 
            
    :param segbase: a new segment base paragraph
    :returns: the allocated selector number
    """
    ...

def should_create_stkvars() -> bool:
    ...

def should_trace_sp() -> bool:
    ...

def show_addr(ea: ida_idaapi.ea_t) -> None:
    r"""Show an address on the autoanalysis indicator. The address is displayed in the form " @:12345678". 
            
    :param ea: - linear address to display
    """
    ...

def show_all_comments() -> bool:
    ...

def show_auto(args: Any) -> None:
    r"""Change autoanalysis indicator value. 
            
    :param ea: linear address being analyzed
    :param type: autoanalysis type (see Autoanalysis queues)
    """
    ...

def show_comments(args: Any) -> Any:
    ...

def show_name(ea: ida_idaapi.ea_t) -> None:
    r"""Insert name to the list of names.
    
    """
    ...

def show_repeatables() -> bool:
    ...

def show_wait_box(message: str) -> None:
    r"""Display a dialog box with "Please wait...". The behavior of the dialog box can be configured with well-known 
    tokens, that should be placed at the start of the format string: 
     "NODELAY\n": the dialog will show immediately, instead of 
     appearing after usual grace threshold 
     "HIDECANCEL\n": the cancel button won't be added to the dialog box 
     and user_cancelled() will always return false (but 
     can be called to refresh UI) 
     Using "HIDECANCEL" implies "NODELAY" 
    Plugins must call hide_wait_box() to close the dialog box, otherwise 
    the user interface will remain disabled. 
     Note that, if the wait dialog is already visible, show_wait_box() will 
     1) push the currently-displayed text on a stack 
     2) display the new text 
    Then, when hide_wait_box() is called, if that stack isn't empty its top 
    label will be popped and restored in the wait dialog. 
    This implies that a plugin should call hide_wait_box() exactly as many 
    times as it called show_wait_box(), or the wait dialog might remain 
    visible and block the UI. 
    Also, in case the plugin knows the wait dialog is currently displayed, 
    alternatively it can call replace_wait_box(), to replace the text of the
    dialog without pushing the currently-displayed text on the stack. 
            
    """
    ...

def sizeof_ldbl() -> int:
    ...

def soff_to_fpoff(pfn: func_t, soff: int) -> int:
    r"""Convert struct offsets into fp-relative offsets. This function converts the offsets inside the udt_type_data_t object into the frame pointer offsets (for example, EBP-relative). 
            
    """
    ...

def split_sreg_range(ea: ida_idaapi.ea_t, rg: int, v: sel_t, tag: uchar, silent: bool = False) -> bool:
    r"""Create a new segment register range. This function is used when the IDP emulator detects that a segment register changes its value. 
            
    :param ea: linear address where the segment register will have a new value. if ea==BADADDR, nothing to do.
    :param rg: the number of the segment register
    :param v: the new value of the segment register. If the value is unknown, you should specify BADSEL.
    :param tag: the register info tag. see Segment register range tags
    :param silent: if false, display a warning() in the case of failure
    :returns: success
    """
    ...

def srcdbg_request_step_into() -> bool:
    ...

def srcdbg_request_step_over() -> bool:
    ...

def srcdbg_request_step_until_ret() -> bool:
    ...

def srcdbg_step_into() -> bool:
    ...

def srcdbg_step_over() -> bool:
    ...

def srcdbg_step_until_ret() -> bool:
    ...

def start_process(path: str = None, args: str = None, sdir: str = None) -> int:
    r"""Start a process in the debugger. \sq{Type, Asynchronous function - available as Request, Notification, dbg_process_start} 
            
    :param path: path to the executable to start
    :param args: arguments to pass to process
    :param sdir: starting directory for the process
    :returns: -1: impossible to create the process
    :returns: 0: the starting of the process was cancelled by the user
    :returns: 1: the process was properly started
    """
    ...

def std_out_segm_footer(ctx: outctx_t, seg: segment_t) -> None:
    r"""Generate segment footer line as a comment line. This function may be used in IDP modules to generate segment footer if the target assembler doesn't have 'ends' directive. 
            
    """
    ...

def step_into() -> bool:
    r"""Execute one instruction in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
            
    """
    ...

def step_into_backwards() -> bool:
    r"""Execute one instruction backwards in the current thread. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_into} 
            
    """
    ...

def step_over() -> bool:
    r"""Execute one instruction in the current thread, but without entering into functions. Others threads keep suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
            
    """
    ...

def step_over_backwards() -> bool:
    r"""Execute one instruction backwards in the current thread, but without entering into functions. Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_over} 
            
    """
    ...

def step_until_ret() -> bool:
    r"""Execute instructions in the current thread until a function return instruction is executed (aka "step out"). Other threads are kept suspended. \sq{Type, Asynchronous function - available as Request, Notification, dbg_step_until_ret} 
            
    """
    ...

def stkvar_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def store_exceptions() -> bool:
    r"""Update the exception information stored in the debugger module by invoking its dbg->set_exception_info callback 
            
    """
    ...

def store_til(ti: til_t, tildir: str, name: str) -> bool:
    r"""Store til to a file. If the til contains garbage, it will be collected before storing the til. Your plugin should call compact_til() before calling store_til(). 
            
    :param ti: type library to store
    :param tildir: directory where to store the til. nullptr means current directory.
    :param name: filename of the til. If it's an absolute path, tildir is ignored.
    * NB: the file extension is forced to .til
    :returns: success
    """
    ...

def str2ea(args: Any) -> uint64:
    r"""Convert string to linear address. Tries to interpret the string as: 
    1) "current IP" keyword if supported by assembler (e.g. "$" in x86) 
    2) segment:offset expression, where "segment" may be a name or a fixed segment register (e.g. cs, ds) 
    3) just segment name/register (translated to segment's start address) 
    4) a name in the database (or debug name during debugging) 
    5) hexadecimal value without prefix or suffix 
    6) +delta or -delta, where numerical 'delta' is added to or subtracted from 'screen_ea' 
    7) register name (only during debugging) 
    8) if all else fails, try to evaluate 'str' as an IDC expression
    
    :param str: string to parse
    :param screen_ea: the current address in the disassembly/pseudocode view
    :returns: success
    """
    ...

def str2ea_ex(args: Any) -> uint64:
    r"""Same as str2ea() but possibly with some steps skipped. 
            
    :param out: the buffer to put the result
    :param str: string to parse
    :param screen_ea: the current address in the disassembly/pseudocode view
    :param flags: see String to address conversion flags
    :returns: success
    """
    ...

def str2reg(p: str) -> int:
    r"""Get any register number (-1 on error)
    
    """
    ...

def str2sreg(name: str) -> Any:
    r"""get segment register number from its name or -1"""
    ...

def str2user(str: Any) -> Any:
    r"""Insert C-style escape characters to string
    
    :param str: the input string
    :returns: new string with escape characters inserted, or None
    """
    ...

def strarray(array: strarray_t, array_size: size_t, code: int) -> str:
    r"""Find a line with the specified code in the strarray_t array. If the last element of the array has code==0 then it is considered as the default entry. 
    If no default entry exists and the code is not found, strarray() returns "". 
            
    """
    ...

def strlit_flag() -> flags64_t:
    r"""Get a flags64_t representing a string literal.
    
    """
    ...

def stroff_as_size(plen: int, tif: tinfo_t, value: asize_t) -> bool:
    r"""Should display a structure offset expression as the structure size?
    
    """
    ...

def stroff_flag() -> flags64_t:
    r"""see FF_opbits
    
    """
    ...

def stru_flag() -> flags64_t:
    r"""Get a flags64_t representing a struct.
    
    """
    ...

def struct_unpack(buffer: Any, signed: Any = False, offs: Any = 0) -> Any:
    r"""
    Unpack a buffer given its length and offset using struct.unpack_from().
    This function will know how to unpack the given buffer by using the lookup table '__struct_unpack_table'
    If the buffer is of unknown length then None is returned. Otherwise the unpacked value is returned.
    
    """
    ...

def suspend_process() -> bool:
    r"""Suspend the process in the debugger. \sq{ Type,
    * Synchronous function (if in a notification handler)
    * Asynchronous function (everywhere else)
    * available as Request, Notification,
    * none (if in a notification handler)
    * dbg_suspend_process (everywhere else) }
    
    
    
    """
    ...

def suspend_thread(tid: thid_t) -> int:
    r"""Suspend thread. Suspending a thread may deadlock the whole application if the suspended was owning some synchronization objects. \sq{Type, Synchronous function - available as request, Notification, none (synchronous function)} 
            
    :param tid: thread id
    :returns: -1: network error
    :returns: 0: failed
    :returns: 1: ok
    """
    ...

def swap_idcvs(v1: idc_value_t, v2: idc_value_t) -> None:
    r"""Swap 2 variables.
    
    """
    ...

def swap_mcode_relation(code: mcode_t) -> mcode_t:
    ...

def swapped_relation(op: ctype_t) -> ctype_t:
    r"""Swap a comparison operator. For example, cot_sge becomes cot_sle.
    
    """
    ...

def switch_dbctx(idx: size_t) -> dbctx_t:
    r"""Switch to the database with the provided context ID 
            
    :param idx: the index of the database to switch to
    :returns: the current dbctx_t instance or nullptr
    """
    ...

def switch_info_t__from_ptrval__(ptrval: size_t) -> switch_info_t:
    ...

def switch_to_golang() -> None:
    r"""switch to GOLANG calling convention (to be used as default CC)
    
    """
    ...

def sync_sources(what: sync_source_t, _with: sync_source_t, sync: bool) -> bool:
    r"""[Un]synchronize sources 
            
    :returns: success
    """
    ...

def tag_addr(ea: ida_idaapi.ea_t) -> str:
    r"""Insert an address mark into a string. 
            
    :param ea: address to include
    """
    ...

def tag_advance(line: str, cnt: int) -> int:
    r"""Move pointer to a 'line' to 'cnt' positions right. Take into account escape sequences. 
            
    :param line: pointer to string
    :param cnt: number of positions to move right
    :returns: moved pointer
    """
    ...

def tag_remove(nonnul_instr: str) -> str:
    r"""Remove color escape sequences from a string. 
            
    :returns: length of resulting string, -1 if error
    """
    ...

def tag_skipcode(line: str) -> int:
    r"""Skip one color code. This function should be used if you are interested in color codes and want to analyze all of them. Otherwise tag_skipcodes() function is better since it will skip all colors at once. This function will skip the current color code if there is one. If the current symbol is not a color code, it will return the input. 
            
    :returns: moved pointer
    """
    ...

def tag_skipcodes(line: str) -> int:
    r"""Move the pointer past all color codes. 
            
    :param line: can't be nullptr
    :returns: moved pointer, can't be nullptr
    """
    ...

def tag_strlen(line: str) -> ssize_t:
    r"""Calculate length of a colored string This function computes the length in unicode codepoints of a line 
            
    :returns: the number of codepoints in the line, or -1 on error
    """
    ...

def take_database_snapshot(snapshot: Any) -> Any:
    r"""Take a database snapshot.
    
    :param snapshot: the snapshot object
    :returns: a tuple (success, error-message)
    """
    ...

def take_memory_snapshot(type: int) -> bool:
    r"""Take a memory snapshot of the running process. 
            
    :param type: specifies which snapshot we want (see SNAP_ Snapshot types)
    :returns: success
    """
    ...

def tbyte_flag() -> flags64_t:
    r"""Get a flags64_t representing a tbyte.
    
    """
    ...

def term_hexrays_plugin() -> None:
    r"""Stop working with hex-rays decompiler.
    
    """
    ...

def textctrl_info_t_assign(_self: Any, other: Any) -> bool:
    ...

def textctrl_info_t_create() -> Any:
    ...

def textctrl_info_t_destroy(py_obj: Any) -> bool:
    ...

def textctrl_info_t_get_clink(_self: Any) -> textctrl_info_t:
    ...

def textctrl_info_t_get_clink_ptr(_self: Any) -> Any:
    ...

def textctrl_info_t_get_flags(_self: Any) -> int:
    ...

def textctrl_info_t_get_tabsize(_self: Any) -> int:
    ...

def textctrl_info_t_get_text(_self: Any) -> str:
    ...

def textctrl_info_t_set_flags(_self: Any, flags: int) -> bool:
    ...

def textctrl_info_t_set_tabsize(_self: Any, tabsize: int) -> bool:
    ...

def textctrl_info_t_set_text(_self: Any, s: str) -> bool:
    ...

def throw_idc_exception(r: idc_value_t, desc: str) -> error_t:
    r"""Create an idc execution exception object. This helper function can be used to return an exception from C++ code to IDC. In other words this function can be called from idc_func_t() callbacks. Sample usage: if ( !ok ) return throw_idc_exception(r, "detailed error msg"); 
            
    :param r: object to hold the exception object
    :param desc: exception description
    :returns: eExecThrow
    """
    ...

def tinfo_errstr(code: tinfo_code_t) -> str:
    r"""Helper function to convert an error code into a printable string. Additional arguments are handled using the functions from err.h 
            
    """
    ...

def to_ea(reg_cs: sel_t, reg_ip: int) -> ida_idaapi.ea_t:
    r"""Convert (sel,off) value to a linear address.
    
    """
    ...

def toggle_bnot(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Toggle binary negation of operand. also see is_bnot()
    
    """
    ...

def toggle_lzero(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Toggle lzero bit. 
            
    :param ea: the item (insn/data) address
    :param n: the operand number (0-first operand, 1-other operands)
    :returns: success
    """
    ...

def toggle_sign(ea: ida_idaapi.ea_t, n: int) -> bool:
    r"""Toggle sign of n-th operand. allowed values of n: 0-first operand, 1-other operands 
            
    """
    ...

def try_to_add_libfunc(ea: ida_idaapi.ea_t) -> int:
    r"""Apply the currently loaded signature file to the specified address. If a library function is found, then create a function and name it accordingly. 
            
    :param ea: any address in the program
    :returns: Library function codes
    """
    ...

def ua_mnem(ea: ida_idaapi.ea_t) -> str:
    r"""Print instruction mnemonics. 
            
    :param ea: linear address of the instruction
    :returns: success
    """
    ...

def udcall_map_begin(map: udcall_map_t) -> udcall_map_iterator_t:
    r"""Get iterator pointing to the beginning of udcall_map_t.
    
    """
    ...

def udcall_map_clear(map: udcall_map_t) -> None:
    r"""Clear udcall_map_t.
    
    """
    ...

def udcall_map_end(map: udcall_map_t) -> udcall_map_iterator_t:
    r"""Get iterator pointing to the end of udcall_map_t.
    
    """
    ...

def udcall_map_erase(map: udcall_map_t, p: udcall_map_iterator_t) -> None:
    r"""Erase current element from udcall_map_t.
    
    """
    ...

def udcall_map_find(map: udcall_map_t, key: ea_t) -> udcall_map_iterator_t:
    r"""Find the specified key in udcall_map_t.
    
    """
    ...

def udcall_map_first(p: udcall_map_iterator_t) -> int:
    r"""Get reference to the current map key.
    
    """
    ...

def udcall_map_free(map: udcall_map_t) -> None:
    r"""Delete udcall_map_t instance.
    
    """
    ...

def udcall_map_insert(map: udcall_map_t, key: ea_t, val: udcall_t) -> udcall_map_iterator_t:
    r"""Insert new (ea_t, udcall_t) pair into udcall_map_t.
    
    """
    ...

def udcall_map_new() -> udcall_map_t:
    r"""Create a new udcall_map_t instance.
    
    """
    ...

def udcall_map_next(p: udcall_map_iterator_t) -> udcall_map_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def udcall_map_prev(p: udcall_map_iterator_t) -> udcall_map_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def udcall_map_second(p: udcall_map_iterator_t) -> udcall_t:
    r"""Get reference to the current map value.
    
    """
    ...

def udcall_map_size(map: udcall_map_t) -> int:
    r"""Get size of udcall_map_t.
    
    """
    ...

def udt_type_data_t__find_member(_this: udt_type_data_t, udm: udm_t, strmem_flags: int) -> ssize_t:
    ...

def udt_type_data_t__get_best_fit_member(_this: udt_type_data_t, disp: asize_t) -> ssize_t:
    ...

def ui_load_new_file(temp_file: str, filename: str, pli: linput_t, neflags: ushort, ploaders: load_info_t) -> bool:
    r"""Display a load file dialog and load file (ui_load_file). 
            
    :param temp_file: name of the file with the extracted archive member.
    :param filename: the name of input file as is, library or archive name
    :param pli: loader input source, may be changed to point to temp_file
    :param neflags: combination of NEF_... bits (see Load file flags)
    :param ploaders: list of loaders which accept file, may be changed for loaders of temp_file
    :returns: true: file was successfully loaded
    :returns: false: otherwise
    """
    ...

def ui_run_debugger(dbgopts: str, exename: str, argc: int, argv: Any) -> bool:
    r"""Load a debugger plugin and run the specified program (ui_run_dbg). 
            
    :param dbgopts: value of the -r command line switch
    :param exename: name of the file to run
    :param argc: number of arguments for the executable
    :param argv: argument vector
    :returns: success
    """
    ...

def unhide_border(ea: ida_idaapi.ea_t) -> None:
    ...

def unhide_item(ea: ida_idaapi.ea_t) -> None:
    ...

def unmark_selection() -> None:
    r"""Unmark selection (ui_unmarksel)
    
    """
    ...

def unpack_idcobj_from_bv(obj: idc_value_t, tif: tinfo_t, bytes: bytevec_t, pio_flags: int = 0) -> error_t:
    r"""Read a typed idc object from the byte vector.
    
    """
    ...

def unpack_idcobj_from_idb(obj: idc_value_t, tif: tinfo_t, ea: ida_idaapi.ea_t, off0: bytevec_t, pio_flags: int = 0) -> error_t:
    r"""Collection of register objects.
    
    Read a typed idc object from the database 
            
    """
    ...

def unpack_object_from_bv(til: til_t, type: bytes, fields: bytes, bytes: Any, pio_flags: int = 0) -> Any:
    r"""Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    
    :param til: Type library. 'None' can be passed.
    :param type: type string
    :param fields: fields string (may be empty or None)
    :param bytes: the bytes to unpack
    :param pio_flags: flags used while unpacking
    :returns: tuple(1, obj) on success, or tuple(0, err) on failure
    """
    ...

def unpack_object_from_idb(til: til_t, type: bytes, fields: bytes, ea: ida_idaapi.ea_t, pio_flags: int = 0) -> Any:
    r"""Unpacks from the database at 'ea' to an object.
    Please refer to unpack_object_from_bv()
    """
    ...

def unregister_action(name: str) -> bool:
    r"""Delete a previously-registered action (ui_unregister_action). 
            
    :param name: name of action
    :returns: success
    """
    ...

def unregister_custom_callcnv(cnv_decref: custom_callcnv_t) -> custom_callcnv_t:
    r"""Unregister a calling convention 
            
    :returns: true if successfully unregistered the custom calling convention
    """
    ...

def unregister_custom_data_format(dfid: Any) -> Any:
    r"""Unregisters a custom data format
    
    :param dfid: data format id
    :returns: Boolean
    """
    ...

def unregister_custom_data_type(dtid: Any) -> Any:
    r"""Unregisters a custom data type.
    
    :param dtid: the data type id
    :returns: Boolean
    """
    ...

def unregister_data_types_and_formats(formats: Any) -> Any:
    r"""
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.
    
    """
    ...

def unregister_timer(timer_obj: Any) -> Any:
    r"""Unregister a timer
    
    NOTE: After the timer has been deleted, the timer_obj will become invalid.
    
    :param timer_obj: a timer object previously returned by a register_timer()
    :returns: Boolean
    """
    ...

def upd_abits(ea: ida_idaapi.ea_t, clr_bits: aflags_t, set_bits: aflags_t) -> None:
    ...

def update_action_checkable(name: str, checkable: bool) -> bool:
    r"""Update an action's checkability (ui_update_action_attr). 
            
    :param name: action name
    :param checkable: new checkability
    :returns: success
    """
    ...

def update_action_checked(name: str, checked: bool) -> bool:
    r"""Update an action's checked state (ui_update_action_attr). 
            
    :param name: action name
    :param checked: new checked state
    :returns: success
    """
    ...

def update_action_icon(name: str, icon: int) -> bool:
    r"""Update an action's icon (ui_update_action_attr). 
            
    :param name: action name
    :param icon: new icon id
    :returns: success
    """
    ...

def update_action_label(name: str, label: str) -> bool:
    r"""Update an action's label (ui_update_action_attr). 
            
    :param name: action name
    :param label: new label
    :returns: success
    """
    ...

def update_action_shortcut(name: str, shortcut: str) -> bool:
    r"""Update an action's shortcut (ui_update_action_attr). 
            
    :param name: action name
    :param shortcut: new shortcut
    :returns: success
    """
    ...

def update_action_state(name: str, state: action_state_t) -> bool:
    r"""Update an action's state (ui_update_action_attr). 
            
    :param name: action name
    :param state: new state
    :returns: success
    """
    ...

def update_action_tooltip(name: str, tooltip: str) -> bool:
    r"""Update an action's tooltip (ui_update_action_attr). 
            
    :param name: action name
    :param tooltip: new tooltip
    :returns: success
    """
    ...

def update_action_visibility(name: str, visible: bool) -> bool:
    r"""Update an action's visibility (ui_update_action_attr). 
            
    :param name: action name
    :param visible: new visibility
    :returns: success
    """
    ...

def update_bpt(bpt: bpt_t) -> bool:
    r"""Update modifiable characteristics of an existing breakpoint. To update the breakpoint location, use change_bptlocs() \sq{Type, Synchronous function, Notification, none (synchronous function)} 
            
    """
    ...

def update_extra_cmt(ea: ida_idaapi.ea_t, what: int, str: str) -> bool:
    ...

def update_fpd(pfn: func_t, fpd: asize_t) -> bool:
    r"""Update frame pointer delta. 
            
    :param pfn: pointer to function structure
    :param fpd: new fpd value. cannot be bigger than the local variable range size.
    :returns: success
    """
    ...

def update_func(pfn: func_t) -> bool:
    r"""Update information about a function in the database (func_t). You must not change the function start and end addresses using this function. Use set_func_start() and set_func_end() for it. 
            
    :param pfn: ptr to function structure
    :returns: success
    """
    ...

def update_hidden_range(ha: hidden_range_t) -> bool:
    r"""Update hidden range information in the database. You cannot use this function to change the range boundaries 
            
    :param ha: range to update
    :returns: success
    """
    ...

def update_segm(s: segment_t) -> bool:
    ...

def use_golang_cc() -> bool:
    r"""is GOLANG calling convention used by default?
    
    """
    ...

def use_mapping(ea: ida_idaapi.ea_t) -> ida_idaapi.ea_t:
    r"""Translate address according to current mappings. 
            
    :param ea: address to translate
    :returns: translated address
    """
    ...

def user_cancelled() -> bool:
    r"""Test the cancellation flag (ui_test_cancelled). 
            
    :returns: true: Cancelled, a message is displayed
    :returns: false: Not cancelled
    """
    ...

def user_cmts_begin(map: user_cmts_t) -> user_cmts_iterator_t:
    r"""Get iterator pointing to the beginning of user_cmts_t.
    
    """
    ...

def user_cmts_clear(map: user_cmts_t) -> None:
    r"""Clear user_cmts_t.
    
    """
    ...

def user_cmts_end(map: user_cmts_t) -> user_cmts_iterator_t:
    r"""Get iterator pointing to the end of user_cmts_t.
    
    """
    ...

def user_cmts_erase(map: user_cmts_t, p: user_cmts_iterator_t) -> None:
    r"""Erase current element from user_cmts_t.
    
    """
    ...

def user_cmts_find(map: user_cmts_t, key: treeloc_t) -> user_cmts_iterator_t:
    r"""Find the specified key in user_cmts_t.
    
    """
    ...

def user_cmts_first(p: user_cmts_iterator_t) -> treeloc_t:
    r"""Get reference to the current map key.
    
    """
    ...

def user_cmts_free(map: user_cmts_t) -> None:
    r"""Delete user_cmts_t instance.
    
    """
    ...

def user_cmts_insert(map: user_cmts_t, key: treeloc_t, val: citem_cmt_t) -> user_cmts_iterator_t:
    r"""Insert new (treeloc_t, citem_cmt_t) pair into user_cmts_t.
    
    """
    ...

def user_cmts_new() -> user_cmts_t:
    r"""Create a new user_cmts_t instance.
    
    """
    ...

def user_cmts_next(p: user_cmts_iterator_t) -> user_cmts_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def user_cmts_prev(p: user_cmts_iterator_t) -> user_cmts_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def user_cmts_second(p: user_cmts_iterator_t) -> citem_cmt_t:
    r"""Get reference to the current map value.
    
    """
    ...

def user_cmts_size(map: user_cmts_t) -> int:
    r"""Get size of user_cmts_t.
    
    """
    ...

def user_iflags_begin(map: user_iflags_t) -> user_iflags_iterator_t:
    r"""Get iterator pointing to the beginning of user_iflags_t.
    
    """
    ...

def user_iflags_clear(map: user_iflags_t) -> None:
    r"""Clear user_iflags_t.
    
    """
    ...

def user_iflags_end(map: user_iflags_t) -> user_iflags_iterator_t:
    r"""Get iterator pointing to the end of user_iflags_t.
    
    """
    ...

def user_iflags_erase(map: user_iflags_t, p: user_iflags_iterator_t) -> None:
    r"""Erase current element from user_iflags_t.
    
    """
    ...

def user_iflags_find(map: user_iflags_t, key: citem_locator_t) -> user_iflags_iterator_t:
    r"""Find the specified key in user_iflags_t.
    
    """
    ...

def user_iflags_first(p: user_iflags_iterator_t) -> citem_locator_t:
    r"""Get reference to the current map key.
    
    """
    ...

def user_iflags_free(map: user_iflags_t) -> None:
    r"""Delete user_iflags_t instance.
    
    """
    ...

def user_iflags_insert(map: user_iflags_t, key: citem_locator_t, val: int32) -> user_iflags_iterator_t:
    r"""Insert new (citem_locator_t, int32) pair into user_iflags_t.
    
    """
    ...

def user_iflags_new() -> user_iflags_t:
    r"""Create a new user_iflags_t instance.
    
    """
    ...

def user_iflags_next(p: user_iflags_iterator_t) -> user_iflags_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def user_iflags_prev(p: user_iflags_iterator_t) -> user_iflags_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def user_iflags_second(p: user_iflags_iterator_t) -> int32:
    r"""Get reference to the current map value.
    
    """
    ...

def user_iflags_size(map: user_iflags_t) -> int:
    r"""Get size of user_iflags_t.
    
    """
    ...

def user_labels_begin(map: user_labels_t) -> user_labels_iterator_t:
    r"""Get iterator pointing to the beginning of user_labels_t.
    
    """
    ...

def user_labels_clear(map: user_labels_t) -> None:
    r"""Clear user_labels_t.
    
    """
    ...

def user_labels_end(map: user_labels_t) -> user_labels_iterator_t:
    r"""Get iterator pointing to the end of user_labels_t.
    
    """
    ...

def user_labels_erase(map: user_labels_t, p: user_labels_iterator_t) -> None:
    r"""Erase current element from user_labels_t.
    
    """
    ...

def user_labels_find(map: user_labels_t, key: int) -> user_labels_iterator_t:
    r"""Find the specified key in user_labels_t.
    
    """
    ...

def user_labels_first(p: user_labels_iterator_t) -> int:
    r"""Get reference to the current map key.
    
    """
    ...

def user_labels_free(map: user_labels_t) -> None:
    r"""Delete user_labels_t instance.
    
    """
    ...

def user_labels_insert(map: user_labels_t, key: int, val: str) -> user_labels_iterator_t:
    r"""Insert new (int, qstring) pair into user_labels_t.
    
    """
    ...

def user_labels_new() -> user_labels_t:
    r"""Create a new user_labels_t instance.
    
    """
    ...

def user_labels_next(p: user_labels_iterator_t) -> user_labels_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def user_labels_prev(p: user_labels_iterator_t) -> user_labels_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def user_labels_second(p: user_labels_iterator_t) -> str:
    r"""Get reference to the current map value.
    
    """
    ...

def user_labels_size(map: user_labels_t) -> int:
    r"""Get size of user_labels_t.
    
    """
    ...

def user_numforms_begin(map: user_numforms_t) -> user_numforms_iterator_t:
    r"""Get iterator pointing to the beginning of user_numforms_t.
    
    """
    ...

def user_numforms_clear(map: user_numforms_t) -> None:
    r"""Clear user_numforms_t.
    
    """
    ...

def user_numforms_end(map: user_numforms_t) -> user_numforms_iterator_t:
    r"""Get iterator pointing to the end of user_numforms_t.
    
    """
    ...

def user_numforms_erase(map: user_numforms_t, p: user_numforms_iterator_t) -> None:
    r"""Erase current element from user_numforms_t.
    
    """
    ...

def user_numforms_find(map: user_numforms_t, key: operand_locator_t) -> user_numforms_iterator_t:
    r"""Find the specified key in user_numforms_t.
    
    """
    ...

def user_numforms_first(p: user_numforms_iterator_t) -> operand_locator_t:
    r"""Get reference to the current map key.
    
    """
    ...

def user_numforms_free(map: user_numforms_t) -> None:
    r"""Delete user_numforms_t instance.
    
    """
    ...

def user_numforms_insert(map: user_numforms_t, key: operand_locator_t, val: number_format_t) -> user_numforms_iterator_t:
    r"""Insert new (operand_locator_t, number_format_t) pair into user_numforms_t.
    
    """
    ...

def user_numforms_new() -> user_numforms_t:
    r"""Create a new user_numforms_t instance.
    
    """
    ...

def user_numforms_next(p: user_numforms_iterator_t) -> user_numforms_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def user_numforms_prev(p: user_numforms_iterator_t) -> user_numforms_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def user_numforms_second(p: user_numforms_iterator_t) -> number_format_t:
    r"""Get reference to the current map value.
    
    """
    ...

def user_numforms_size(map: user_numforms_t) -> int:
    r"""Get size of user_numforms_t.
    
    """
    ...

def user_unions_begin(map: user_unions_t) -> user_unions_iterator_t:
    r"""Get iterator pointing to the beginning of user_unions_t.
    
    """
    ...

def user_unions_clear(map: user_unions_t) -> None:
    r"""Clear user_unions_t.
    
    """
    ...

def user_unions_end(map: user_unions_t) -> user_unions_iterator_t:
    r"""Get iterator pointing to the end of user_unions_t.
    
    """
    ...

def user_unions_erase(map: user_unions_t, p: user_unions_iterator_t) -> None:
    r"""Erase current element from user_unions_t.
    
    """
    ...

def user_unions_find(map: user_unions_t, key: ea_t) -> user_unions_iterator_t:
    r"""Find the specified key in user_unions_t.
    
    """
    ...

def user_unions_first(p: user_unions_iterator_t) -> int:
    r"""Get reference to the current map key.
    
    """
    ...

def user_unions_free(map: user_unions_t) -> None:
    r"""Delete user_unions_t instance.
    
    """
    ...

def user_unions_insert(map: user_unions_t, key: ea_t, val: intvec_t) -> user_unions_iterator_t:
    r"""Insert new (ea_t, intvec_t) pair into user_unions_t.
    
    """
    ...

def user_unions_new() -> user_unions_t:
    r"""Create a new user_unions_t instance.
    
    """
    ...

def user_unions_next(p: user_unions_iterator_t) -> user_unions_iterator_t:
    r"""Move to the next element.
    
    """
    ...

def user_unions_prev(p: user_unions_iterator_t) -> user_unions_iterator_t:
    r"""Move to the previous element.
    
    """
    ...

def user_unions_second(p: user_unions_iterator_t) -> intvec_t:
    r"""Get reference to the current map value.
    
    """
    ...

def user_unions_size(map: user_unions_t) -> int:
    r"""Get size of user_unions_t.
    
    """
    ...

def uses_aflag_modsp(flags: aflags_t) -> bool:
    ...

def uses_modsp(ea: ida_idaapi.ea_t) -> bool:
    ...

def validate_idb(vld_flags: int = 0) -> int:
    r"""Validate the database 
            
    :param vld_flags: combination of VLD_.. constants
    :returns: number of corrupted/fixed records
    """
    ...

def validate_name(name: str, type: nametype_t, flags: int = 1) -> Any:
    r"""Validate a name. If SN_NOCHECK is specified, this function replaces all invalid characters in the name with SUBSTCHAR. However, it will return false if name is valid but not allowed to be an identifier (is a register name).
    
    :param name: ptr to name. the name will be modified
    :param type: the type of name we want to validate
    :param flags: see SN_*
    :returns: success
    """
    ...

def value_repr_t__from_opinfo(_this: value_repr_t, flags: flags64_t, afl: aflags_t, opinfo: opinfo_t, ap: array_parameters_t) -> bool:
    ...

def value_repr_t__print_(_this: value_repr_t, colored: bool) -> str:
    ...

def verify_argloc(vloc: argloc_t, size: int, gaps: rangeset_t) -> int:
    r"""Verify argloc_t. 
            
    :param vloc: argloc to verify
    :param size: total size of the variable
    :param gaps: if not nullptr, specifies gaps in structure definition. these gaps should not map to any argloc, but everything else must be covered
    :returns: 0 if ok, otherwise an interr code.
    """
    ...

def verify_tinfo(typid: typid_t) -> int:
    ...

def viewer_attach_menu_item(g: graph_viewer_t, name: str) -> bool:
    r"""Attach a previously-registered action to the view's context menu. See kernwin.hpp for how to register actions. 
            
    :param g: graph viewer
    :param name: action name
    :returns: success
    """
    ...

def viewer_center_on(gv: graph_viewer_t, node: int) -> None:
    r"""Center the graph view on the given node.
    
    """
    ...

def viewer_create_groups(gv: graph_viewer_t, out_group_nodes: intvec_t, gi: groups_crinfos_t) -> bool:
    r"""This will perform an operation similar to what happens when a user manually selects a set of nodes, right-clicks and selects "Create group". This is a wrapper around interactive_graph_t::create_group that will, in essence:
    * clone the current graph
    * for each group_crinfo_t, attempt creating group in that new graph
    * if all were successful, animate to that new graph.
    
    
    
    """
    ...

def viewer_del_node_info(gv: graph_viewer_t, n: int) -> None:
    r"""Delete node info for node in given viewer (see del_node_info())
    
    """
    ...

def viewer_delete_groups(gv: graph_viewer_t, groups: intvec_t, new_current: int = -1) -> bool:
    r"""Wrapper around interactive_graph_t::delete_group. This function will:
    * clone the current graph
    * attempt deleting the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            
    """
    ...

def viewer_fit_window(gv: graph_viewer_t) -> None:
    r"""Fit graph viewer to its parent form.
    
    """
    ...

def viewer_get_curnode(gv: graph_viewer_t) -> int:
    r"""Get number of currently selected node (-1 if none)
    
    """
    ...

def viewer_get_gli(out: graph_location_info_t, gv: graph_viewer_t, flags: int = 0) -> bool:
    r"""Get location info for given graph view If flags contains GLICTL_CENTER, then the gli that will be retrieved, will be the one at the center of the view. Otherwise it will be the top-left. 
            
    """
    ...

def viewer_get_node_info(gv: graph_viewer_t, out: node_info_t, n: int) -> bool:
    r"""Get node info for node in given viewer (see get_node_info())
    
    """
    ...

def viewer_get_selection(gv: graph_viewer_t, sgs: screen_graph_selection_t) -> bool:
    r"""Get currently selected items for graph viewer.
    
    """
    ...

def viewer_set_gli(gv: graph_viewer_t, gli: graph_location_info_t, flags: int = 0) -> None:
    r"""Set location info for given graph view If flags contains GLICTL_CENTER, then the gli will be set to be the center of the view. Otherwise it will be the top-left. 
            
    """
    ...

def viewer_set_groups_visibility(gv: graph_viewer_t, groups: intvec_t, expand: bool, new_current: int = -1) -> bool:
    r"""Wrapper around interactive_graph_t::change_visibility. This function will:
    * clone the current graph
    * attempt changing visibility of the groups in that new graph
    * if successful, animate to that new graph. 
    
    
            
    """
    ...

def viewer_set_node_info(gv: graph_viewer_t, n: int, ni: node_info_t, flags: int) -> None:
    r"""Set node info for node in given viewer (see set_node_info())
    
    """
    ...

def viewer_set_titlebar_height(gv: graph_viewer_t, height: int) -> int:
    r"""Set height of node title bars (grcode_set_titlebar_height)
    
    """
    ...

def visit_patched_bytes(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t, callable: Any) -> Any:
    r"""Enumerates patched bytes in the given range and invokes a callable
    
    :param ea1: start address
    :param ea2: end address
    :param callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    :returns: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.
    """
    ...

def visit_stroff_udms(sfv: udm_visitor_t, path: tid_t, disp: adiff_t, appzero: bool) -> adiff_t:
    r"""Visit structure fields in a stroff expression or in a reference to a struct data variable. This function can be used to enumerate all components of an expression like 'a.b.c'. 
            
    :param sfv: visitor object
    :param path: struct path (path[0] contains the initial struct id)
    :param disp: offset into structure
    :param appzero: should visit field at offset zero?
    :returns: visitor result
    """
    ...

def visit_subtypes(visitor: tinfo_visitor_t, out: type_mods_t, tif: tinfo_t, name: str, cmt: str) -> int:
    ...

def wait_for_next_event(wfne: int, timeout: int) -> dbg_event_code_t:
    r"""Wait for the next event.
    This function (optionally) resumes the process execution, and waits for a debugger event until a possible timeout occurs.
    
    :param wfne: combination of Wait for debugger event flags constants
    :param timeout: number of seconds to wait, -1-infinity
    :returns: either an event_id_t (if > 0), or a dbg_event_code_t (if <= 0)
    """
    ...

def warning(message: Any) -> Any:
    r"""Display a message in a warning message box
    
    :param message: message to print
    """
    ...

def was_ida_decision(ea: ida_idaapi.ea_t) -> bool:
    ...

def word_flag() -> flags64_t:
    r"""Get a flags64_t representing a word.
    
    """
    ...

def write_dbg_memory(args: Any) -> ssize_t:
    ...

def write_tinfo_bitfield_value(typid: typid_t, dst: uint64, v: uint64, bitoff: int) -> uint64:
    ...

def writebytes(h: int, l: int, size: int, mf: bool) -> int:
    r"""Write at most 4 bytes to file. 
            
    :param h: file handle
    :param l: value to write
    :param size: size of value in bytes (1,2,4)
    :param mf: is MSB first?
    :returns: 0 on success, nonzero otherwise
    """
    ...

def xrefchar(xrtype: char) -> char:
    r"""Get character describing the xref type. 
            
    :param xrtype: combination of Cross-Reference type flags and a cref_t of dref_t value
    """
    ...

def yword_flag() -> flags64_t:
    r"""Get a flags64_t representing a ymm word.
    
    """
    ...

def zword_flag() -> flags64_t:
    r"""Get a flags64_t representing a zmm word.
    
    """
    ...

A80_addc: int  # 171
A80_addcix: int  # 172
A80_addciy: int  # 173
A80_addix: int  # 169
A80_addiy: int  # 170
A80_cmpd: int  # 182
A80_cmpi: int  # 181
A80_im0: int  # 183
A80_im1: int  # 184
A80_im2: int  # 185
A80_jrc: int  # 177
A80_jrnc: int  # 178
A80_jrnz: int  # 180
A80_jrz: int  # 179
A80_lbcd: int  # 149
A80_lded: int  # 150
A80_lixd: int  # 152
A80_liyd: int  # 153
A80_lspd: int  # 151
A80_mvai: int  # 168
A80_mvar: int  # 167
A80_mvia: int  # 166
A80_mvra: int  # 165
A80_otd: int  # 186
A80_oti: int  # 187
A80_pcix: int  # 163
A80_pciy: int  # 164
A80_sbcd: int  # 154
A80_sded: int  # 155
A80_sixd: int  # 157
A80_siyd: int  # 158
A80_spix: int  # 161
A80_spiy: int  # 162
A80_sspd: int  # 156
A80_subc: int  # 174
A80_subcix: int  # 175
A80_subciy: int  # 176
A80_xtix: int  # 159
A80_xtiy: int  # 160
AA_CHECKABLE: int  # 6
AA_CHECKED: int  # 7
AA_ICON: int  # 4
AA_LABEL: int  # 1
AA_NONE: int  # 0
AA_SHORTCUT: int  # 2
AA_STATE: int  # 5
AA_TOOLTIP: int  # 3
AA_VISIBILITY: int  # 8
ABI_8ALIGN4: int  # 1
ABI_BIGARG_ALIGN: int  # 4
ABI_GCC_LAYOUT: int  # 128
ABI_HARD_FLOAT: int  # 32
ABI_HUGEARG_ALIGN: int  # 512
ABI_MAP_STKARGS: int  # 256
ABI_PACK_STKARGS: int  # 2
ABI_SET_BY_USER: int  # 64
ABI_STACK_LDBL: int  # 8
ABI_STACK_VARARGS: int  # 16
ABS_NO: int  # 1
ABS_UNK: int  # 0
ABS_YES: int  # 2
ACCEPT_ARCHIVE: int  # 8192
ACCEPT_CONTINUE: int  # 16384
ACCEPT_FIRST: int  # 32768
ACFL_BLKOPT: int  # 2
ACFL_GLBDEL: int  # 8
ACFL_GLBPROP: int  # 4
ACFL_GUESS: int  # 16
ACFL_LOCOPT: int  # 1
ACF_HAS_FIELD_DIRTREE_SELECTION: int  # 4
ACF_HAS_SELECTION: int  # 1
ACF_HAS_SOURCE: int  # 8
ACF_HAS_TYPE_REF: int  # 16
ACF_XTRN_EA: int  # 2
AD218X_alu_00: int  # 48
AD218X_alu_01: int  # 49
AD218X_alu_02: int  # 50
AD218X_alu_03: int  # 51
AD218X_alu_04: int  # 52
AD218X_alu_05: int  # 53
AD218X_alu_06: int  # 54
AD218X_alu_07: int  # 55
AD218X_alu_08: int  # 56
AD218X_alu_09: int  # 57
AD218X_alu_0a: int  # 58
AD218X_alu_0b: int  # 59
AD218X_alu_0c: int  # 60
AD218X_alu_0d: int  # 61
AD218X_alu_0e: int  # 62
AD218X_alu_0f: int  # 63
AD218X_alu_10: int  # 64
AD218X_alu_11: int  # 65
AD218X_alu_12: int  # 66
AD218X_alu_13: int  # 67
AD218X_alu_14: int  # 68
AD218X_alu_15: int  # 69
AD218X_alu_16: int  # 70
AD218X_alu_17: int  # 71
AD218X_alu_18: int  # 72
AD218X_alu_19: int  # 73
AD218X_alu_1a: int  # 74
AD218X_alu_1b: int  # 75
AD218X_alu_1c: int  # 76
AD218X_alu_1d: int  # 77
AD218X_amf: int  # 90
AD218X_amf_01: int  # 1
AD218X_amf_02: int  # 3
AD218X_amf_03: int  # 2
AD218X_amf_04: int  # 4
AD218X_amf_05: int  # 5
AD218X_amf_06: int  # 6
AD218X_amf_07: int  # 7
AD218X_amf_08: int  # 8
AD218X_amf_09: int  # 9
AD218X_amf_0a: int  # 10
AD218X_amf_0b: int  # 11
AD218X_amf_0c: int  # 12
AD218X_amf_0d: int  # 13
AD218X_amf_0e: int  # 14
AD218X_amf_0f: int  # 15
AD218X_amf_10: int  # 16
AD218X_amf_11: int  # 17
AD218X_amf_12: int  # 18
AD218X_amf_13: int  # 19
AD218X_amf_14: int  # 20
AD218X_amf_15: int  # 21
AD218X_amf_16: int  # 22
AD218X_amf_17: int  # 23
AD218X_amf_18: int  # 24
AD218X_amf_19: int  # 25
AD218X_amf_1a: int  # 26
AD218X_amf_1b: int  # 27
AD218X_amf_1c: int  # 28
AD218X_amf_1d: int  # 29
AD218X_amf_1e: int  # 30
AD218X_amf_1f: int  # 31
AD218X_amf_move_0: int  # 137
AD218X_amf_move_1: int  # 138
AD218X_amf_move_2: int  # 139
AD218X_amf_move_3: int  # 140
AD218X_amf_move_4: int  # 141
AD218X_amf_move_5: int  # 142
AD218X_amf_move_6: int  # 143
AD218X_amf_move_7: int  # 144
AD218X_amf_move_8: int  # 145
AD218X_amf_move_9: int  # 146
AD218X_amf_move_a: int  # 147
AD218X_call: int  # 117
AD218X_call_1: int  # 118
AD218X_call_2: int  # 119
AD218X_do: int  # 125
AD218X_double_move: int  # 136
AD218X_flag_out: int  # 128
AD218X_idle: int  # 126
AD218X_idle_1: int  # 127
AD218X_ints_dis: int  # 133
AD218X_ints_ena: int  # 134
AD218X_jump: int  # 112
AD218X_jump_1: int  # 113
AD218X_jump_2: int  # 114
AD218X_jump_3: int  # 115
AD218X_jump_4: int  # 116
AD218X_last: int  # 148
AD218X_mac_0: int  # 78
AD218X_mac_1: int  # 79
AD218X_mac_2: int  # 80
AD218X_mac_3: int  # 81
AD218X_mac_4: int  # 82
AD218X_mac_5: int  # 83
AD218X_mac_6: int  # 84
AD218X_mac_7: int  # 85
AD218X_mac_8: int  # 86
AD218X_mac_9: int  # 87
AD218X_mac_a: int  # 88
AD218X_mac_b: int  # 89
AD218X_mode_ctl: int  # 130
AD218X_modify: int  # 135
AD218X_move_0: int  # 100
AD218X_move_1: int  # 101
AD218X_move_2: int  # 102
AD218X_move_3: int  # 103
AD218X_move_4: int  # 104
AD218X_move_5: int  # 105
AD218X_move_6: int  # 106
AD218X_move_7: int  # 107
AD218X_move_8: int  # 108
AD218X_move_9: int  # 109
AD218X_move_a: int  # 110
AD218X_move_b: int  # 111
AD218X_nop: int  # 124
AD218X_null: int  # 0
AD218X_rti: int  # 122
AD218X_rti_cond: int  # 123
AD218X_rts: int  # 120
AD218X_rts_cond: int  # 121
AD218X_shft: int  # 91
AD218X_shft_0: int  # 32
AD218X_shft_1: int  # 33
AD218X_shft_2: int  # 34
AD218X_shft_3: int  # 35
AD218X_shft_4: int  # 36
AD218X_shft_5: int  # 37
AD218X_shft_6: int  # 38
AD218X_shft_7: int  # 39
AD218X_shft_8: int  # 40
AD218X_shft_9: int  # 41
AD218X_shft_a: int  # 42
AD218X_shft_b: int  # 43
AD218X_shft_c: int  # 44
AD218X_shft_d: int  # 45
AD218X_shft_e: int  # 46
AD218X_shft_f: int  # 47
AD218X_shifter_0: int  # 92
AD218X_shifter_1: int  # 93
AD218X_shifter_2: int  # 94
AD218X_shifter_3: int  # 95
AD218X_shifter_4: int  # 96
AD218X_shifter_5: int  # 97
AD218X_shifter_6: int  # 98
AD218X_shifter_7: int  # 99
AD218X_stack_ctl: int  # 129
AD218X_tops_r: int  # 132
AD218X_tops_w: int  # 131
ADDSEG_FILLGAP: int  # 16
ADDSEG_IDBENC: int  # 128
ADDSEG_NOAA: int  # 64
ADDSEG_NOSREG: int  # 1
ADDSEG_NOTRUNC: int  # 4
ADDSEG_OR_DIE: int  # 2
ADDSEG_QUIET: int  # 8
ADDSEG_SPARSE: int  # 32
ADDTIL_ABORTED: int  # 3
ADDTIL_COMP: int  # 2
ADDTIL_DEFAULT: int  # 0
ADDTIL_FAILED: int  # 0
ADDTIL_INCOMP: int  # 1
ADDTIL_OK: int  # 1
ADDTIL_SILENT: int  # 2
ADF_CHECKABLE: int  # 64
ADF_CHECKED: int  # 128
ADF_GLOBAL: int  # 16
ADF_NO_HIGHLIGHT: int  # 32
ADF_NO_UNDO: int  # 2
ADF_OT_MASK: int  # 12
ADF_OT_PLUGIN: int  # 0
ADF_OT_PLUGMOD: int  # 4
ADF_OT_PROCMOD: int  # 8
ADF_OWN_HANDLER: int  # 1
AEF_IDBENC: int  # 1
AEF_NODUMMY: int  # 2
AEF_NOFORCE: int  # 8
AEF_UTF8: int  # 0
AEF_WEAK: int  # 4
AF2_DOEH: int  # 1
AF2_DORTTI: int  # 2
AF2_MACRO: int  # 4
AF2_MERGESTR: int  # 8
AFL_ALIGNFLOW: int  # 16777216
AFL_BNOT0: int  # 256
AFL_BNOT1: int  # 512
AFL_COLORED: int  # 262144
AFL_FIXEDSPD: int  # 8388608
AFL_HIDDEN: int  # 16
AFL_HR_DETERMINED: int  # -1073741824
AFL_HR_GUESSED_DATA: int  # -2147483648
AFL_HR_GUESSED_FUNC: int  # 1073741824
AFL_IDA_GUESSED: int  # 0
AFL_LIB: int  # 1024
AFL_LINNUM: int  # 1
AFL_LNAME: int  # 16384
AFL_LZERO0: int  # 65536
AFL_LZERO1: int  # 131072
AFL_MANUAL: int  # 32
AFL_NOBRD: int  # 64
AFL_NORET: int  # 4194304
AFL_NOTCODE: int  # 268435456
AFL_NOTPROC: int  # 536870912
AFL_PUBNAM: int  # 4
AFL_RETFP: int  # 67108864
AFL_SIGN0: int  # 1048576
AFL_SIGN1: int  # 2097152
AFL_TERSESTR: int  # 524288
AFL_TI: int  # 2048
AFL_TI0: int  # 4096
AFL_TI1: int  # 8192
AFL_TILCMT: int  # 32768
AFL_TYPE_GUESSED: int  # -1040187392
AFL_USEMODSP: int  # 134217728
AFL_USERSP: int  # 2
AFL_USERTI: int  # 33554432
AFL_WEAKNAM: int  # 8
AFL_ZSTROFF: int  # 128
AF_ANORET: int  # 16384
AF_CHKUNI: int  # 262144
AF_CODE: int  # 1
AF_DATOFF: int  # 4194304
AF_DOCODE: int  # 1073741824
AF_DODATA: int  # 536870912
AF_DREFOFF: int  # 1048576
AF_FINAL: int  # 2147483648
AF_FIXUP: int  # 524288
AF_FLIRT: int  # 8388608
AF_FTAIL: int  # 256
AF_HFLIRT: int  # 67108864
AF_IMMOFF: int  # 2097152
AF_JFUNC: int  # 134217728
AF_JUMPTBL: int  # 4
AF_LVAR: int  # 512
AF_MARKCODE: int  # 2
AF_MEMFUNC: int  # 32768
AF_NULLSUB: int  # 268435456
AF_PROC: int  # 128
AF_PROCPTR: int  # 64
AF_PURDAT: int  # 8
AF_REGARG: int  # 2048
AF_SIGCMT: int  # 16777216
AF_SIGMLT: int  # 33554432
AF_STKARG: int  # 1024
AF_STRLIT: int  # 131072
AF_TRACE: int  # 4096
AF_TRFUNC: int  # 65536
AF_UNK: int  # 32
AF_USED: int  # 16
AF_VERSP: int  # 8192
AHF_VERSION: int  # 1
AHF_VERSION_MASK: int  # 255
ALLOW_UNUSED_LABELS: int  # 1
ALOC_CUSTOM: int  # 7
ALOC_DIST: int  # 2
ALOC_NONE: int  # 0
ALOC_REG1: int  # 3
ALOC_REG2: int  # 4
ALOC_RREL: int  # 5
ALOC_STACK: int  # 1
ALOC_STATIC: int  # 6
ALOPT_APPEND: int  # 32
ALOPT_IGNCLT: int  # 4
ALOPT_IGNHEADS: int  # 1
ALOPT_IGNPRINT: int  # 2
ALOPT_MAX4K: int  # 8
ALOPT_ONLYTERM: int  # 16
ALPHA_addf: int  # 1
ALPHA_addg: int  # 2
ALPHA_addl: int  # 3
ALPHA_addl_v: int  # 4
ALPHA_addq: int  # 5
ALPHA_addq_v: int  # 6
ALPHA_adds: int  # 7
ALPHA_addt: int  # 8
ALPHA_amask: int  # 9
ALPHA_and: int  # 10
ALPHA_andnot: int  # 220
ALPHA_beq: int  # 11
ALPHA_bge: int  # 12
ALPHA_bgt: int  # 13
ALPHA_bic: int  # 14
ALPHA_bis: int  # 15
ALPHA_blbc: int  # 16
ALPHA_blbs: int  # 17
ALPHA_ble: int  # 18
ALPHA_blt: int  # 19
ALPHA_bne: int  # 20
ALPHA_br: int  # 21
ALPHA_br0: int  # 222
ALPHA_bsr: int  # 22
ALPHA_call_pal: int  # 23
ALPHA_clr: int  # 203
ALPHA_cmoveq: int  # 24
ALPHA_cmovge: int  # 25
ALPHA_cmovgt: int  # 26
ALPHA_cmovlbc: int  # 27
ALPHA_cmovlbs: int  # 28
ALPHA_cmovle: int  # 29
ALPHA_cmovlt: int  # 30
ALPHA_cmovne: int  # 31
ALPHA_cmpbge: int  # 32
ALPHA_cmpeq: int  # 33
ALPHA_cmpgeq: int  # 34
ALPHA_cmpgle: int  # 35
ALPHA_cmpglt: int  # 36
ALPHA_cmple: int  # 37
ALPHA_cmplt: int  # 38
ALPHA_cmpteq: int  # 39
ALPHA_cmptle: int  # 40
ALPHA_cmptlt: int  # 41
ALPHA_cmptun: int  # 42
ALPHA_cmpule: int  # 43
ALPHA_cmpult: int  # 44
ALPHA_cpys: int  # 45
ALPHA_cpyse: int  # 46
ALPHA_cpysn: int  # 47
ALPHA_ctlz: int  # 48
ALPHA_ctpop: int  # 49
ALPHA_cttz: int  # 50
ALPHA_cvtdg: int  # 51
ALPHA_cvtgd: int  # 52
ALPHA_cvtgf: int  # 53
ALPHA_cvtgq: int  # 54
ALPHA_cvtlq: int  # 55
ALPHA_cvtqf: int  # 56
ALPHA_cvtqg: int  # 57
ALPHA_cvtql: int  # 58
ALPHA_cvtqs: int  # 59
ALPHA_cvtqt: int  # 60
ALPHA_cvtst: int  # 61
ALPHA_cvttq: int  # 62
ALPHA_cvtts: int  # 63
ALPHA_divf: int  # 64
ALPHA_divg: int  # 65
ALPHA_divs: int  # 66
ALPHA_divt: int  # 67
ALPHA_ecb: int  # 68
ALPHA_eqv: int  # 69
ALPHA_excb: int  # 70
ALPHA_extbl: int  # 71
ALPHA_extlh: int  # 72
ALPHA_extll: int  # 73
ALPHA_extqh: int  # 74
ALPHA_extql: int  # 75
ALPHA_extwh: int  # 76
ALPHA_extwl: int  # 77
ALPHA_fabs: int  # 204
ALPHA_fbeq: int  # 78
ALPHA_fbge: int  # 79
ALPHA_fbgt: int  # 80
ALPHA_fble: int  # 81
ALPHA_fblt: int  # 82
ALPHA_fbne: int  # 83
ALPHA_fclr: int  # 205
ALPHA_fcmoveq: int  # 84
ALPHA_fcmovge: int  # 85
ALPHA_fcmovgt: int  # 86
ALPHA_fcmovle: int  # 87
ALPHA_fcmovlt: int  # 88
ALPHA_fcmovne: int  # 89
ALPHA_fetch: int  # 90
ALPHA_fetch_m: int  # 91
ALPHA_fmov: int  # 206
ALPHA_fneg: int  # 207
ALPHA_fnop: int  # 202
ALPHA_ftois: int  # 92
ALPHA_ftoit: int  # 93
ALPHA_implver: int  # 94
ALPHA_insbl: int  # 95
ALPHA_inslh: int  # 96
ALPHA_insll: int  # 97
ALPHA_insqh: int  # 98
ALPHA_insql: int  # 99
ALPHA_inswh: int  # 100
ALPHA_inswl: int  # 101
ALPHA_itoff: int  # 102
ALPHA_itofs: int  # 103
ALPHA_itoft: int  # 104
ALPHA_jmp: int  # 105
ALPHA_jsr: int  # 106
ALPHA_jsr_coroutine: int  # 107
ALPHA_last: int  # 223
ALPHA_lda: int  # 108
ALPHA_ldah: int  # 109
ALPHA_ldbu: int  # 110
ALPHA_ldf: int  # 112
ALPHA_ldg: int  # 113
ALPHA_ldl: int  # 114
ALPHA_ldl_l: int  # 115
ALPHA_ldq: int  # 116
ALPHA_ldq_l: int  # 117
ALPHA_ldq_u: int  # 118
ALPHA_lds: int  # 119
ALPHA_ldt: int  # 120
ALPHA_ldwu: int  # 111
ALPHA_maxsb8: int  # 121
ALPHA_maxsw4: int  # 122
ALPHA_maxub8: int  # 123
ALPHA_maxuw4: int  # 124
ALPHA_mb: int  # 125
ALPHA_mf_fpcr: int  # 126
ALPHA_minsb8: int  # 127
ALPHA_minsw4: int  # 128
ALPHA_minub8: int  # 129
ALPHA_minuw4: int  # 130
ALPHA_mov: int  # 208
ALPHA_mskbl: int  # 131
ALPHA_msklh: int  # 132
ALPHA_mskll: int  # 133
ALPHA_mskqh: int  # 134
ALPHA_mskql: int  # 135
ALPHA_mskwh: int  # 136
ALPHA_mskwl: int  # 137
ALPHA_mt_fpcr: int  # 138
ALPHA_mulf: int  # 139
ALPHA_mulg: int  # 140
ALPHA_mull: int  # 141
ALPHA_mull_v: int  # 142
ALPHA_mulq: int  # 143
ALPHA_mulq_v: int  # 144
ALPHA_muls: int  # 145
ALPHA_mult: int  # 146
ALPHA_negf: int  # 213
ALPHA_negg: int  # 214
ALPHA_negl: int  # 209
ALPHA_negl_v: int  # 210
ALPHA_negq: int  # 211
ALPHA_negq_v: int  # 212
ALPHA_negs: int  # 215
ALPHA_negt: int  # 216
ALPHA_nop: int  # 201
ALPHA_not: int  # 217
ALPHA_null: int  # 0
ALPHA_or: int  # 219
ALPHA_ornot: int  # 147
ALPHA_perr: int  # 148
ALPHA_pklb: int  # 149
ALPHA_pkwb: int  # 150
ALPHA_rc: int  # 151
ALPHA_ret: int  # 152
ALPHA_rpcc: int  # 153
ALPHA_rs: int  # 154
ALPHA_s4addl: int  # 155
ALPHA_s4addq: int  # 156
ALPHA_s4subl: int  # 157
ALPHA_s4subq: int  # 158
ALPHA_s8addl: int  # 159
ALPHA_s8addq: int  # 160
ALPHA_s8subl: int  # 161
ALPHA_s8subq: int  # 162
ALPHA_sextb: int  # 163
ALPHA_sextl: int  # 218
ALPHA_sextw: int  # 164
ALPHA_sll: int  # 165
ALPHA_sqrtf: int  # 166
ALPHA_sqrtg: int  # 167
ALPHA_sqrts: int  # 168
ALPHA_sqrtt: int  # 169
ALPHA_sra: int  # 170
ALPHA_srl: int  # 171
ALPHA_stb: int  # 172
ALPHA_stf: int  # 173
ALPHA_stg: int  # 174
ALPHA_stl: int  # 176
ALPHA_stl_c: int  # 177
ALPHA_stq: int  # 178
ALPHA_stq_c: int  # 179
ALPHA_stq_u: int  # 180
ALPHA_sts: int  # 175
ALPHA_stt: int  # 181
ALPHA_stw: int  # 182
ALPHA_subf: int  # 183
ALPHA_subg: int  # 184
ALPHA_subl: int  # 185
ALPHA_subl_v: int  # 186
ALPHA_subq: int  # 187
ALPHA_subq_v: int  # 188
ALPHA_subs: int  # 189
ALPHA_subt: int  # 190
ALPHA_trapb: int  # 191
ALPHA_umulh: int  # 192
ALPHA_unop: int  # 200
ALPHA_unpkbl: int  # 193
ALPHA_unpkbw: int  # 194
ALPHA_wh64: int  # 195
ALPHA_wmb: int  # 196
ALPHA_xor: int  # 197
ALPHA_xornot: int  # 221
ALPHA_zap: int  # 198
ALPHA_zapnot: int  # 199
ANCHOR_BLKCMT: int  # 536870912
ANCHOR_CITEM: int  # 0
ANCHOR_INDEX: int  # 536870911
ANCHOR_ITP: int  # -2147483648
ANCHOR_LVAR: int  # 1073741824
ANCHOR_MASK: int  # -1073741824
ANY_FPSIZE: int  # 256
ANY_REGSIZE: int  # 128
APPCALL_DEBEV: int  # 2
APPCALL_MANUAL: int  # 1
APPCALL_TIMEOUT: int  # 4
APPT_16BIT: int  # 128
APPT_1THREAD: int  # 32
APPT_32BIT: int  # 256
APPT_64BIT: int  # 512
APPT_CONSOLE: int  # 1
APPT_DRIVER: int  # 16
APPT_GRAPHIC: int  # 2
APPT_LIBRARY: int  # 8
APPT_MTHREAD: int  # 64
APPT_PROGRAM: int  # 4
AP_ALLOWDUPS: int  # 1
AP_ARRAY: int  # 8
AP_IDXBASEMASK: int  # 240
AP_IDXBIN: int  # 48
AP_IDXDEC: int  # 0
AP_IDXHEX: int  # 16
AP_IDXOCT: int  # 32
AP_INDEX: int  # 4
AP_SIGNED: int  # 2
ARC_abs: int  # 46
ARC_abss: int  # 73
ARC_abssh: int  # 74
ARC_abssw: int  # 74
ARC_acm: int  # 104
ARC_adc: int  # 20
ARC_adcs: int  # 202
ARC_add: int  # 19
ARC_add1: int  # 47
ARC_add2: int  # 48
ARC_add3: int  # 49
ARC_addqbs: int  # 105
ARC_adds: int  # 75
ARC_addsdw: int  # 76
ARC_aex: int  # 141
ARC_and: int  # 23
ARC_asl: int  # 34
ARC_aslacc: int  # 248
ARC_asls: int  # 77
ARC_aslsacc: int  # 249
ARC_asr: int  # 6
ARC_asr16: int  # 216
ARC_asr8: int  # 217
ARC_asrs: int  # 78
ARC_asrsr: int  # 162
ARC_avgqb: int  # 106
ARC_b: int  # 14
ARC_bbit0: int  # 41
ARC_bbit1: int  # 42
ARC_bclr: int  # 50
ARC_bi: int  # 138
ARC_bic: int  # 25
ARC_bih: int  # 139
ARC_bl: int  # 15
ARC_bmsk: int  # 51
ARC_bmskn: int  # 142
ARC_br: int  # 43
ARC_brk: int  # 31
ARC_bset: int  # 52
ARC_bspeek: int  # 244
ARC_bspop: int  # 245
ARC_bspush: int  # 212
ARC_btst: int  # 53
ARC_bxor: int  # 54
ARC_cbflyhf0r: int  # 281
ARC_cbflyhf1r: int  # 300
ARC_clamp: int  # 107
ARC_clri: int  # 155
ARC_cmacchfr: int  # 261
ARC_cmacchnfr: int  # 260
ARC_cmachfr: int  # 259
ARC_cmachnfr: int  # 258
ARC_cmp: int  # 55
ARC_cmpychfr: int  # 254
ARC_cmpychnfr: int  # 257
ARC_cmpyhfmr: int  # 280
ARC_cmpyhfr: int  # 253
ARC_cmpyhnfr: int  # 252
ARC_daddh11: int  # 108
ARC_daddh12: int  # 109
ARC_daddh21: int  # 110
ARC_daddh22: int  # 111
ARC_dexcl1: int  # 112
ARC_dexcl2: int  # 113
ARC_div: int  # 158
ARC_divaw: int  # 79
ARC_divf: int  # 268
ARC_divu: int  # 159
ARC_dmach: int  # 169
ARC_dmachbl: int  # 277
ARC_dmachbm: int  # 278
ARC_dmachf: int  # 209
ARC_dmachfr: int  # 210
ARC_dmachu: int  # 170
ARC_dmpyh: int  # 167
ARC_dmpyhbl: int  # 275
ARC_dmpyhbm: int  # 276
ARC_dmpyhf: int  # 207
ARC_dmpyhfr: int  # 208
ARC_dmpyhu: int  # 168
ARC_dmpyhwf: int  # 204
ARC_dmulh11: int  # 114
ARC_dmulh12: int  # 115
ARC_dmulh21: int  # 116
ARC_dmulh22: int  # 117
ARC_drsubh11: int  # 122
ARC_drsubh12: int  # 123
ARC_drsubh21: int  # 124
ARC_drsubh22: int  # 125
ARC_dsubh11: int  # 118
ARC_dsubh12: int  # 119
ARC_dsubh21: int  # 120
ARC_dsubh22: int  # 121
ARC_ei: int  # 309
ARC_enter: int  # 156
ARC_ex: int  # 56
ARC_extb: int  # 10
ARC_exth: int  # 11
ARC_extw: int  # 11
ARC_fadd: int  # 126
ARC_fcvt32: int  # 306
ARC_ffs: int  # 222
ARC_flag: int  # 5
ARC_flagacc: int  # 250
ARC_fls: int  # 223
ARC_fmul: int  # 127
ARC_fsadd: int  # 126
ARC_fscmp: int  # 301
ARC_fscmpf: int  # 302
ARC_fsdiv: int  # 305
ARC_fsmadd: int  # 303
ARC_fsmsub: int  # 304
ARC_fsmul: int  # 127
ARC_fssqrt: int  # 307
ARC_fssub: int  # 128
ARC_fsub: int  # 128
ARC_fxtr: int  # 129
ARC_getacc: int  # 224
ARC_iaddr: int  # 130
ARC_j: int  # 17
ARC_jl: int  # 18
ARC_jli: int  # 308
ARC_kflag: int  # 310
ARC_last: int  # 312
ARC_ld: int  # 1
ARC_ldi: int  # 140
ARC_leave: int  # 157
ARC_llock: int  # 152
ARC_lp: int  # 16
ARC_lr: int  # 2
ARC_lsl: int  # 29
ARC_lsl16: int  # 214
ARC_lsl8: int  # 219
ARC_lsr: int  # 7
ARC_lsr16: int  # 215
ARC_lsr8: int  # 218
ARC_mac: int  # 165
ARC_macd: int  # 181
ARC_macdf: int  # 272
ARC_macdu: int  # 182
ARC_macdw: int  # 90
ARC_macf: int  # 264
ARC_macflw: int  # 98
ARC_macfr: int  # 265
ARC_machflw: int  # 101
ARC_machlw: int  # 100
ARC_machulw: int  # 99
ARC_maclw: int  # 97
ARC_macrdw: int  # 92
ARC_macu: int  # 166
ARC_macudw: int  # 91
ARC_macwhfl: int  # 292
ARC_macwhflr: int  # 293
ARC_macwhfm: int  # 288
ARC_macwhfmr: int  # 289
ARC_macwhkl: int  # 294
ARC_macwhkul: int  # 295
ARC_macwhl: int  # 283
ARC_macwhul: int  # 285
ARC_max: int  # 37
ARC_min: int  # 38
ARC_modif: int  # 251
ARC_mov: int  # 27
ARC_mpy: int  # 57
ARC_mpyd: int  # 179
ARC_mpydf: int  # 271
ARC_mpydu: int  # 180
ARC_mpyf: int  # 262
ARC_mpyfr: int  # 263
ARC_mpyh: int  # 58
ARC_mpyhm: int  # 59
ARC_mpyhu: int  # 59
ARC_mpym: int  # 58
ARC_mpyqb: int  # 131
ARC_mpyu: int  # 60
ARC_mpyuw: int  # 137
ARC_mpyw: int  # 136
ARC_mpywhfl: int  # 290
ARC_mpywhflr: int  # 291
ARC_mpywhfm: int  # 286
ARC_mpywhfmr: int  # 287
ARC_mpywhkl: int  # 296
ARC_mpywhkul: int  # 297
ARC_mpywhl: int  # 282
ARC_mpywhul: int  # 284
ARC_msubdf: int  # 274
ARC_msubdw: int  # 93
ARC_msubf: int  # 266
ARC_msubfr: int  # 267
ARC_msubwhfl: int  # 273
ARC_msubwhflr: int  # 279
ARC_msubwhfm: int  # 298
ARC_msubwhfmr: int  # 299
ARC_mul64: int  # 35
ARC_muldw: int  # 87
ARC_mulflw: int  # 96
ARC_mulhflw: int  # 103
ARC_mulhlw: int  # 102
ARC_mullw: int  # 95
ARC_mulrdw: int  # 89
ARC_mulu64: int  # 36
ARC_muludw: int  # 88
ARC_mululw: int  # 94
ARC_neg: int  # 61
ARC_negs: int  # 80
ARC_negsh: int  # 81
ARC_negsw: int  # 81
ARC_nop: int  # 28
ARC_norm: int  # 40
ARC_normacc: int  # 225
ARC_normh: int  # 82
ARC_normw: int  # 82
ARC_not: int  # 62
ARC_null: int  # 0
ARC_or: int  # 24
ARC_pkqb: int  # 133
ARC_pop: int  # 44
ARC_push: int  # 45
ARC_rcmp: int  # 63
ARC_rem: int  # 160
ARC_remu: int  # 161
ARC_rlc: int  # 30
ARC_rnd16: int  # 83
ARC_rndh: int  # 83
ARC_rol: int  # 151
ARC_rol8: int  # 220
ARC_ror: int  # 12
ARC_ror8: int  # 221
ARC_rrc: int  # 13
ARC_rsub: int  # 64
ARC_rtie: int  # 65
ARC_sat16: int  # 84
ARC_satf: int  # 226
ARC_sath: int  # 84
ARC_sbc: int  # 22
ARC_sbcs: int  # 203
ARC_scond: int  # 153
ARC_setacc: int  # 164
ARC_seteq: int  # 143
ARC_setge: int  # 146
ARC_setgt: int  # 150
ARC_seths: int  # 148
ARC_seti: int  # 154
ARC_setle: int  # 149
ARC_setlo: int  # 147
ARC_setlt: int  # 145
ARC_setne: int  # 144
ARC_sexb: int  # 8
ARC_sexh: int  # 9
ARC_sexw: int  # 9
ARC_sfxtr: int  # 132
ARC_sleep: int  # 32
ARC_sqrt: int  # 246
ARC_sqrtf: int  # 247
ARC_sr: int  # 4
ARC_st: int  # 3
ARC_store_instructions: int  # 4
ARC_sub: int  # 21
ARC_sub1: int  # 66
ARC_sub2: int  # 67
ARC_sub3: int  # 68
ARC_subs: int  # 85
ARC_subsdw: int  # 86
ARC_swap: int  # 39
ARC_swape: int  # 213
ARC_swi: int  # 33
ARC_sync: int  # 69
ARC_trap: int  # 70
ARC_tst: int  # 71
ARC_unimp: int  # 72
ARC_upkqb: int  # 134
ARC_vabs2h: int  # 239
ARC_vabss2h: int  # 240
ARC_vadd2h: int  # 171
ARC_vadd4b: int  # 198
ARC_vadds2h: int  # 172
ARC_vaddsub2h: int  # 175
ARC_vaddsubs2h: int  # 176
ARC_valgn2h: int  # 163
ARC_vasl2h: int  # 192
ARC_vasls2h: int  # 193
ARC_vasr2h: int  # 194
ARC_vasrs2h: int  # 195
ARC_vasrsr2h: int  # 197
ARC_vext2bhl: int  # 235
ARC_vext2bhlf: int  # 231
ARC_vext2bhm: int  # 236
ARC_vext2bhmf: int  # 232
ARC_vlsr2h: int  # 196
ARC_vmac2h: int  # 187
ARC_vmac2hf: int  # 188
ARC_vmac2hfr: int  # 190
ARC_vmac2hnfr: int  # 269
ARC_vmac2hu: int  # 189
ARC_vmax2h: int  # 199
ARC_vmin2h: int  # 201
ARC_vmpy2h: int  # 183
ARC_vmpy2hf: int  # 184
ARC_vmpy2hfr: int  # 186
ARC_vmpy2hu: int  # 185
ARC_vmpy2hwf: int  # 191
ARC_vmsub2hf: int  # 255
ARC_vmsub2hfr: int  # 256
ARC_vmsub2hnfr: int  # 270
ARC_vneg2h: int  # 241
ARC_vnegs2h: int  # 242
ARC_vnorm2h: int  # 243
ARC_vpack2hbl: int  # 227
ARC_vpack2hblf: int  # 229
ARC_vpack2hbm: int  # 228
ARC_vpack2hbmf: int  # 230
ARC_vpack2hl: int  # 205
ARC_vpack2hm: int  # 206
ARC_vperm: int  # 211
ARC_vrep2hl: int  # 233
ARC_vrep2hm: int  # 234
ARC_vsext2bhl: int  # 237
ARC_vsext2bhm: int  # 238
ARC_vsub2h: int  # 173
ARC_vsub4b: int  # 200
ARC_vsubadd2h: int  # 177
ARC_vsubadds2h: int  # 178
ARC_vsubs2h: int  # 174
ARC_wevt: int  # 311
ARC_xor: int  # 26
ARC_xpkqb: int  # 135
ARGREGS_BY_SLOTS: int  # 3
ARGREGS_FP_MASKS_GP: int  # 4
ARGREGS_GP_ONLY: int  # 1
ARGREGS_INDEPENDENT: int  # 2
ARGREGS_MIPS_O32: int  # 5
ARGREGS_POLICY_UNDEFINED: int  # 0
ARGREGS_RISCV: int  # 6
ARM_abs: int  # 556
ARM_adc: int  # 15
ARM_add: int  # 14
ARM_addg: int  # 895
ARM_addhn: int  # 563
ARM_addhn2: int  # 564
ARM_addp: int  # 678
ARM_addv: int  # 793
ARM_adr: int  # 44
ARM_adrl: int  # 81
ARM_adrp: int  # 497
ARM_aesd: int  # 449
ARM_aese: int  # 450
ARM_aesimc: int  # 451
ARM_aesmc: int  # 452
ARM_amx: int  # 959
ARM_and: int  # 10
ARM_asr: int  # 5
ARM_asrl: int  # 1087
ARM_at: int  # 539
ARM_aut: int  # 869
ARM_autg: int  # 1098
ARM_axflag: int  # 894
ARM_b: int  # 3
ARM_bcax: int  # 918
ARM_bf: int  # 1109
ARM_bfc: int  # 273
ARM_bfcsel: int  # 1113
ARM_bfcvt: int  # 951
ARM_bfcvtn: int  # 949
ARM_bfcvtn2: int  # 950
ARM_bfdot: int  # 948
ARM_bfi: int  # 272
ARM_bfl: int  # 1111
ARM_bflx: int  # 1112
ARM_bfm: int  # 498
ARM_bfmlalb: int  # 946
ARM_bfmlalt: int  # 947
ARM_bfmmla: int  # 945
ARM_bfx: int  # 1110
ARM_bfxil: int  # 501
ARM_bic: int  # 24
ARM_bif: int  # 573
ARM_bit: int  # 574
ARM_bkpt: int  # 45
ARM_bl: int  # 4
ARM_blr: int  # 471
ARM_blx1: int  # 46
ARM_blx2: int  # 47
ARM_br: int  # 470
ARM_brk: int  # 542
ARM_bsl: int  # 575
ARM_bti: int  # 910
ARM_bx: int  # 41
ARM_bxaut: int  # 1099
ARM_bxj: int  # 166
ARM_cas: int  # 856
ARM_casa: int  # 858
ARM_casal: int  # 859
ARM_casl: int  # 857
ARM_casp: int  # 860
ARM_caspa: int  # 862
ARM_caspal: int  # 863
ARM_caspl: int  # 861
ARM_cbnz: int  # 283
ARM_cbz: int  # 282
ARM_ccmn: int  # 521
ARM_ccmp: int  # 522
ARM_cdp: int  # 83
ARM_cdp2: int  # 84
ARM_cfinv: int  # 889
ARM_chka: int  # 292
ARM_cinc: int  # 517
ARM_cinv: int  # 518
ARM_clrex: int  # 256
ARM_cls: int  # 509
ARM_clz: int  # 48
ARM_cmeq: int  # 576
ARM_cmge: int  # 579
ARM_cmgt: int  # 582
ARM_cmhi: int  # 581
ARM_cmhs: int  # 578
ARM_cmle: int  # 585
ARM_cmlo: int  # 587
ARM_cmls: int  # 584
ARM_cmlt: int  # 588
ARM_cmn: int  # 21
ARM_cmp: int  # 20
ARM_cmpp: int  # 898
ARM_cmtst: int  # 788
ARM_cneg: int  # 519
ARM_cnt: int  # 595
ARM_cps: int  # 169
ARM_cpsid: int  # 170
ARM_cpsie: int  # 171
ARM_crc32: int  # 873
ARM_crc32c: int  # 874
ARM_csel: int  # 511
ARM_cset: int  # 515
ARM_csetm: int  # 516
ARM_csinc: int  # 512
ARM_csinv: int  # 513
ARM_csneg: int  # 514
ARM_cx1: int  # 1114
ARM_cx1A: int  # 1115
ARM_cx1d: int  # 1116
ARM_cx1dA: int  # 1117
ARM_cx2: int  # 1118
ARM_cx2A: int  # 1119
ARM_cx2d: int  # 1120
ARM_cx2dA: int  # 1121
ARM_cx3: int  # 1122
ARM_cx3A: int  # 1123
ARM_cx3d: int  # 1124
ARM_cx3dA: int  # 1125
ARM_dbg: int  # 287
ARM_dc: int  # 538
ARM_dcps1: int  # 463
ARM_dcps2: int  # 464
ARM_dcps3: int  # 465
ARM_dls: int  # 1103
ARM_dlstp: int  # 1105
ARM_dmb: int  # 285
ARM_drps: int  # 534
ARM_dsb: int  # 284
ARM_dup: int  # 627
ARM_enterx: int  # 290
ARM_eon: int  # 507
ARM_eor: int  # 11
ARM_eor3: int  # 919
ARM_eret: int  # 429
ARM_esb: int  # 1101
ARM_ext: int  # 629
ARM_extr: int  # 504
ARM_fabd: int  # 551
ARM_fabs: int  # 557
ARM_fabsd: int  # 95
ARM_fabss: int  # 96
ARM_facge: int  # 558
ARM_facgt: int  # 559
ARM_facle: int  # 560
ARM_faclt: int  # 561
ARM_fadd: int  # 562
ARM_faddd: int  # 97
ARM_faddp: int  # 679
ARM_fadds: int  # 98
ARM_fccmp: int  # 592
ARM_fccmpe: int  # 593
ARM_fcmeq: int  # 577
ARM_fcmge: int  # 580
ARM_fcmgt: int  # 583
ARM_fcmle: int  # 586
ARM_fcmlt: int  # 589
ARM_fcmp: int  # 590
ARM_fcmpd: int  # 99
ARM_fcmpe: int  # 591
ARM_fcmped: int  # 101
ARM_fcmpes: int  # 102
ARM_fcmpezd: int  # 103
ARM_fcmpezs: int  # 104
ARM_fcmps: int  # 100
ARM_fcmpzd: int  # 105
ARM_fcmpzs: int  # 106
ARM_fcpyd: int  # 107
ARM_fcpys: int  # 108
ARM_fcsel: int  # 594
ARM_fcvt: int  # 596
ARM_fcvtas: int  # 598
ARM_fcvtau: int  # 603
ARM_fcvtds: int  # 110
ARM_fcvtl: int  # 611
ARM_fcvtl2: int  # 612
ARM_fcvtms: int  # 601
ARM_fcvtmu: int  # 606
ARM_fcvtn: int  # 609
ARM_fcvtn2: int  # 610
ARM_fcvtns: int  # 599
ARM_fcvtnu: int  # 604
ARM_fcvtps: int  # 600
ARM_fcvtpu: int  # 605
ARM_fcvtsd: int  # 109
ARM_fcvtxn: int  # 613
ARM_fcvtxn2: int  # 614
ARM_fcvtzs: int  # 597
ARM_fcvtzu: int  # 602
ARM_fdiv: int  # 626
ARM_fdivd: int  # 111
ARM_fdivs: int  # 112
ARM_fjcvtzs: int  # 886
ARM_fldd: int  # 113
ARM_fldmd: int  # 115
ARM_fldms: int  # 116
ARM_fldmx: int  # 117
ARM_flds: int  # 114
ARM_fmacd: int  # 118
ARM_fmacs: int  # 119
ARM_fmadd: int  # 622
ARM_fmax: int  # 644
ARM_fmaxnm: int  # 645
ARM_fmaxnmp: int  # 685
ARM_fmaxnmv: int  # 799
ARM_fmaxp: int  # 684
ARM_fmaxv: int  # 798
ARM_fmdhr: int  # 154
ARM_fmdlr: int  # 156
ARM_fmdrr: int  # 162
ARM_fmin: int  # 648
ARM_fminnm: int  # 649
ARM_fminnmp: int  # 689
ARM_fminnmv: int  # 803
ARM_fminp: int  # 688
ARM_fminv: int  # 802
ARM_fmla: int  # 650
ARM_fmlal: int  # 941
ARM_fmlal2: int  # 942
ARM_fmls: int  # 653
ARM_fmlsl: int  # 943
ARM_fmlsl2: int  # 944
ARM_fmov: int  # 660
ARM_fmrdh: int  # 155
ARM_fmrdl: int  # 157
ARM_fmrrd: int  # 163
ARM_fmrrs: int  # 165
ARM_fmrs: int  # 161
ARM_fmrx: int  # 159
ARM_fmscd: int  # 120
ARM_fmscs: int  # 121
ARM_fmsr: int  # 160
ARM_fmsrr: int  # 164
ARM_fmstat: int  # 122
ARM_fmsub: int  # 623
ARM_fmul: int  # 667
ARM_fmuld: int  # 123
ARM_fmuls: int  # 124
ARM_fmulx: int  # 669
ARM_fmxr: int  # 158
ARM_fneg: int  # 675
ARM_fnegd: int  # 125
ARM_fnegs: int  # 126
ARM_fnmacd: int  # 127
ARM_fnmacs: int  # 128
ARM_fnmadd: int  # 624
ARM_fnmscd: int  # 129
ARM_fnmscs: int  # 130
ARM_fnmsub: int  # 625
ARM_fnmul: int  # 670
ARM_fnmuld: int  # 131
ARM_fnmuls: int  # 132
ARM_frecpe: int  # 732
ARM_frecps: int  # 733
ARM_frecpx: int  # 734
ARM_frint32x: int  # 914
ARM_frint32z: int  # 915
ARM_frint64x: int  # 916
ARM_frint64z: int  # 917
ARM_frinta: int  # 615
ARM_frinti: int  # 616
ARM_frintm: int  # 617
ARM_frintn: int  # 618
ARM_frintp: int  # 619
ARM_frintx: int  # 620
ARM_frintz: int  # 621
ARM_frsqrte: int  # 745
ARM_frsqrts: int  # 746
ARM_fsitod: int  # 133
ARM_fsitos: int  # 134
ARM_fsqrt: int  # 765
ARM_fsqrtd: int  # 135
ARM_fsqrts: int  # 136
ARM_fstd: int  # 137
ARM_fstmd: int  # 139
ARM_fstms: int  # 140
ARM_fstmx: int  # 141
ARM_fsts: int  # 138
ARM_fsub: int  # 773
ARM_fsubd: int  # 142
ARM_fsubs: int  # 143
ARM_ftosid: int  # 144
ARM_ftosis: int  # 145
ARM_ftosizd: int  # 146
ARM_ftosizs: int  # 147
ARM_ftouid: int  # 148
ARM_ftouis: int  # 149
ARM_ftouizd: int  # 150
ARM_ftouizs: int  # 151
ARM_fuitod: int  # 152
ARM_fuitos: int  # 153
ARM_genter: int  # 954
ARM_gexit: int  # 955
ARM_gmi: int  # 900
ARM_hb: int  # 293
ARM_hbl: int  # 294
ARM_hblp: int  # 295
ARM_hbp: int  # 296
ARM_hint: int  # 541
ARM_hlt: int  # 466
ARM_hvc: int  # 430
ARM_ic: int  # 537
ARM_ins: int  # 628
ARM_irg: int  # 899
ARM_isb: int  # 286
ARM_it: int  # 278
ARM_last: int  # 1134
ARM_lctp: int  # 1095
ARM_ld1: int  # 634
ARM_ld1r: int  # 638
ARM_ld2: int  # 635
ARM_ld2r: int  # 639
ARM_ld3: int  # 636
ARM_ld3r: int  # 640
ARM_ld4: int  # 637
ARM_ld4r: int  # 641
ARM_lda: int  # 431
ARM_ldadd: int  # 808
ARM_ldadda: int  # 810
ARM_ldaddal: int  # 811
ARM_ldaddl: int  # 809
ARM_ldaex: int  # 433
ARM_ldapr: int  # 807
ARM_ldapur: int  # 887
ARM_ldar: int  # 484
ARM_ldaxp: int  # 488
ARM_ldaxr: int  # 486
ARM_ldc: int  # 85
ARM_ldc2: int  # 86
ARM_ldclr: int  # 814
ARM_ldclra: int  # 816
ARM_ldclral: int  # 817
ARM_ldclrl: int  # 815
ARM_ldeor: int  # 820
ARM_ldeora: int  # 822
ARM_ldeoral: int  # 823
ARM_ldeorl: int  # 821
ARM_ldg: int  # 908
ARM_ldgm: int  # 909
ARM_ldlar: int  # 864
ARM_ldm: int  # 33
ARM_ldnp: int  # 476
ARM_ldp: int  # 474
ARM_ldr: int  # 30
ARM_ldrd: int  # 49
ARM_ldrd2: int  # 871
ARM_ldrex: int  # 172
ARM_ldrexb: int  # 257
ARM_ldrexd: int  # 258
ARM_ldrexh: int  # 259
ARM_ldrpc: int  # 31
ARM_ldset: int  # 826
ARM_ldseta: int  # 828
ARM_ldsetal: int  # 829
ARM_ldsetl: int  # 827
ARM_ldsmax: int  # 832
ARM_ldsmaxa: int  # 834
ARM_ldsmaxal: int  # 835
ARM_ldsmaxl: int  # 833
ARM_ldsmin: int  # 838
ARM_ldsmina: int  # 840
ARM_ldsminal: int  # 841
ARM_ldsminl: int  # 839
ARM_ldtr: int  # 478
ARM_ldumax: int  # 844
ARM_ldumaxa: int  # 846
ARM_ldumaxal: int  # 847
ARM_ldumaxl: int  # 845
ARM_ldumin: int  # 850
ARM_ldumina: int  # 852
ARM_lduminal: int  # 853
ARM_lduminl: int  # 851
ARM_ldur: int  # 472
ARM_ldxp: int  # 482
ARM_ldxr: int  # 480
ARM_le1: int  # 1106
ARM_le2: int  # 1107
ARM_leavex: int  # 291
ARM_letp: int  # 1108
ARM_lsl: int  # 6
ARM_lsll: int  # 1085
ARM_lsr: int  # 7
ARM_lsrl: int  # 1086
ARM_madd: int  # 523
ARM_mcr: int  # 91
ARM_mcr2: int  # 92
ARM_mcrr: int  # 93
ARM_mcrr2: int  # 167
ARM_mla: int  # 29
ARM_mls: int  # 279
ARM_mneg: int  # 525
ARM_mov: int  # 23
ARM_movi: int  # 492
ARM_movk: int  # 496
ARM_movl: int  # 80
ARM_movn: int  # 495
ARM_movt: int  # 269
ARM_movz: int  # 494
ARM_mrc: int  # 89
ARM_mrc2: int  # 90
ARM_mrrc: int  # 94
ARM_mrrc2: int  # 168
ARM_mrs: int  # 26
ARM_msr: int  # 27
ARM_msub: int  # 524
ARM_mul: int  # 28
ARM_mul53hi: int  # 961
ARM_mul53lo: int  # 960
ARM_mvn: int  # 25
ARM_mvni: int  # 493
ARM_neg: int  # 9
ARM_ngc: int  # 520
ARM_nop: int  # 2
ARM_not: int  # 508
ARM_null: int  # 0
ARM_orn: int  # 268
ARM_orr: int  # 22
ARM_pac: int  # 868
ARM_pacbti: int  # 1097
ARM_pacg: int  # 1100
ARM_pkhbt: int  # 173
ARM_pkhtb: int  # 174
ARM_pld: int  # 50
ARM_pldw: int  # 880
ARM_pli: int  # 276
ARM_pmul: int  # 668
ARM_pmull: int  # 673
ARM_pmull2: int  # 674
ARM_pop: int  # 42
ARM_prfm: int  # 490
ARM_prfum: int  # 491
ARM_pssbb: int  # 913
ARM_push: int  # 43
ARM_qadd: int  # 51
ARM_qadd16: int  # 175
ARM_qadd8: int  # 176
ARM_qaddsubx: int  # 177
ARM_qasx: int  # 177
ARM_qdadd: int  # 52
ARM_qdsub: int  # 53
ARM_qsax: int  # 180
ARM_qsub: int  # 54
ARM_qsub16: int  # 178
ARM_qsub8: int  # 179
ARM_qsubaddx: int  # 180
ARM_raddhn: int  # 729
ARM_raddhn2: int  # 730
ARM_rax1: int  # 920
ARM_rbit: int  # 277
ARM_ret: int  # 1
ARM_rev: int  # 181
ARM_rev16: int  # 182
ARM_rev32: int  # 510
ARM_rev64: int  # 735
ARM_revsh: int  # 183
ARM_rfe: int  # 184
ARM_rmif: int  # 890
ARM_ror: int  # 8
ARM_rrx: int  # 289
ARM_rsb: int  # 13
ARM_rsc: int  # 17
ARM_rshrn: int  # 742
ARM_rshrn2: int  # 743
ARM_rsubhn: int  # 749
ARM_rsubhn2: int  # 750
ARM_saba: int  # 544
ARM_sabal: int  # 547
ARM_sabal2: int  # 548
ARM_sabd: int  # 550
ARM_sabdl: int  # 554
ARM_sabdl2: int  # 555
ARM_sadalp: int  # 677
ARM_sadd16: int  # 185
ARM_sadd8: int  # 186
ARM_saddl: int  # 567
ARM_saddl2: int  # 568
ARM_saddlp: int  # 681
ARM_saddlv: int  # 795
ARM_saddsubx: int  # 187
ARM_saddw: int  # 571
ARM_saddw2: int  # 572
ARM_sasx: int  # 187
ARM_sb: int  # 911
ARM_sbc: int  # 16
ARM_sbdc: int  # 1021
ARM_sbfiz: int  # 502
ARM_sbfm: int  # 499
ARM_sbfx: int  # 270
ARM_scvtf: int  # 608
ARM_sdiv: int  # 280
ARM_sdot: int  # 939
ARM_sdsb: int  # 958
ARM_sel: int  # 188
ARM_setend: int  # 189
ARM_setf16: int  # 892
ARM_setf8: int  # 891
ARM_sev: int  # 264
ARM_sevl: int  # 467
ARM_sg: int  # 877
ARM_sha1c: int  # 453
ARM_sha1h: int  # 456
ARM_sha1m: int  # 454
ARM_sha1p: int  # 455
ARM_sha1su0: int  # 457
ARM_sha1su1: int  # 458
ARM_sha256h: int  # 459
ARM_sha256h2: int  # 460
ARM_sha256su0: int  # 461
ARM_sha256su1: int  # 462
ARM_sha512h: int  # 922
ARM_sha512h2: int  # 923
ARM_sha512su0: int  # 924
ARM_sha512su1: int  # 925
ARM_shadd: int  # 631
ARM_shadd16: int  # 190
ARM_shadd8: int  # 191
ARM_shaddsubx: int  # 192
ARM_shasx: int  # 192
ARM_shl: int  # 761
ARM_shll: int  # 762
ARM_shll2: int  # 763
ARM_shrn: int  # 759
ARM_shrn2: int  # 760
ARM_shsax: int  # 195
ARM_shsub: int  # 633
ARM_shsub16: int  # 193
ARM_shsub8: int  # 194
ARM_shsubaddx: int  # 195
ARM_sli: int  # 764
ARM_sm3partw1: int  # 926
ARM_sm3partw2: int  # 927
ARM_sm3ss1: int  # 928
ARM_sm3tt1a: int  # 929
ARM_sm3tt1b: int  # 930
ARM_sm3tt2a: int  # 931
ARM_sm3tt2b: int  # 932
ARM_sm4e: int  # 933
ARM_sm4ekey: int  # 934
ARM_smaddl: int  # 526
ARM_smax: int  # 643
ARM_smaxp: int  # 683
ARM_smaxv: int  # 797
ARM_smc: int  # 267
ARM_smin: int  # 647
ARM_sminp: int  # 687
ARM_sminv: int  # 801
ARM_smlabb: int  # 55
ARM_smlabt: int  # 57
ARM_smlad: int  # 196
ARM_smladx: int  # 197
ARM_smlal: int  # 38
ARM_smlal2: int  # 652
ARM_smlalbb: int  # 59
ARM_smlalbt: int  # 61
ARM_smlald: int  # 200
ARM_smlaldx: int  # 201
ARM_smlaltb: int  # 60
ARM_smlaltt: int  # 62
ARM_smlatb: int  # 56
ARM_smlatt: int  # 58
ARM_smlawb: int  # 63
ARM_smlawt: int  # 65
ARM_smlsd: int  # 202
ARM_smlsdx: int  # 203
ARM_smlsl: int  # 656
ARM_smlsl2: int  # 657
ARM_smlsld: int  # 206
ARM_smlsldx: int  # 207
ARM_smmla: int  # 208
ARM_smmlar: int  # 209
ARM_smmls: int  # 212
ARM_smmlsr: int  # 213
ARM_smmul: int  # 210
ARM_smmulr: int  # 211
ARM_smnegl: int  # 528
ARM_smov: int  # 659
ARM_smsubl: int  # 527
ARM_smuad: int  # 198
ARM_smuadx: int  # 199
ARM_smulbb: int  # 67
ARM_smulbt: int  # 69
ARM_smulh: int  # 529
ARM_smull: int  # 37
ARM_smull2: int  # 672
ARM_smultb: int  # 68
ARM_smultt: int  # 70
ARM_smulwb: int  # 64
ARM_smulwt: int  # 66
ARM_smusd: int  # 204
ARM_smusdx: int  # 205
ARM_sqabs: int  # 690
ARM_sqadd: int  # 692
ARM_sqdmlal: int  # 695
ARM_sqdmlal2: int  # 696
ARM_sqdmlsl: int  # 697
ARM_sqdmlsl2: int  # 698
ARM_sqdmulh: int  # 699
ARM_sqdmull: int  # 700
ARM_sqdmull2: int  # 701
ARM_sqneg: int  # 708
ARM_sqrdmlah: int  # 866
ARM_sqrdmlsh: int  # 867
ARM_sqrdmulh: int  # 709
ARM_sqrshl: int  # 711
ARM_sqrshr: int  # 1094
ARM_sqrshrl: int  # 1093
ARM_sqrshrn: int  # 714
ARM_sqrshrn2: int  # 715
ARM_sqrshrun: int  # 716
ARM_sqrshrun2: int  # 717
ARM_sqshl: int  # 719
ARM_sqshll: int  # 1088
ARM_sqshlu: int  # 720
ARM_sqshrn: int  # 723
ARM_sqshrn2: int  # 724
ARM_sqshrun: int  # 725
ARM_sqshrun2: int  # 726
ARM_sqsub: int  # 728
ARM_sqxtn: int  # 704
ARM_sqxtn2: int  # 705
ARM_sqxtun: int  # 706
ARM_sqxtun2: int  # 707
ARM_srhadd: int  # 737
ARM_sri: int  # 768
ARM_srs: int  # 214
ARM_srshl: int  # 739
ARM_srshr: int  # 741
ARM_srshrl: int  # 1091
ARM_srsra: int  # 748
ARM_ssat: int  # 215
ARM_ssat16: int  # 216
ARM_ssax: int  # 219
ARM_ssbb: int  # 912
ARM_sshl: int  # 752
ARM_sshll: int  # 755
ARM_sshll2: int  # 756
ARM_sshr: int  # 758
ARM_ssra: int  # 767
ARM_ssub16: int  # 217
ARM_ssub8: int  # 218
ARM_ssubaddx: int  # 219
ARM_ssubl: int  # 778
ARM_ssubl2: int  # 779
ARM_ssubw: int  # 782
ARM_ssubw2: int  # 783
ARM_st1: int  # 769
ARM_st2: int  # 770
ARM_st2g: int  # 904
ARM_st3: int  # 771
ARM_st4: int  # 772
ARM_stadd: int  # 812
ARM_staddl: int  # 813
ARM_stc: int  # 87
ARM_stc2: int  # 88
ARM_stclr: int  # 818
ARM_stclrl: int  # 819
ARM_steor: int  # 824
ARM_steorl: int  # 825
ARM_stg: int  # 901
ARM_stgm: int  # 906
ARM_stgp: int  # 907
ARM_stl: int  # 432
ARM_stlex: int  # 434
ARM_stllr: int  # 865
ARM_stlr: int  # 485
ARM_stlur: int  # 888
ARM_stlxp: int  # 489
ARM_stlxr: int  # 487
ARM_stm: int  # 34
ARM_stnp: int  # 477
ARM_stp: int  # 475
ARM_str: int  # 32
ARM_strd: int  # 71
ARM_strd2: int  # 872
ARM_strex: int  # 220
ARM_strexb: int  # 260
ARM_strexd: int  # 261
ARM_strexh: int  # 262
ARM_stset: int  # 830
ARM_stsetl: int  # 831
ARM_stsmax: int  # 836
ARM_stsmaxl: int  # 837
ARM_stsmin: int  # 842
ARM_stsminl: int  # 843
ARM_sttr: int  # 479
ARM_stumax: int  # 848
ARM_stumaxl: int  # 849
ARM_stumin: int  # 854
ARM_stuminl: int  # 855
ARM_stur: int  # 473
ARM_stxp: int  # 483
ARM_stxr: int  # 481
ARM_stz2g: int  # 905
ARM_stzg: int  # 902
ARM_stzgm: int  # 903
ARM_sub: int  # 12
ARM_subg: int  # 896
ARM_subhn: int  # 774
ARM_subhn2: int  # 775
ARM_subp: int  # 897
ARM_sudot: int  # 935
ARM_suqadd: int  # 693
ARM_svc: int  # 36
ARM_swbkpt: int  # 82
ARM_swp: int  # 35
ARM_swpa: int  # 805
ARM_swpal: int  # 806
ARM_swpl: int  # 804
ARM_sxtab: int  # 221
ARM_sxtab16: int  # 223
ARM_sxtah: int  # 225
ARM_sxtb: int  # 222
ARM_sxtb16: int  # 224
ARM_sxth: int  # 226
ARM_sxtl: int  # 663
ARM_sxtl2: int  # 664
ARM_sxtw: int  # 505
ARM_sys: int  # 535
ARM_sysl: int  # 536
ARM_tbb: int  # 274
ARM_tbh: int  # 275
ARM_tbl: int  # 784
ARM_tbnz: int  # 469
ARM_tbx: int  # 785
ARM_tbz: int  # 468
ARM_teq: int  # 19
ARM_tlbi: int  # 540
ARM_trap: int  # 952
ARM_trap2: int  # 953
ARM_trn1: int  # 786
ARM_trn2: int  # 787
ARM_tst: int  # 18
ARM_tt: int  # 875
ARM_tta: int  # 876
ARM_uaba: int  # 543
ARM_uabal: int  # 545
ARM_uabal2: int  # 546
ARM_uabd: int  # 549
ARM_uabdl: int  # 552
ARM_uabdl2: int  # 553
ARM_uadalp: int  # 676
ARM_uadd16: int  # 227
ARM_uadd8: int  # 228
ARM_uaddl: int  # 565
ARM_uaddl2: int  # 566
ARM_uaddlp: int  # 680
ARM_uaddlv: int  # 794
ARM_uaddsubx: int  # 229
ARM_uaddw: int  # 569
ARM_uaddw2: int  # 570
ARM_uasx: int  # 229
ARM_ubfiz: int  # 503
ARM_ubfm: int  # 500
ARM_ubfx: int  # 271
ARM_ucvtf: int  # 607
ARM_udiv: int  # 281
ARM_udot: int  # 940
ARM_uhadd: int  # 630
ARM_uhadd16: int  # 230
ARM_uhadd8: int  # 231
ARM_uhaddsubx: int  # 232
ARM_uhasx: int  # 232
ARM_uhsax: int  # 235
ARM_uhsub: int  # 632
ARM_uhsub16: int  # 233
ARM_uhsub8: int  # 234
ARM_uhsubaddx: int  # 235
ARM_umaal: int  # 236
ARM_umaddl: int  # 530
ARM_umax: int  # 642
ARM_umaxp: int  # 682
ARM_umaxv: int  # 796
ARM_umin: int  # 646
ARM_uminp: int  # 686
ARM_uminv: int  # 800
ARM_umlal: int  # 40
ARM_umlal2: int  # 651
ARM_umlsl: int  # 654
ARM_umlsl2: int  # 655
ARM_ummla: int  # 936
ARM_umnegl: int  # 532
ARM_umov: int  # 658
ARM_umsubl: int  # 531
ARM_umulh: int  # 533
ARM_umull: int  # 39
ARM_umull2: int  # 671
ARM_und: int  # 288
ARM_uqadd: int  # 691
ARM_uqadd16: int  # 237
ARM_uqadd8: int  # 238
ARM_uqaddsubx: int  # 239
ARM_uqasx: int  # 239
ARM_uqrshl: int  # 710
ARM_uqrshll: int  # 1092
ARM_uqrshrn: int  # 712
ARM_uqrshrn2: int  # 713
ARM_uqsax: int  # 242
ARM_uqshl: int  # 718
ARM_uqshll: int  # 1089
ARM_uqshrn: int  # 721
ARM_uqshrn2: int  # 722
ARM_uqsub: int  # 727
ARM_uqsub16: int  # 240
ARM_uqsub8: int  # 241
ARM_uqsubaddx: int  # 242
ARM_uqxtn: int  # 702
ARM_uqxtn2: int  # 703
ARM_urecpe: int  # 731
ARM_urhadd: int  # 736
ARM_urshl: int  # 738
ARM_urshr: int  # 740
ARM_urshrl: int  # 1090
ARM_ursqrte: int  # 744
ARM_ursra: int  # 747
ARM_usad8: int  # 244
ARM_usada8: int  # 243
ARM_usat: int  # 245
ARM_usat16: int  # 246
ARM_usax: int  # 249
ARM_usdot: int  # 937
ARM_ushl: int  # 751
ARM_ushll: int  # 753
ARM_ushll2: int  # 754
ARM_ushr: int  # 757
ARM_usmmla: int  # 938
ARM_usqadd: int  # 694
ARM_usra: int  # 766
ARM_usub16: int  # 247
ARM_usub8: int  # 248
ARM_usubaddx: int  # 249
ARM_usubl: int  # 776
ARM_usubl2: int  # 777
ARM_usubw: int  # 780
ARM_usubw2: int  # 781
ARM_uxtab: int  # 250
ARM_uxtab16: int  # 252
ARM_uxtah: int  # 254
ARM_uxtb: int  # 251
ARM_uxtb16: int  # 253
ARM_uxth: int  # 255
ARM_uxtl: int  # 661
ARM_uxtl2: int  # 662
ARM_uxtw: int  # 506
ARM_uzp1: int  # 789
ARM_uzp2: int  # 790
ARM_vaba: int  # 297
ARM_vabal: int  # 298
ARM_vabav: int  # 1054
ARM_vabd: int  # 299
ARM_vabdl: int  # 300
ARM_vabs: int  # 301
ARM_vacge: int  # 302
ARM_vacgt: int  # 303
ARM_vacle: int  # 304
ARM_vaclt: int  # 305
ARM_vadc: int  # 1019
ARM_vadcI: int  # 1020
ARM_vadd: int  # 306
ARM_vaddhn: int  # 307
ARM_vaddl: int  # 308
ARM_vaddlv: int  # 1055
ARM_vaddlvA: int  # 1056
ARM_vaddv: int  # 1057
ARM_vaddvA: int  # 1058
ARM_vaddw: int  # 309
ARM_vand: int  # 310
ARM_vbic: int  # 311
ARM_vbif: int  # 312
ARM_vbit: int  # 313
ARM_vbrsr: int  # 962
ARM_vbsl: int  # 314
ARM_vcadd: int  # 1018
ARM_vceq: int  # 315
ARM_vcge: int  # 316
ARM_vcgt: int  # 317
ARM_vcle: int  # 318
ARM_vcls: int  # 319
ARM_vclt: int  # 320
ARM_vclz: int  # 321
ARM_vcmla: int  # 1062
ARM_vcmp: int  # 322
ARM_vcmpe: int  # 323
ARM_vcmpv: int  # 1026
ARM_vcmul: int  # 963
ARM_vcnt: int  # 324
ARM_vctp: int  # 1096
ARM_vcvt: int  # 325
ARM_vcvta: int  # 438
ARM_vcvtb: int  # 327
ARM_vcvtm: int  # 441
ARM_vcvtn: int  # 439
ARM_vcvtp: int  # 440
ARM_vcvtr: int  # 326
ARM_vcvtt: int  # 328
ARM_vcx1: int  # 1126
ARM_vcx1A: int  # 1127
ARM_vcx2: int  # 1128
ARM_vcx2A: int  # 1129
ARM_vcx3: int  # 1130
ARM_vcx3A: int  # 1131
ARM_vddup: int  # 1014
ARM_vdiv: int  # 329
ARM_vdup: int  # 330
ARM_vdwdup: int  # 1016
ARM_veor: int  # 331
ARM_vext: int  # 332
ARM_vfma: int  # 333
ARM_vfmas: int  # 964
ARM_vfms: int  # 334
ARM_vfnma: int  # 335
ARM_vfnms: int  # 336
ARM_vhadd: int  # 337
ARM_vhcadd: int  # 1017
ARM_vhsub: int  # 338
ARM_vidup: int  # 1013
ARM_vins: int  # 884
ARM_viwdup: int  # 1015
ARM_vjcvt: int  # 885
ARM_vld1: int  # 339
ARM_vld2: int  # 340
ARM_vld20: int  # 1064
ARM_vld21: int  # 1065
ARM_vld3: int  # 341
ARM_vld4: int  # 342
ARM_vld40: int  # 1066
ARM_vld41: int  # 1067
ARM_vld42: int  # 1068
ARM_vld43: int  # 1069
ARM_vldm: int  # 343
ARM_vldr: int  # 344
ARM_vldrb: int  # 1076
ARM_vldrd: int  # 1079
ARM_vldrh: int  # 1077
ARM_vldrw: int  # 1078
ARM_vlldm: int  # 878
ARM_vlstm: int  # 879
ARM_vmax: int  # 345
ARM_vmaxa: int  # 965
ARM_vmaxav: int  # 1031
ARM_vmaxnm: int  # 436
ARM_vmaxnma: int  # 966
ARM_vmaxnmav: int  # 1035
ARM_vmaxnmv: int  # 1034
ARM_vmaxv: int  # 1030
ARM_vmin: int  # 346
ARM_vmina: int  # 967
ARM_vminav: int  # 1033
ARM_vminnm: int  # 437
ARM_vminnma: int  # 968
ARM_vminnmav: int  # 1037
ARM_vminnmv: int  # 1036
ARM_vminv: int  # 1032
ARM_vmla: int  # 347
ARM_vmladav: int  # 993
ARM_vmladavA: int  # 995
ARM_vmladavAX: int  # 996
ARM_vmladavX: int  # 994
ARM_vmlal: int  # 348
ARM_vmlaldav: int  # 1001
ARM_vmlaldavA: int  # 1003
ARM_vmlaldavAX: int  # 1004
ARM_vmlaldavX: int  # 1002
ARM_vmlas: int  # 969
ARM_vmls: int  # 349
ARM_vmlsdav: int  # 997
ARM_vmlsdavA: int  # 999
ARM_vmlsdavAX: int  # 1000
ARM_vmlsdavX: int  # 998
ARM_vmlsl: int  # 350
ARM_vmlsldav: int  # 1005
ARM_vmlsldavA: int  # 1007
ARM_vmlsldavAX: int  # 1008
ARM_vmlsldavX: int  # 1006
ARM_vmov: int  # 351
ARM_vmov2: int  # 1084
ARM_vmovl: int  # 352
ARM_vmovlb: int  # 1060
ARM_vmovlt: int  # 1061
ARM_vmovn: int  # 353
ARM_vmovnb: int  # 970
ARM_vmovnt: int  # 971
ARM_vmovx: int  # 883
ARM_vmrs: int  # 354
ARM_vmsr: int  # 355
ARM_vmul: int  # 356
ARM_vmulh: int  # 972
ARM_vmull: int  # 357
ARM_vmullb: int  # 974
ARM_vmullt: int  # 975
ARM_vmvn: int  # 358
ARM_vneg: int  # 359
ARM_vnmla: int  # 360
ARM_vnmls: int  # 361
ARM_vnmul: int  # 362
ARM_vorn: int  # 363
ARM_vorr: int  # 364
ARM_vpadal: int  # 365
ARM_vpadd: int  # 366
ARM_vpaddl: int  # 367
ARM_vpmax: int  # 368
ARM_vpmin: int  # 369
ARM_vpnot: int  # 1028
ARM_vpop: int  # 370
ARM_vpsel: int  # 1025
ARM_vpst: int  # 1029
ARM_vpt: int  # 1027
ARM_vpush: int  # 371
ARM_vqabs: int  # 372
ARM_vqadd: int  # 373
ARM_vqdmladh: int  # 976
ARM_vqdmladhX: int  # 977
ARM_vqdmlah: int  # 980
ARM_vqdmlal: int  # 374
ARM_vqdmlash: int  # 981
ARM_vqdmlsdh: int  # 983
ARM_vqdmlsdhX: int  # 984
ARM_vqdmlsl: int  # 375
ARM_vqdmulh: int  # 376
ARM_vqdmull: int  # 377
ARM_vqdmullb: int  # 1023
ARM_vqdmullt: int  # 1024
ARM_vqmovn: int  # 378
ARM_vqmovnb: int  # 987
ARM_vqmovnt: int  # 988
ARM_vqmovun: int  # 379
ARM_vqmovunb: int  # 989
ARM_vqmovunt: int  # 990
ARM_vqneg: int  # 380
ARM_vqrdmladh: int  # 978
ARM_vqrdmladhX: int  # 979
ARM_vqrdmlah: int  # 881
ARM_vqrdmlash: int  # 982
ARM_vqrdmlsdh: int  # 985
ARM_vqrdmlsdhX: int  # 986
ARM_vqrdmlsh: int  # 882
ARM_vqrdmulh: int  # 381
ARM_vqrshl: int  # 382
ARM_vqrshrn: int  # 383
ARM_vqrshrnb: int  # 1040
ARM_vqrshrnt: int  # 1041
ARM_vqrshrun: int  # 384
ARM_vqrshrunb: int  # 1044
ARM_vqrshrunt: int  # 1045
ARM_vqshl: int  # 385
ARM_vqshlu: int  # 386
ARM_vqshrn: int  # 387
ARM_vqshrnb: int  # 1038
ARM_vqshrnt: int  # 1039
ARM_vqshrun: int  # 388
ARM_vqshrunb: int  # 1042
ARM_vqshrunt: int  # 1043
ARM_vqsub: int  # 389
ARM_vraddhn: int  # 390
ARM_vrecpe: int  # 391
ARM_vrecps: int  # 392
ARM_vrev16: int  # 393
ARM_vrev32: int  # 394
ARM_vrev64: int  # 395
ARM_vrhadd: int  # 396
ARM_vrinta: int  # 445
ARM_vrintm: int  # 448
ARM_vrintn: int  # 446
ARM_vrintp: int  # 447
ARM_vrintr: int  # 443
ARM_vrintx: int  # 442
ARM_vrintz: int  # 444
ARM_vrmlaldavh: int  # 1050
ARM_vrmlaldavhA: int  # 1052
ARM_vrmlaldavhAX: int  # 1053
ARM_vrmlaldavhX: int  # 1051
ARM_vrmlsldavh: int  # 1009
ARM_vrmlsldavhA: int  # 1011
ARM_vrmlsldavhAX: int  # 1012
ARM_vrmlsldavhX: int  # 1010
ARM_vrmulh: int  # 973
ARM_vrshl: int  # 397
ARM_vrshr: int  # 398
ARM_vrshrn: int  # 399
ARM_vrshrnb: int  # 1048
ARM_vrshrnt: int  # 1049
ARM_vrsqrte: int  # 400
ARM_vrsqrts: int  # 401
ARM_vrsra: int  # 402
ARM_vrsubhn: int  # 403
ARM_vsbcI: int  # 1022
ARM_vscclrm: int  # 1063
ARM_vsel: int  # 435
ARM_vshl: int  # 404
ARM_vshlc: int  # 1059
ARM_vshll: int  # 405
ARM_vshllb: int  # 991
ARM_vshllt: int  # 992
ARM_vshr: int  # 406
ARM_vshrn: int  # 407
ARM_vshrnb: int  # 1046
ARM_vshrnt: int  # 1047
ARM_vsli: int  # 408
ARM_vsqrt: int  # 409
ARM_vsra: int  # 410
ARM_vsri: int  # 411
ARM_vst1: int  # 412
ARM_vst2: int  # 413
ARM_vst20: int  # 1070
ARM_vst21: int  # 1071
ARM_vst3: int  # 414
ARM_vst4: int  # 415
ARM_vst40: int  # 1072
ARM_vst41: int  # 1073
ARM_vst42: int  # 1074
ARM_vst43: int  # 1075
ARM_vstm: int  # 416
ARM_vstr: int  # 417
ARM_vstrb: int  # 1080
ARM_vstrd: int  # 1083
ARM_vstrh: int  # 1081
ARM_vstrw: int  # 1082
ARM_vsub: int  # 418
ARM_vsubhn: int  # 419
ARM_vsubl: int  # 420
ARM_vsubw: int  # 421
ARM_vswp: int  # 422
ARM_vtbl: int  # 423
ARM_vtbx: int  # 424
ARM_vtrn: int  # 425
ARM_vtst: int  # 426
ARM_vuzp: int  # 427
ARM_vzip: int  # 428
ARM_wfe: int  # 265
ARM_wfet: int  # 1132
ARM_wfi: int  # 266
ARM_wfit: int  # 1133
ARM_wkdmc: int  # 956
ARM_wkdmd: int  # 957
ARM_wls: int  # 1102
ARM_wlstp: int  # 1104
ARM_xaflag: int  # 893
ARM_xar: int  # 921
ARM_xpac: int  # 870
ARM_xtn: int  # 665
ARM_xtn2: int  # 666
ARM_yield: int  # 263
ARM_zip1: int  # 791
ARM_zip2: int  # 792
AS2_BRACE: int  # 1
AS2_BYTE1CHAR: int  # 4
AS2_COLONSUF: int  # 32
AS2_IDEALDSCR: int  # 8
AS2_STRINV: int  # 2
AS2_TERSESTR: int  # 16
AS2_YWORD: int  # 64
AS2_ZWORD: int  # 128
ASB_BINF0: int  # 0
ASB_BINF1: int  # 131072
ASB_BINF2: int  # 262144
ASB_BINF3: int  # 393216
ASB_BINF4: int  # 524288
ASB_BINF5: int  # 655360
ASD_DECF0: int  # 0
ASD_DECF1: int  # 4096
ASD_DECF2: int  # 8192
ASD_DECF3: int  # 12288
ASH_HEXF0: int  # 0
ASH_HEXF1: int  # 512
ASH_HEXF2: int  # 1024
ASH_HEXF3: int  # 1536
ASH_HEXF4: int  # 2048
ASH_HEXF5: int  # 2560
ASKBTN_BTN1: int  # 1
ASKBTN_BTN2: int  # 0
ASKBTN_BTN3: int  # -1
ASKBTN_CANCEL: int  # -1
ASKBTN_NO: int  # 0
ASKBTN_YES: int  # 1
ASO_OCTF0: int  # 0
ASO_OCTF1: int  # 16384
ASO_OCTF2: int  # 32768
ASO_OCTF3: int  # 49152
ASO_OCTF4: int  # 65536
ASO_OCTF5: int  # 81920
ASO_OCTF6: int  # 98304
ASO_OCTF7: int  # 114688
AST_DISABLE: int  # 7
AST_DISABLE_ALWAYS: int  # 4
AST_DISABLE_FOR_IDB: int  # 5
AST_DISABLE_FOR_WIDGET: int  # 6
AST_ENABLE: int  # 3
AST_ENABLE_ALWAYS: int  # 0
AST_ENABLE_FOR_IDB: int  # 1
AST_ENABLE_FOR_WIDGET: int  # 2
AS_1TEXT: int  # 64
AS_2CHRE: int  # 8
AS_ALIGN2: int  # 536870912
AS_ASCIIC: int  # 1073741824
AS_ASCIIZ: int  # -2147483648
AS_BINFM: int  # 917504
AS_COLON: int  # 2
AS_DECFM: int  # 12288
AS_HEXFM: int  # 3584
AS_LALIGN: int  # 33554432
AS_N2CHR: int  # 32
AS_NCHRE: int  # 16
AS_NCMAS: int  # 256
AS_NHIAS: int  # 128
AS_NOCODECLN: int  # 67108864
AS_NOSPACE: int  # 268435456
AS_NOXRF: int  # 4194304
AS_OCTFM: int  # 114688
AS_OFFST: int  # 1
AS_ONEDUP: int  # 2097152
AS_RELSUP: int  # 16777216
AS_UDATA: int  # 4
AS_UNEQU: int  # 1048576
AS_XTRNTYPE: int  # 8388608
AU_CHLB: int  # 90
AU_CODE: int  # 20
AU_FCHUNK: int  # 38
AU_FINAL: int  # 200
AU_LBF2: int  # 70
AU_LBF3: int  # 80
AU_LIBF: int  # 60
AU_NONE: int  # 0
AU_PROC: int  # 30
AU_TAIL: int  # 35
AU_TYPE: int  # 50
AU_UNK: int  # 10
AU_USD2: int  # 45
AU_USED: int  # 40
AU_WEAK: int  # 25
AVR_adc: int  # 2
AVR_add: int  # 1
AVR_adiw: int  # 3
AVR_and: int  # 9
AVR_andi: int  # 10
AVR_asr: int  # 77
AVR_bclr: int  # 80
AVR_bld: int  # 84
AVR_brbc: int  # 41
AVR_brbs: int  # 40
AVR_brcc: int  # 45
AVR_brcs: int  # 44
AVR_breq: int  # 42
AVR_brge: int  # 50
AVR_brhc: int  # 53
AVR_brhs: int  # 52
AVR_brid: int  # 59
AVR_brie: int  # 58
AVR_brlo: int  # 47
AVR_brlt: int  # 51
AVR_brmi: int  # 48
AVR_brne: int  # 43
AVR_brpl: int  # 49
AVR_brsh: int  # 46
AVR_brtc: int  # 55
AVR_brts: int  # 54
AVR_brvc: int  # 57
AVR_brvs: int  # 56
AVR_bset: int  # 79
AVR_bst: int  # 83
AVR_call: int  # 32
AVR_cbi: int  # 82
AVR_cbr: int  # 17
AVR_clc: int  # 86
AVR_clh: int  # 100
AVR_cli: int  # 92
AVR_cln: int  # 88
AVR_clr: int  # 21
AVR_cls: int  # 94
AVR_clt: int  # 98
AVR_clv: int  # 96
AVR_clz: int  # 90
AVR_com: int  # 14
AVR_cp: int  # 23
AVR_cpc: int  # 24
AVR_cpi: int  # 25
AVR_cpse: int  # 35
AVR_dec: int  # 19
AVR_des: int  # 115
AVR_eicall: int  # 113
AVR_eijmp: int  # 114
AVR_elpm: int  # 104
AVR_eor: int  # 13
AVR_espm: int  # 105
AVR_fmul: int  # 106
AVR_fmuls: int  # 107
AVR_fmulsu: int  # 108
AVR_icall: int  # 31
AVR_ijmp: int  # 28
AVR_in: int  # 69
AVR_inc: int  # 18
AVR_jmp: int  # 29
AVR_lac: int  # 116
AVR_las: int  # 117
AVR_last: int  # 120
AVR_lat: int  # 118
AVR_ld: int  # 63
AVR_ldd: int  # 64
AVR_ldi: int  # 61
AVR_lds: int  # 62
AVR_lpm: int  # 68
AVR_lsl: int  # 73
AVR_lsr: int  # 74
AVR_mov: int  # 60
AVR_movw: int  # 109
AVR_mul: int  # 26
AVR_muls: int  # 110
AVR_mulsu: int  # 111
AVR_neg: int  # 15
AVR_nop: int  # 101
AVR_null: int  # 0
AVR_or: int  # 11
AVR_ori: int  # 12
AVR_out: int  # 70
AVR_pop: int  # 72
AVR_push: int  # 71
AVR_rcall: int  # 30
AVR_ret: int  # 33
AVR_reti: int  # 34
AVR_rjmp: int  # 27
AVR_rol: int  # 75
AVR_ror: int  # 76
AVR_sbc: int  # 6
AVR_sbci: int  # 7
AVR_sbi: int  # 81
AVR_sbic: int  # 38
AVR_sbis: int  # 39
AVR_sbiw: int  # 8
AVR_sbr: int  # 16
AVR_sbrc: int  # 36
AVR_sbrs: int  # 37
AVR_sec: int  # 85
AVR_seh: int  # 99
AVR_sei: int  # 91
AVR_sen: int  # 87
AVR_ser: int  # 22
AVR_ses: int  # 93
AVR_set: int  # 97
AVR_sev: int  # 95
AVR_sez: int  # 89
AVR_sleep: int  # 102
AVR_spm: int  # 112
AVR_st: int  # 66
AVR_std: int  # 67
AVR_sts: int  # 65
AVR_sub: int  # 4
AVR_subi: int  # 5
AVR_swap: int  # 78
AVR_tst: int  # 20
AVR_wdr: int  # 103
AVR_xch: int  # 119
Appcall: Appcall__  # <ida_idd.Appcall__ object at 0x7acfb6252270>
BADADDR: int  # 18446744073709551615
BADADDR32: int  # 4294967295
BADADDR64: int  # 18446744073709551615
BADDIFF: int  # 18446744073709551615
BADMEMSIZE: int  # 9223372036854775807
BADNODE: int  # 18446744073709551615
BADORD: int  # 4294967295
BADSEL: int  # 18446744073709551615
BADSIZE: int  # 18446744073709551615
BBLK_TRACE: int  # 8
BFA_FUNC_EXT_FORMAT: int  # 128
BFA_FUNC_MARKER: int  # 15
BFA_HIGH: int  # 4
BFA_NORET: int  # 1
BFA_PURE: int  # 2
BFA_STATIC: int  # 8
BFA_VIRTUAL: int  # 16
BINOPSTATE_DONE: int  # 524288
BINOPSTATE_GO: int  # 262144
BINOPSTATE_NONE: int  # 0
BIN_SEARCH_BACKWARD: int  # 16
BIN_SEARCH_BITMASK: int  # 32
BIN_SEARCH_CASE: int  # 1
BIN_SEARCH_FORWARD: int  # 0
BIN_SEARCH_INITED: int  # 4
BIN_SEARCH_NOBREAK: int  # 2
BIN_SEARCH_NOCASE: int  # 0
BIN_SEARCH_NOSHOW: int  # 8
BITNESS_CHANGED: int  # -2147483648
BKPT_ACTIVE: int  # 8
BKPT_BADBPT: int  # 1
BKPT_CNDREADY: int  # 32
BKPT_FAKEPEND: int  # 64
BKPT_LISTBPT: int  # 2
BKPT_PAGE: int  # 128
BKPT_PARTIAL: int  # 16
BKPT_TRACE: int  # 4
BLT_0WAY: int  # 2
BLT_1WAY: int  # 3
BLT_2WAY: int  # 4
BLT_NONE: int  # 0
BLT_NWAY: int  # 5
BLT_STOP: int  # 1
BLT_XTRN: int  # 6
BOOKMARKS_PROMPT_WITH_HINT_PREFIX: str  # 
BPLT_ABS: int  # 0
BPLT_REL: int  # 1
BPLT_SRC: int  # 3
BPLT_SYM: int  # 2
BPTCK_ACT: int  # 2
BPTCK_NO: int  # 0
BPTCK_NONE: int  # -1
BPTCK_YES: int  # 1
BPTEV_ADDED: int  # 0
BPTEV_CHANGED: int  # 2
BPTEV_REMOVED: int  # 1
BPT_BAD_ADDR: int  # 4
BPT_BAD_ALIGN: int  # 3
BPT_BAD_LEN: int  # 5
BPT_BAD_TYPE: int  # 2
BPT_BRK: int  # 1
BPT_DEFAULT: int  # 12
BPT_ELANG_MASK: int  # 4026531840
BPT_ELANG_SHIFT: int  # 28
BPT_ENABLED: int  # 8
BPT_EXEC: int  # 8
BPT_INTERNAL_ERR: int  # 1
BPT_LOWCND: int  # 16
BPT_OK: int  # 0
BPT_PAGE_OK: int  # 10
BPT_RDWR: int  # 3
BPT_READ: int  # 2
BPT_READ_ERROR: int  # 7
BPT_SKIP: int  # 9
BPT_SOFT: int  # 4
BPT_TOO_MANY: int  # 6
BPT_TRACE: int  # 2
BPT_TRACEON: int  # 32
BPT_TRACE_BBLK: int  # 256
BPT_TRACE_FUNC: int  # 128
BPT_TRACE_INSN: int  # 64
BPT_TRACE_TYPES: int  # 448
BPT_UPDMEM: int  # 4
BPT_WRITE: int  # 1
BPT_WRITE_ERROR: int  # 8
BPU_1B: int  # 1
BPU_2B: int  # 2
BPU_4B: int  # 4
BREAKPOINT: int  # 5
BTE_ALWAYS: int  # 128
BTE_BITMASK: int  # 16
BTE_CHAR: int  # 32
BTE_HEX: int  # 0
BTE_OUT_MASK: int  # 96
BTE_RESERVED: int  # 8
BTE_SDEC: int  # 64
BTE_SIZE_MASK: int  # 7
BTE_UDEC: int  # 96
BTF_BOOL: int  # 8
BTF_BYTE: int  # 17
BTF_CHAR: int  # 50
BTF_DOUBLE: int  # 25
BTF_ENUM: int  # 45
BTF_FLOAT: int  # 9
BTF_INT: int  # 7
BTF_INT128: int  # 22
BTF_INT16: int  # 19
BTF_INT32: int  # 20
BTF_INT64: int  # 21
BTF_INT8: int  # 18
BTF_LDOUBLE: int  # 41
BTF_SINT: int  # 23
BTF_STRUCT: int  # 13
BTF_TBYTE: int  # 57
BTF_TYPEDEF: int  # 61
BTF_UCHAR: int  # 34
BTF_UINT: int  # 39
BTF_UINT128: int  # 38
BTF_UINT16: int  # 35
BTF_UINT32: int  # 36
BTF_UINT64: int  # 37
BTF_UINT8: int  # 34
BTF_UNION: int  # 29
BTF_UNK: int  # 48
BTF_VOID: int  # 1
BTMT_ARRESERV: int  # 32
BTMT_BFLDI16: int  # 16
BTMT_BFLDI32: int  # 32
BTMT_BFLDI64: int  # 48
BTMT_BFLDI8: int  # 0
BTMT_BOOL1: int  # 16
BTMT_BOOL2: int  # 32
BTMT_BOOL4: int  # 48
BTMT_BOOL8: int  # 32
BTMT_CHAR: int  # 48
BTMT_CLOSURE: int  # 48
BTMT_DEFBOOL: int  # 0
BTMT_DEFCALL: int  # 0
BTMT_DEFPTR: int  # 0
BTMT_DOUBLE: int  # 16
BTMT_ENUM: int  # 32
BTMT_FAR: int  # 32
BTMT_FARCALL: int  # 32
BTMT_FLOAT: int  # 0
BTMT_INTCALL: int  # 48
BTMT_LNGDBL: int  # 32
BTMT_NEAR: int  # 16
BTMT_NEARCALL: int  # 16
BTMT_NONBASED: int  # 16
BTMT_SIGNED: int  # 16
BTMT_SIZE0: int  # 0
BTMT_SIZE12: int  # 16
BTMT_SIZE128: int  # 48
BTMT_SIZE48: int  # 32
BTMT_SPECFLT: int  # 48
BTMT_STRUCT: int  # 0
BTMT_TYPEDEF: int  # 48
BTMT_UNION: int  # 16
BTMT_UNKSIGN: int  # 0
BTMT_UNSIGNED: int  # 32
BTMT_USIGNED: int  # 32
BTM_CONST: int  # 64
BTM_VOLATILE: int  # 128
BT_ARRAY: int  # 11
BT_BITFIELD: int  # 14
BT_BOOL: int  # 8
BT_COMPLEX: int  # 13
BT_FLOAT: int  # 9
BT_FUNC: int  # 12
BT_INT: int  # 7
BT_INT128: int  # 6
BT_INT16: int  # 3
BT_INT32: int  # 4
BT_INT64: int  # 5
BT_INT8: int  # 2
BT_LOG_INSTS: int  # 1
BT_PTR: int  # 10
BT_RESERVED: int  # 15
BT_SEGREG: int  # 55
BT_UNK: int  # 0
BT_UNKNOWN: int  # 48
BT_UNK_BYTE: int  # 17
BT_UNK_DWORD: int  # 33
BT_UNK_OWORD: int  # 49
BT_UNK_QWORD: int  # 32
BT_UNK_WORD: int  # 16
BT_VOID: int  # 1
BWN_ADDRWATCH: int  # 45
BWN_BOOKMARKS: int  # 57
BWN_BPTS: int  # 13
BWN_CALLS: int  # 11
BWN_CALLS_CALLEES: int  # 48
BWN_CALLS_CALLERS: int  # 47
BWN_CALL_STACK: int  # 17
BWN_CHOOSER: int  # 35
BWN_CLI: int  # 31
BWN_CMDPALCSR: int  # 41
BWN_CMDPALWIN: int  # 42
BWN_CPUREGS: int  # 38
BWN_CUSTVIEW: int  # 44
BWN_CV_LINE_INFOS: int  # 51
BWN_DISASM: int  # 27
BWN_DISASMS: int  # 27
BWN_DISASM_ARROWS: int  # 50
BWN_EXPORTS: int  # 0
BWN_FRAME: int  # 25
BWN_FUNCS: int  # 3
BWN_HEXVIEW: int  # 28
BWN_IMPORTS: int  # 1
BWN_LOCALS: int  # 33
BWN_LOCTYPS: int  # 10
BWN_MDVIEWCSR: int  # 49
BWN_MICROCODE: int  # 61
BWN_MODULES: int  # 15
BWN_NAMES: int  # 2
BWN_NAVBAND: int  # 26
BWN_NOTEPAD: int  # 29
BWN_OUTPUT: int  # 30
BWN_PROBS: int  # 12
BWN_PSEUDOCODE: int  # 46
BWN_SCRIPTS_CSR: int  # 56
BWN_SEARCH: int  # 19
BWN_SEGREGS: int  # 6
BWN_SEGS: int  # 5
BWN_SELS: int  # 7
BWN_SHORTCUTCSR: int  # 36
BWN_SHORTCUTWIN: int  # 37
BWN_SIGNS: int  # 8
BWN_SNIPPETS: int  # 43
BWN_SNIPPETS_CSR: int  # 55
BWN_SO_OFFSETS: int  # 40
BWN_SO_STRUCTS: int  # 39
BWN_SRCPTHMAP_CSR: int  # 52
BWN_SRCPTHUND_CSR: int  # 53
BWN_STKVIEW: int  # 34
BWN_STRINGS: int  # 4
BWN_THREADS: int  # 14
BWN_TICSR: int  # 10
BWN_TILIST: int  # 58
BWN_TILS: int  # 9
BWN_TILVIEW: int  # 10
BWN_TIL_VIEW: int  # 59
BWN_TRACE: int  # 16
BWN_TYPE_EDITOR: int  # 60
BWN_UNDOHIST: int  # 54
BWN_UNKNOWN: int  # -1
BWN_WATCH: int  # 32
BWN_XREFS: int  # 18
BWN_XREF_TREE: int  # 62
C166_add: int  # 1
C166_addb: int  # 2
C166_addc: int  # 3
C166_addcb: int  # 4
C166_and: int  # 5
C166_andb: int  # 6
C166_ashr: int  # 7
C166_atomic: int  # 8
C166_band: int  # 9
C166_bclr: int  # 10
C166_bcmp: int  # 11
C166_bfldh: int  # 12
C166_bfldl: int  # 13
C166_bmov: int  # 14
C166_bmovn: int  # 15
C166_bor: int  # 16
C166_bset: int  # 17
C166_bxor: int  # 18
C166_calla: int  # 19
C166_calli: int  # 20
C166_callr: int  # 21
C166_calls: int  # 22
C166_cmp: int  # 23
C166_cmpb: int  # 24
C166_cmpd1: int  # 25
C166_cmpd2: int  # 26
C166_cmpi1: int  # 27
C166_cmpi2: int  # 28
C166_cpl: int  # 29
C166_cplb: int  # 30
C166_diswdt: int  # 31
C166_div: int  # 32
C166_divl: int  # 33
C166_divlu: int  # 34
C166_divu: int  # 35
C166_einit: int  # 36
C166_enwdt: int  # 103
C166_extp: int  # 38
C166_extpr: int  # 39
C166_extr: int  # 37
C166_exts: int  # 40
C166_extsr: int  # 41
C166_idle: int  # 42
C166_jb: int  # 43
C166_jbc: int  # 44
C166_jmpa: int  # 45
C166_jmpi: int  # 46
C166_jmpr: int  # 47
C166_jmps: int  # 48
C166_jnb: int  # 49
C166_jnbs: int  # 50
C166_last: int  # 105
C166_mov: int  # 51
C166_movb: int  # 52
C166_movbs: int  # 53
C166_movbz: int  # 54
C166_mul: int  # 55
C166_mulu: int  # 56
C166_neg: int  # 57
C166_negb: int  # 58
C166_nop: int  # 59
C166_null: int  # 0
C166_or: int  # 60
C166_orb: int  # 61
C166_pcall: int  # 62
C166_pop: int  # 63
C166_prior: int  # 64
C166_push: int  # 65
C166_pwrdn: int  # 66
C166_ret: int  # 67
C166_reti: int  # 68
C166_retp: int  # 69
C166_rets: int  # 70
C166_rol: int  # 71
C166_ror: int  # 72
C166_sbrk: int  # 104
C166_scxt: int  # 73
C166_shl: int  # 74
C166_shr: int  # 75
C166_srst: int  # 76
C166_srvwdt: int  # 77
C166_sub: int  # 78
C166_subb: int  # 79
C166_subc: int  # 80
C166_subcb: int  # 81
C166_trap: int  # 82
C166_xor: int  # 83
C166_xorb: int  # 84
C39_adc: int  # 1
C39_add: int  # 2
C39_anc: int  # 3
C39_and: int  # 4
C39_ane: int  # 5
C39_arr: int  # 6
C39_asl: int  # 7
C39_asr: int  # 8
C39_bar: int  # 9
C39_bas: int  # 10
C39_bbr: int  # 11
C39_bbs: int  # 12
C39_bcc: int  # 13
C39_bcs: int  # 14
C39_beq: int  # 15
C39_bit: int  # 16
C39_bmi: int  # 17
C39_bne: int  # 18
C39_bpl: int  # 19
C39_bra: int  # 20
C39_brk: int  # 21
C39_bvc: int  # 22
C39_bvs: int  # 23
C39_clc: int  # 24
C39_cld: int  # 25
C39_cli: int  # 26
C39_clv: int  # 27
C39_clw: int  # 28
C39_cmp: int  # 29
C39_cpx: int  # 30
C39_cpy: int  # 31
C39_dcp: int  # 32
C39_dec: int  # 33
C39_dex: int  # 34
C39_dey: int  # 35
C39_eor: int  # 36
C39_exc: int  # 37
C39_inc: int  # 38
C39_ini: int  # 39
C39_inx: int  # 40
C39_iny: int  # 41
C39_isb: int  # 42
C39_jmp: int  # 43
C39_jpi: int  # 44
C39_jsb: int  # 45
C39_jsr: int  # 46
C39_lab: int  # 47
C39_lae: int  # 48
C39_lai: int  # 49
C39_lan: int  # 50
C39_last: int  # 115
C39_lax: int  # 51
C39_lda: int  # 52
C39_ldx: int  # 53
C39_ldy: int  # 54
C39_lii: int  # 55
C39_lsr: int  # 56
C39_lxa: int  # 57
C39_mpa: int  # 58
C39_mpy: int  # 59
C39_neg: int  # 60
C39_nop: int  # 61
C39_null: int  # 0
C39_nxt: int  # 62
C39_ora: int  # 63
C39_pha: int  # 64
C39_phi: int  # 65
C39_php: int  # 66
C39_phw: int  # 67
C39_phx: int  # 68
C39_phy: int  # 69
C39_pia: int  # 70
C39_pla: int  # 71
C39_pli: int  # 72
C39_plp: int  # 73
C39_plw: int  # 74
C39_plx: int  # 75
C39_ply: int  # 76
C39_psh: int  # 77
C39_pul: int  # 78
C39_rba: int  # 79
C39_rla: int  # 80
C39_rmb: int  # 81
C39_rnd: int  # 82
C39_rol: int  # 83
C39_ror: int  # 84
C39_rra: int  # 85
C39_rti: int  # 86
C39_rts: int  # 87
C39_sax: int  # 88
C39_sba: int  # 89
C39_sbc: int  # 90
C39_sbx: int  # 91
C39_sec: int  # 92
C39_sed: int  # 93
C39_sei: int  # 94
C39_sha: int  # 95
C39_shs: int  # 96
C39_shx: int  # 97
C39_shy: int  # 98
C39_slo: int  # 99
C39_smb: int  # 100
C39_sre: int  # 101
C39_sta: int  # 102
C39_sti: int  # 103
C39_stx: int  # 104
C39_sty: int  # 105
C39_taw: int  # 108
C39_tax: int  # 106
C39_tay: int  # 107
C39_tip: int  # 109
C39_tsx: int  # 110
C39_twa: int  # 111
C39_txa: int  # 112
C39_txs: int  # 113
C39_tya: int  # 114
CALC_CURLY_BRACES: int  # 0
CALL_SPOILS_ONLY_ARGS: int  # 16384
CB_CANCEL: int  # -7
CB_CLOSE: int  # -3
CB_DESTROYING: int  # -5
CB_INIT: int  # -1
CB_INVISIBLE: int  # -4
CB_NO: int  # -6
CB_YES: int  # -2
CCI_PURGE: int  # 2
CCI_USER: int  # 4
CCI_VARARG: int  # 1
CCN_C: int  # 0
CCN_CPP: int  # 1
CC_ALLOW_ARGPERM: int  # 2
CC_ALLOW_REGHOLES: int  # 4
CC_CDECL_OK: int  # 1
CC_GOLANG_OK: int  # 16
CC_HAS_ELLIPSIS: int  # 8
CDVF_LINEICONS: int  # 2
CDVF_NOLINES: int  # 1
CDVF_STATUSBAR: int  # 4
CDVH_LINES_ALIGNMENT: int  # 1009
CDVH_LINES_CLICK: int  # 1002
CDVH_LINES_DBLCLICK: int  # 1003
CDVH_LINES_DRAWICON: int  # 1005
CDVH_LINES_ICONMARGIN: int  # 1007
CDVH_LINES_LINENUM: int  # 1006
CDVH_LINES_POPUP: int  # 1004
CDVH_LINES_RADIX: int  # 1008
CDVH_SRCVIEW: int  # 1001
CDVH_USERDATA: int  # 1000
CEF_RETERR: int  # 1
CFG_SUBDIR: str  # cfg
CFL_FINAL: int  # 1
CFL_HELPER: int  # 2
CFL_NORET: int  # 4
CFS_BOUNDS: int  # 1
CFS_LOCKED: int  # 8
CFS_LVARS_HIDDEN: int  # 4
CFS_TEXT: int  # 2
CF_CALL: int  # 2
CF_CHG1: int  # 4
CF_CHG2: int  # 8
CF_CHG3: int  # 16
CF_CHG4: int  # 32
CF_CHG5: int  # 64
CF_CHG6: int  # 128
CF_CHG7: int  # 131072
CF_CHG8: int  # 262144
CF_HLL: int  # 65536
CF_JUMP: int  # 16384
CF_SHFT: int  # 32768
CF_STOP: int  # 1
CF_USE1: int  # 256
CF_USE2: int  # 512
CF_USE3: int  # 1024
CF_USE4: int  # 2048
CF_USE5: int  # 4096
CF_USE6: int  # 8192
CF_USE7: int  # 524288
CF_USE8: int  # 1048576
CH2_HAS_INODE2INDEX: int  # 2
CH2_LAZY_LOADED: int  # 1
CHART_FOLLOW_DIRECTION: int  # 8
CHART_GEN_DOT: int  # 8192
CHART_GEN_GDL: int  # 16384
CHART_IGNORE_DATA_BSS: int  # 32
CHART_IGNORE_LIB_FROM: int  # 128
CHART_IGNORE_LIB_TO: int  # 64
CHART_IGNORE_XTRN: int  # 16
CHART_NOLIBFUNCS: int  # 1024
CHART_PRINT_COMMENTS: int  # 256
CHART_PRINT_DOTS: int  # 512
CHART_PRINT_NAMES: int  # 4096
CHART_RECURSIVE: int  # 4
CHART_REFERENCED: int  # 2
CHART_REFERENCING: int  # 1
CHART_WINGRAPH: int  # 32768
CHCOL_DEC: int  # 196608
CHCOL_DEFHIDDEN: int  # 1048576
CHCOL_DRAGHINT: int  # 2097152
CHCOL_EA: int  # 262144
CHCOL_FNAME: int  # 327680
CHCOL_FORMAT: int  # 458752
CHCOL_HEX: int  # 131072
CHCOL_INODENAME: int  # 4194304
CHCOL_PATH: int  # 65536
CHCOL_PLAIN: int  # 0
CHF_FAKE: int  # 8
CHF_INITED: int  # 1
CHF_OVER: int  # 4
CHF_PASSTHRU: int  # 16
CHF_REPLACED: int  # 2
CHF_TERM: int  # 32
CHITEM_BOLD: int  # 1
CHITEM_GRAY: int  # 16
CHITEM_ITALIC: int  # 2
CHITEM_STRIKE: int  # 8
CHITEM_UNDER: int  # 4
CHOOSER_MENU_EDIT: int  # 0
CHOOSER_MENU_JUMP: int  # 1
CHOOSER_MENU_SEARCH: int  # 2
CHOOSER_MULTI_SELECTION: int  # 2
CHOOSER_NOMAINMENU: str  # NOMAINMENU

CHOOSER_NOSTATUSBAR: str  # NOSTATUSBAR

CHOOSER_NO_SELECTION: int  # 1
CHOOSER_POPUP_MENU: int  # 4
CH_ATTRS: int  # 32
CH_BUILTIN_MASK: int  # 33030144
CH_BUILTIN_SHIFT: int  # 19
CH_CAN_DEL: int  # 512
CH_CAN_EDIT: int  # 1024
CH_CAN_INS: int  # 256
CH_CAN_REFRESH: int  # 2048
CH_FORCE_DEFAULT: int  # 128
CH_HAS_DIFF: int  # 268435456
CH_HAS_DIRTREE: int  # 33554432
CH_KEEP: int  # 2
CH_MODAL: int  # 1
CH_MULTI: int  # 4
CH_MULTI_EDIT: int  # 8
CH_NOBTNS: int  # 16
CH_NOIDB: int  # 64
CH_NON_PERSISTED_TREE: int  # -2147483648
CH_NO_FILTER: int  # 1073741824
CH_NO_SORT: int  # 536870912
CH_NO_STATUS_BAR: int  # 65536
CH_QFLT: int  # 4096
CH_QFTYP_DEFAULT: int  # 0
CH_QFTYP_FUZZY: int  # 32768
CH_QFTYP_MASK: int  # 57344
CH_QFTYP_NORMAL: int  # 8192
CH_QFTYP_REGEX: int  # 24576
CH_QFTYP_SHIFT: int  # 13
CH_QFTYP_WHOLE_WORDS: int  # 16384
CH_RENAME_IS_EDIT: int  # 262144
CH_RESTORE: int  # 131072
CH_TM_FOLDERS_ONLY: int  # 67108864
CH_TM_FULL_TREE: int  # 134217728
CH_TM_MASK: int  # 201326592
CH_TM_NO_TREE: int  # 0
CH_TM_SHIFT: int  # 26
CH_UNUSED: int  # 64
CIT_COLLAPSED: int  # 1
CK_EXTRA1: int  # 82
CK_EXTRA10: int  # 91
CK_EXTRA11: int  # 92
CK_EXTRA12: int  # 93
CK_EXTRA13: int  # 94
CK_EXTRA14: int  # 95
CK_EXTRA15: int  # 96
CK_EXTRA16: int  # 97
CK_EXTRA2: int  # 83
CK_EXTRA3: int  # 84
CK_EXTRA4: int  # 85
CK_EXTRA5: int  # 86
CK_EXTRA6: int  # 87
CK_EXTRA7: int  # 88
CK_EXTRA8: int  # 89
CK_EXTRA9: int  # 90
CK_TRACE: int  # 80
CK_TRACE_OVL: int  # 81
CLNL_FINDCMT: int  # 4
CLNL_LTRIM: int  # 2
CLNL_RTRIM: int  # 1
CLNL_TRIM: int  # 3
CMAT_BUILT: int  # 1
CMAT_CASTED: int  # 7
CMAT_CPA: int  # 5
CMAT_FINAL: int  # 8
CMAT_NICE: int  # 3
CMAT_TRANS1: int  # 2
CMAT_TRANS2: int  # 4
CMAT_TRANS3: int  # 6
CMAT_ZERO: int  # 0
CMP_A: int  # 4
CMP_AE: int  # 2
CMP_B: int  # 3
CMP_BE: int  # 5
CMP_GE: int  # 7
CMP_GT: int  # 6
CMP_LE: int  # 9
CMP_LT: int  # 8
CMP_NZ: int  # 0
CMP_Z: int  # 1
CMT_ALL: int  # 31
CMT_BLOCK1: int  # 2
CMT_BLOCK2: int  # 4
CMT_FUNC: int  # 16
CMT_LVAR: int  # 8
CMT_NONE: int  # 0
CMT_TAIL: int  # 1
CM_CC_CDECL: int  # 48
CM_CC_ELLIPSIS: int  # 64
CM_CC_FASTCALL: int  # 112
CM_CC_FIRST_PLAIN_CUSTOM: int  # 512
CM_CC_GOLANG: int  # 176
CM_CC_GOSTK: int  # 256
CM_CC_INVALID: int  # 0
CM_CC_LAST_USERCALL: int  # 255
CM_CC_MASK: int  # 240
CM_CC_PASCAL: int  # 96
CM_CC_RESERVE3: int  # 192
CM_CC_SPECIAL: int  # 240
CM_CC_SPECIALE: int  # 208
CM_CC_SPECIALP: int  # 224
CM_CC_SPOILED: int  # 160
CM_CC_STDCALL: int  # 80
CM_CC_SWIFT: int  # 144
CM_CC_THISCALL: int  # 128
CM_CC_UNKNOWN: int  # 16
CM_CC_VOIDARG: int  # 32
CM_MASK: int  # 3
CM_M_FF: int  # 4
CM_M_FN: int  # 12
CM_M_MASK: int  # 12
CM_M_NF: int  # 8
CM_M_NN: int  # 0
CM_N16_F32: int  # 2
CM_N32_F48: int  # 3
CM_N64: int  # 1
CM_N8_F16: int  # 1
CM_UNKNOWN: int  # 0
CN_KEEP_TRAILING_DIGITS: int  # 1
CN_KEEP_UNDERSCORES: int  # 2
COLLAPSED_NODE: int  # -2147483648
COLOR_ADDR: int  # 40
COLOR_ADDR_SIZE: int  # 16
COLOR_ALTOP: int  # 22
COLOR_ASMDIR: int  # 27
COLOR_AUTOCMT: int  # 4
COLOR_BG_MAX: int  # 13
COLOR_BINPREF: int  # 20
COLOR_CHAR: int  # 10
COLOR_CNAME: int  # 37
COLOR_CODE: int  # 5
COLOR_CODNAME: int  # 26
COLOR_COLLAPSED: int  # 39
COLOR_CREF: int  # 14
COLOR_CREFTAIL: int  # 16
COLOR_CURITEM: int  # 9
COLOR_CURLINE: int  # 10
COLOR_DATA: int  # 6
COLOR_DATNAME: int  # 6
COLOR_DCHAR: int  # 30
COLOR_DEFAULT: int  # 1
COLOR_DEMNAME: int  # 8
COLOR_DNAME: int  # 7
COLOR_DNUM: int  # 31
COLOR_DREF: int  # 15
COLOR_DREFTAIL: int  # 17
COLOR_DSTR: int  # 29
COLOR_ERROR: int  # 18
COLOR_ESC: str  # 
COLOR_EXTERN: int  # 8
COLOR_EXTRA: int  # 21
COLOR_FG_MAX: int  # 40
COLOR_HIDLINE: int  # 11
COLOR_HIDNAME: int  # 23
COLOR_IMPNAME: int  # 34
COLOR_INSN: int  # 5
COLOR_INV: str  # 
COLOR_KEYWORD: int  # 32
COLOR_LIBFUNC: int  # 3
COLOR_LIBNAME: int  # 24
COLOR_LOCNAME: int  # 25
COLOR_LUMFUNC: int  # 12
COLOR_LUMINA: int  # 52
COLOR_MACRO: int  # 28
COLOR_NUMBER: int  # 12
COLOR_OFF: str  # 
COLOR_ON: str  # 
COLOR_OPND1: int  # 41
COLOR_OPND2: int  # 42
COLOR_OPND3: int  # 43
COLOR_OPND4: int  # 44
COLOR_OPND5: int  # 45
COLOR_OPND6: int  # 46
COLOR_OPND7: int  # 47
COLOR_OPND8: int  # 48
COLOR_PREFIX: int  # 19
COLOR_REG: int  # 33
COLOR_REGCMT: int  # 2
COLOR_REGFUNC: int  # 4
COLOR_RESERVED1: int  # 51
COLOR_RPTCMT: int  # 3
COLOR_SEGNAME: int  # 35
COLOR_SELECTED: int  # 2
COLOR_STRING: int  # 11
COLOR_SYMBOL: int  # 9
COLOR_UNAME: int  # 38
COLOR_UNKNAME: int  # 36
COLOR_UNKNOWN: int  # 7
COLOR_VOIDOP: int  # 13
COMMSTATE_DONE: int  # 512
COMMSTATE_GO: int  # 256
COMMSTATE_NONE: int  # 0
COMP_BC: int  # 2
COMP_BP: int  # 8
COMP_GNU: int  # 6
COMP_MASK: int  # 15
COMP_MS: int  # 1
COMP_UNK: int  # 0
COMP_UNSURE: int  # 128
COMP_VISAGE: int  # 7
COMP_WATCOM: int  # 3
CPBLK_FAST: int  # 0
CPBLK_MINREF: int  # 1
CPBLK_OPTJMP: int  # 2
CPL_DEL_MACROS: int  # 1
CPL_ONLY_SAFE: int  # 4
CPL_USE_LABELS: int  # 2
CP_BOM: int  # 65279
CP_ELLIPSIS: int  # 8230
CP_REPLCHAR: int  # 65533
CP_UTF16: int  # 1200
CP_UTF8: int  # 65001
CR16_addb: int  # 1
CR16_addcb: int  # 5
CR16_addcw: int  # 6
CR16_addub: int  # 3
CR16_adduw: int  # 4
CR16_addw: int  # 2
CR16_andb: int  # 7
CR16_andw: int  # 8
CR16_ashub: int  # 9
CR16_ashuw: int  # 10
CR16_bal: int  # 26
CR16_bcc: int  # 14
CR16_bcs: int  # 13
CR16_beq: int  # 11
CR16_beq0b: int  # 31
CR16_beq0w: int  # 32
CR16_beq1b: int  # 29
CR16_beq1w: int  # 30
CR16_bfc: int  # 20
CR16_bfs: int  # 19
CR16_bge: int  # 24
CR16_bgt: int  # 17
CR16_bhi: int  # 15
CR16_bhs: int  # 22
CR16_ble: int  # 18
CR16_blo: int  # 21
CR16_bls: int  # 16
CR16_blt: int  # 23
CR16_bne: int  # 12
CR16_bne0b: int  # 35
CR16_bne0w: int  # 36
CR16_bne1b: int  # 33
CR16_bne1w: int  # 34
CR16_br: int  # 25
CR16_cbitb: int  # 106
CR16_cbitw: int  # 107
CR16_cmpb: int  # 27
CR16_cmpw: int  # 28
CR16_di: int  # 37
CR16_ei: int  # 38
CR16_eiwait: int  # 109
CR16_excp: int  # 39
CR16_jal: int  # 55
CR16_jcc: int  # 43
CR16_jcs: int  # 42
CR16_jeq: int  # 40
CR16_jfc: int  # 49
CR16_jfs: int  # 48
CR16_jge: int  # 53
CR16_jgt: int  # 46
CR16_jhi: int  # 44
CR16_jhs: int  # 51
CR16_jle: int  # 47
CR16_jlo: int  # 50
CR16_jls: int  # 45
CR16_jlt: int  # 52
CR16_jne: int  # 41
CR16_jump: int  # 54
CR16_last: int  # 112
CR16_loadb: int  # 56
CR16_loadm: int  # 58
CR16_loadw: int  # 57
CR16_lpr: int  # 59
CR16_lshb: int  # 60
CR16_lshw: int  # 61
CR16_movb: int  # 62
CR16_movd: int  # 66
CR16_movw: int  # 63
CR16_movxb: int  # 64
CR16_movzb: int  # 65
CR16_mulb: int  # 67
CR16_mulsb: int  # 69
CR16_mulsw: int  # 70
CR16_muluw: int  # 71
CR16_mulw: int  # 68
CR16_nop: int  # 72
CR16_null: int  # 0
CR16_orb: int  # 73
CR16_orw: int  # 74
CR16_pop: int  # 76
CR16_popret: int  # 77
CR16_push: int  # 75
CR16_retx: int  # 78
CR16_sbitb: int  # 104
CR16_sbitw: int  # 105
CR16_scc: int  # 82
CR16_scs: int  # 81
CR16_seq: int  # 79
CR16_sfc: int  # 88
CR16_sfs: int  # 87
CR16_sge: int  # 92
CR16_sgt: int  # 85
CR16_shi: int  # 83
CR16_shs: int  # 90
CR16_sle: int  # 86
CR16_slo: int  # 89
CR16_sls: int  # 84
CR16_slt: int  # 91
CR16_sne: int  # 80
CR16_spr: int  # 93
CR16_storb: int  # 94
CR16_storm: int  # 96
CR16_storw: int  # 95
CR16_subb: int  # 97
CR16_subcb: int  # 99
CR16_subcw: int  # 100
CR16_subw: int  # 98
CR16_tbit: int  # 101
CR16_tbitb: int  # 102
CR16_tbitw: int  # 103
CR16_wait: int  # 108
CR16_xorb: int  # 110
CR16_xorw: int  # 111
CREATETB_ADV: int  # 1
CSIDL_APPDATA: int  # 26
CSIDL_LOCAL_APPDATA: int  # 28
CSIDL_PROGRAM_FILES: int  # 38
CSIDL_PROGRAM_FILESX86: int  # 42
CSIDL_PROGRAM_FILES_COMMON: int  # 43
CSS_BREAK: int  # -4
CSS_NODBG: int  # -1
CSS_NOMEM: int  # -3
CSS_NORANGE: int  # -2
CSS_OK: int  # 0
CTXF_BINOP_STATE: int  # 786432
CTXF_BIT_PREFIX: int  # 2097152
CTXF_CMT_STATE: int  # 768
CTXF_CODE: int  # 4
CTXF_DBLIND_OPND: int  # 131072
CTXF_DEMANGLED_LABEL: int  # 4096
CTXF_DEMANGLED_OK: int  # 16384
CTXF_GEN_CMT: int  # 128
CTXF_GEN_XREFS: int  # 16
CTXF_HIDDEN_ADDR: int  # 1048576
CTXF_LABEL_OK: int  # 8192
CTXF_MAIN: int  # 1
CTXF_MULTI: int  # 2
CTXF_NORMAL_LABEL: int  # 2048
CTXF_OUTCTX_T: int  # 65536
CTXF_OVSTORE_PRNT: int  # 32768
CTXF_STACK: int  # 8
CTXF_UNHIDE: int  # 4194304
CTXF_VOIDS: int  # 1024
CTXF_XREF_STATE: int  # 96
CURLOC_LIST: str  # $ curlocs
CUSTOM_INSN_ITYPE: int  # 32768
CVH_CLICK: int  # 6
CVH_CLOSE: int  # 5
CVH_CURPOS: int  # 4
CVH_DBLCLICK: int  # 3
CVH_HELP: int  # 8
CVH_KEYDOWN: int  # 1
CVH_MOUSEMOVE: int  # 9
CVH_POPUP: int  # 2
CVH_QT_AWARE: int  # 7
CVH_USERDATA: int  # 0
CVLF_USE_MOUSE: int  # 1
CVNF_ACT: int  # 4
CVNF_JUMP: int  # 2
CVNF_LAZY: int  # 1
CV_FAST: int  # 0
CV_INSNS: int  # 16
CV_PARENTS: int  # 2
CV_POST: int  # 4
CV_PRUNE: int  # 1
CV_RESTART: int  # 8
C_PC_COMPACT: int  # 10
C_PC_FLAT: int  # 3
C_PC_HUGE: int  # 6
C_PC_LARGE: int  # 6
C_PC_MEDIUM: int  # 14
C_PC_SMALL: int  # 2
C_PC_TINY: int  # 2
DALVIK_ADD_DOUBLE: int  # 163
DALVIK_ADD_DOUBLE_2ADDR: int  # 195
DALVIK_ADD_FLOAT: int  # 158
DALVIK_ADD_FLOAT_2ADDR: int  # 190
DALVIK_ADD_INT: int  # 136
DALVIK_ADD_INT_2ADDR: int  # 168
DALVIK_ADD_INT_LIT16: int  # 200
DALVIK_ADD_INT_LIT8: int  # 208
DALVIK_ADD_LONG: int  # 147
DALVIK_ADD_LONG_2ADDR: int  # 179
DALVIK_AGET: int  # 63
DALVIK_AGET_BOOLEAN: int  # 66
DALVIK_AGET_BYTE: int  # 67
DALVIK_AGET_CHAR: int  # 68
DALVIK_AGET_OBJECT: int  # 65
DALVIK_AGET_SHORT: int  # 69
DALVIK_AGET_WIDE: int  # 64
DALVIK_AND_INT: int  # 141
DALVIK_AND_INT_2ADDR: int  # 173
DALVIK_AND_INT_LIT16: int  # 205
DALVIK_AND_INT_LIT8: int  # 213
DALVIK_AND_LONG: int  # 152
DALVIK_AND_LONG_2ADDR: int  # 184
DALVIK_APUT: int  # 70
DALVIK_APUT_BOOLEAN: int  # 73
DALVIK_APUT_BYTE: int  # 74
DALVIK_APUT_CHAR: int  # 75
DALVIK_APUT_OBJECT: int  # 72
DALVIK_APUT_SHORT: int  # 76
DALVIK_APUT_WIDE: int  # 71
DALVIK_ARRAY_LENGTH: int  # 34
DALVIK_BREAKPOINT: int  # 228
DALVIK_CHECK_CAST: int  # 32
DALVIK_CMPG_DOUBLE: int  # 49
DALVIK_CMPG_FLOAT: int  # 47
DALVIK_CMPL_DOUBLE: int  # 48
DALVIK_CMPL_FLOAT: int  # 46
DALVIK_CMP_LONG: int  # 50
DALVIK_CONST: int  # 21
DALVIK_CONST_16: int  # 20
DALVIK_CONST_4: int  # 19
DALVIK_CONST_CLASS: int  # 29
DALVIK_CONST_HIGH16: int  # 22
DALVIK_CONST_METHOD_HANDLE: int  # 251
DALVIK_CONST_METHOD_TYPE: int  # 252
DALVIK_CONST_STRING: int  # 27
DALVIK_CONST_STRING_JUMBO: int  # 28
DALVIK_CONST_WIDE: int  # 25
DALVIK_CONST_WIDE_16: int  # 23
DALVIK_CONST_WIDE_32: int  # 24
DALVIK_CONST_WIDE_HIGH16: int  # 26
DALVIK_DIV_DOUBLE: int  # 166
DALVIK_DIV_DOUBLE_2ADDR: int  # 198
DALVIK_DIV_FLOAT: int  # 161
DALVIK_DIV_FLOAT_2ADDR: int  # 193
DALVIK_DIV_INT: int  # 139
DALVIK_DIV_INT_2ADDR: int  # 171
DALVIK_DIV_INT_LIT16: int  # 203
DALVIK_DIV_INT_LIT8: int  # 211
DALVIK_DIV_LONG: int  # 150
DALVIK_DIV_LONG_2ADDR: int  # 182
DALVIK_DOUBLE_TO_FLOAT: int  # 132
DALVIK_DOUBLE_TO_INT: int  # 130
DALVIK_DOUBLE_TO_LONG: int  # 131
DALVIK_EXECUTE_INLINE: int  # 230
DALVIK_EXECUTE_INLINE_RANGE: int  # 231
DALVIK_FILLED_NEW_ARRAY: int  # 37
DALVIK_FILLED_NEW_ARRAY_RANGE: int  # 38
DALVIK_FILL_ARRAY_DATA: int  # 39
DALVIK_FLOAT_TO_DOUBLE: int  # 129
DALVIK_FLOAT_TO_INT: int  # 127
DALVIK_FLOAT_TO_LONG: int  # 128
DALVIK_GOTO: int  # 41
DALVIK_GOTO_16: int  # 42
DALVIK_GOTO_32: int  # 43
DALVIK_IF_EQ: int  # 51
DALVIK_IF_EQZ: int  # 57
DALVIK_IF_GE: int  # 54
DALVIK_IF_GEZ: int  # 60
DALVIK_IF_GT: int  # 55
DALVIK_IF_GTZ: int  # 61
DALVIK_IF_LE: int  # 56
DALVIK_IF_LEZ: int  # 62
DALVIK_IF_LT: int  # 53
DALVIK_IF_LTZ: int  # 59
DALVIK_IF_NE: int  # 52
DALVIK_IF_NEZ: int  # 58
DALVIK_IGET: int  # 77
DALVIK_IGET_BOOLEAN: int  # 80
DALVIK_IGET_BYTE: int  # 81
DALVIK_IGET_CHAR: int  # 82
DALVIK_IGET_OBJECT: int  # 79
DALVIK_IGET_OBJECT_QUICK: int  # 236
DALVIK_IGET_OBJECT_VOLATILE: int  # 223
DALVIK_IGET_QUICK: int  # 234
DALVIK_IGET_SHORT: int  # 83
DALVIK_IGET_VOLATILE: int  # 219
DALVIK_IGET_WIDE: int  # 78
DALVIK_IGET_WIDE_QUICK: int  # 235
DALVIK_IGET_WIDE_VOLATILE: int  # 224
DALVIK_INSTANCE_OF: int  # 33
DALVIK_INT_TO_BYTE: int  # 133
DALVIK_INT_TO_CHAR: int  # 134
DALVIK_INT_TO_DOUBLE: int  # 123
DALVIK_INT_TO_FLOAT: int  # 122
DALVIK_INT_TO_LONG: int  # 121
DALVIK_INT_TO_SHORT: int  # 135
DALVIK_INVOKE_CUSTOM: int  # 249
DALVIK_INVOKE_CUSTOM_RANGE: int  # 250
DALVIK_INVOKE_DIRECT: int  # 107
DALVIK_INVOKE_DIRECT_EMPTY: int  # 232
DALVIK_INVOKE_DIRECT_RANGE: int  # 112
DALVIK_INVOKE_INTERFACE: int  # 109
DALVIK_INVOKE_INTERFACE_RANGE: int  # 114
DALVIK_INVOKE_POLYMORPHIC: int  # 247
DALVIK_INVOKE_POLYMORPHIC_RANGE: int  # 248
DALVIK_INVOKE_STATIC: int  # 108
DALVIK_INVOKE_STATIC_RANGE: int  # 113
DALVIK_INVOKE_SUPER: int  # 106
DALVIK_INVOKE_SUPER_QUICK: int  # 242
DALVIK_INVOKE_SUPER_QUICK_RANGE: int  # 243
DALVIK_INVOKE_SUPER_RANGE: int  # 111
DALVIK_INVOKE_VIRTUAL: int  # 105
DALVIK_INVOKE_VIRTUAL_QUICK: int  # 240
DALVIK_INVOKE_VIRTUAL_QUICK_RANGE: int  # 241
DALVIK_INVOKE_VIRTUAL_RANGE: int  # 110
DALVIK_IPUT: int  # 84
DALVIK_IPUT_BOOLEAN: int  # 87
DALVIK_IPUT_BYTE: int  # 88
DALVIK_IPUT_CHAR: int  # 89
DALVIK_IPUT_OBJECT: int  # 86
DALVIK_IPUT_OBJECT_QUICK: int  # 239
DALVIK_IPUT_OBJECT_VOLATILE: int  # 244
DALVIK_IPUT_QUICK: int  # 237
DALVIK_IPUT_SHORT: int  # 90
DALVIK_IPUT_VOLATILE: int  # 220
DALVIK_IPUT_WIDE: int  # 85
DALVIK_IPUT_WIDE_QUICK: int  # 238
DALVIK_IPUT_WIDE_VOLATILE: int  # 225
DALVIK_LAST: int  # 253
DALVIK_LONG_TO_DOUBLE: int  # 126
DALVIK_LONG_TO_FLOAT: int  # 125
DALVIK_LONG_TO_INT: int  # 124
DALVIK_MONITOR_ENTER: int  # 30
DALVIK_MONITOR_EXIT: int  # 31
DALVIK_MOVE: int  # 2
DALVIK_MOVE_16: int  # 4
DALVIK_MOVE_EXCEPTION: int  # 14
DALVIK_MOVE_FROM16: int  # 3
DALVIK_MOVE_OBJECT: int  # 8
DALVIK_MOVE_OBJECT_16: int  # 10
DALVIK_MOVE_OBJECT_FROM16: int  # 9
DALVIK_MOVE_RESULT: int  # 11
DALVIK_MOVE_RESULT_OBJECT: int  # 13
DALVIK_MOVE_RESULT_WIDE: int  # 12
DALVIK_MOVE_WIDE: int  # 5
DALVIK_MOVE_WIDE_16: int  # 7
DALVIK_MOVE_WIDE_FROM16: int  # 6
DALVIK_MUL_DOUBLE: int  # 165
DALVIK_MUL_DOUBLE_2ADDR: int  # 197
DALVIK_MUL_FLOAT: int  # 160
DALVIK_MUL_FLOAT_2ADDR: int  # 192
DALVIK_MUL_INT: int  # 138
DALVIK_MUL_INT_2ADDR: int  # 170
DALVIK_MUL_INT_LIT16: int  # 202
DALVIK_MUL_INT_LIT8: int  # 210
DALVIK_MUL_LONG: int  # 149
DALVIK_MUL_LONG_2ADDR: int  # 181
DALVIK_NEG_DOUBLE: int  # 120
DALVIK_NEG_FLOAT: int  # 119
DALVIK_NEG_INT: int  # 115
DALVIK_NEG_LONG: int  # 117
DALVIK_NEW_ARRAY: int  # 36
DALVIK_NEW_INSTANCE: int  # 35
DALVIK_NOP: int  # 1
DALVIK_NOT_INT: int  # 116
DALVIK_NOT_LONG: int  # 118
DALVIK_OR_INT: int  # 142
DALVIK_OR_INT_2ADDR: int  # 174
DALVIK_OR_INT_LIT16: int  # 206
DALVIK_OR_INT_LIT8: int  # 214
DALVIK_OR_LONG: int  # 153
DALVIK_OR_LONG_2ADDR: int  # 185
DALVIK_PACKED_SWITCH: int  # 44
DALVIK_REM_DOUBLE: int  # 167
DALVIK_REM_DOUBLE_2ADDR: int  # 199
DALVIK_REM_FLOAT: int  # 162
DALVIK_REM_FLOAT_2ADDR: int  # 194
DALVIK_REM_INT: int  # 140
DALVIK_REM_INT_2ADDR: int  # 172
DALVIK_REM_INT_LIT16: int  # 204
DALVIK_REM_INT_LIT8: int  # 212
DALVIK_REM_LONG: int  # 151
DALVIK_REM_LONG_2ADDR: int  # 183
DALVIK_RETURN: int  # 16
DALVIK_RETURN_OBJECT: int  # 18
DALVIK_RETURN_VOID: int  # 15
DALVIK_RETURN_VOID_BARRIER: int  # 233
DALVIK_RETURN_WIDE: int  # 17
DALVIK_RSUB_INT: int  # 201
DALVIK_RSUB_INT_LIT8: int  # 209
DALVIK_SGET: int  # 91
DALVIK_SGET_BOOLEAN: int  # 94
DALVIK_SGET_BYTE: int  # 95
DALVIK_SGET_CHAR: int  # 96
DALVIK_SGET_OBJECT: int  # 93
DALVIK_SGET_OBJECT_VOLATILE: int  # 245
DALVIK_SGET_SHORT: int  # 97
DALVIK_SGET_VOLATILE: int  # 221
DALVIK_SGET_WIDE: int  # 92
DALVIK_SGET_WIDE_VOLATILE: int  # 226
DALVIK_SHL_INT: int  # 144
DALVIK_SHL_INT_2ADDR: int  # 176
DALVIK_SHL_INT_LIT8: int  # 216
DALVIK_SHL_LONG: int  # 155
DALVIK_SHL_LONG_2ADDR: int  # 187
DALVIK_SHR_INT: int  # 145
DALVIK_SHR_INT_2ADDR: int  # 177
DALVIK_SHR_INT_LIT8: int  # 217
DALVIK_SHR_LONG: int  # 156
DALVIK_SHR_LONG_2ADDR: int  # 188
DALVIK_SPARSE_SWITCH: int  # 45
DALVIK_SPUT: int  # 98
DALVIK_SPUT_BOOLEAN: int  # 101
DALVIK_SPUT_BYTE: int  # 102
DALVIK_SPUT_CHAR: int  # 103
DALVIK_SPUT_OBJECT: int  # 100
DALVIK_SPUT_OBJECT_VOLATILE: int  # 246
DALVIK_SPUT_SHORT: int  # 104
DALVIK_SPUT_VOLATILE: int  # 222
DALVIK_SPUT_WIDE: int  # 99
DALVIK_SPUT_WIDE_VOLATILE: int  # 227
DALVIK_SUB_DOUBLE: int  # 164
DALVIK_SUB_DOUBLE_2ADDR: int  # 196
DALVIK_SUB_FLOAT: int  # 159
DALVIK_SUB_FLOAT_2ADDR: int  # 191
DALVIK_SUB_INT: int  # 137
DALVIK_SUB_INT_2ADDR: int  # 169
DALVIK_SUB_LONG: int  # 148
DALVIK_SUB_LONG_2ADDR: int  # 180
DALVIK_THROW: int  # 40
DALVIK_THROW_VERIFICATION_ERROR: int  # 229
DALVIK_UNUSED: int  # 0
DALVIK_USHR_INT: int  # 146
DALVIK_USHR_INT_2ADDR: int  # 178
DALVIK_USHR_INT_LIT8: int  # 218
DALVIK_USHR_LONG: int  # 157
DALVIK_USHR_LONG_2ADDR: int  # 189
DALVIK_XOR_INT: int  # 143
DALVIK_XOR_INT_2ADDR: int  # 175
DALVIK_XOR_INT_LIT16: int  # 207
DALVIK_XOR_INT_LIT8: int  # 215
DALVIK_XOR_LONG: int  # 154
DALVIK_XOR_LONG_2ADDR: int  # 186
DBFL_BAK: int  # 4
DBFL_COMP: int  # 2
DBFL_KILL: int  # 1
DBFL_TEMP: int  # 8
DBGINV_ALL: int  # 32767
DBGINV_MEMCFG: int  # 2
DBGINV_MEMORY: int  # 1
DBGINV_NONE: int  # 0
DBGINV_REDRAW: int  # 32768
DBGINV_REGS: int  # 4
DBG_FLAG_ADD_ENVS: int  # 134217728
DBG_FLAG_ANYSIZE_HWBPT: int  # 4194304
DBG_FLAG_CAN_CONT_BPT: int  # 16
DBG_FLAG_CLEAN_EXIT: int  # 256
DBG_FLAG_CONNSTRING: int  # 8192
DBG_FLAG_DEBTHREAD: int  # 524288
DBG_FLAG_DEBUG_DLL: int  # 1048576
DBG_FLAG_DISABLE_ASLR: int  # 536870912
DBG_FLAG_DONT_DISTURB: int  # 64
DBG_FLAG_EXITSHOTOK: int  # 65536
DBG_FLAG_FAKE_ATTACH: int  # 4
DBG_FLAG_FAKE_MEMORY: int  # 2097152
DBG_FLAG_FAST_STEP: int  # 67108864
DBG_FLAG_FULL_INSTR_BPT: int  # 2147483648
DBG_FLAG_HWDATBPT_ONE: int  # 8
DBG_FLAG_LAZY_WATCHPTS: int  # 33554432
DBG_FLAG_LOWCNDS: int  # 262144
DBG_FLAG_MANMEMINFO: int  # 32768
DBG_FLAG_MERGE_ENVS: int  # 268435456
DBG_FLAG_NEEDPORT: int  # 32
DBG_FLAG_NOHOST: int  # 2
DBG_FLAG_NOPARAMETERS: int  # 2048
DBG_FLAG_NOPASSWORD: int  # 4096
DBG_FLAG_NOSTARTDIR: int  # 1024
DBG_FLAG_PREFER_SWBPTS: int  # 16777216
DBG_FLAG_REMOTE: int  # 1
DBG_FLAG_SAFE: int  # 128
DBG_FLAG_SMALLBLKS: int  # 16384
DBG_FLAG_TRACER_MODULE: int  # 8388608
DBG_FLAG_TTD: int  # 1073741824
DBG_FLAG_USE_SREGS: int  # 512
DBG_FLAG_VIRTHREADS: int  # 131072
DBG_HAS_APPCALL: int  # 17592186044416
DBG_HAS_ATTACH_PROCESS: int  # 8589934592
DBG_HAS_CHECK_BPT: int  # 2199023255552
DBG_HAS_DETACH_PROCESS: int  # 17179869184
DBG_HAS_GET_PROCESSES: int  # 4294967296
DBG_HAS_MAP_ADDRESS: int  # 70368744177664
DBG_HAS_OPEN_FILE: int  # 4398046511104
DBG_HAS_REQUEST_PAUSE: int  # 34359738368
DBG_HAS_REXEC: int  # 35184372088832
DBG_HAS_SET_EXCEPTION_INFO: int  # 68719476736
DBG_HAS_SET_RESUME_MODE: int  # 549755813888
DBG_HAS_THREAD_CONTINUE: int  # 274877906944
DBG_HAS_THREAD_GET_SREG_BASE: int  # 1099511627776
DBG_HAS_THREAD_SUSPEND: int  # 137438953472
DBG_HAS_UPDATE_CALL_STACK: int  # 8796093022208
DBG_HIDE_WINDOW: int  # 32
DBG_NO_ASLR: int  # 128
DBG_NO_TRACE: int  # 16
DBG_PROC_32BIT: int  # 4
DBG_PROC_64BIT: int  # 8
DBG_PROC_IS_DLL: int  # 1
DBG_PROC_IS_GUI: int  # 2
DBG_RESMOD_STEP_BACKINTO: int  # 256
DBG_RESMOD_STEP_HANDLE: int  # 128
DBG_RESMOD_STEP_INTO: int  # 1
DBG_RESMOD_STEP_OUT: int  # 4
DBG_RESMOD_STEP_OVER: int  # 2
DBG_RESMOD_STEP_SRCINTO: int  # 8
DBG_RESMOD_STEP_SRCOUT: int  # 32
DBG_RESMOD_STEP_SRCOVER: int  # 16
DBG_RESMOD_STEP_USER: int  # 64
DBG_SUSPENDED: int  # 64
DEBNAME_EXACT: int  # 0
DEBNAME_LOWER: int  # 1
DEBNAME_NICE: int  # 3
DEBNAME_UPPER: int  # 2
DEBUGGER_ID_6811_EMULATOR: int  # 7
DEBUGGER_ID_ARM_IPHONE_USER: int  # 5
DEBUGGER_ID_ARM_LINUX_USER: int  # 11
DEBUGGER_ID_ARM_MACOS_USER: int  # 17
DEBUGGER_ID_DALVIK_USER: int  # 15
DEBUGGER_ID_GDB_USER: int  # 8
DEBUGGER_ID_TRACE_REPLAYER: int  # 12
DEBUGGER_ID_WINDBG: int  # 9
DEBUGGER_ID_X86_DOSBOX_EMULATOR: int  # 10
DEBUGGER_ID_X86_IA32_BOCHS: int  # 6
DEBUGGER_ID_X86_IA32_LINUX_USER: int  # 1
DEBUGGER_ID_X86_IA32_MACOSX_USER: int  # 3
DEBUGGER_ID_X86_IA32_WIN32_USER: int  # 0
DEBUGGER_ID_X86_PIN_TRACER: int  # 14
DEBUGGER_ID_XNU_USER: int  # 16
DECOMP_ALL_BLKS: int  # 16
DECOMP_GXREFS_DEFLT: int  # 0
DECOMP_GXREFS_FORCE: int  # 128
DECOMP_GXREFS_NOUPD: int  # 64
DECOMP_NO_CACHE: int  # 2
DECOMP_NO_FRAME: int  # 4
DECOMP_NO_HIDE: int  # 32
DECOMP_NO_WAIT: int  # 1
DECOMP_OUTLINE: int  # -2147483648
DECOMP_VOID_MBA: int  # 256
DECOMP_WARNINGS: int  # 8
DEC_ERROR: int  # -1
DEC_NOTASK: int  # -2
DEC_TIMEOUT: int  # 0
DEFAULT_CURSOR_Y: int  # 65535
DEFAULT_INDENT: int  # 65535
DEFAULT_LNNUM: int  # -1
DEFAULT_PLACE_LNNUM: int  # -1
DEFMASK64: int  # 18446744073709551615
DEF_ADDRSIZE: int  # 8
DELIT_DELNAMES: int  # 2
DELIT_EXPAND: int  # 1
DELIT_KEEPFUNC: int  # 32
DELIT_NOCMT: int  # 16
DELIT_NOTRUNC: int  # 4
DELIT_NOUNAME: int  # 8
DELIT_SIMPLE: int  # 0
DEMNAM_CMNT: int  # 0
DEMNAM_FIRST: int  # 8
DEMNAM_GCC3: int  # 4
DEMNAM_MASK: int  # 3
DEMNAM_NAME: int  # 1
DEMNAM_NONE: int  # 2
DIRTREE_BPTS: int  # 5
DIRTREE_END: int  # 7
DIRTREE_FUNCS: int  # 1
DIRTREE_IDAPLACE_BOOKMARKS: int  # 4
DIRTREE_IMPORTS: int  # 3
DIRTREE_LOCAL_TYPES: int  # 0
DIRTREE_LTYPES_BOOKMARKS: int  # 6
DIRTREE_NAMES: int  # 2
DLLEXT: str  # so
DOPT_BPT_MSGS: int  # 16
DOPT_DISABLE_ASLR: int  # 524288
DOPT_END_BPT: int  # 65536
DOPT_ENTRY_BPT: int  # 4096
DOPT_EXCDLG: int  # 24576
DOPT_FAST_STEP: int  # 262144
DOPT_INFO_BPT: int  # 512
DOPT_INFO_MSGS: int  # 256
DOPT_LIB_BPT: int  # 128
DOPT_LIB_MSGS: int  # 64
DOPT_LOAD_DINFO: int  # 32768
DOPT_REAL_MEMORY: int  # 1024
DOPT_REDO_STACK: int  # 2048
DOPT_SEGM_MSGS: int  # 1
DOPT_START_BPT: int  # 2
DOPT_TEMP_HWBPT: int  # 131072
DOPT_THREAD_BPT: int  # 8
DOPT_THREAD_MSGS: int  # 4
DP_BEFORE: int  # 32
DP_BOTTOM: int  # 8
DP_FLOATING: int  # 128
DP_INSIDE: int  # 16
DP_LEFT: int  # 1
DP_RIGHT: int  # 4
DP_SZHINT: int  # 256
DP_TAB: int  # 64
DP_TOP: int  # 2
DQT_COMPILER: int  # 0
DQT_FULL: int  # 2
DQT_NAME_TYPE: int  # 1
DQT_NPURGED_2: int  # -2
DQT_NPURGED_4: int  # -4
DQT_NPURGED_8: int  # -8
DRC_CRC: int  # 2
DRC_ERROR: int  # -7
DRC_EVENTS: int  # 3
DRC_FAILED: int  # -1
DRC_IDBSEG: int  # -4
DRC_NETERR: int  # -2
DRC_NOCHG: int  # -6
DRC_NOFILE: int  # -3
DRC_NONE: int  # 0
DRC_NOPROC: int  # -5
DRC_OK: int  # 1
DSP56_abs: int  # 1
DSP56_adc: int  # 2
DSP56_add: int  # 3
DSP56_addl: int  # 4
DSP56_addr: int  # 5
DSP56_and: int  # 6
DSP56_andi: int  # 7
DSP56_asl: int  # 8
DSP56_asl4: int  # 9
DSP56_asr: int  # 10
DSP56_asr16: int  # 12
DSP56_asr4: int  # 11
DSP56_bcc: int  # 18
DSP56_bchg: int  # 19
DSP56_bclr: int  # 20
DSP56_bfchg: int  # 13
DSP56_bfclr: int  # 14
DSP56_bfset: int  # 15
DSP56_bftsth: int  # 16
DSP56_bftstl: int  # 17
DSP56_bra: int  # 21
DSP56_brclr: int  # 22
DSP56_brkcc: int  # 23
DSP56_brset: int  # 24
DSP56_bscc: int  # 25
DSP56_bsclr: int  # 26
DSP56_bset: int  # 27
DSP56_bsr: int  # 28
DSP56_bsset: int  # 29
DSP56_btst: int  # 30
DSP56_chkaau: int  # 31
DSP56_clb: int  # 32
DSP56_clr: int  # 33
DSP56_clr24: int  # 34
DSP56_cmp: int  # 35
DSP56_cmpm: int  # 36
DSP56_cmpu: int  # 37
DSP56_debug: int  # 38
DSP56_debugcc: int  # 39
DSP56_dec: int  # 40
DSP56_dec24: int  # 41
DSP56_div: int  # 42
DSP56_dmac: int  # 43
DSP56_do: int  # 44
DSP56_do_f: int  # 45
DSP56_dor: int  # 46
DSP56_dor_f: int  # 47
DSP56_enddo: int  # 48
DSP56_eor: int  # 49
DSP56_ext: int  # 52
DSP56_extract: int  # 50
DSP56_extractu: int  # 51
DSP56_ill: int  # 53
DSP56_imac: int  # 54
DSP56_impy: int  # 55
DSP56_inc: int  # 56
DSP56_inc24: int  # 57
DSP56_insert: int  # 58
DSP56_jcc: int  # 59
DSP56_jclr: int  # 60
DSP56_jmp: int  # 61
DSP56_jscc: int  # 62
DSP56_jsclr: int  # 63
DSP56_jset: int  # 64
DSP56_jsr: int  # 65
DSP56_jsset: int  # 66
DSP56_last: int  # 133
DSP56_lea: int  # 71
DSP56_lra: int  # 67
DSP56_lsl: int  # 68
DSP56_lsr: int  # 69
DSP56_lua: int  # 70
DSP56_mac: int  # 72
DSP56_mac_s_u: int  # 74
DSP56_maci: int  # 73
DSP56_macr: int  # 75
DSP56_macri: int  # 76
DSP56_max: int  # 77
DSP56_maxm: int  # 78
DSP56_merge: int  # 79
DSP56_move: int  # 80
DSP56_movec: int  # 81
DSP56_movei: int  # 82
DSP56_movem: int  # 83
DSP56_movep: int  # 84
DSP56_moves: int  # 85
DSP56_mpy: int  # 86
DSP56_mpy_s_u: int  # 88
DSP56_mpyi: int  # 87
DSP56_mpyr: int  # 89
DSP56_mpyri: int  # 90
DSP56_neg: int  # 91
DSP56_negc: int  # 92
DSP56_nop: int  # 93
DSP56_norm: int  # 94
DSP56_normf: int  # 95
DSP56_not: int  # 96
DSP56_null: int  # 0
DSP56_or: int  # 97
DSP56_ori: int  # 98
DSP56_pflush: int  # 99
DSP56_pflushun: int  # 100
DSP56_pfree: int  # 101
DSP56_plock: int  # 102
DSP56_plockr: int  # 103
DSP56_pmov: int  # 132
DSP56_punlock: int  # 104
DSP56_punlockr: int  # 105
DSP56_rep: int  # 106
DSP56_repcc: int  # 107
DSP56_reset: int  # 108
DSP56_rnd: int  # 109
DSP56_rol: int  # 110
DSP56_ror: int  # 111
DSP56_rti: int  # 112
DSP56_rts: int  # 113
DSP56_sbc: int  # 114
DSP56_stop: int  # 115
DSP56_sub: int  # 116
DSP56_subl: int  # 117
DSP56_subr: int  # 118
DSP56_swap: int  # 119
DSP56_swi: int  # 131
DSP56_tcc: int  # 120
DSP56_tfr: int  # 121
DSP56_tfr2: int  # 122
DSP56_tfr3: int  # 123
DSP56_trap: int  # 124
DSP56_trapcc: int  # 125
DSP56_tst: int  # 126
DSP56_tst2: int  # 127
DSP56_vsl: int  # 128
DSP56_wait: int  # 129
DSP56_zero: int  # 130
DSP96_abs: int  # 1
DSP96_add: int  # 2
DSP96_addc: int  # 3
DSP96_and: int  # 4
DSP96_andc: int  # 5
DSP96_andi: int  # 6
DSP96_asl: int  # 7
DSP96_asr: int  # 8
DSP96_bcc: int  # 9
DSP96_bccd: int  # 10
DSP96_bchg: int  # 11
DSP96_bclr: int  # 12
DSP96_bfind: int  # 13
DSP96_bra: int  # 14
DSP96_brclr: int  # 15
DSP96_brset: int  # 16
DSP96_bscc: int  # 17
DSP96_bsccd: int  # 18
DSP96_bsclr: int  # 19
DSP96_bset: int  # 20
DSP96_bsr: int  # 21
DSP96_bsrd: int  # 22
DSP96_bsset: int  # 23
DSP96_btst: int  # 24
DSP96_clr: int  # 25
DSP96_cmp: int  # 26
DSP96_cmpg: int  # 27
DSP96_debugcc: int  # 28
DSP96_dec: int  # 29
DSP96_do: int  # 30
DSP96_dor: int  # 31
DSP96_enddo: int  # 32
DSP96_eor: int  # 33
DSP96_ext: int  # 34
DSP96_extb: int  # 35
DSP96_fabs: int  # 36
DSP96_fadd: int  # 37
DSP96_faddsub: int  # 38
DSP96_fbcc: int  # 39
DSP96_fbccd: int  # 40
DSP96_fbscc: int  # 41
DSP96_fbsccd: int  # 42
DSP96_fclr: int  # 43
DSP96_fcmp: int  # 44
DSP96_fcmpg: int  # 45
DSP96_fcmpm: int  # 46
DSP96_fcopys: int  # 47
DSP96_fdebugcc: int  # 48
DSP96_fgetman: int  # 49
DSP96_fint: int  # 50
DSP96_fjcc: int  # 51
DSP96_fjccd: int  # 52
DSP96_fjscc: int  # 53
DSP96_fjsccd: int  # 54
DSP96_float: int  # 55
DSP96_floatu: int  # 56
DSP96_floor: int  # 57
DSP96_fmove: int  # 58
DSP96_fmpy: int  # 62
DSP96_fmpyfadd: int  # 59
DSP96_fmpyfaddsub: int  # 60
DSP96_fmpyfsub: int  # 61
DSP96_fneg: int  # 63
DSP96_fscale: int  # 64
DSP96_fseedd: int  # 65
DSP96_fseedr: int  # 66
DSP96_fsub: int  # 67
DSP96_ftfr: int  # 68
DSP96_ftrapcc: int  # 69
DSP96_ftst: int  # 70
DSP96_getexp: int  # 71
DSP96_illegal: int  # 72
DSP96_inc: int  # 73
DSP96_int: int  # 74
DSP96_intrz: int  # 75
DSP96_intu: int  # 76
DSP96_inturz: int  # 77
DSP96_jcc: int  # 78
DSP96_jccd: int  # 79
DSP96_jclr: int  # 80
DSP96_join: int  # 81
DSP96_joinb: int  # 82
DSP96_jscc: int  # 83
DSP96_jsccd: int  # 84
DSP96_jsclr: int  # 85
DSP96_jset: int  # 86
DSP96_jsset: int  # 87
DSP96_last: int  # 125
DSP96_lea: int  # 88
DSP96_lra: int  # 89
DSP96_lsl: int  # 90
DSP96_lsr: int  # 91
DSP96_move: int  # 92
DSP96_movec: int  # 93
DSP96_movei: int  # 94
DSP96_movem: int  # 95
DSP96_movep: int  # 96
DSP96_moves: int  # 97
DSP96_moveta: int  # 98
DSP96_mpys: int  # 99
DSP96_mpyu: int  # 100
DSP96_neg: int  # 101
DSP96_negc: int  # 102
DSP96_nop: int  # 103
DSP96_not: int  # 104
DSP96_null: int  # 0
DSP96_or: int  # 105
DSP96_orc: int  # 106
DSP96_ori: int  # 107
DSP96_rep: int  # 108
DSP96_reset: int  # 109
DSP96_rol: int  # 110
DSP96_ror: int  # 111
DSP96_rti: int  # 112
DSP96_rtr: int  # 113
DSP96_rts: int  # 114
DSP96_setw: int  # 115
DSP96_split: int  # 116
DSP96_splitb: int  # 117
DSP96_stop: int  # 118
DSP96_sub: int  # 119
DSP96_subc: int  # 120
DSP96_tfr: int  # 121
DSP96_trapcc: int  # 122
DSP96_tst: int  # 123
DSP96_wait: int  # 124
DSTATE_NOTASK: int  # 0
DSTATE_RUN: int  # 1
DSTATE_SUSP: int  # -1
DTE_ALREADY_EXISTS: int  # 1
DTE_BAD_PATH: int  # 5
DTE_CANT_RENAME: int  # 6
DTE_LAST: int  # 9
DTE_MAX_DIR: int  # 8
DTE_NOT_DIRECTORY: int  # 3
DTE_NOT_EMPTY: int  # 4
DTE_NOT_FOUND: int  # 2
DTE_OK: int  # 0
DTE_OWN_CHILD: int  # 7
DTN_DISPLAY_NAME: int  # 1
DTN_FULL_NAME: int  # 0
DTP_NODUP: int  # 1
DT_TYPE: int  # -268435456
EDGE_BACK: int  # 3
EDGE_CROSS: int  # 4
EDGE_FORWARD: int  # 2
EDGE_NONE: int  # 0
EDGE_SUBGRAPH: int  # 5
EDGE_TREE: int  # 1
ENC_MUTF8: str  # MUTF-8
ENC_UTF16: str  # UTF-16
ENC_UTF16BE: str  # UTF-16BE
ENC_UTF16LE: str  # UTF-16LE
ENC_UTF32: str  # UTF-32
ENC_UTF32BE: str  # UTF-32BE
ENC_UTF32LE: str  # UTF-32LE
ENC_UTF8: str  # UTF-8
ENC_WIN1252: str  # windows-1252
EONE: bytes
EQ_CMPDEST: int  # 4
EQ_IGNCODE: int  # 2
EQ_IGNSIZE: int  # 1
EQ_OPTINSN: int  # 8
ETF_AUTONAME: int  # 64
ETF_BYTIL: int  # 128
ETF_COMPATIBLE: int  # 8
ETF_FORCENAME: int  # 32
ETF_FUNCARG: int  # 16
ETF_MAY_DESTROY: int  # 4
ETF_NO_ARRAY: int  # 256
ETF_NO_LAYOUT: int  # 2
ETF_NO_SAVE: int  # 1
ETWO: bytes
EXCDLG_ALWAYS: int  # 24576
EXCDLG_NEVER: int  # 0
EXCDLG_UNKNOWN: int  # 8192
EXCEPTION: int  # 7
EXCLUDE_PASS_REGS: int  # 128
EXCLUDE_VOLATILE: int  # 1024
EXC_BREAK: int  # 1
EXC_HANDLE: int  # 2
EXC_MSG: int  # 4
EXC_SILENT: int  # 8
EXFL_ALL: int  # 511
EXFL_ALONE: int  # 8
EXFL_CPADONE: int  # 1
EXFL_CSTR: int  # 16
EXFL_FPOP: int  # 4
EXFL_JUMPOUT: int  # 128
EXFL_LVALUE: int  # 2
EXFL_PARTIAL: int  # 32
EXFL_UNDEF: int  # 64
EXFL_VFTABLE: int  # 256
EXTFUN_BASE: int  # 1
EXTFUN_NORET: int  # 2
EXTFUN_SAFE: int  # 4
EZERO: bytes
E_NEXT: int  # 2000
E_PREV: int  # 1000
E_SPECIAL_EXP: int  # 32767
F2MC_adb: int  # 120
F2MC_add: int  # 8
F2MC_addc1: int  # 9
F2MC_addc2: int  # 10
F2MC_addcw: int  # 18
F2MC_adddc: int  # 11
F2MC_addl: int  # 22
F2MC_addsp: int  # 118
F2MC_addw1: int  # 16
F2MC_addw2: int  # 17
F2MC_and: int  # 49
F2MC_andl: int  # 60
F2MC_andw1: int  # 53
F2MC_andw2: int  # 54
F2MC_asr: int  # 68
F2MC_asrl: int  # 77
F2MC_asrw1: int  # 71
F2MC_asrw2: int  # 72
F2MC_bbc: int  # 129
F2MC_bbc16: int  # 170
F2MC_bbs: int  # 130
F2MC_bbs16: int  # 171
F2MC_bc: int  # 82
F2MC_bc16: int  # 152
F2MC_bge: int  # 91
F2MC_bge16: int  # 161
F2MC_bgt: int  # 93
F2MC_bgt16: int  # 163
F2MC_bhi: int  # 95
F2MC_bhi16: int  # 165
F2MC_ble: int  # 92
F2MC_ble16: int  # 162
F2MC_bls: int  # 94
F2MC_bls16: int  # 164
F2MC_blt: int  # 90
F2MC_blt16: int  # 160
F2MC_bn: int  # 84
F2MC_bn16: int  # 154
F2MC_bnc: int  # 83
F2MC_bnc16: int  # 153
F2MC_bnt: int  # 89
F2MC_bnt16: int  # 159
F2MC_bnv: int  # 87
F2MC_bnv16: int  # 157
F2MC_bnz: int  # 81
F2MC_bnz16: int  # 151
F2MC_bp: int  # 85
F2MC_bp16: int  # 155
F2MC_bra: int  # 96
F2MC_bt: int  # 88
F2MC_bt16: int  # 158
F2MC_bv: int  # 86
F2MC_bv16: int  # 156
F2MC_bz: int  # 80
F2MC_bz16: int  # 150
F2MC_call: int  # 99
F2MC_callp: int  # 101
F2MC_callv: int  # 100
F2MC_cbne: int  # 102
F2MC_cbne16: int  # 166
F2MC_clrb: int  # 128
F2MC_cmp1: int  # 30
F2MC_cmp2: int  # 31
F2MC_cmpl: int  # 34
F2MC_cmpw1: int  # 32
F2MC_cmpw2: int  # 33
F2MC_cmr: int  # 125
F2MC_cwbne: int  # 103
F2MC_cwbne16: int  # 167
F2MC_dbnz: int  # 104
F2MC_dbnz16: int  # 168
F2MC_dec: int  # 25
F2MC_decl: int  # 29
F2MC_decw: int  # 27
F2MC_div1: int  # 42
F2MC_div2: int  # 43
F2MC_divu1: int  # 35
F2MC_divu2: int  # 36
F2MC_divuw: int  # 37
F2MC_divw: int  # 44
F2MC_dtb: int  # 121
F2MC_dwbnz: int  # 105
F2MC_dwbnz16: int  # 169
F2MC_ext: int  # 136
F2MC_extw: int  # 137
F2MC_filsi: int  # 144
F2MC_filswi: int  # 149
F2MC_inc: int  # 24
F2MC_incl: int  # 28
F2MC_incw: int  # 26
F2MC_int: int  # 106
F2MC_int9: int  # 108
F2MC_intp: int  # 107
F2MC_jctx: int  # 116
F2MC_jmp: int  # 97
F2MC_jmpp: int  # 98
F2MC_last: int  # 173
F2MC_link: int  # 110
F2MC_lsl: int  # 70
F2MC_lsll: int  # 79
F2MC_lslw1: int  # 75
F2MC_lslw2: int  # 76
F2MC_lsr: int  # 69
F2MC_lsrl: int  # 78
F2MC_lsrw1: int  # 73
F2MC_lsrw2: int  # 74
F2MC_mov: int  # 1
F2MC_movb: int  # 126
F2MC_movea: int  # 117
F2MC_movl: int  # 7
F2MC_movn: int  # 2
F2MC_movsd: int  # 141
F2MC_movsi: int  # 140
F2MC_movswd: int  # 146
F2MC_movswi: int  # 145
F2MC_movw: int  # 5
F2MC_movx: int  # 3
F2MC_mul1: int  # 45
F2MC_mul2: int  # 46
F2MC_mulu1: int  # 38
F2MC_mulu2: int  # 39
F2MC_muluw1: int  # 40
F2MC_muluw2: int  # 41
F2MC_mulw1: int  # 47
F2MC_mulw2: int  # 48
F2MC_ncc: int  # 124
F2MC_neg: int  # 63
F2MC_negw: int  # 64
F2MC_nop: int  # 119
F2MC_not: int  # 52
F2MC_notw: int  # 59
F2MC_nrml: int  # 65
F2MC_null: int  # 0
F2MC_or: int  # 50
F2MC_orl: int  # 61
F2MC_orw1: int  # 55
F2MC_orw2: int  # 56
F2MC_pcb: int  # 122
F2MC_popw: int  # 115
F2MC_pushw: int  # 114
F2MC_ret: int  # 112
F2MC_reti: int  # 109
F2MC_retp: int  # 113
F2MC_rolc: int  # 67
F2MC_rorc: int  # 66
F2MC_sbbs: int  # 131
F2MC_sbbs16: int  # 172
F2MC_sceqd: int  # 143
F2MC_sceqi: int  # 142
F2MC_scweqd: int  # 148
F2MC_scweqi: int  # 147
F2MC_setb: int  # 127
F2MC_spb: int  # 123
F2MC_sub: int  # 12
F2MC_subc1: int  # 13
F2MC_subc2: int  # 14
F2MC_subcw: int  # 21
F2MC_subdc: int  # 15
F2MC_subl: int  # 23
F2MC_subw1: int  # 19
F2MC_subw2: int  # 20
F2MC_swap: int  # 134
F2MC_swapw: int  # 135
F2MC_unlink: int  # 111
F2MC_wbtc: int  # 133
F2MC_wbts: int  # 132
F2MC_xch: int  # 4
F2MC_xchw: int  # 6
F2MC_xor: int  # 51
F2MC_xorl: int  # 62
F2MC_xorw1: int  # 57
F2MC_xorw2: int  # 58
F2MC_zext: int  # 138
F2MC_zextw: int  # 139
FAH_BYTE: int  # 255
FAI_ARRAY: int  # 8
FAI_HIDDEN: int  # 1
FAI_RETPTR: int  # 2
FAI_STRUCT: int  # 4
FAI_UNUSED: int  # 16
FCBF_CONT: int  # 1
FCBF_DELIM: int  # 8
FCBF_ERR_REPL: int  # 2
FCBF_FF_LIT: int  # 4
FCI_DEAD: int  # 2
FCI_EXPLOCS: int  # 1024
FCI_FINAL: int  # 4
FCI_HASCALL: int  # 128
FCI_HASFMT: int  # 256
FCI_NORET: int  # 8
FCI_NOSIDE: int  # 32
FCI_PROP: int  # 1
FCI_PURE: int  # 16
FCI_SPLOK: int  # 64
FC_APPND: int  # 8
FC_CALL_ENDS: int  # 32
FC_CHKBREAK: int  # 16
FC_NOEXT: int  # 2
FC_NOPREDS: int  # 64
FC_OUTLINES: int  # 128
FC_PREDS: int  # 0
FC_PRINT: int  # 1
FC_RESERVED: int  # 4
FD_BACKWARD: int  # 0
FD_DEF: int  # 2
FD_DIRTY: int  # 4
FD_FORWARD: int  # 1
FD_USE: int  # 0
FF_0CHAR: int  # 3145728
FF_0CUST: int  # 13631488
FF_0ENUM: int  # 8388608
FF_0FLT: int  # 12582912
FF_0FOP: int  # 9437184
FF_0NUMB: int  # 6291456
FF_0NUMD: int  # 2097152
FF_0NUMH: int  # 1048576
FF_0NUMO: int  # 7340032
FF_0OFF: int  # 5242880
FF_0SEG: int  # 4194304
FF_0STK: int  # 11534336
FF_0STRO: int  # 10485760
FF_0VOID: int  # 0
FF_1CHAR: int  # 50331648
FF_1CUST: int  # 218103808
FF_1ENUM: int  # 134217728
FF_1FLT: int  # 201326592
FF_1FOP: int  # 150994944
FF_1NUMB: int  # 100663296
FF_1NUMD: int  # 33554432
FF_1NUMH: int  # 16777216
FF_1NUMO: int  # 117440512
FF_1OFF: int  # 83886080
FF_1SEG: int  # 67108864
FF_1STK: int  # 184549376
FF_1STRO: int  # 167772160
FF_1VOID: int  # 0
FF_ALIGN: int  # -1342177280
FF_ANYNAME: int  # 49152
FF_BNOT: int  # 262144
FF_BYTE: int  # 0
FF_CODE: int  # 1536
FF_COMM: int  # 2048
FF_CUSTOM: int  # -805306368
FF_DATA: int  # 1024
FF_DOUBLE: int  # -1879048192
FF_DWORD: int  # 536870912
FF_FLOAT: int  # -2147483648
FF_FLOW: int  # 65536
FF_FUNC: int  # 268435456
FF_IMMD: int  # 1073741824
FF_IVL: int  # 256
FF_JUMP: int  # -2147483648
FF_LABL: int  # 32768
FF_LINE: int  # 8192
FF_NAME: int  # 16384
FF_N_CHAR: int  # 3
FF_N_CUST: int  # 13
FF_N_ENUM: int  # 8
FF_N_FLT: int  # 12
FF_N_FOP: int  # 9
FF_N_NUMB: int  # 6
FF_N_NUMD: int  # 2
FF_N_NUMH: int  # 1
FF_N_NUMO: int  # 7
FF_N_OFF: int  # 5
FF_N_SEG: int  # 4
FF_N_STK: int  # 11
FF_N_STRO: int  # 10
FF_N_VOID: int  # 0
FF_OWORD: int  # 1879048192
FF_PACKREAL: int  # -1610612736
FF_QWORD: int  # 805306368
FF_REF: int  # 4096
FF_SIGN: int  # 131072
FF_STRLIT: int  # 1342177280
FF_STRUCT: int  # 1610612736
FF_TAIL: int  # 512
FF_TBYTE: int  # 1073741824
FF_UNK: int  # 0
FF_UNUSED: int  # 524288
FF_WORD: int  # 268435456
FF_YWORD: int  # -536870912
FF_ZWORD: int  # -268435456
FILEREG_NOTPATCHABLE: int  # 0
FILEREG_PATCHABLE: int  # 1
FIND_FUNC_DEFINE: int  # 1
FIND_FUNC_EXIST: int  # 2
FIND_FUNC_IGNOREFN: int  # 2
FIND_FUNC_KEEPBD: int  # 4
FIND_FUNC_NORMAL: int  # 0
FIND_FUNC_OK: int  # 1
FIND_FUNC_UNDEF: int  # 0
FIRST_NONTRIVIAL_TYPID: int  # 256
FIXUPF_CREATED: int  # 8
FIXUPF_EXTDEF: int  # 2
FIXUPF_LOADER_MASK: int  # -268435456
FIXUPF_REL: int  # 1
FIXUPF_UNUSED: int  # 4
FIXUP_CUSTOM: int  # 32768
FIXUP_HI16: int  # 7
FIXUP_HI8: int  # 6
FIXUP_LOW16: int  # 9
FIXUP_LOW8: int  # 8
FIXUP_OFF16: int  # 1
FIXUP_OFF16S: int  # 15
FIXUP_OFF32: int  # 4
FIXUP_OFF32S: int  # 16
FIXUP_OFF64: int  # 12
FIXUP_OFF8: int  # 13
FIXUP_OFF8S: int  # 14
FIXUP_PTR16: int  # 3
FIXUP_PTR32: int  # 5
FIXUP_SEG16: int  # 2
FMTFUNC_PRINTF: int  # 0
FMTFUNC_SCANF: int  # 1
FMTFUNC_STRFMON: int  # 3
FMTFUNC_STRFTIME: int  # 2
FMT_64: str  # ll
FMT_EA: str  # ll
FMT_Z: str  # zu
FMT_ZS: str  # zd
FMT_ZX: str  # zX
FORBID_UNUSED_LABELS: int  # 0
FPC_ARGS: int  # 0
FPC_LVARS: int  # 3
FPC_RETADDR: int  # 1
FPC_SAVREGS: int  # 2
FPVAL_NWORDS: int  # 8
FPV_BADARG: int  # 0
FPV_NAN: int  # 2
FPV_NINF: int  # 4
FPV_NORM: int  # 1
FPV_PINF: int  # 3
FRAME_UDM_NAME_R: str  # __return_address
FRAME_UDM_NAME_S: str  # __saved_registers
FRB_CHAR: int  # 6
FRB_CUSTOM: int  # 12
FRB_ENUM: int  # 8
FRB_FLOAT: int  # 5
FRB_INVBITS: int  # 512
FRB_INVSIGN: int  # 256
FRB_LZERO: int  # 2048
FRB_MASK: int  # 15
FRB_NUMB: int  # 1
FRB_NUMD: int  # 4
FRB_NUMH: int  # 3
FRB_NUMO: int  # 2
FRB_OFFSET: int  # 9
FRB_SEG: int  # 7
FRB_SIGNED: int  # 1024
FRB_STRLIT: int  # 10
FRB_STROFF: int  # 11
FRB_TABFORM: int  # 4096
FRB_UNK: int  # 0
FTI_ALL: int  # 8191
FTI_ARGLOCS: int  # 256
FTI_CALLTYPE: int  # 192
FTI_CONST: int  # 1024
FTI_CTOR: int  # 2048
FTI_DEFCALL: int  # 0
FTI_DTOR: int  # 4096
FTI_EXPLOCS: int  # 512
FTI_FARCALL: int  # 128
FTI_HIGH: int  # 8
FTI_INTCALL: int  # 192
FTI_NEARCALL: int  # 64
FTI_NORET: int  # 2
FTI_PURE: int  # 4
FTI_SPOILED: int  # 1
FTI_STATIC: int  # 16
FTI_VIRTUAL: int  # 32
FT_LOG_RET: int  # 1
FULL_XDSU: int  # 256
FUNC_BOTTOMBP: int  # 256
FUNC_CATCH: int  # 1048576
FUNC_FAR: int  # 2
FUNC_FRAME: int  # 16
FUNC_FUZZY_SP: int  # 2048
FUNC_HIDDEN: int  # 64
FUNC_IMPORT_PREFIX: str  # __imp_
FUNC_LIB: int  # 4
FUNC_LUMINA: int  # 65536
FUNC_NAME_CONTAINING_RECORD: str  # CONTAINING_RECORD
FUNC_NAME_EMPTY: str  # $empty
FUNC_NAME_MEMCPY: str  # memcpy
FUNC_NAME_MEMSET: str  # memset
FUNC_NAME_MEMSET32: str  # memset32
FUNC_NAME_MEMSET64: str  # memset64
FUNC_NAME_MORESTACK: str  # runtime_morestack
FUNC_NAME_PRESENT: str  # $present
FUNC_NAME_STRCAT: str  # strcat
FUNC_NAME_STRCPY: str  # strcpy
FUNC_NAME_STRLEN: str  # strlen
FUNC_NAME_TAIL: str  # tail
FUNC_NAME_VA_ARG: str  # va_arg
FUNC_NAME_WCSCAT: str  # wcscat
FUNC_NAME_WCSCPY: str  # wcscpy
FUNC_NAME_WCSLEN: str  # wcslen
FUNC_NAME_WMEMCPY: str  # wmemcpy
FUNC_NAME_WMEMSET: str  # wmemset
FUNC_NORET: int  # 1
FUNC_NORET_PENDING: int  # 512
FUNC_OUTLINE: int  # 131072
FUNC_PROLOG_OK: int  # 4096
FUNC_PURGED_OK: int  # 16384
FUNC_REANALYZE: int  # 262144
FUNC_SP_READY: int  # 1024
FUNC_STATICDEF: int  # 8
FUNC_TAIL: int  # 32768
FUNC_THUNK: int  # 128
FUNC_TRACE: int  # 4
FUNC_UNWIND: int  # 524288
FUNC_USERFAR: int  # 32
GB_ldh: int  # 250
GB_stop: int  # 251
GCA_ALLOC: int  # 4
GCA_EMPTY: int  # 1
GCA_NALLOC: int  # 8
GCA_OFIRST: int  # 16
GCA_OLAST: int  # 32
GCA_SPEC: int  # 2
GCO_DEF: int  # 4
GCO_REG: int  # 1
GCO_STK: int  # 0
GCO_USE: int  # 2
GCRF_ALL: int  # 9223372036854775811
GCRF_CURRENT: int  # 9223372036854775810
GCRF_HEADER: int  # 9223372036854775808
GCRF_HIGH_BIT: int  # 9223372036854775808
GCRF_SELECTION: int  # 9223372036854775809
GC_ASR: int  # 1
GC_DIRTY_ALL: int  # 63
GC_END: int  # 3
GC_REGS_AND_STKVARS: int  # 0
GC_XDSU: int  # 2
GDISMF_ADDR_TAG: int  # 2
GDISMF_AS_STACK: int  # 1
GDISMF_REMOVE_TAGS: int  # 4
GDISMF_UNHIDE: int  # 8
GENDSM_FORCE_CODE: int  # 1
GENDSM_MULTI_LINE: int  # 2
GENDSM_REMOVE_TAGS: int  # 4
GENDSM_UNHIDE: int  # 8
GENFLG_ASMINC: int  # 64
GENFLG_ASMTYPE: int  # 16
GENFLG_GENHTML: int  # 32
GENFLG_IDCTYPE: int  # 8
GENFLG_MAPDMNG: int  # 4
GENFLG_MAPLOC: int  # 8
GENFLG_MAPNAME: int  # 2
GENFLG_MAPSEG: int  # 1
GETN_APPZERO: int  # 1
GETN_NODUMMY: int  # 4
GETN_NOFIXUP: int  # 2
GFE_32BIT: int  # 4
GFE_IDB_VALUE: int  # 2
GFE_VALUE: int  # 1
GH_BYTESEX_HAS_HIGHBYTE: int  # 16
GH_PRINT_ALL: int  # 15
GH_PRINT_ALL_BUT_BYTESEX: int  # 11
GH_PRINT_ASM: int  # 2
GH_PRINT_BYTESEX: int  # 4
GH_PRINT_HEADER: int  # 8
GH_PRINT_PROC: int  # 1
GH_PRINT_PROC_AND_ASM: int  # 3
GH_PRINT_PROC_ASM_AND_BYTESEX: int  # 7
GLICTL_CENTER: int  # 1
GLN_ALL: int  # 3
GLN_CURRENT: int  # 1
GLN_GOTO_TARGET: int  # 2
GMB_READALL: int  # 1
GMB_WAITBOX: int  # 2
GNCN_NOCOLOR: int  # 2
GNCN_NODBGNM: int  # 256
GNCN_NOFUNC: int  # 8
GNCN_NOLABEL: int  # 4
GNCN_NOSEG: int  # 1
GNCN_PREFDBG: int  # 512
GNCN_REQFUNC: int  # 64
GNCN_REQNAME: int  # 128
GNCN_SEGNUM: int  # 32
GNCN_SEG_FUNC: int  # 16
GN_COLORED: int  # 2
GN_DEMANGLED: int  # 4
GN_ISRET: int  # 128
GN_LOCAL: int  # 64
GN_LONG: int  # 32
GN_NOT_DUMMY: int  # 512
GN_NOT_ISRET: int  # 256
GN_SHORT: int  # 16
GN_STRICT: int  # 8
GN_VISIBLE: int  # 1
GOTEA_NODE_IDX: int  # 0
GOTEA_NODE_NAME: str  # $ got
GTD_CALC_ARGLOCS: int  # 0
GTD_CALC_LAYOUT: int  # 0
GTD_DEL_BITFLDS: int  # 64
GTD_NO_ARGLOCS: int  # 128
GTD_NO_LAYOUT: int  # 128
GTS_BASECLASS: int  # 2
GTS_NESTED: int  # 1
GUESSED_DATA: int  # 3
GUESSED_FUNC: int  # 2
GUESSED_NONE: int  # 0
GUESSED_WEAK: int  # 1
GUESS_FUNC_FAILED: int  # 0
GUESS_FUNC_OK: int  # 2
GUESS_FUNC_TRIVIAL: int  # 1
H8500_add_g: int  # 13
H8500_add_q: int  # 14
H8500_adds: int  # 16
H8500_addx: int  # 18
H8500_and: int  # 33
H8500_andc: int  # 83
H8500_bcc: int  # 53
H8500_bclr: int  # 46
H8500_bcs: int  # 54
H8500_beq: int  # 56
H8500_bge: int  # 61
H8500_bgt: int  # 63
H8500_bhi: int  # 51
H8500_ble: int  # 64
H8500_bls: int  # 52
H8500_blt: int  # 62
H8500_bmi: int  # 60
H8500_bne: int  # 55
H8500_bnot: int  # 47
H8500_bpl: int  # 59
H8500_bpt: int  # 87
H8500_bra: int  # 49
H8500_brn: int  # 50
H8500_bset: int  # 45
H8500_bsr: int  # 67
H8500_btst: int  # 48
H8500_bvc: int  # 57
H8500_bvs: int  # 58
H8500_clr: int  # 31
H8500_cmp_e: int  # 25
H8500_cmp_g: int  # 24
H8500_cmp_i: int  # 26
H8500_dadd: int  # 20
H8500_divxu: int  # 23
H8500_dsub: int  # 21
H8500_exts: int  # 27
H8500_extu: int  # 28
H8500_jmp: int  # 65
H8500_jsr: int  # 68
H8500_last: int  # 88
H8500_ldc: int  # 81
H8500_ldm: int  # 7
H8500_link: int  # 78
H8500_mov_e: int  # 2
H8500_mov_f: int  # 4
H8500_mov_g: int  # 1
H8500_mov_i: int  # 3
H8500_mov_l: int  # 5
H8500_mov_s: int  # 6
H8500_movfpe: int  # 12
H8500_movtpe: int  # 11
H8500_mulxu: int  # 22
H8500_neg: int  # 30
H8500_nop: int  # 86
H8500_not: int  # 36
H8500_null: int  # 0
H8500_or: int  # 34
H8500_orc: int  # 84
H8500_pjmp: int  # 66
H8500_pjsr: int  # 69
H8500_prtd: int  # 73
H8500_prts: int  # 71
H8500_rotl: int  # 41
H8500_rotr: int  # 42
H8500_rotxl: int  # 43
H8500_rotxr: int  # 44
H8500_rtd: int  # 72
H8500_rte: int  # 77
H8500_rts: int  # 70
H8500_scb: int  # 74
H8500_shal: int  # 37
H8500_shar: int  # 38
H8500_shll: int  # 39
H8500_shlr: int  # 40
H8500_sleep: int  # 80
H8500_stc: int  # 82
H8500_stm: int  # 8
H8500_sub: int  # 15
H8500_subs: int  # 17
H8500_subx: int  # 19
H8500_swap: int  # 10
H8500_tas: int  # 32
H8500_trap_vs: int  # 76
H8500_trapa: int  # 75
H8500_tst: int  # 29
H8500_unlk: int  # 79
H8500_xch: int  # 9
H8500_xor: int  # 35
H8500_xorc: int  # 85
H8_add: int  # 1
H8_adds: int  # 2
H8_addx: int  # 3
H8_and: int  # 4
H8_andc: int  # 5
H8_band: int  # 6
H8_bcc: int  # 11
H8_bclr: int  # 23
H8_bclreq: int  # 98
H8_bclrne: int  # 97
H8_bcs: int  # 12
H8_beq: int  # 14
H8_bfld: int  # 101
H8_bfst: int  # 102
H8_bge: int  # 19
H8_bgt: int  # 21
H8_bhi: int  # 9
H8_biand: int  # 24
H8_bild: int  # 25
H8_bior: int  # 26
H8_bist: int  # 27
H8_bistz: int  # 100
H8_bixor: int  # 28
H8_bld: int  # 29
H8_ble: int  # 22
H8_bls: int  # 10
H8_blt: int  # 20
H8_bmi: int  # 18
H8_bne: int  # 13
H8_bnot: int  # 30
H8_bor: int  # 31
H8_bpl: int  # 17
H8_bra: int  # 7
H8_brabc: int  # 109
H8_brabs: int  # 110
H8_bras: int  # 91
H8_brn: int  # 8
H8_bset: int  # 32
H8_bseteq: int  # 96
H8_bsetne: int  # 95
H8_bsr: int  # 33
H8_bsrbc: int  # 111
H8_bsrbs: int  # 112
H8_bst: int  # 34
H8_bstz: int  # 99
H8_btst: int  # 35
H8_bvc: int  # 15
H8_bvs: int  # 16
H8_bxor: int  # 36
H8_clrmac: int  # 37
H8_cmp: int  # 38
H8_daa: int  # 39
H8_das: int  # 40
H8_dec: int  # 41
H8_divs: int  # 104
H8_divu: int  # 106
H8_divxs: int  # 42
H8_divxu: int  # 43
H8_eepmov: int  # 44
H8_exts: int  # 45
H8_extu: int  # 46
H8_inc: int  # 47
H8_jmp: int  # 48
H8_jsr: int  # 49
H8_last: int  # 113
H8_ldc: int  # 50
H8_ldm: int  # 51
H8_ldmac: int  # 52
H8_mac: int  # 53
H8_mov: int  # 54
H8_movab: int  # 92
H8_moval: int  # 94
H8_movaw: int  # 93
H8_movfpe: int  # 55
H8_movmd: int  # 89
H8_movsd: int  # 90
H8_movtpe: int  # 56
H8_muls: int  # 103
H8_mulsu: int  # 107
H8_mulu: int  # 105
H8_muluu: int  # 108
H8_mulxs: int  # 57
H8_mulxu: int  # 58
H8_neg: int  # 59
H8_nop: int  # 60
H8_not: int  # 61
H8_null: int  # 0
H8_or: int  # 62
H8_orc: int  # 63
H8_pop: int  # 64
H8_push: int  # 65
H8_rotl: int  # 66
H8_rotr: int  # 67
H8_rotxl: int  # 68
H8_rotxr: int  # 69
H8_rte: int  # 70
H8_rtel: int  # 87
H8_rts: int  # 71
H8_rtsl: int  # 88
H8_shal: int  # 72
H8_shar: int  # 73
H8_shll: int  # 74
H8_shlr: int  # 75
H8_sleep: int  # 76
H8_stc: int  # 77
H8_stm: int  # 78
H8_stmac: int  # 79
H8_sub: int  # 80
H8_subs: int  # 81
H8_subx: int  # 82
H8_tas: int  # 83
H8_trapa: int  # 84
H8_xor: int  # 85
H8_xorc: int  # 86
HBF_CALL_WITH_NEW_EXEC: int  # 1
HBF_VOLATILE_METHOD_SET: int  # 2
HD_in0: int  # 139
HD_mlt: int  # 140
HD_otdm: int  # 143
HD_otdmr: int  # 144
HD_otim: int  # 141
HD_otimr: int  # 142
HD_out0: int  # 145
HD_slp: int  # 146
HD_tst: int  # 147
HD_tstio: int  # 148
HEXRAYS_API_MAGIC: int  # 62699504545038340
HF_COMMENT: int  # 5
HF_DEFAULT: int  # 0
HF_KEYWORD1: int  # 1
HF_KEYWORD2: int  # 2
HF_KEYWORD3: int  # 3
HF_MAX: int  # 12
HF_NUMBER: int  # 7
HF_PREPROC: int  # 6
HF_STRING: int  # 4
HF_USER1: int  # 8
HF_USER2: int  # 9
HF_USER3: int  # 10
HF_USER4: int  # 11
HIF_IDENTIFIER: int  # 1
HIF_LOCKED: int  # 4
HIF_NOCASE: int  # 8
HIF_REGISTER: int  # 2
HIF_SLOT_0: int  # 134217728
HIF_SLOT_1: int  # 402653184
HIF_SLOT_2: int  # 671088640
HIF_SLOT_3: int  # 939524096
HIF_SLOT_4: int  # 1207959552
HIF_SLOT_5: int  # 1476395008
HIF_SLOT_6: int  # 1744830464
HIF_SLOT_7: int  # 2013265920
HIF_SLOT_SHIFT: int  # 28
HIF_USE_SLOT: int  # 134217728
HIST_CMD: int  # 7
HIST_CMT: int  # 2
HIST_DIR: int  # 8
HIST_FILE: int  # 5
HIST_IDENT: int  # 4
HIST_IDENT2: int  # 9
HIST_SEG: int  # 1
HIST_SRCH: int  # 3
HIST_TYPE: int  # 6
HKCB_GLOBAL: int  # 1
HPPA_add: int  # 1
HPPA_addb: int  # 2
HPPA_addi: int  # 3
HPPA_addib: int  # 4
HPPA_addil: int  # 5
HPPA_and: int  # 6
HPPA_andcm: int  # 7
HPPA_b: int  # 8
HPPA_bb: int  # 9
HPPA_be: int  # 10
HPPA_blr: int  # 11
HPPA_break: int  # 12
HPPA_bv: int  # 13
HPPA_bve: int  # 14
HPPA_call: int  # 134
HPPA_cldd: int  # 15
HPPA_cldw: int  # 16
HPPA_clrbts: int  # 17
HPPA_cmpb: int  # 18
HPPA_cmpclr: int  # 19
HPPA_cmpib: int  # 20
HPPA_cmpiclr: int  # 21
HPPA_copr: int  # 22
HPPA_copy: int  # 141
HPPA_cstd: int  # 23
HPPA_cstw: int  # 24
HPPA_dcor: int  # 25
HPPA_depd: int  # 26
HPPA_depdi: int  # 27
HPPA_depw: int  # 28
HPPA_depwi: int  # 29
HPPA_diag: int  # 30
HPPA_ds: int  # 31
HPPA_extrd: int  # 32
HPPA_extrw: int  # 33
HPPA_fabs: int  # 108
HPPA_fadd: int  # 109
HPPA_fcmp: int  # 110
HPPA_fcnv: int  # 111
HPPA_fcpy: int  # 112
HPPA_fdc: int  # 34
HPPA_fdce: int  # 35
HPPA_fdiv: int  # 113
HPPA_fic: int  # 36
HPPA_fice: int  # 37
HPPA_fid: int  # 114
HPPA_fldd: int  # 115
HPPA_fldw: int  # 116
HPPA_fmpy: int  # 117
HPPA_fmpyadd: int  # 118
HPPA_fmpyfadd: int  # 119
HPPA_fmpynfadd: int  # 120
HPPA_fmpysub: int  # 121
HPPA_fneg: int  # 122
HPPA_fnegabs: int  # 123
HPPA_frem: int  # 124
HPPA_frnd: int  # 125
HPPA_fsqrt: int  # 126
HPPA_fstd: int  # 127
HPPA_fstw: int  # 128
HPPA_fsub: int  # 129
HPPA_ftest: int  # 130
HPPA_hadd: int  # 38
HPPA_havg: int  # 39
HPPA_hshl: int  # 40
HPPA_hshladd: int  # 41
HPPA_hshr: int  # 42
HPPA_hshradd: int  # 43
HPPA_hsub: int  # 44
HPPA_idtlbt: int  # 45
HPPA_iitlbt: int  # 46
HPPA_last: int  # 144
HPPA_lci: int  # 47
HPPA_ldb: int  # 48
HPPA_ldcd: int  # 49
HPPA_ldcw: int  # 50
HPPA_ldd: int  # 51
HPPA_ldda: int  # 52
HPPA_ldh: int  # 53
HPPA_ldi: int  # 140
HPPA_ldil: int  # 54
HPPA_ldo: int  # 55
HPPA_ldsid: int  # 56
HPPA_ldw: int  # 57
HPPA_ldwa: int  # 58
HPPA_lpa: int  # 59
HPPA_mfctl: int  # 60
HPPA_mfia: int  # 61
HPPA_mfsp: int  # 62
HPPA_mixh: int  # 63
HPPA_mixw: int  # 64
HPPA_movb: int  # 65
HPPA_movib: int  # 66
HPPA_mtctl: int  # 67
HPPA_mtsar: int  # 142
HPPA_mtsarcm: int  # 68
HPPA_mtsm: int  # 69
HPPA_mtsp: int  # 70
HPPA_nop: int  # 143
HPPA_null: int  # 0
HPPA_or: int  # 71
HPPA_pdc: int  # 72
HPPA_pdtlb: int  # 73
HPPA_pdtlbe: int  # 74
HPPA_permh: int  # 75
HPPA_pitlb: int  # 76
HPPA_pitlbe: int  # 77
HPPA_pmdis: int  # 132
HPPA_pmenb: int  # 133
HPPA_popbts: int  # 78
HPPA_probe: int  # 79
HPPA_probei: int  # 80
HPPA_pushbts: int  # 81
HPPA_pushnom: int  # 82
HPPA_ret: int  # 135
HPPA_rfi: int  # 83
HPPA_rsm: int  # 84
HPPA_shladd: int  # 85
HPPA_shld: int  # 136
HPPA_shlw: int  # 137
HPPA_shrd: int  # 138
HPPA_shrpd: int  # 86
HPPA_shrpw: int  # 87
HPPA_shrw: int  # 139
HPPA_spop0: int  # 88
HPPA_spop1: int  # 89
HPPA_spop2: int  # 90
HPPA_spop3: int  # 91
HPPA_ssm: int  # 92
HPPA_stb: int  # 93
HPPA_stby: int  # 94
HPPA_std: int  # 95
HPPA_stda: int  # 96
HPPA_stdby: int  # 97
HPPA_sth: int  # 98
HPPA_stw: int  # 99
HPPA_stwa: int  # 100
HPPA_sub: int  # 101
HPPA_subi: int  # 102
HPPA_sync: int  # 103
HPPA_syncdma: int  # 104
HPPA_uaddcm: int  # 105
HPPA_uxor: int  # 106
HPPA_xmpyu: int  # 131
HPPA_xor: int  # 107
HTI_CPP: int  # 1
HTI_DCL: int  # 1024
HTI_EXT: int  # 4
HTI_FIL: int  # 64
HTI_HIGH: int  # 32768
HTI_INT: int  # 2
HTI_LEX: int  # 8
HTI_LOWER: int  # 65536
HTI_MAC: int  # 128
HTI_NDC: int  # 2048
HTI_NER: int  # 512
HTI_NOBASE: int  # 1048576
HTI_NWR: int  # 256
HTI_PAK: int  # 28672
HTI_PAK1: int  # 4096
HTI_PAK16: int  # 20480
HTI_PAK2: int  # 8192
HTI_PAK4: int  # 12288
HTI_PAK8: int  # 16384
HTI_PAKDEF: int  # 0
HTI_PAK_SHIFT: int  # 12
HTI_RAWARGS: int  # 131072
HTI_RELAXED: int  # 524288
HTI_SEMICOLON: int  # 2097152
HTI_STANDALONE: int  # 4194304
HTI_TST: int  # 32
HTI_UNP: int  # 16
HVUI_REGISTRY_NAME: str  # hvui
I196_add2: int  # 1
I196_add3: int  # 2
I196_addb2: int  # 3
I196_addb3: int  # 4
I196_addc: int  # 5
I196_addcb: int  # 6
I196_and2: int  # 7
I196_and3: int  # 8
I196_andb2: int  # 9
I196_andb3: int  # 10
I196_bmov: int  # 11
I196_bmovi: int  # 12
I196_br: int  # 13
I196_clr: int  # 14
I196_clrb: int  # 15
I196_clrc: int  # 16
I196_clrvt: int  # 17
I196_cmp: int  # 18
I196_cmpb: int  # 19
I196_cmpl: int  # 20
I196_dec: int  # 21
I196_decb: int  # 22
I196_di: int  # 23
I196_div: int  # 24
I196_divb: int  # 25
I196_divu: int  # 26
I196_divub: int  # 27
I196_djnz: int  # 28
I196_djnzw: int  # 29
I196_dpts: int  # 30
I196_ebmovi: int  # 113
I196_ebr: int  # 114
I196_ecall: int  # 115
I196_ei: int  # 31
I196_ejmp: int  # 116
I196_eld: int  # 117
I196_eldb: int  # 118
I196_epts: int  # 32
I196_est: int  # 119
I196_estb: int  # 120
I196_ext: int  # 33
I196_extb: int  # 34
I196_idlpd: int  # 35
I196_inc: int  # 36
I196_incb: int  # 37
I196_jbc: int  # 38
I196_jbs: int  # 39
I196_jc: int  # 40
I196_je: int  # 41
I196_jge: int  # 42
I196_jgt: int  # 43
I196_jh: int  # 44
I196_jle: int  # 45
I196_jlt: int  # 46
I196_jnc: int  # 47
I196_jne: int  # 48
I196_jnh: int  # 49
I196_jnst: int  # 50
I196_jnv: int  # 51
I196_jnvt: int  # 52
I196_jst: int  # 53
I196_jv: int  # 54
I196_jvt: int  # 55
I196_last: int  # 121
I196_lcall: int  # 56
I196_ld: int  # 57
I196_ldb: int  # 58
I196_ldbse: int  # 59
I196_ldbze: int  # 60
I196_ljmp: int  # 61
I196_mul2: int  # 62
I196_mul3: int  # 63
I196_mulb2: int  # 64
I196_mulb3: int  # 65
I196_mulu2: int  # 66
I196_mulu3: int  # 67
I196_mulub2: int  # 68
I196_mulub3: int  # 69
I196_neg: int  # 70
I196_negb: int  # 71
I196_nop: int  # 72
I196_norml: int  # 73
I196_not: int  # 74
I196_notb: int  # 75
I196_null: int  # 0
I196_or: int  # 76
I196_orb: int  # 77
I196_pop: int  # 78
I196_popa: int  # 79
I196_popf: int  # 80
I196_push: int  # 81
I196_pusha: int  # 82
I196_pushf: int  # 83
I196_ret: int  # 84
I196_rst: int  # 85
I196_scall: int  # 86
I196_setc: int  # 87
I196_shl: int  # 88
I196_shlb: int  # 89
I196_shll: int  # 90
I196_shr: int  # 91
I196_shra: int  # 92
I196_shrab: int  # 93
I196_shral: int  # 94
I196_shrb: int  # 95
I196_shrl: int  # 96
I196_sjmp: int  # 97
I196_skip: int  # 98
I196_st: int  # 99
I196_stb: int  # 100
I196_sub2: int  # 101
I196_sub3: int  # 102
I196_subb2: int  # 103
I196_subb3: int  # 104
I196_subc: int  # 105
I196_subcb: int  # 106
I196_tijmp: int  # 107
I196_trap: int  # 108
I196_xch: int  # 109
I196_xchb: int  # 110
I196_xor: int  # 111
I196_xorb: int  # 112
I51_acall: int  # 1
I51_add: int  # 2
I51_addc: int  # 3
I51_ajmp: int  # 4
I51_anl: int  # 5
I51_cjne: int  # 6
I51_clr: int  # 7
I51_cmp: int  # 64
I51_cpl: int  # 8
I51_da: int  # 9
I51_dec: int  # 10
I51_div: int  # 11
I51_djnz: int  # 12
I51_ecall: int  # 55
I51_ejmp: int  # 54
I51_emov: int  # 65
I51_eret: int  # 56
I51_inc: int  # 13
I51_jb: int  # 14
I51_jbc: int  # 15
I51_jc: int  # 16
I51_je: int  # 51
I51_jg: int  # 48
I51_jle: int  # 47
I51_jmp: int  # 17
I51_jnb: int  # 18
I51_jnc: int  # 19
I51_jne: int  # 52
I51_jnz: int  # 20
I51_jsg: int  # 46
I51_jsge: int  # 50
I51_jsl: int  # 49
I51_jsle: int  # 45
I51_jz: int  # 21
I51_last: int  # 66
I51_lcall: int  # 22
I51_ljmp: int  # 23
I51_mov: int  # 24
I51_movc: int  # 25
I51_movh: int  # 57
I51_movs: int  # 59
I51_movx: int  # 26
I51_movz: int  # 58
I51_mul: int  # 27
I51_nop: int  # 28
I51_null: int  # 0
I51_orl: int  # 29
I51_pop: int  # 30
I51_push: int  # 31
I51_ret: int  # 32
I51_reti: int  # 33
I51_rl: int  # 34
I51_rlc: int  # 35
I51_rr: int  # 36
I51_rrc: int  # 37
I51_setb: int  # 38
I51_sjmp: int  # 39
I51_sll: int  # 62
I51_sra: int  # 61
I51_srl: int  # 60
I51_sub: int  # 63
I51_subb: int  # 40
I51_swap: int  # 41
I51_trap: int  # 53
I51_xch: int  # 42
I51_xchd: int  # 43
I51_xrl: int  # 44
I5_aci: int  # 1
I5_adc: int  # 2
I5_add: int  # 3
I5_adi: int  # 4
I5_ana: int  # 5
I5_ani: int  # 6
I5_arhl: int  # 189
I5_call: int  # 7
I5_cc: int  # 11
I5_cm: int  # 15
I5_cma: int  # 19
I5_cmc: int  # 16
I5_cmp: int  # 17
I5_cnc: int  # 10
I5_cnz: int  # 8
I5_cp: int  # 14
I5_cpe: int  # 13
I5_cpi: int  # 18
I5_cpo: int  # 12
I5_cz: int  # 9
I5_daa: int  # 20
I5_dad: int  # 21
I5_dcr: int  # 22
I5_dcx: int  # 23
I5_di: int  # 24
I5_dsub: int  # 188
I5_ei: int  # 25
I5_halt: int  # 26
I5_in: int  # 27
I5_inr: int  # 28
I5_inx: int  # 29
I5_jc: int  # 34
I5_jm: int  # 38
I5_jmp: int  # 30
I5_jnc: int  # 33
I5_jnx5: int  # 197
I5_jnz: int  # 31
I5_jp: int  # 37
I5_jpe: int  # 36
I5_jpo: int  # 35
I5_jx5: int  # 196
I5_jz: int  # 32
I5_last: int  # 252
I5_lda: int  # 39
I5_ldax: int  # 40
I5_ldhi: int  # 191
I5_ldsi: int  # 192
I5_lhld: int  # 41
I5_lhlx: int  # 194
I5_lxi: int  # 42
I5_mov: int  # 43
I5_mvi: int  # 44
I5_nop: int  # 45
I5_null: int  # 0
I5_ora: int  # 46
I5_ori: int  # 47
I5_out: int  # 48
I5_pchl: int  # 49
I5_pop: int  # 50
I5_push: int  # 51
I5_ral: int  # 61
I5_rar: int  # 63
I5_rc: int  # 56
I5_rdel: int  # 190
I5_ret: int  # 52
I5_rim: int  # 79
I5_rlc: int  # 62
I5_rm: int  # 60
I5_rnc: int  # 55
I5_rnz: int  # 53
I5_rp: int  # 59
I5_rpe: int  # 58
I5_rpo: int  # 57
I5_rrc: int  # 64
I5_rst: int  # 65
I5_rstv: int  # 195
I5_rz: int  # 54
I5_sbb: int  # 66
I5_sbi: int  # 67
I5_shld: int  # 72
I5_shlx: int  # 193
I5_sim: int  # 80
I5_sphl: int  # 69
I5_sta: int  # 70
I5_stax: int  # 71
I5_stc: int  # 68
I5_sub: int  # 74
I5_sui: int  # 73
I5_xchg: int  # 77
I5_xra: int  # 75
I5_xri: int  # 76
I5_xthl: int  # 78
I860_adds: int  # 1
I860_addu: int  # 2
I860_and: int  # 3
I860_andh: int  # 4
I860_andnot: int  # 5
I860_andnoth: int  # 6
I860_bc: int  # 7
I860_bc_t: int  # 8
I860_bla: int  # 9
I860_bnc: int  # 10
I860_bnc_t: int  # 11
I860_br: int  # 12
I860_bri: int  # 13
I860_bte: int  # 14
I860_btne: int  # 15
I860_call: int  # 16
I860_calli: int  # 17
I860_fadd: int  # 18
I860_faddp: int  # 19
I860_faddz: int  # 20
I860_famov: int  # 21
I860_fiadd: int  # 22
I860_fisub: int  # 23
I860_fix: int  # 24
I860_fld: int  # 25
I860_flush: int  # 26
I860_fmlow_dd: int  # 27
I860_fmul: int  # 28
I860_form: int  # 29
I860_frcp: int  # 30
I860_frsqr: int  # 31
I860_fst: int  # 32
I860_fsub: int  # 33
I860_ftrunc: int  # 34
I860_fxfr: int  # 35
I860_fzchkl: int  # 36
I860_fzchks: int  # 37
I860_i2ap1: int  # 86
I860_i2apt: int  # 87
I860_i2as1: int  # 102
I860_i2ast: int  # 103
I860_i2p1: int  # 84
I860_i2pt: int  # 85
I860_i2s1: int  # 100
I860_i2st: int  # 101
I860_ia1p2: int  # 94
I860_ia1s2: int  # 110
I860_iat1p2: int  # 92
I860_iat1s2: int  # 108
I860_introvr: int  # 38
I860_ixfr: int  # 39
I860_last: int  # 142
I860_ld: int  # 41
I860_ld_c: int  # 40
I860_ldint: int  # 42
I860_ldio: int  # 43
I860_lock: int  # 44
I860_m12apm: int  # 89
I860_m12asm: int  # 105
I860_m12tpa: int  # 95
I860_m12tpm: int  # 93
I860_m12tsa: int  # 111
I860_m12tsm: int  # 109
I860_m12ttpa: int  # 91
I860_m12ttsa: int  # 107
I860_mi2mp1: int  # 118
I860_mi2mpt: int  # 119
I860_mi2ms1: int  # 133
I860_mi2mst: int  # 134
I860_mi2p1: int  # 116
I860_mi2pt: int  # 117
I860_mi2s1: int  # 131
I860_mi2st: int  # 132
I860_mim1p2: int  # 126
I860_mim1s2: int  # 141
I860_mimt1p2: int  # 124
I860_mimt1s2: int  # 139
I860_mm12mpm: int  # 121
I860_mm12msm: int  # 136
I860_mm12tpm: int  # 125
I860_mm12tsm: int  # 140
I860_mm12ttpm: int  # 123
I860_mm12ttsm: int  # 138
I860_mr2mp1: int  # 114
I860_mr2mpt: int  # 115
I860_mr2ms1: int  # 129
I860_mr2mst: int  # 130
I860_mr2p1: int  # 112
I860_mr2pt: int  # 113
I860_mr2s1: int  # 127
I860_mr2st: int  # 128
I860_mrm1p2: int  # 122
I860_mrm1s2: int  # 137
I860_mrmt1p2: int  # 120
I860_mrmt1s2: int  # 135
I860_null: int  # 0
I860_or: int  # 45
I860_orh: int  # 46
I860_pfadd: int  # 47
I860_pfaddp: int  # 48
I860_pfaddz: int  # 49
I860_pfamov: int  # 50
I860_pfeq: int  # 51
I860_pfgt: int  # 52
I860_pfiadd: int  # 53
I860_pfisub: int  # 54
I860_pfix: int  # 55
I860_pfld: int  # 56
I860_pfle: int  # 57
I860_pfmul: int  # 58
I860_pfmul3_dd: int  # 59
I860_pform: int  # 60
I860_pfsub: int  # 61
I860_pftrunc: int  # 62
I860_pfzchkl: int  # 63
I860_pfzchks: int  # 64
I860_pst_d: int  # 65
I860_r2ap1: int  # 82
I860_r2apt: int  # 83
I860_r2as1: int  # 98
I860_r2ast: int  # 99
I860_r2p1: int  # 80
I860_r2pt: int  # 81
I860_r2s1: int  # 96
I860_r2st: int  # 97
I860_ra1p2: int  # 90
I860_ra1s2: int  # 106
I860_rat1p2: int  # 88
I860_rat1s2: int  # 104
I860_scyc: int  # 66
I860_shl: int  # 67
I860_shr: int  # 68
I860_shra: int  # 69
I860_shrd: int  # 70
I860_st: int  # 72
I860_st_c: int  # 71
I860_stio: int  # 73
I860_subs: int  # 74
I860_subu: int  # 75
I860_trap: int  # 76
I860_unlock: int  # 77
I860_xor: int  # 78
I860_xorh: int  # 79
I960_addc: int  # 1
I960_addi: int  # 2
I960_addie: int  # 180
I960_addig: int  # 175
I960_addige: int  # 185
I960_addil: int  # 190
I960_addile: int  # 200
I960_addine: int  # 195
I960_addino: int  # 170
I960_addio: int  # 205
I960_addo: int  # 3
I960_addoe: int  # 179
I960_addog: int  # 174
I960_addoge: int  # 184
I960_addol: int  # 189
I960_addole: int  # 199
I960_addone: int  # 194
I960_addono: int  # 169
I960_addoo: int  # 204
I960_alterbit: int  # 4
I960_and: int  # 5
I960_andnot: int  # 6
I960_atadd: int  # 7
I960_atmod: int  # 8
I960_b: int  # 9
I960_bal: int  # 10
I960_balx: int  # 11
I960_bbc: int  # 12
I960_bbs: int  # 13
I960_be: int  # 16
I960_bg: int  # 15
I960_bge: int  # 17
I960_bl: int  # 18
I960_ble: int  # 20
I960_bne: int  # 19
I960_bno: int  # 14
I960_bo: int  # 21
I960_bswap: int  # 138
I960_bx: int  # 22
I960_call: int  # 23
I960_calls: int  # 24
I960_callx: int  # 25
I960_chkbit: int  # 26
I960_clrbit: int  # 27
I960_cmpdeci: int  # 28
I960_cmpdeco: int  # 29
I960_cmpi: int  # 30
I960_cmpib: int  # 135
I960_cmpibe: int  # 33
I960_cmpibg: int  # 32
I960_cmpibge: int  # 34
I960_cmpibl: int  # 35
I960_cmpible: int  # 37
I960_cmpibne: int  # 36
I960_cmpibno: int  # 31
I960_cmpibo: int  # 38
I960_cmpinci: int  # 39
I960_cmpinco: int  # 40
I960_cmpis: int  # 137
I960_cmpo: int  # 41
I960_cmpob: int  # 134
I960_cmpobe: int  # 43
I960_cmpobg: int  # 42
I960_cmpobge: int  # 44
I960_cmpobl: int  # 45
I960_cmpoble: int  # 47
I960_cmpobne: int  # 46
I960_cmpos: int  # 136
I960_cmpstr: int  # 144
I960_concmpi: int  # 48
I960_concmpo: int  # 49
I960_condrec: int  # 154
I960_condwait: int  # 165
I960_daddc: int  # 151
I960_dcctl: int  # 158
I960_dcinva: int  # 133
I960_divi: int  # 50
I960_divo: int  # 51
I960_dmovt: int  # 153
I960_dsubc: int  # 152
I960_ediv: int  # 52
I960_emul: int  # 53
I960_eshro: int  # 54
I960_extract: int  # 55
I960_faddr: int  # 209
I960_faddrl: int  # 210
I960_fatanr: int  # 211
I960_fatanrl: int  # 212
I960_faulte: int  # 58
I960_faultg: int  # 57
I960_faultge: int  # 59
I960_faultl: int  # 60
I960_faultle: int  # 62
I960_faultne: int  # 61
I960_faultno: int  # 56
I960_faulto: int  # 63
I960_fclassr: int  # 213
I960_fclassrl: int  # 214
I960_fcmpor: int  # 215
I960_fcmporl: int  # 216
I960_fcmpr: int  # 217
I960_fcmprl: int  # 218
I960_fcosr: int  # 219
I960_fcosrl: int  # 220
I960_fcpyrsre: int  # 221
I960_fcpysre: int  # 222
I960_fcvtilr: int  # 223
I960_fcvtir: int  # 224
I960_fcvtri: int  # 225
I960_fcvtril: int  # 226
I960_fcvtzri: int  # 227
I960_fcvtzril: int  # 228
I960_fdivr: int  # 229
I960_fdivrl: int  # 230
I960_fexpr: int  # 231
I960_fexprl: int  # 232
I960_fill: int  # 150
I960_flogbnr: int  # 233
I960_flogbnrl: int  # 234
I960_flogepr: int  # 235
I960_flogeprl: int  # 236
I960_flogr: int  # 237
I960_flogrl: int  # 238
I960_flushreg: int  # 64
I960_fmark: int  # 65
I960_fmovr: int  # 239
I960_fmovre: int  # 240
I960_fmovrl: int  # 241
I960_fmulr: int  # 242
I960_fmulrl: int  # 243
I960_fp_first: int  # 209
I960_fp_last: int  # 257
I960_fremr: int  # 244
I960_fremrl: int  # 245
I960_froundr: int  # 246
I960_froundrl: int  # 247
I960_fscaler: int  # 248
I960_fscalerl: int  # 249
I960_fsinr: int  # 250
I960_fsinrl: int  # 251
I960_fsqrtr: int  # 252
I960_fsqrtrl: int  # 253
I960_fsubr: int  # 254
I960_fsubrl: int  # 255
I960_ftanr: int  # 256
I960_ftanrl: int  # 257
I960_halt: int  # 159
I960_icctl: int  # 157
I960_inspacc: int  # 147
I960_intctl: int  # 156
I960_intdis: int  # 139
I960_inten: int  # 140
I960_last: int  # 258
I960_ld: int  # 66
I960_lda: int  # 67
I960_ldib: int  # 68
I960_ldis: int  # 69
I960_ldl: int  # 70
I960_ldob: int  # 71
I960_ldos: int  # 72
I960_ldphy: int  # 148
I960_ldq: int  # 73
I960_ldt: int  # 74
I960_ldtime: int  # 168
I960_mark: int  # 75
I960_modac: int  # 76
I960_modi: int  # 77
I960_modify: int  # 78
I960_modpc: int  # 79
I960_modtc: int  # 80
I960_mov: int  # 81
I960_movl: int  # 82
I960_movq: int  # 83
I960_movqstr: int  # 145
I960_movstr: int  # 146
I960_movt: int  # 84
I960_muli: int  # 85
I960_mulo: int  # 86
I960_nand: int  # 87
I960_nor: int  # 88
I960_not: int  # 89
I960_notand: int  # 90
I960_notbit: int  # 91
I960_notor: int  # 92
I960_null: int  # 0
I960_or: int  # 93
I960_ornot: int  # 94
I960_receive: int  # 155
I960_remi: int  # 95
I960_remo: int  # 96
I960_resumprcs: int  # 162
I960_ret: int  # 97
I960_rotate: int  # 98
I960_saveprcs: int  # 164
I960_scanbit: int  # 99
I960_scanbyte: int  # 100
I960_schedprcs: int  # 163
I960_sdma: int  # 130
I960_sele: int  # 183
I960_selg: int  # 178
I960_selge: int  # 188
I960_sell: int  # 193
I960_selle: int  # 203
I960_selne: int  # 198
I960_selno: int  # 173
I960_selo: int  # 208
I960_send: int  # 160
I960_sendserv: int  # 161
I960_setbit: int  # 101
I960_shli: int  # 102
I960_shlo: int  # 103
I960_shrdi: int  # 104
I960_shri: int  # 105
I960_shro: int  # 106
I960_signal: int  # 167
I960_spanbit: int  # 107
I960_st: int  # 108
I960_stib: int  # 109
I960_stis: int  # 110
I960_stl: int  # 111
I960_stob: int  # 112
I960_stos: int  # 113
I960_stq: int  # 114
I960_stt: int  # 115
I960_subc: int  # 116
I960_subi: int  # 117
I960_subie: int  # 182
I960_subig: int  # 177
I960_subige: int  # 187
I960_subil: int  # 192
I960_subile: int  # 202
I960_subine: int  # 197
I960_subino: int  # 172
I960_subio: int  # 207
I960_subo: int  # 118
I960_suboe: int  # 181
I960_subog: int  # 176
I960_suboge: int  # 186
I960_subol: int  # 191
I960_subole: int  # 201
I960_subone: int  # 196
I960_subono: int  # 171
I960_suboo: int  # 206
I960_syncf: int  # 119
I960_synld: int  # 149
I960_synmov: int  # 141
I960_synmovl: int  # 142
I960_synmovq: int  # 143
I960_sysctl: int  # 131
I960_teste: int  # 122
I960_testg: int  # 121
I960_testge: int  # 123
I960_testl: int  # 124
I960_testle: int  # 126
I960_testne: int  # 125
I960_testno: int  # 120
I960_testo: int  # 127
I960_udma: int  # 132
I960_wait: int  # 166
I960_xnor: int  # 128
I960_xor: int  # 129
IA64_0: int  # 1
IA64_1: int  # 2
IA64_a: int  # 3
IA64_acq: int  # 4
IA64_add: int  # 5
IA64_addl: int  # 6
IA64_addp4: int  # 7
IA64_adds: int  # 8
IA64_alloc: int  # 9
IA64_and: int  # 10
IA64_andcm: int  # 11
IA64_b: int  # 12
IA64_bias: int  # 13
IA64_br: int  # 14
IA64_break: int  # 15
IA64_brl: int  # 16
IA64_brp: int  # 17
IA64_bsw: int  # 18
IA64_c: int  # 19
IA64_call: int  # 20
IA64_cexit: int  # 21
IA64_chk: int  # 22
IA64_cloop: int  # 23
IA64_clr: int  # 24
IA64_clrrrb: int  # 25
IA64_cmp: int  # 26
IA64_cmp4: int  # 27
IA64_cmpxchg1: int  # 28
IA64_cmpxchg2: int  # 29
IA64_cmpxchg4: int  # 30
IA64_cmpxchg8: int  # 31
IA64_cond: int  # 32
IA64_cover: int  # 33
IA64_ctop: int  # 34
IA64_czx1: int  # 35
IA64_czx2: int  # 36
IA64_d: int  # 37
IA64_dep: int  # 38
IA64_dpnt: int  # 39
IA64_dptk: int  # 40
IA64_e: int  # 41
IA64_epc: int  # 42
IA64_eq: int  # 43
IA64_excl: int  # 44
IA64_exit: int  # 45
IA64_exp: int  # 46
IA64_extr: int  # 47
IA64_f: int  # 48
IA64_fabs: int  # 49
IA64_fadd: int  # 50
IA64_famax: int  # 51
IA64_famin: int  # 52
IA64_fand: int  # 53
IA64_fandcm: int  # 54
IA64_fault: int  # 55
IA64_fc: int  # 56
IA64_fchkf: int  # 57
IA64_fclass: int  # 58
IA64_fclrf: int  # 59
IA64_fcmp: int  # 60
IA64_fcvt: int  # 61
IA64_fetchadd4: int  # 62
IA64_fetchadd8: int  # 63
IA64_few: int  # 64
IA64_fill: int  # 65
IA64_flushrs: int  # 66
IA64_fma: int  # 67
IA64_fmax: int  # 68
IA64_fmerge: int  # 69
IA64_fmin: int  # 70
IA64_fmix: int  # 71
IA64_fmpy: int  # 72
IA64_fms: int  # 73
IA64_fneg: int  # 74
IA64_fnegabs: int  # 75
IA64_fnma: int  # 76
IA64_fnmpy: int  # 77
IA64_fnorm: int  # 78
IA64_for: int  # 79
IA64_fpabs: int  # 80
IA64_fpack: int  # 81
IA64_fpamax: int  # 82
IA64_fpamin: int  # 83
IA64_fpcmp: int  # 84
IA64_fpcvt: int  # 85
IA64_fpma: int  # 86
IA64_fpmax: int  # 87
IA64_fpmerge: int  # 88
IA64_fpmin: int  # 89
IA64_fpmpy: int  # 90
IA64_fpms: int  # 91
IA64_fpneg: int  # 92
IA64_fpnegabs: int  # 93
IA64_fpnma: int  # 94
IA64_fpnmpy: int  # 95
IA64_fprcpa: int  # 96
IA64_fprsqrta: int  # 97
IA64_frcpa: int  # 98
IA64_frsqrta: int  # 99
IA64_fselect: int  # 100
IA64_fsetc: int  # 101
IA64_fsub: int  # 102
IA64_fswap: int  # 103
IA64_fsxt: int  # 104
IA64_fwb: int  # 105
IA64_fx: int  # 106
IA64_fxor: int  # 107
IA64_fxu: int  # 108
IA64_g: int  # 109
IA64_ga: int  # 110
IA64_ge: int  # 111
IA64_getf: int  # 112
IA64_geu: int  # 113
IA64_gt: int  # 114
IA64_gtu: int  # 115
IA64_h: int  # 116
IA64_hu: int  # 117
IA64_i: int  # 118
IA64_ia: int  # 119
IA64_imp: int  # 120
IA64_invala: int  # 121
IA64_itc: int  # 122
IA64_itr: int  # 123
IA64_l: int  # 124
IA64_last: int  # 284
IA64_ld1: int  # 125
IA64_ld2: int  # 126
IA64_ld4: int  # 127
IA64_ld8: int  # 128
IA64_ldf: int  # 129
IA64_ldf8: int  # 130
IA64_ldfd: int  # 131
IA64_ldfe: int  # 132
IA64_ldfp8: int  # 133
IA64_ldfpd: int  # 134
IA64_ldfps: int  # 135
IA64_ldfs: int  # 136
IA64_le: int  # 137
IA64_leu: int  # 138
IA64_lfetch: int  # 139
IA64_loadrs: int  # 140
IA64_loop: int  # 141
IA64_lr: int  # 142
IA64_lt: int  # 143
IA64_ltu: int  # 144
IA64_lu: int  # 145
IA64_m: int  # 146
IA64_many: int  # 147
IA64_mf: int  # 148
IA64_mix1: int  # 149
IA64_mix2: int  # 150
IA64_mix4: int  # 151
IA64_mov: int  # 152
IA64_movl: int  # 153
IA64_mux1: int  # 154
IA64_mux2: int  # 155
IA64_nc: int  # 156
IA64_ne: int  # 157
IA64_neq: int  # 158
IA64_nge: int  # 159
IA64_ngt: int  # 160
IA64_nl: int  # 161
IA64_nle: int  # 162
IA64_nlt: int  # 163
IA64_nm: int  # 164
IA64_nop: int  # 165
IA64_nr: int  # 166
IA64_ns: int  # 167
IA64_nt1: int  # 168
IA64_nt2: int  # 169
IA64_nta: int  # 170
IA64_null: int  # 0
IA64_nz: int  # 171
IA64_or: int  # 172
IA64_orcm: int  # 173
IA64_ord: int  # 174
IA64_pack2: int  # 175
IA64_pack4: int  # 176
IA64_padd1: int  # 177
IA64_padd2: int  # 178
IA64_padd4: int  # 179
IA64_pavg1: int  # 180
IA64_pavg2: int  # 181
IA64_pavgsub1: int  # 182
IA64_pavgsub2: int  # 183
IA64_pcmp1: int  # 184
IA64_pcmp2: int  # 185
IA64_pcmp4: int  # 186
IA64_pmax1: int  # 187
IA64_pmax2: int  # 188
IA64_pmin1: int  # 189
IA64_pmin2: int  # 190
IA64_pmpy2: int  # 191
IA64_pmpyshr2: int  # 192
IA64_popcnt: int  # 193
IA64_pr: int  # 194
IA64_probe: int  # 195
IA64_psad1: int  # 196
IA64_pshl2: int  # 197
IA64_pshl4: int  # 198
IA64_pshladd2: int  # 199
IA64_pshr2: int  # 200
IA64_pshr4: int  # 201
IA64_pshradd2: int  # 202
IA64_psub1: int  # 203
IA64_psub2: int  # 204
IA64_psub4: int  # 205
IA64_ptc: int  # 206
IA64_ptr: int  # 207
IA64_r: int  # 208
IA64_raz: int  # 209
IA64_rel: int  # 210
IA64_ret: int  # 211
IA64_rfi: int  # 212
IA64_rsm: int  # 213
IA64_rum: int  # 214
IA64_rw: int  # 215
IA64_s: int  # 216
IA64_s0: int  # 217
IA64_s1: int  # 218
IA64_s2: int  # 219
IA64_s3: int  # 220
IA64_sa: int  # 221
IA64_se: int  # 222
IA64_setf: int  # 223
IA64_shl: int  # 224
IA64_shladd: int  # 225
IA64_shladdp4: int  # 226
IA64_shr: int  # 227
IA64_shrp: int  # 228
IA64_sig: int  # 229
IA64_spill: int  # 230
IA64_spnt: int  # 231
IA64_sptk: int  # 232
IA64_srlz: int  # 233
IA64_ssm: int  # 234
IA64_sss: int  # 235
IA64_st1: int  # 236
IA64_st2: int  # 237
IA64_st4: int  # 238
IA64_st8: int  # 239
IA64_stf: int  # 240
IA64_stf8: int  # 241
IA64_stfd: int  # 242
IA64_stfe: int  # 243
IA64_stfs: int  # 244
IA64_sub: int  # 245
IA64_sum: int  # 246
IA64_sxt1: int  # 247
IA64_sxt2: int  # 248
IA64_sxt4: int  # 249
IA64_sync: int  # 250
IA64_tak: int  # 251
IA64_tbit: int  # 252
IA64_thash: int  # 253
IA64_tnat: int  # 254
IA64_tpa: int  # 255
IA64_trunc: int  # 256
IA64_ttag: int  # 257
IA64_u: int  # 258
IA64_unc: int  # 259
IA64_unord: int  # 260
IA64_unpack1: int  # 261
IA64_unpack2: int  # 262
IA64_unpack4: int  # 263
IA64_uss: int  # 264
IA64_uus: int  # 265
IA64_uuu: int  # 266
IA64_w: int  # 267
IA64_wexit: int  # 268
IA64_wtop: int  # 269
IA64_x: int  # 270
IA64_xchg1: int  # 271
IA64_xchg2: int  # 272
IA64_xchg4: int  # 273
IA64_xchg8: int  # 274
IA64_xf: int  # 275
IA64_xma: int  # 276
IA64_xmpy: int  # 277
IA64_xor: int  # 278
IA64_xuf: int  # 279
IA64_z: int  # 280
IA64_zxt1: int  # 281
IA64_zxt2: int  # 282
IA64_zxt4: int  # 283
IDAINFO_PROCNAME_SIZE: int  # 16
IDAINFO_STRLIT_PREF_SIZE: int  # 16
IDAINFO_TAG_SIZE: int  # 3
IDALIB_API_MAGIC: int  # 8339911660797952
IDASGN_APPLIED: int  # 2
IDASGN_BADARG: int  # 1
IDASGN_CURRENT: int  # 3
IDASGN_OK: int  # 0
IDASGN_PLANNED: int  # 4
IDA_DEBUG_ACCESSIBILITY: int  # 524288
IDA_DEBUG_ALREADY: int  # 8192
IDA_DEBUG_ALWAYS: int  # -1
IDA_DEBUG_APPCALL: int  # 131072
IDA_DEBUG_CHECKMEM: int  # 256
IDA_DEBUG_CONFIG: int  # 128
IDA_DEBUG_DBGINFO: int  # 4194304
IDA_DEBUG_DEBUGGER: int  # 65536
IDA_DEBUG_DEMANGLE: int  # 1024
IDA_DEBUG_DREFS: int  # 1
IDA_DEBUG_FLIRT: int  # 4
IDA_DEBUG_IDP: int  # 8
IDA_DEBUG_IDS: int  # 64
IDA_DEBUG_INTERNET: int  # 1048576
IDA_DEBUG_LDR: int  # 16
IDA_DEBUG_LICENSE: int  # 512
IDA_DEBUG_LUMINA: int  # 8388608
IDA_DEBUG_NETWORK: int  # 1048576
IDA_DEBUG_NOTIFY: int  # 32768
IDA_DEBUG_OFFSET: int  # 2
IDA_DEBUG_PLUGIN: int  # 32
IDA_DEBUG_QUEUE: int  # 2048
IDA_DEBUG_RANGECB: int  # 134217728
IDA_DEBUG_REGEX: int  # 33554432
IDA_DEBUG_ROLLBACK: int  # 4096
IDA_DEBUG_SIMPLEX: int  # 2097152
IDA_DEBUG_SRCDBG: int  # 262144
IDA_DEBUG_SUBPROC: int  # 67108864
IDA_DEBUG_THEMES: int  # 16777216
IDA_DEBUG_TIL: int  # 16384
IDA_REGISTRY_NAME: str  # ida
IDA_SDK_VERSION: int  # 920
IDA_SUBDIR_IDADIR_FIRST: int  # 2
IDA_SUBDIR_IDP: int  # 1
IDA_SUBDIR_ONLY_EXISTING: int  # 4
IDBDEC_ESCAPE: int  # 1
IDB_COMPRESSED: int  # 2
IDB_DESKTOPS_NODE_NAME: str  # $ desktops
IDB_DESKTOPS_TAG: str  # S
IDB_EXT: str  # i64
IDB_EXT32: str  # idb
IDB_EXT64: str  # i64
IDB_PACKED: int  # 1
IDB_UNPACKED: int  # 0
IDCHK_ARG: int  # -1
IDCHK_KEY: int  # -2
IDCHK_MAX: int  # -3
IDCHK_OK: int  # 0
IDC_LANG_EXT: str  # idc
IDC_SUBDIR: str  # idc
IDD_INTERFACE_VERSION: int  # 31
IDI_ALTVAL: int  # 1
IDI_BITMAP: int  # 16384
IDI_BLOB: int  # 8
IDI_BUFVAR: int  # 16496
IDI_BYTEARRAY: int  # 64
IDI_CSTR: int  # 16
IDI_DEC: int  # 128
IDI_EA_HEX: int  # 0
IDI_HASH: int  # 2048
IDI_HEX: int  # 256
IDI_HLPSTRUC: int  # 4096
IDI_INC: int  # 512
IDI_MAP_VAL: int  # 1024
IDI_NODEVAL: int  # 15
IDI_NOMERGE: int  # 65536
IDI_ONOFF: int  # 32768
IDI_QSTRING: int  # 32
IDI_READONLY: int  # 8192
IDI_SCALAR: int  # 0
IDI_STRUCFLD: int  # 0
IDI_SUPVAL: int  # 2
IDI_VALOBJ: int  # 4
IDPOPT_BADKEY: int  # 1
IDPOPT_BADTYPE: int  # 2
IDPOPT_BADVALUE: int  # 3
IDPOPT_BIT: int  # 3
IDPOPT_BIT_BOOL: int  # 50331648
IDPOPT_BIT_UCHAR: int  # 16777216
IDPOPT_BIT_UINT: int  # 0
IDPOPT_BIT_USHORT: int  # 33554432
IDPOPT_CST: int  # 6
IDPOPT_CST_PARAMS: int  # 16777216
IDPOPT_FLT: int  # 4
IDPOPT_I64: int  # 5
IDPOPT_I64_RANGE: int  # 16777216
IDPOPT_I64_UNS: int  # 33554432
IDPOPT_JVL: int  # 7
IDPOPT_MBROFF: int  # 262144
IDPOPT_NUM: int  # 2
IDPOPT_NUM_CHAR: int  # 16777216
IDPOPT_NUM_INT: int  # 0
IDPOPT_NUM_RANGE: int  # 67108864
IDPOPT_NUM_SHORT: int  # 33554432
IDPOPT_NUM_UNS: int  # 134217728
IDPOPT_OK: int  # 0
IDPOPT_PRI_DEFAULT: int  # 1
IDPOPT_PRI_HIGH: int  # 2
IDPOPT_STR: int  # 1
IDPOPT_STR_LONG: int  # 33554432
IDPOPT_STR_QSTRING: int  # 16777216
IDP_DLL: str  # *.so
IDP_INTERFACE_VERSION: int  # 900
IDP_SUBDIR: str  # procs
IDS_SUBDIR: str  # ids
IEEE_E: int  # 1
IEEE_EXONE: int  # 16383
IEEE_M: int  # 2
IEEE_NI: int  # 11
IK_ADD: int  # 107
IK_APPS: int  # 93
IK_BACK: int  # 8
IK_BROWSER_BACK: int  # 166
IK_BROWSER_FAVORITES: int  # 171
IK_BROWSER_FORWARD: int  # 167
IK_BROWSER_HOME: int  # 172
IK_BROWSER_REFRESH: int  # 168
IK_BROWSER_SEARCH: int  # 170
IK_BROWSER_STOP: int  # 169
IK_CANCEL: int  # 3
IK_CAPITAL: int  # 20
IK_CLEAR: int  # 12
IK_CONTROL: int  # 17
IK_DECIMAL: int  # 110
IK_DELETE: int  # 46
IK_DIVIDE: int  # 111
IK_DOWN: int  # 40
IK_END: int  # 35
IK_ESCAPE: int  # 27
IK_EXECUTE: int  # 43
IK_F1: int  # 112
IK_F10: int  # 121
IK_F11: int  # 122
IK_F12: int  # 123
IK_F13: int  # 124
IK_F14: int  # 125
IK_F15: int  # 126
IK_F16: int  # 127
IK_F17: int  # 128
IK_F18: int  # 129
IK_F19: int  # 130
IK_F2: int  # 113
IK_F20: int  # 131
IK_F21: int  # 132
IK_F22: int  # 133
IK_F23: int  # 134
IK_F24: int  # 135
IK_F3: int  # 114
IK_F4: int  # 115
IK_F5: int  # 116
IK_F6: int  # 117
IK_F7: int  # 118
IK_F8: int  # 119
IK_F9: int  # 120
IK_HELP: int  # 47
IK_HOME: int  # 36
IK_INSERT: int  # 45
IK_KANA: int  # 21
IK_LAUNCH_APP1: int  # 182
IK_LAUNCH_APP2: int  # 183
IK_LAUNCH_MAIL: int  # 180
IK_LAUNCH_MEDIA_SELECT: int  # 181
IK_LCONTROL: int  # 162
IK_LEFT: int  # 37
IK_LMENU: int  # 164
IK_LSHIFT: int  # 160
IK_LWIN: int  # 91
IK_MEDIA_NEXT_TRACK: int  # 176
IK_MEDIA_PLAY_PAUSE: int  # 179
IK_MEDIA_PREV_TRACK: int  # 177
IK_MEDIA_STOP: int  # 178
IK_MENU: int  # 18
IK_MODECHANGE: int  # 31
IK_MULTIPLY: int  # 106
IK_NEXT: int  # 34
IK_NUMLOCK: int  # 144
IK_NUMPAD0: int  # 96
IK_NUMPAD1: int  # 97
IK_NUMPAD2: int  # 98
IK_NUMPAD3: int  # 99
IK_NUMPAD4: int  # 100
IK_NUMPAD5: int  # 101
IK_NUMPAD6: int  # 102
IK_NUMPAD7: int  # 103
IK_NUMPAD8: int  # 104
IK_NUMPAD9: int  # 105
IK_OEM_1: int  # 186
IK_OEM_102: int  # 226
IK_OEM_2: int  # 191
IK_OEM_3: int  # 192
IK_OEM_4: int  # 219
IK_OEM_5: int  # 220
IK_OEM_6: int  # 221
IK_OEM_7: int  # 222
IK_OEM_CLEAR: int  # 254
IK_OEM_COMMA: int  # 188
IK_OEM_FJ_MASSHOU: int  # 147
IK_OEM_FJ_TOUROKU: int  # 148
IK_OEM_MINUS: int  # 189
IK_OEM_PERIOD: int  # 190
IK_OEM_PLUS: int  # 187
IK_PAUSE: int  # 19
IK_PLAY: int  # 250
IK_PRINT: int  # 42
IK_PRIOR: int  # 33
IK_RCONTROL: int  # 163
IK_RETURN: int  # 13
IK_RIGHT: int  # 39
IK_RMENU: int  # 165
IK_RSHIFT: int  # 161
IK_RWIN: int  # 92
IK_SCROLL: int  # 145
IK_SELECT: int  # 41
IK_SEPARATOR: int  # 108
IK_SHIFT: int  # 16
IK_SLEEP: int  # 95
IK_SNAPSHOT: int  # 44
IK_SPACE: int  # 32
IK_SUBTRACT: int  # 109
IK_TAB: int  # 9
IK_UP: int  # 38
IK_VOLUME_DOWN: int  # 174
IK_VOLUME_MUTE: int  # 173
IK_VOLUME_UP: int  # 175
IK_ZOOM: int  # 251
INCLUDE_DEAD_RETREGS: int  # 4096
INCLUDE_RESTRICTED: int  # 8192
INCLUDE_SPOILED_REGS: int  # 64
INCLUDE_UNUSED_SRC: int  # 2048
INFFL_ALLASM: int  # 2
INFFL_AUTO: int  # 1
INFFL_CHKOPS: int  # 32
INFFL_GRAPH_VIEW: int  # 128
INFFL_LOADIDC: int  # 4
INFFL_NMOPS: int  # 64
INFFL_NOUSER: int  # 8
INFFL_READONLY: int  # 16
INFORMATION: int  # 10
INF_ABIBITS: int  # 67
INF_ABINAME: int  # 81
INF_AF: int  # 10
INF_AF2: int  # 11
INF_APPCALL_OPTIONS: int  # 68
INF_APPTYPE: int  # 7
INF_ARCHIVE_PATH: int  # 82
INF_ASMTYPE: int  # 8
INF_BASEADDR: int  # 12
INF_BIN_PREFIX_SIZE: int  # 47
INF_CALLCNV: int  # 99
INF_CC_CM: int  # 58
INF_CC_DEFALIGN: int  # 62
INF_CC_ID: int  # 57
INF_CC_SIZE_B: int  # 60
INF_CC_SIZE_E: int  # 61
INF_CC_SIZE_I: int  # 59
INF_CC_SIZE_L: int  # 64
INF_CC_SIZE_LDBL: int  # 66
INF_CC_SIZE_LL: int  # 65
INF_CC_SIZE_S: int  # 63
INF_CMTFLG: int  # 45
INF_CMT_INDENT: int  # 41
INF_COMPILER_INFO: int  # 98
INF_CRC32: int  # 92
INF_CTIME: int  # 89
INF_C_MACROS: int  # 72
INF_DATABASE_CHANGE_COUNT: int  # 4
INF_DATATYPES: int  # 55
INF_DBG_BINPATHS: int  # 79
INF_DEMNAMES: int  # 38
INF_DUALOP_GRAPH: int  # 74
INF_DUALOP_TEXT: int  # 75
INF_ELAPSED: int  # 90
INF_FILETYPE: int  # 5
INF_FILE_FORMAT_NAME: int  # 69
INF_FSIZE: int  # 95
INF_GENFLAGS: int  # 2
INF_GROUPS: int  # 70
INF_HIGHOFF: int  # 24
INF_H_PATH: int  # 71
INF_IDA_VERSION: int  # 77
INF_IDSNODE: int  # 94
INF_IMAGEBASE: int  # 93
INF_INCLUDE: int  # 73
INF_INDENT: int  # 40
INF_INITIAL_VERSION: int  # 88
INF_INPUT_FILE_PATH: int  # 97
INF_LAST: int  # 100
INF_LENXREF: int  # 43
INF_LFLAGS: int  # 3
INF_LIMITER: int  # 46
INF_LISTNAMES: int  # 39
INF_LONG_DEMNAMES: int  # 37
INF_LOWOFF: int  # 23
INF_MAIN: int  # 18
INF_MARGIN: int  # 42
INF_MAXREF: int  # 25
INF_MAX_AUTONAME_LEN: int  # 34
INF_MAX_EA: int  # 20
INF_MD5: int  # 76
INF_MIN_EA: int  # 19
INF_NAMETYPE: int  # 35
INF_NETDELTA: int  # 29
INF_NOPENS: int  # 91
INF_NOTEPAD: int  # 85
INF_OBSOLETE_CC: int  # 56
INF_OMAX_EA: int  # 22
INF_OMIN_EA: int  # 21
INF_OSTYPE: int  # 6
INF_OUTFILEENC: int  # 96
INF_OUTFLAGS: int  # 44
INF_PREFFLAG: int  # 48
INF_PRIVRANGE: int  # 26
INF_PRIVRANGE_END_EA: int  # 28
INF_PRIVRANGE_START_EA: int  # 27
INF_PROBLEMS: int  # 83
INF_PROCNAME: int  # 1
INF_REFCMTNUM: int  # 32
INF_SELECTORS: int  # 84
INF_SHA256: int  # 80
INF_SHORT_DEMNAMES: int  # 36
INF_SPECSEGS: int  # 9
INF_SRCDBG_PATHS: int  # 86
INF_SRCDBG_UNDESIRED: int  # 87
INF_START_CS: int  # 14
INF_START_EA: int  # 16
INF_START_IP: int  # 15
INF_START_SP: int  # 17
INF_START_SS: int  # 13
INF_STRLIT_BREAK: int  # 50
INF_STRLIT_FLAGS: int  # 49
INF_STRLIT_PREF: int  # 53
INF_STRLIT_SERNUM: int  # 54
INF_STRLIT_ZEROES: int  # 51
INF_STRTYPE: int  # 52
INF_STR_ENCODINGS: int  # 78
INF_TYPE_XREFNUM: int  # 31
INF_VERSION: int  # 0
INF_XREFFLAG: int  # 33
INF_XREFNUM: int  # 30
INLINE_DONTCOPY: int  # 2
INLINE_EXTFRAME: int  # 1
INSN_64BIT: int  # 4
INSN_MACRO: int  # 1
INSN_MODMAC: int  # 2
INSN_TRACE: int  # 2
IOREDIR_APPEND: int  # 4
IOREDIR_INPUT: int  # 1
IOREDIR_OUTPUT: int  # 2
IOREDIR_QUOTED: int  # 8
IPROP_ASSERT: int  # 128
IPROP_CLNPOP: int  # 8
IPROP_COMBINED: int  # 2048
IPROP_DONT_COMB: int  # 262144
IPROP_DONT_PROP: int  # 131072
IPROP_EXTSTX: int  # 4096
IPROP_FARCALL: int  # 32
IPROP_FPINSN: int  # 16
IPROP_IGNLOWSRC: int  # 8192
IPROP_INV_JX: int  # 16384
IPROP_MBARRIER: int  # 524288
IPROP_MULTI_MOV: int  # 65536
IPROP_OPTIONAL: int  # 1
IPROP_PERSIST: int  # 2
IPROP_SPLIT: int  # 1792
IPROP_SPLIT1: int  # 256
IPROP_SPLIT2: int  # 512
IPROP_SPLIT4: int  # 768
IPROP_SPLIT8: int  # 1024
IPROP_TAILCALL: int  # 64
IPROP_UNMERGED: int  # 1048576
IPROP_UNPAIRED: int  # 2097152
IPROP_WAS_NORET: int  # 32768
IPROP_WILDMATCH: int  # 4
IRI_EXTENDED: int  # 0
IRI_RET_LITERALLY: int  # 1
IRI_SKIP_RETTARGET: int  # 2
IRI_STRICT: int  # 3
ITEM_END_CANCEL: int  # 16
ITEM_END_FIXUP: int  # 1
ITEM_END_INITED: int  # 2
ITEM_END_NAME: int  # 4
ITEM_END_XREF: int  # 8
ITP_ARG1: int  # 1
ITP_ARG64: int  # 64
ITP_ASM: int  # 66
ITP_BLOCK1: int  # 74
ITP_BLOCK2: int  # 75
ITP_BRACE1: int  # 65
ITP_BRACE2: int  # 72
ITP_CASE: int  # 1073741824
ITP_COLON: int  # 73
ITP_CURLY1: int  # 70
ITP_CURLY2: int  # 71
ITP_DO: int  # 68
ITP_ELSE: int  # 67
ITP_EMPTY: int  # 0
ITP_INNER_LAST: int  # 65
ITP_SEMI: int  # 69
ITP_SIGN: int  # 536870912
ITP_TRY: int  # 76
IT_LOG_SAME_IP: int  # 1
IWID_ADDRWATCH: int  # 35184372088832
IWID_ALL: int  # 18446744073709551615
IWID_ANY_LISTING: int  # 288318337518141440
IWID_BOOKMARKS: int  # 144115188075855872
IWID_BPTS: int  # 8192
IWID_CALLS: int  # 2048
IWID_CALLS_CALLEES: int  # 281474976710656
IWID_CALLS_CALLERS: int  # 140737488355328
IWID_CALL_STACK: int  # 131072
IWID_CHOOSER: int  # 34359738368
IWID_CLI: int  # 2147483648
IWID_CMDPALCSR: int  # 2199023255552
IWID_CMDPALWIN: int  # 4398046511104
IWID_CPUREGS: int  # 274877906944
IWID_CUSTVIEW: int  # 17592186044416
IWID_CV_LINE_INFOS: int  # 2251799813685248
IWID_DISASM: int  # 134217728
IWID_DISASMS: int  # 134217728
IWID_DISASM_ARROWS: int  # 1125899906842624
IWID_EA_LISTING: int  # 70369146830848
IWID_EXPORTS: int  # 1
IWID_FRAME: int  # 33554432
IWID_FUNCS: int  # 8
IWID_HEXVIEW: int  # 268435456
IWID_IMPORTS: int  # 2
IWID_LOCALS: int  # 8589934592
IWID_LOCTYPS: int  # 1024
IWID_MDVIEWCSR: int  # 562949953421312
IWID_MODULES: int  # 32768
IWID_NAMES: int  # 4
IWID_NAVBAND: int  # 67108864
IWID_NOTEPAD: int  # 536870912
IWID_OUTPUT: int  # 1073741824
IWID_PROBS: int  # 4096
IWID_PSEUDOCODE: int  # 70368744177664
IWID_SCRIPTS_CSR: int  # 72057594037927936
IWID_SEARCH: int  # 524288
IWID_SEGREGS: int  # 64
IWID_SEGS: int  # 32
IWID_SELS: int  # 128
IWID_SHORTCUTCSR: int  # 68719476736
IWID_SHORTCUTWIN: int  # 137438953472
IWID_SIGNS: int  # 256
IWID_SNIPPETS: int  # 8796093022208
IWID_SNIPPETS_CSR: int  # 36028797018963968
IWID_SO_OFFSETS: int  # 1099511627776
IWID_SO_STRUCTS: int  # 549755813888
IWID_SRCPTHMAP_CSR: int  # 4503599627370496
IWID_SRCPTHUND_CSR: int  # 9007199254740992
IWID_STKVIEW: int  # 17179869184
IWID_STRINGS: int  # 16
IWID_THREADS: int  # 16384
IWID_TICSR: int  # 1024
IWID_TILIST: int  # 288230376151711744
IWID_TILS: int  # 512
IWID_TILVIEW: int  # 1024
IWID_TIL_VIEW: int  # 576460752303423488
IWID_TRACE: int  # 65536
IWID_TYPE_EDITOR: int  # 1152921504606846976
IWID_UNDOHIST: int  # 18014398509481984
IWID_WATCH: int  # 4294967296
IWID_XREFS: int  # 262144
IWID_XREF_TREE: int  # 4611686018427387904
KR1878_adc: int  # 24
KR1878_add: int  # 3
KR1878_addl: int  # 10
KR1878_and: int  # 5
KR1878_bic: int  # 12
KR1878_bis: int  # 13
KR1878_btg: int  # 14
KR1878_btt: int  # 15
KR1878_cmp: int  # 2
KR1878_cmpl: int  # 9
KR1878_cst: int  # 32
KR1878_ijmp: int  # 43
KR1878_ijsr: int  # 44
KR1878_jc: int  # 42
KR1878_jmp: int  # 35
KR1878_jnc: int  # 41
KR1878_jns: int  # 39
KR1878_jnz: int  # 37
KR1878_js: int  # 40
KR1878_jsr: int  # 36
KR1878_jz: int  # 38
KR1878_last: int  # 53
KR1878_ldr: int  # 26
KR1878_mfpr: int  # 28
KR1878_mov: int  # 1
KR1878_movl: int  # 8
KR1878_mtpr: int  # 27
KR1878_neg: int  # 17
KR1878_nop: int  # 48
KR1878_not: int  # 18
KR1878_null: int  # 0
KR1878_or: int  # 6
KR1878_pop: int  # 30
KR1878_push: int  # 29
KR1878_reset: int  # 51
KR1878_rlc: int  # 22
KR1878_rrc: int  # 23
KR1878_rti: int  # 47
KR1878_rts: int  # 45
KR1878_rtsc: int  # 46
KR1878_sbc: int  # 25
KR1878_shl: int  # 19
KR1878_shr: int  # 20
KR1878_shra: int  # 21
KR1878_sksp: int  # 52
KR1878_sst: int  # 31
KR1878_stop: int  # 50
KR1878_sub: int  # 4
KR1878_subl: int  # 11
KR1878_swap: int  # 16
KR1878_tdc: int  # 34
KR1878_tof: int  # 33
KR1878_wait: int  # 49
KR1878_xor: int  # 7
LDRF_RELOAD: int  # 1
LDRF_REQ_PROC: int  # 2
LDR_SUBDIR: str  # loaders
LECVT_CANCELED: int  # -1
LECVT_ERROR: int  # 0
LECVT_OK: int  # 1
LECVT_WITHIN_LISTING: int  # 1
LFLG_64BIT: int  # 4
LFLG_COMPRESS: int  # 1024
LFLG_DBG_NOPATH: int  # 128
LFLG_FLAT_OFF32: int  # 16
LFLG_ILP32: int  # 4096
LFLG_IS_DLL: int  # 8
LFLG_KERNMODE: int  # 2048
LFLG_MSF: int  # 32
LFLG_PACK: int  # 512
LFLG_PC_FLAT: int  # 2
LFLG_PC_FPP: int  # 1
LFLG_SNAPSHOT: int  # 256
LFLG_WIDE_HBF: int  # 64
LHF_HISTORY_DISABLED: int  # 1
LIBFUNC_DELAY: int  # 2
LIBFUNC_FOUND: int  # 0
LIBFUNC_NONE: int  # 1
LIB_LOADED: int  # 8
LIB_UNLOADED: int  # 9
LINPUT_GENERIC: int  # 4
LINPUT_LOCAL: int  # 1
LINPUT_NONE: int  # 0
LINPUT_PROCMEM: int  # 3
LINPUT_RFILE: int  # 2
LMT_EMPTY: int  # 4
LMT_THICK: int  # 2
LMT_THIN: int  # 1
LN_AUTO: int  # 4
LN_NORMAL: int  # 1
LN_PUBLIC: int  # 2
LN_WEAK: int  # 8
LOADER_DLL: str  # *.so
LOCOPT_ALL: int  # 1
LOCOPT_REFINE: int  # 2
LOCOPT_REFINE2: int  # 4
LOC_CLOSE: int  # 0
LOC_KEEP: int  # 2
LOC_UNMAKE: int  # 1
LROEF_CPS_RANGE: int  # 1
LROEF_FULL_LINE: int  # 0
LROEF_MASK: int  # 16777215
LSEF_ALL: int  # 7
LSEF_PLACE: int  # 1
LSEF_PTYPE: int  # 4
LSEF_RINFO: int  # 2
LS_CTYPE: int  # 2
LS_CTYPE2: int  # 4
LS_CTYPE_3V: int  # 32
LS_CTYPE_ALT: int  # 8
LS_STARTUP: int  # 1
LS_ZIP: int  # 16
LTC_ADDED: int  # 1
LTC_ALIASED: int  # 4
LTC_COMPILER: int  # 5
LTC_DELETED: int  # 2
LTC_EDITED: int  # 3
LTC_NONE: int  # 0
LTC_TIL_COMPACTED: int  # 8
LTC_TIL_LOADED: int  # 6
LTC_TIL_UNLOADED: int  # 7
LVINF_KEEP: int  # 1
LVINF_NOMAP: int  # 8
LVINF_NOPTR: int  # 4
LVINF_SPLIT: int  # 2
LVINF_UNUSED: int  # 16
M16C_abs: int  # 1
M16C_adc: int  # 2
M16C_adcf: int  # 3
M16C_add: int  # 4
M16C_addf: int  # 165
M16C_addx: int  # 123
M16C_adjnz: int  # 5
M16C_adsf: int  # 166
M16C_and: int  # 6
M16C_band: int  # 7
M16C_bclr: int  # 8
M16C_bitindex: int  # 124
M16C_bmcnd: int  # 9
M16C_bmeq: int  # 12
M16C_bmge: int  # 16
M16C_bmgeu: int  # 10
M16C_bmgt: int  # 21
M16C_bmgtu: int  # 11
M16C_bmle: int  # 14
M16C_bmleu: int  # 18
M16C_bmlt: int  # 23
M16C_bmltu: int  # 17
M16C_bmn: int  # 13
M16C_bmne: int  # 19
M16C_bmno: int  # 22
M16C_bmo: int  # 15
M16C_bmpz: int  # 20
M16C_bnand: int  # 24
M16C_bnor: int  # 25
M16C_bnot: int  # 26
M16C_bntst: int  # 27
M16C_bnxor: int  # 28
M16C_bor: int  # 29
M16C_brk: int  # 30
M16C_brk2: int  # 125
M16C_bset: int  # 31
M16C_btst: int  # 32
M16C_btstc: int  # 33
M16C_btsts: int  # 34
M16C_bxor: int  # 35
M16C_clip: int  # 126
M16C_cmp: int  # 36
M16C_cmpf: int  # 167
M16C_cmpx: int  # 127
M16C_cnvif: int  # 168
M16C_dadc: int  # 37
M16C_dadd: int  # 38
M16C_dec: int  # 39
M16C_div: int  # 40
M16C_divf: int  # 169
M16C_divu: int  # 41
M16C_divx: int  # 42
M16C_dsbb: int  # 43
M16C_dsub: int  # 44
M16C_ediv: int  # 170
M16C_edivu: int  # 171
M16C_edivx: int  # 172
M16C_emul: int  # 173
M16C_emulu: int  # 174
M16C_enter: int  # 45
M16C_exitd: int  # 46
M16C_exiti: int  # 175
M16C_exts: int  # 47
M16C_extz: int  # 128
M16C_fclr: int  # 48
M16C_freit: int  # 129
M16C_fset: int  # 49
M16C_inc: int  # 50
M16C_index1: int  # 176
M16C_index2: int  # 177
M16C_indexb: int  # 130
M16C_indexbd: int  # 131
M16C_indexbs: int  # 132
M16C_indexl: int  # 133
M16C_indexld: int  # 134
M16C_indexls: int  # 135
M16C_indexw: int  # 136
M16C_indexwd: int  # 137
M16C_indexws: int  # 138
M16C_int: int  # 51
M16C_into: int  # 52
M16C_jcnd: int  # 53
M16C_jeq: int  # 56
M16C_jge: int  # 60
M16C_jgeu: int  # 54
M16C_jgt: int  # 65
M16C_jgtu: int  # 55
M16C_jle: int  # 58
M16C_jleu: int  # 62
M16C_jlt: int  # 67
M16C_jltu: int  # 61
M16C_jmp: int  # 68
M16C_jmpi: int  # 69
M16C_jmps: int  # 70
M16C_jn: int  # 57
M16C_jne: int  # 63
M16C_jno: int  # 66
M16C_jo: int  # 59
M16C_jpz: int  # 64
M16C_jsr: int  # 71
M16C_jsri: int  # 72
M16C_jsrs: int  # 73
M16C_last: int  # 185
M16C_ldc: int  # 74
M16C_ldctx: int  # 75
M16C_lde: int  # 76
M16C_ldintb: int  # 77
M16C_ldipl: int  # 78
M16C_max: int  # 139
M16C_min: int  # 140
M16C_mov: int  # 79
M16C_mova: int  # 80
M16C_movhh: int  # 81
M16C_movhl: int  # 82
M16C_movlh: int  # 83
M16C_movll: int  # 84
M16C_movx: int  # 141
M16C_mul: int  # 85
M16C_mulex: int  # 142
M16C_mulf: int  # 178
M16C_mulu: int  # 86
M16C_mulx: int  # 179
M16C_neg: int  # 87
M16C_nop: int  # 88
M16C_not: int  # 89
M16C_null: int  # 0
M16C_or: int  # 90
M16C_pop: int  # 91
M16C_popc: int  # 92
M16C_popm: int  # 93
M16C_push: int  # 94
M16C_pusha: int  # 95
M16C_pushc: int  # 96
M16C_pushm: int  # 97
M16C_reit: int  # 98
M16C_rmpa: int  # 99
M16C_rolc: int  # 100
M16C_rorc: int  # 101
M16C_rot: int  # 102
M16C_round: int  # 180
M16C_rts: int  # 103
M16C_sbb: int  # 104
M16C_sbjnz: int  # 105
M16C_sccnd: int  # 143
M16C_sceq: int  # 146
M16C_scge: int  # 150
M16C_scgeu: int  # 144
M16C_scgt: int  # 155
M16C_scgtu: int  # 145
M16C_scle: int  # 148
M16C_scleu: int  # 152
M16C_sclt: int  # 157
M16C_scltu: int  # 151
M16C_scmpu: int  # 158
M16C_scn: int  # 147
M16C_scne: int  # 153
M16C_scno: int  # 156
M16C_sco: int  # 149
M16C_scpz: int  # 154
M16C_sha: int  # 106
M16C_shanc: int  # 163
M16C_shl: int  # 107
M16C_shlnc: int  # 164
M16C_sin: int  # 159
M16C_smovb: int  # 108
M16C_smovf: int  # 109
M16C_smovu: int  # 160
M16C_sout: int  # 161
M16C_sstr: int  # 110
M16C_stc: int  # 111
M16C_stctx: int  # 112
M16C_ste: int  # 113
M16C_stnz: int  # 114
M16C_stop: int  # 181
M16C_stz: int  # 115
M16C_stzx: int  # 116
M16C_sub: int  # 117
M16C_subf: int  # 182
M16C_subx: int  # 162
M16C_suntil: int  # 183
M16C_swhile: int  # 184
M16C_tst: int  # 118
M16C_und: int  # 119
M16C_wait: int  # 120
M16C_xchg: int  # 121
M16C_xor: int  # 122
M65816_adc: int  # 1
M65816_and: int  # 2
M65816_asl: int  # 3
M65816_bcc: int  # 4
M65816_bcs: int  # 5
M65816_beq: int  # 6
M65816_bit: int  # 7
M65816_bmi: int  # 8
M65816_bne: int  # 9
M65816_bpl: int  # 10
M65816_bra: int  # 11
M65816_brk: int  # 12
M65816_brl: int  # 13
M65816_bvc: int  # 14
M65816_bvs: int  # 15
M65816_clc: int  # 16
M65816_cld: int  # 17
M65816_cli: int  # 18
M65816_clv: int  # 19
M65816_cmp: int  # 20
M65816_cop: int  # 21
M65816_cpx: int  # 22
M65816_cpy: int  # 23
M65816_dec: int  # 24
M65816_dex: int  # 25
M65816_dey: int  # 26
M65816_eor: int  # 27
M65816_inc: int  # 28
M65816_inx: int  # 29
M65816_iny: int  # 30
M65816_jml: int  # 31
M65816_jmp: int  # 32
M65816_jsl: int  # 33
M65816_jsr: int  # 34
M65816_last: int  # 93
M65816_lda: int  # 35
M65816_ldx: int  # 36
M65816_ldy: int  # 37
M65816_lsr: int  # 38
M65816_mvn: int  # 39
M65816_mvp: int  # 40
M65816_nop: int  # 41
M65816_null: int  # 0
M65816_ora: int  # 42
M65816_pea: int  # 43
M65816_pei: int  # 44
M65816_per: int  # 45
M65816_pha: int  # 46
M65816_phb: int  # 47
M65816_phd: int  # 48
M65816_phk: int  # 49
M65816_php: int  # 50
M65816_phx: int  # 51
M65816_phy: int  # 52
M65816_pla: int  # 53
M65816_plb: int  # 54
M65816_pld: int  # 55
M65816_plp: int  # 56
M65816_plx: int  # 57
M65816_ply: int  # 58
M65816_rep: int  # 59
M65816_rol: int  # 60
M65816_ror: int  # 61
M65816_rti: int  # 62
M65816_rtl: int  # 63
M65816_rts: int  # 64
M65816_sbc: int  # 65
M65816_sec: int  # 66
M65816_sed: int  # 67
M65816_sei: int  # 68
M65816_sep: int  # 69
M65816_sta: int  # 70
M65816_stp: int  # 71
M65816_stx: int  # 72
M65816_sty: int  # 73
M65816_stz: int  # 74
M65816_tax: int  # 75
M65816_tay: int  # 76
M65816_tcd: int  # 77
M65816_tcs: int  # 78
M65816_tdc: int  # 79
M65816_trb: int  # 80
M65816_tsb: int  # 81
M65816_tsc: int  # 82
M65816_tsx: int  # 83
M65816_txa: int  # 84
M65816_txs: int  # 85
M65816_txy: int  # 86
M65816_tya: int  # 87
M65816_tyx: int  # 88
M65816_wai: int  # 89
M65816_wdm: int  # 90
M65816_xba: int  # 91
M65816_xce: int  # 92
M65_adc: int  # 1
M65_anc: int  # 2
M65_and: int  # 3
M65_ane: int  # 4
M65_arr: int  # 5
M65_asl: int  # 6
M65_asr: int  # 7
M65_bbr0: int  # 77
M65_bbr1: int  # 78
M65_bbr2: int  # 79
M65_bbr3: int  # 80
M65_bbr4: int  # 81
M65_bbr5: int  # 82
M65_bbr6: int  # 83
M65_bbr7: int  # 84
M65_bbs0: int  # 85
M65_bbs1: int  # 86
M65_bbs2: int  # 87
M65_bbs3: int  # 88
M65_bbs4: int  # 89
M65_bbs5: int  # 90
M65_bbs6: int  # 91
M65_bbs7: int  # 92
M65_bcc: int  # 8
M65_bcs: int  # 9
M65_beq: int  # 10
M65_bit: int  # 11
M65_bmi: int  # 12
M65_bne: int  # 13
M65_bpl: int  # 14
M65_bra: int  # 116
M65_brk: int  # 15
M65_bvc: int  # 16
M65_bvs: int  # 17
M65_clc: int  # 18
M65_cld: int  # 19
M65_cli: int  # 20
M65_clv: int  # 21
M65_cmp: int  # 22
M65_cpx: int  # 23
M65_cpy: int  # 24
M65_dcp: int  # 25
M65_dec: int  # 26
M65_dex: int  # 27
M65_dey: int  # 28
M65_eor: int  # 29
M65_inc: int  # 30
M65_inx: int  # 31
M65_iny: int  # 32
M65_isb: int  # 33
M65_jmp: int  # 34
M65_jmpi: int  # 35
M65_jsr: int  # 36
M65_lae: int  # 37
M65_last: int  # 119
M65_lax: int  # 38
M65_lda: int  # 39
M65_ldx: int  # 40
M65_ldy: int  # 41
M65_lsr: int  # 42
M65_lxa: int  # 43
M65_nop: int  # 44
M65_null: int  # 0
M65_ora: int  # 45
M65_pha: int  # 46
M65_php: int  # 47
M65_phx: int  # 114
M65_phy: int  # 112
M65_pla: int  # 48
M65_plp: int  # 49
M65_plx: int  # 115
M65_ply: int  # 113
M65_rla: int  # 50
M65_rmb0: int  # 93
M65_rmb1: int  # 94
M65_rmb2: int  # 95
M65_rmb3: int  # 96
M65_rmb4: int  # 97
M65_rmb5: int  # 98
M65_rmb6: int  # 99
M65_rmb7: int  # 100
M65_rol: int  # 51
M65_ror: int  # 52
M65_rra: int  # 53
M65_rti: int  # 54
M65_rts: int  # 55
M65_sax: int  # 56
M65_sbc: int  # 57
M65_sbx: int  # 58
M65_sec: int  # 59
M65_sed: int  # 60
M65_sei: int  # 61
M65_sha: int  # 62
M65_shs: int  # 63
M65_shx: int  # 64
M65_shy: int  # 65
M65_slo: int  # 66
M65_smb0: int  # 101
M65_smb1: int  # 102
M65_smb2: int  # 103
M65_smb3: int  # 104
M65_smb4: int  # 105
M65_smb5: int  # 106
M65_smb6: int  # 107
M65_smb7: int  # 108
M65_sre: int  # 67
M65_sta: int  # 68
M65_stp: int  # 118
M65_stx: int  # 69
M65_sty: int  # 70
M65_stz: int  # 109
M65_tax: int  # 71
M65_tay: int  # 72
M65_trb: int  # 111
M65_tsb: int  # 110
M65_tsx: int  # 73
M65_txa: int  # 74
M65_txs: int  # 75
M65_tya: int  # 76
M65_wai: int  # 117
MAKELINE_BINPREF: int  # 1
MAKELINE_NONE: int  # 0
MAKELINE_STACK: int  # 4
MAKELINE_VOID: int  # 2
MANGLED_CODE: int  # 0
MANGLED_DATA: int  # 1
MANGLED_UNKNOWN: int  # 2
MAXADDR: int  # 0
MAXEXP_DOUBLE: int  # 1024
MAXEXP_FLOAT: int  # 128
MAXEXP_LNGDBL: int  # 16384
MAXNAMELEN: int  # 512
MAXNAMESIZE: int  # 512
MAXSPECSIZE: int  # 1024
MAXSTR: int  # 1024
MAXSTRUCPATH: int  # 32
MAX_DATABASE_DESCRIPTION: int  # 128
MAX_DECL_ALIGN: int  # 15
MAX_ENUM_SERIAL: int  # 255
MAX_FUNC_ARGS: int  # 256
MAX_GROUPS: int  # 8
MAX_MARK_SLOT: int  # 1024
MAX_NODENAME_SIZE: int  # 32768
MAX_SEGM_TRANSLATIONS: int  # 64
MAX_SPACES_ADDED: int  # 524288
MAX_SUPPORTED_STACK_SIZE: int  # 1048576
MAX_UTF8_SEQ_LEN: int  # 8
MAX_VLR_SIZE: int  # 8
MAX_VLR_SVALUE: int  # 9223372036854775807
MAX_VLR_VALUE: int  # 18446744073709551615
MAYMUST_ACCESS_MASK: int  # 1
MAY_ACCESS: int  # 1
MBA2_ALL_FLAGS: int  # 131071
MBA2_ARGIDX_OK: int  # 64
MBA2_ARGIDX_SORTED: int  # 1024
MBA2_CODE16_BIT: int  # 2048
MBA2_DONT_VERIFY: int  # -2147483648
MBA2_HAS_OUTLINES: int  # 8192
MBA2_INITIAL_FLAGS: int  # 3
MBA2_IS_CTR: int  # 16
MBA2_IS_DTR: int  # 32
MBA2_LVARNAMES_OK: int  # 1
MBA2_LVARS_RENAMED: int  # 2
MBA2_NO_DUP_CALLS: int  # 128
MBA2_NO_DUP_LVARS: int  # 256
MBA2_NO_FRAME: int  # 16384
MBA2_OVER_CHAINS: int  # 4
MBA2_PROP_COMPLEX: int  # 32768
MBA2_STACK_RETVAL: int  # 4096
MBA2_UNDEF_RETVAR: int  # 512
MBA2_VALRNG_DONE: int  # 8
MBA_ASRPROP: int  # 8192
MBA_ASRTOK: int  # 2048
MBA_CALLS: int  # 4096
MBA_CHVARS: int  # 2097152
MBA_CMBBLK: int  # 1024
MBA_CMNSTK: int  # 256
MBA_COLGDL: int  # 8388608
MBA_DELPAIRS: int  # 1048576
MBA_GLBOPT: int  # 65536
MBA_INITIAL_FLAGS: int  # 1459618817
MBA_INSGDL: int  # 16777216
MBA_LOADED: int  # 8
MBA_LVARS0: int  # 262144
MBA_LVARS1: int  # 524288
MBA_NICE: int  # 33554432
MBA_NOFUNC: int  # 2
MBA_NUMADDR: int  # 536870912
MBA_PASSREGS: int  # 64
MBA_PATTERN: int  # 4
MBA_PRCDEFS: int  # 1
MBA_PREOPT: int  # 512
MBA_REFINE: int  # 67108864
MBA_RETFP: int  # 16
MBA_RETREF: int  # 32768
MBA_SAVRST: int  # 16384
MBA_SHORT: int  # 4194304
MBA_SPLINFO: int  # 32
MBA_THUNK: int  # 128
MBA_VALNUM: int  # 1073741824
MBA_WINGR32: int  # 268435456
MBL_BACKPROP: int  # 4096
MBL_CALL: int  # 2048
MBL_COMB: int  # 64
MBL_DEAD: int  # 256
MBL_DMT64: int  # 32
MBL_DSLOT: int  # 16384
MBL_EXTFRAME: int  # 262144
MBL_FAKE: int  # 2
MBL_GOTO: int  # 4
MBL_INCONST: int  # 1024
MBL_INLINED: int  # 131072
MBL_KEEP: int  # 65536
MBL_LIST: int  # 512
MBL_NONFAKE: int  # 0
MBL_NORET: int  # 8192
MBL_PRIV: int  # 1
MBL_PROP: int  # 128
MBL_PUSH: int  # 16
MBL_TCAL: int  # 8
MBL_VALRANGES: int  # 32768
MC12XGATE_adc: int  # 282
MC12XGATE_add: int  # 283
MC12XGATE_add16: int  # 354
MC12XGATE_addh: int  # 284
MC12XGATE_addl: int  # 285
MC12XGATE_and: int  # 286
MC12XGATE_and16: int  # 355
MC12XGATE_andh: int  # 287
MC12XGATE_andl: int  # 288
MC12XGATE_asr: int  # 289
MC12XGATE_bcc: int  # 290
MC12XGATE_bcs: int  # 291
MC12XGATE_beq: int  # 292
MC12XGATE_bfext: int  # 293
MC12XGATE_bffo: int  # 294
MC12XGATE_bfins: int  # 295
MC12XGATE_bfinsi: int  # 296
MC12XGATE_bfinsx: int  # 297
MC12XGATE_bge: int  # 298
MC12XGATE_bgt: int  # 299
MC12XGATE_bhi: int  # 300
MC12XGATE_bhs: int  # 301
MC12XGATE_bith: int  # 302
MC12XGATE_bitl: int  # 303
MC12XGATE_ble: int  # 304
MC12XGATE_blo: int  # 305
MC12XGATE_bls: int  # 306
MC12XGATE_blt: int  # 307
MC12XGATE_bmi: int  # 308
MC12XGATE_bne: int  # 309
MC12XGATE_bpl: int  # 310
MC12XGATE_bra: int  # 311
MC12XGATE_brk: int  # 312
MC12XGATE_bvc: int  # 313
MC12XGATE_bvs: int  # 314
MC12XGATE_cmp: int  # 315
MC12XGATE_cmp16: int  # 356
MC12XGATE_cmpl: int  # 316
MC12XGATE_com: int  # 317
MC12XGATE_cpc: int  # 318
MC12XGATE_cpch: int  # 319
MC12XGATE_csem: int  # 320
MC12XGATE_csl: int  # 321
MC12XGATE_csr: int  # 322
MC12XGATE_jal: int  # 323
MC12XGATE_ldb: int  # 324
MC12XGATE_ldh: int  # 325
MC12XGATE_ldl: int  # 326
MC12XGATE_ldw: int  # 327
MC12XGATE_ldw16: int  # 357
MC12XGATE_lsl: int  # 328
MC12XGATE_lsr: int  # 329
MC12XGATE_mov: int  # 330
MC12XGATE_neg: int  # 331
MC12XGATE_nop: int  # 332
MC12XGATE_or: int  # 333
MC12XGATE_or16: int  # 358
MC12XGATE_orh: int  # 334
MC12XGATE_orl: int  # 335
MC12XGATE_par: int  # 336
MC12XGATE_rol: int  # 337
MC12XGATE_ror: int  # 338
MC12XGATE_rts: int  # 339
MC12XGATE_sbc: int  # 340
MC12XGATE_sex: int  # 341
MC12XGATE_sif: int  # 342
MC12XGATE_ssem: int  # 343
MC12XGATE_stb: int  # 344
MC12XGATE_stw: int  # 345
MC12XGATE_sub: int  # 346
MC12XGATE_sub16: int  # 359
MC12XGATE_subh: int  # 347
MC12XGATE_subl: int  # 348
MC12XGATE_tfr: int  # 349
MC12XGATE_tst: int  # 350
MC12XGATE_xnor: int  # 351
MC12XGATE_xnor16: int  # 360
MC12XGATE_xnorh: int  # 352
MC12XGATE_xnorl: int  # 353
MC12X_addx: int  # 211
MC12X_addy: int  # 212
MC12X_aded: int  # 213
MC12X_adex: int  # 214
MC12X_adey: int  # 215
MC12X_andx: int  # 216
MC12X_andy: int  # 217
MC12X_aslw: int  # 218
MC12X_aslx: int  # 219
MC12X_asly: int  # 220
MC12X_asrw: int  # 221
MC12X_asrx: int  # 222
MC12X_asry: int  # 223
MC12X_bitx: int  # 224
MC12X_bity: int  # 225
MC12X_btas: int  # 226
MC12X_clrw: int  # 227
MC12X_clrx: int  # 228
MC12X_clry: int  # 229
MC12X_comw: int  # 230
MC12X_comx: int  # 231
MC12X_comy: int  # 232
MC12X_cped: int  # 233
MC12X_cpes: int  # 234
MC12X_cpex: int  # 235
MC12X_cpey: int  # 236
MC12X_decw: int  # 237
MC12X_decx: int  # 238
MC12X_decy: int  # 239
MC12X_eorx: int  # 240
MC12X_eory: int  # 241
MC12X_gldaa: int  # 242
MC12X_gldab: int  # 243
MC12X_gldd: int  # 244
MC12X_glds: int  # 245
MC12X_gldx: int  # 246
MC12X_gldy: int  # 247
MC12X_gstaa: int  # 248
MC12X_gstab: int  # 249
MC12X_gstd: int  # 250
MC12X_gsts: int  # 251
MC12X_gstx: int  # 252
MC12X_gsty: int  # 253
MC12X_incw: int  # 254
MC12X_incx: int  # 255
MC12X_incy: int  # 256
MC12X_lsrw: int  # 257
MC12X_lsrx: int  # 258
MC12X_lsry: int  # 259
MC12X_negw: int  # 260
MC12X_negx: int  # 261
MC12X_negy: int  # 262
MC12X_orx: int  # 263
MC12X_ory: int  # 264
MC12X_pshcw: int  # 265
MC12X_pulcw: int  # 266
MC12X_rolw: int  # 267
MC12X_rolx: int  # 268
MC12X_roly: int  # 269
MC12X_rorw: int  # 270
MC12X_rorx: int  # 271
MC12X_rory: int  # 272
MC12X_sbed: int  # 273
MC12X_sbex: int  # 274
MC12X_sbey: int  # 275
MC12X_subx: int  # 276
MC12X_suby: int  # 277
MC12X_sys: int  # 281
MC12X_tstw: int  # 278
MC12X_tstx: int  # 279
MC12X_tsty: int  # 280
MC12_aba: int  # 1
MC12_abx: int  # 2
MC12_aby: int  # 3
MC12_adca: int  # 4
MC12_adcb: int  # 5
MC12_adda: int  # 6
MC12_addb: int  # 7
MC12_addd: int  # 8
MC12_anda: int  # 9
MC12_andb: int  # 10
MC12_andcc: int  # 11
MC12_asl: int  # 12
MC12_asla: int  # 13
MC12_aslb: int  # 14
MC12_asld: int  # 15
MC12_asr: int  # 16
MC12_asra: int  # 17
MC12_asrb: int  # 18
MC12_bcc: int  # 19
MC12_bclr: int  # 20
MC12_bcs: int  # 21
MC12_beq: int  # 22
MC12_bge: int  # 23
MC12_bgnd: int  # 24
MC12_bgt: int  # 25
MC12_bhi: int  # 26
MC12_bhs: int  # 27
MC12_bita: int  # 28
MC12_bitb: int  # 29
MC12_ble: int  # 30
MC12_blo: int  # 31
MC12_bls: int  # 32
MC12_blt: int  # 33
MC12_bmi: int  # 34
MC12_bne: int  # 35
MC12_bpl: int  # 36
MC12_bra: int  # 37
MC12_brclr: int  # 38
MC12_brn: int  # 39
MC12_brset: int  # 40
MC12_bset: int  # 41
MC12_bsr: int  # 42
MC12_bvc: int  # 43
MC12_bvs: int  # 44
MC12_call: int  # 45
MC12_cba: int  # 46
MC12_clc: int  # 47
MC12_cli: int  # 48
MC12_clr: int  # 49
MC12_clra: int  # 50
MC12_clrb: int  # 51
MC12_clv: int  # 52
MC12_cmpa: int  # 53
MC12_cmpb: int  # 54
MC12_com: int  # 55
MC12_coma: int  # 56
MC12_comb: int  # 57
MC12_cpd: int  # 58
MC12_cps: int  # 59
MC12_cpx: int  # 60
MC12_cpy: int  # 61
MC12_daa: int  # 62
MC12_dbeq: int  # 63
MC12_dbne: int  # 64
MC12_dec: int  # 65
MC12_deca: int  # 66
MC12_decb: int  # 67
MC12_des: int  # 68
MC12_dex: int  # 69
MC12_dey: int  # 70
MC12_ediv: int  # 71
MC12_edivs: int  # 72
MC12_emacs: int  # 73
MC12_emaxd: int  # 74
MC12_emaxm: int  # 75
MC12_emind: int  # 76
MC12_eminm: int  # 77
MC12_emul: int  # 78
MC12_emuls: int  # 79
MC12_eora: int  # 80
MC12_eorb: int  # 81
MC12_etbl: int  # 82
MC12_exg: int  # 83
MC12_fdiv: int  # 84
MC12_ibeq: int  # 85
MC12_ibne: int  # 86
MC12_idiv: int  # 87
MC12_idivs: int  # 88
MC12_inc: int  # 89
MC12_inca: int  # 90
MC12_incb: int  # 91
MC12_ins: int  # 92
MC12_inx: int  # 93
MC12_iny: int  # 94
MC12_jmp: int  # 95
MC12_jsr: int  # 96
MC12_last: int  # 361
MC12_lbcc: int  # 97
MC12_lbcs: int  # 98
MC12_lbeq: int  # 99
MC12_lbge: int  # 100
MC12_lbgt: int  # 101
MC12_lbhi: int  # 102
MC12_lbhs: int  # 103
MC12_lble: int  # 104
MC12_lblo: int  # 105
MC12_lbls: int  # 106
MC12_lblt: int  # 107
MC12_lbmi: int  # 108
MC12_lbne: int  # 109
MC12_lbpl: int  # 110
MC12_lbra: int  # 111
MC12_lbrn: int  # 112
MC12_lbvc: int  # 113
MC12_lbvs: int  # 114
MC12_ldaa: int  # 115
MC12_ldab: int  # 116
MC12_ldd: int  # 117
MC12_lds: int  # 118
MC12_ldx: int  # 119
MC12_ldy: int  # 120
MC12_leas: int  # 121
MC12_leax: int  # 122
MC12_leay: int  # 123
MC12_lsl: int  # 124
MC12_lsla: int  # 125
MC12_lslb: int  # 126
MC12_lsld: int  # 127
MC12_lsr: int  # 128
MC12_lsra: int  # 129
MC12_lsrb: int  # 130
MC12_lsrd: int  # 131
MC12_maxa: int  # 132
MC12_maxm: int  # 133
MC12_mem: int  # 134
MC12_mina: int  # 135
MC12_minm: int  # 136
MC12_movb: int  # 137
MC12_movw: int  # 138
MC12_mul: int  # 139
MC12_neg: int  # 140
MC12_nega: int  # 141
MC12_negb: int  # 142
MC12_nop: int  # 143
MC12_null: int  # 0
MC12_oraa: int  # 144
MC12_orab: int  # 145
MC12_orcc: int  # 146
MC12_psha: int  # 147
MC12_pshb: int  # 148
MC12_pshc: int  # 149
MC12_pshd: int  # 150
MC12_pshx: int  # 151
MC12_pshy: int  # 152
MC12_pula: int  # 153
MC12_pulb: int  # 154
MC12_pulc: int  # 155
MC12_puld: int  # 156
MC12_pulx: int  # 157
MC12_puly: int  # 158
MC12_rev: int  # 159
MC12_revw: int  # 160
MC12_rol: int  # 161
MC12_rola: int  # 162
MC12_rolb: int  # 163
MC12_ror: int  # 164
MC12_rora: int  # 165
MC12_rorb: int  # 166
MC12_rtc: int  # 167
MC12_rti: int  # 168
MC12_rts: int  # 169
MC12_sba: int  # 170
MC12_sbca: int  # 171
MC12_sbcb: int  # 172
MC12_sec: int  # 173
MC12_sei: int  # 174
MC12_sev: int  # 175
MC12_sex: int  # 176
MC12_skip1: int  # 209
MC12_skip2: int  # 210
MC12_staa: int  # 177
MC12_stab: int  # 178
MC12_std: int  # 179
MC12_stop: int  # 180
MC12_sts: int  # 181
MC12_stx: int  # 182
MC12_sty: int  # 183
MC12_suba: int  # 184
MC12_subb: int  # 185
MC12_subd: int  # 186
MC12_swi: int  # 187
MC12_tab: int  # 188
MC12_tap: int  # 189
MC12_tba: int  # 190
MC12_tbeq: int  # 191
MC12_tbl: int  # 192
MC12_tbne: int  # 193
MC12_tfr: int  # 194
MC12_tpa: int  # 195
MC12_trap: int  # 196
MC12_tst: int  # 197
MC12_tsta: int  # 198
MC12_tstb: int  # 199
MC12_tsx: int  # 200
MC12_tsy: int  # 201
MC12_txs: int  # 202
MC12_tys: int  # 203
MC12_wai: int  # 204
MC12_wav: int  # 205
MC12_wavr: int  # 206
MC12_xgdx: int  # 207
MC12_xgdy: int  # 208
MC6816_aba: int  # 19
MC6816_abx: int  # 177
MC6816_aby: int  # 178
MC6816_abz: int  # 179
MC6816_ace: int  # 242
MC6816_aced: int  # 243
MC6816_adca: int  # 20
MC6816_adcb: int  # 21
MC6816_adcd: int  # 22
MC6816_adce: int  # 23
MC6816_adda: int  # 24
MC6816_addb: int  # 25
MC6816_addd: int  # 26
MC6816_adde: int  # 27
MC6816_ade: int  # 28
MC6816_adx: int  # 180
MC6816_ady: int  # 181
MC6816_adz: int  # 182
MC6816_aex: int  # 183
MC6816_aey: int  # 184
MC6816_aez: int  # 185
MC6816_ais: int  # 226
MC6816_aix: int  # 186
MC6816_aiy: int  # 187
MC6816_aiz: int  # 188
MC6816_anda: int  # 86
MC6816_andb: int  # 87
MC6816_andd: int  # 88
MC6816_ande: int  # 89
MC6816_andp: int  # 236
MC6816_asl: int  # 110
MC6816_asla: int  # 111
MC6816_aslb: int  # 112
MC6816_asld: int  # 113
MC6816_asle: int  # 114
MC6816_aslm: int  # 244
MC6816_aslw: int  # 115
MC6816_asr: int  # 116
MC6816_asra: int  # 117
MC6816_asrb: int  # 118
MC6816_asrd: int  # 119
MC6816_asre: int  # 120
MC6816_asrm: int  # 245
MC6816_asrw: int  # 121
MC6816_bcc: int  # 136
MC6816_bclr: int  # 100
MC6816_bclrw: int  # 101
MC6816_bcs: int  # 137
MC6816_beq: int  # 138
MC6816_bge: int  # 146
MC6816_bgnd: int  # 260
MC6816_bgt: int  # 147
MC6816_bhi: int  # 144
MC6816_bita: int  # 98
MC6816_bitb: int  # 99
MC6816_ble: int  # 148
MC6816_bls: int  # 145
MC6816_blt: int  # 149
MC6816_bmi: int  # 139
MC6816_bne: int  # 140
MC6816_bpl: int  # 141
MC6816_bra: int  # 134
MC6816_brclr: int  # 168
MC6816_brn: int  # 135
MC6816_brset: int  # 169
MC6816_bset: int  # 102
MC6816_bsetw: int  # 103
MC6816_bsr: int  # 171
MC6816_bvc: int  # 142
MC6816_bvs: int  # 143
MC6816_cba: int  # 41
MC6816_clr: int  # 68
MC6816_clra: int  # 69
MC6816_clrb: int  # 70
MC6816_clrd: int  # 71
MC6816_clre: int  # 72
MC6816_clrm: int  # 246
MC6816_clrw: int  # 73
MC6816_cmpa: int  # 42
MC6816_cmpb: int  # 43
MC6816_com: int  # 74
MC6816_coma: int  # 75
MC6816_comb: int  # 76
MC6816_comd: int  # 77
MC6816_come: int  # 78
MC6816_comw: int  # 79
MC6816_cpd: int  # 44
MC6816_cpe: int  # 45
MC6816_cps: int  # 227
MC6816_cpx: int  # 189
MC6816_cpy: int  # 190
MC6816_cpz: int  # 191
MC6816_daa: int  # 39
MC6816_dec: int  # 60
MC6816_deca: int  # 61
MC6816_decb: int  # 62
MC6816_decw: int  # 63
MC6816_ediv: int  # 52
MC6816_edivs: int  # 53
MC6816_emul: int  # 54
MC6816_emuls: int  # 55
MC6816_eora: int  # 90
MC6816_eorb: int  # 91
MC6816_eord: int  # 92
MC6816_eore: int  # 93
MC6816_fdiv: int  # 56
MC6816_fmuls: int  # 57
MC6816_idiv: int  # 58
MC6816_inc: int  # 64
MC6816_inca: int  # 65
MC6816_incb: int  # 66
MC6816_incw: int  # 67
MC6816_jmp: int  # 170
MC6816_jsr: int  # 172
MC6816_last: int  # 262
MC6816_lbcc: int  # 152
MC6816_lbcs: int  # 153
MC6816_lbeq: int  # 154
MC6816_lbev: int  # 155
MC6816_lbge: int  # 164
MC6816_lbgt: int  # 165
MC6816_lbhi: int  # 162
MC6816_lble: int  # 166
MC6816_lbls: int  # 163
MC6816_lblt: int  # 167
MC6816_lbmi: int  # 156
MC6816_lbmv: int  # 157
MC6816_lbne: int  # 158
MC6816_lbpl: int  # 159
MC6816_lbra: int  # 150
MC6816_lbrn: int  # 151
MC6816_lbsr: int  # 173
MC6816_lbvc: int  # 160
MC6816_lbvs: int  # 161
MC6816_ldaa: int  # 1
MC6816_ldab: int  # 2
MC6816_ldd: int  # 3
MC6816_lde: int  # 4
MC6816_lded: int  # 5
MC6816_ldhi: int  # 247
MC6816_lds: int  # 228
MC6816_ldx: int  # 192
MC6816_ldy: int  # 193
MC6816_ldz: int  # 194
MC6816_lpstop: int  # 258
MC6816_lsr: int  # 104
MC6816_lsra: int  # 105
MC6816_lsrb: int  # 106
MC6816_lsrd: int  # 107
MC6816_lsre: int  # 108
MC6816_lsrw: int  # 109
MC6816_mac: int  # 248
MC6816_movb: int  # 6
MC6816_movw: int  # 7
MC6816_mul: int  # 59
MC6816_neg: int  # 80
MC6816_nega: int  # 81
MC6816_negb: int  # 82
MC6816_negd: int  # 83
MC6816_nege: int  # 84
MC6816_negw: int  # 85
MC6816_nop: int  # 261
MC6816_null: int  # 0
MC6816_oraa: int  # 94
MC6816_orab: int  # 95
MC6816_ord: int  # 96
MC6816_ore: int  # 97
MC6816_orp: int  # 237
MC6816_psha: int  # 230
MC6816_pshb: int  # 231
MC6816_pshm: int  # 232
MC6816_pshmac: int  # 249
MC6816_pula: int  # 233
MC6816_pulb: int  # 234
MC6816_pulm: int  # 235
MC6816_pulmac: int  # 250
MC6816_rmac: int  # 251
MC6816_rol: int  # 122
MC6816_rola: int  # 123
MC6816_rolb: int  # 124
MC6816_rold: int  # 125
MC6816_role: int  # 126
MC6816_rolw: int  # 127
MC6816_ror: int  # 128
MC6816_rora: int  # 129
MC6816_rorb: int  # 130
MC6816_rord: int  # 131
MC6816_rore: int  # 132
MC6816_rorw: int  # 133
MC6816_rti: int  # 175
MC6816_rts: int  # 174
MC6816_sba: int  # 29
MC6816_sbca: int  # 30
MC6816_sbcb: int  # 31
MC6816_sbcd: int  # 32
MC6816_sbce: int  # 33
MC6816_sde: int  # 34
MC6816_staa: int  # 8
MC6816_stab: int  # 9
MC6816_std: int  # 10
MC6816_ste: int  # 11
MC6816_sted: int  # 12
MC6816_sts: int  # 229
MC6816_stx: int  # 195
MC6816_sty: int  # 196
MC6816_stz: int  # 197
MC6816_suba: int  # 35
MC6816_subb: int  # 36
MC6816_subd: int  # 37
MC6816_sube: int  # 38
MC6816_swi: int  # 176
MC6816_sxt: int  # 40
MC6816_tab: int  # 13
MC6816_tap: int  # 238
MC6816_tba: int  # 14
MC6816_tbek: int  # 216
MC6816_tbsk: int  # 217
MC6816_tbxk: int  # 218
MC6816_tbyk: int  # 219
MC6816_tbzk: int  # 220
MC6816_tde: int  # 15
MC6816_tdmsk: int  # 252
MC6816_tdp: int  # 239
MC6816_ted: int  # 16
MC6816_tedm: int  # 253
MC6816_tekb: int  # 221
MC6816_tem: int  # 254
MC6816_tmer: int  # 255
MC6816_tmet: int  # 256
MC6816_tmxed: int  # 257
MC6816_tpa: int  # 240
MC6816_tpd: int  # 241
MC6816_tskb: int  # 222
MC6816_tst: int  # 46
MC6816_tsta: int  # 47
MC6816_tstb: int  # 48
MC6816_tstd: int  # 49
MC6816_tste: int  # 50
MC6816_tstw: int  # 51
MC6816_tsx: int  # 198
MC6816_tsy: int  # 199
MC6816_tsz: int  # 200
MC6816_txkb: int  # 223
MC6816_txs: int  # 201
MC6816_txy: int  # 202
MC6816_txz: int  # 203
MC6816_tykb: int  # 224
MC6816_tys: int  # 204
MC6816_tyx: int  # 205
MC6816_tyz: int  # 206
MC6816_tzkb: int  # 225
MC6816_tzs: int  # 207
MC6816_tzx: int  # 208
MC6816_tzy: int  # 209
MC6816_wai: int  # 259
MC6816_xgab: int  # 17
MC6816_xgde: int  # 18
MC6816_xgdx: int  # 210
MC6816_xgdy: int  # 211
MC6816_xgdz: int  # 212
MC6816_xgex: int  # 213
MC6816_xgey: int  # 214
MC6816_xgez: int  # 215
MERGE_KIND_AFLAGS_EA: int  # 31
MERGE_KIND_AUTOQ: int  # 1
MERGE_KIND_BOOKMARKS: int  # 45
MERGE_KIND_BPTS: int  # 43
MERGE_KIND_BYTEVAL: int  # 23
MERGE_KIND_CREFS: int  # 41
MERGE_KIND_CUSTCNV: int  # 8
MERGE_KIND_CUSTDATA: int  # 7
MERGE_KIND_DBG_MEMREGS: int  # 56
MERGE_KIND_DEBUGGER: int  # 55
MERGE_KIND_DEKSTOPS: int  # 52
MERGE_KIND_DIRTREE: int  # 47
MERGE_KIND_DREFS: int  # 42
MERGE_KIND_ENCODINGS: int  # 3
MERGE_KIND_ENCODINGS2: int  # 4
MERGE_KIND_END: int  # -2
MERGE_KIND_ENUMS: int  # 9
MERGE_KIND_EXPORTS: int  # 26
MERGE_KIND_EXTRACMT: int  # 30
MERGE_KIND_FILEREGIONS: int  # 33
MERGE_KIND_FIXUPS: int  # 24
MERGE_KIND_FLAGS: int  # 29
MERGE_KIND_FLOWS: int  # 40
MERGE_KIND_FRAME: int  # 38
MERGE_KIND_FRAMEMGR: int  # 37
MERGE_KIND_FUNC: int  # 36
MERGE_KIND_GHSTRCMT: int  # 15
MERGE_KIND_HIDDENRANGES: int  # 34
MERGE_KIND_IGNOREMICRO: int  # 32
MERGE_KIND_IMPORTS: int  # 27
MERGE_KIND_INF: int  # 2
MERGE_KIND_LAST: int  # 58
MERGE_KIND_LOADER: int  # 54
MERGE_KIND_LUMINA: int  # 57
MERGE_KIND_MAPPING: int  # 25
MERGE_KIND_NETNODE: int  # 0
MERGE_KIND_NONE: int  # -1
MERGE_KIND_NOTEPAD: int  # 53
MERGE_KIND_ORPHANS: int  # 22
MERGE_KIND_PATCHES: int  # 28
MERGE_KIND_PROBLEMS: int  # 50
MERGE_KIND_SCRIPTS: int  # 6
MERGE_KIND_SCRIPTS2: int  # 5
MERGE_KIND_SEGGRPS: int  # 20
MERGE_KIND_SEGMENTS: int  # 19
MERGE_KIND_SEGREGS: int  # 21
MERGE_KIND_SELECTORS: int  # 17
MERGE_KIND_SIGNATURES: int  # 49
MERGE_KIND_SOURCEFILES: int  # 35
MERGE_KIND_STKPNTS: int  # 39
MERGE_KIND_STRMEM: int  # 13
MERGE_KIND_STRMEMCMT: int  # 16
MERGE_KIND_STRUCTS: int  # 10
MERGE_KIND_STT: int  # 18
MERGE_KIND_TILS: int  # 11
MERGE_KIND_TINFO: int  # 12
MERGE_KIND_TRYBLKS: int  # 46
MERGE_KIND_UDTMEM: int  # 14
MERGE_KIND_UI: int  # 51
MERGE_KIND_VFTABLES: int  # 48
MERGE_KIND_WATCHPOINTS: int  # 44
MERR_BADARCH: int  # -31
MERR_BADBLK: int  # -4
MERR_BADCALL: int  # -12
MERR_BADFRAME: int  # -13
MERR_BADIDB: int  # -15
MERR_BADRANGES: int  # -30
MERR_BADSP: int  # -5
MERR_BITNESS: int  # -11
MERR_BLOCK: int  # 1
MERR_BUSY: int  # -26
MERR_CANCELED: int  # -18
MERR_CLOUD: int  # -34
MERR_COMPLEX: int  # -22
MERR_DSLOT: int  # -32
MERR_EMULATOR: int  # -35
MERR_EXCEPTION: int  # -8
MERR_EXTERN: int  # -28
MERR_FARPTR: int  # -27
MERR_FUNCSIZE: int  # -29
MERR_HUGESTACK: int  # -9
MERR_INSN: int  # -2
MERR_INTERR: int  # -1
MERR_LICENSE: int  # -23
MERR_LOOP: int  # -36
MERR_LVARS: int  # -10
MERR_MAX_ERR: int  # 35
MERR_MEM: int  # -3
MERR_OK: int  # 0
MERR_ONLY32: int  # -24
MERR_ONLY64: int  # -25
MERR_OVERLAP: int  # -20
MERR_PARTINIT: int  # -21
MERR_PROLOG: int  # -6
MERR_RECDEPTH: int  # -19
MERR_REDO: int  # -17
MERR_SIZEOF: int  # -16
MERR_STOP: int  # -33
MERR_SWITCH: int  # -7
MERR_UNKTYPE: int  # -14
ME_ERRAUTO: int  # -7
ME_FRAME: int  # -5
ME_ILLSTR: int  # -3
ME_INTERR: int  # -1
ME_NOCOMP: int  # -6
ME_NOERROR_LIMIT: int  # -10
ME_NOHASHMEM: int  # -8
ME_NOSTRMEM: int  # -9
ME_PARAMERR: int  # -2
ME_SMALLANS: int  # -4
MFF_FAST: int  # 0
MFF_NOWAIT: int  # 4
MFF_READ: int  # 1
MFF_WRITE: int  # 2
MH_LISTEN: int  # 1
MH_TERSE: int  # 2
MH_UI_CHAR_MASK: int  # 8323072
MH_UI_COLONNAME: int  # 12189696
MH_UI_COMMANAME: int  # 11272192
MH_UI_COMPLEX: int  # 512
MH_UI_DP_NOLINEDIFF: int  # 1024
MH_UI_DP_SHORTNAME: int  # 2048
MH_UI_INDENT: int  # 4096
MH_UI_NODETAILS: int  # 256
MH_UI_SPLITNAME: int  # 8388608
MIN_VLR_SVALUE: int  # -9223372036854775808
MIPS_R5900_first: int  # 314
MIPS_R5900_last: int  # 429
MIPS_absq_s_ph: int  # 929
MIPS_absq_s_pw: int  # 947
MIPS_absq_s_qb: int  # 928
MIPS_absq_s_qh: int  # 946
MIPS_absq_s_w: int  # 930
MIPS_ac0iu: int  # 734
MIPS_add: int  # 1
MIPS_addi: int  # 30
MIPS_addiu: int  # 31
MIPS_addiupc: int  # 1740
MIPS_addmiu: int  # 737
MIPS_addq_ph: int  # 849
MIPS_addq_pw: int  # 870
MIPS_addq_qh: int  # 869
MIPS_addq_s_ph: int  # 860
MIPS_addq_s_pw: int  # 880
MIPS_addq_s_qh: int  # 879
MIPS_addq_s_w: int  # 861
MIPS_addqh_ph: int  # 1099
MIPS_addqh_r_ph: int  # 1105
MIPS_addqh_r_w: int  # 1106
MIPS_addqh_w: int  # 1100
MIPS_addsc: int  # 845
MIPS_addu: int  # 2
MIPS_addu_ob: int  # 867
MIPS_addu_ph: int  # 844
MIPS_addu_qb: int  # 843
MIPS_addu_s_ob: int  # 873
MIPS_addu_s_ph: int  # 853
MIPS_addu_s_qb: int  # 852
MIPS_adduh_qb: int  # 1098
MIPS_adduh_r_qb: int  # 1104
MIPS_addwc: int  # 848
MIPS_alnv_ps: int  # 507
MIPS_aluipc: int  # 1742
MIPS_and: int  # 3
MIPS_andi: int  # 36
MIPS_append: int  # 1114
MIPS_b: int  # 202
MIPS_baddu: int  # 573
MIPS_bal: int  # 203
MIPS_balc: int  # 1737
MIPS_balign: int  # 1115
MIPS_balrsc: int  # 1758
MIPS_bbeqzc: int  # 1744
MIPS_bbit0: int  # 574
MIPS_bbit032: int  # 575
MIPS_bbit1: int  # 576
MIPS_bbit132: int  # 577
MIPS_bbnezc: int  # 1748
MIPS_bc: int  # 1736
MIPS_bc0f: int  # 82
MIPS_bc0fl: int  # 86
MIPS_bc0t: int  # 90
MIPS_bc0tl: int  # 94
MIPS_bc1any2f: int  # 788
MIPS_bc1any2t: int  # 789
MIPS_bc1any4f: int  # 790
MIPS_bc1any4t: int  # 791
MIPS_bc1f: int  # 83
MIPS_bc1fl: int  # 87
MIPS_bc1t: int  # 91
MIPS_bc1tl: int  # 95
MIPS_bc2f: int  # 84
MIPS_bc2fl: int  # 88
MIPS_bc2t: int  # 92
MIPS_bc2tl: int  # 96
MIPS_bc3f: int  # 85
MIPS_bc3fl: int  # 89
MIPS_bc3t: int  # 93
MIPS_bc3tl: int  # 97
MIPS_bclr: int  # 741
MIPS_beq: int  # 110
MIPS_beqc: int  # 1754
MIPS_beqic: int  # 1743
MIPS_beql: int  # 111
MIPS_beqz: int  # 200
MIPS_beqzc: int  # 832
MIPS_beqzl: int  # 201
MIPS_bext: int  # 744
MIPS_bfins: int  # 736
MIPS_bgec: int  # 1755
MIPS_bgeic: int  # 1745
MIPS_bgeiuc: int  # 1746
MIPS_bgeuc: int  # 1756
MIPS_bgez: int  # 98
MIPS_bgezal: int  # 99
MIPS_bgezall: int  # 100
MIPS_bgezals: int  # 833
MIPS_bgezl: int  # 101
MIPS_bgtz: int  # 102
MIPS_bgtzl: int  # 103
MIPS_bins: int  # 743
MIPS_bitrev: int  # 935
MIPS_bitrevb: int  # 1761
MIPS_bitrevh: int  # 1760
MIPS_bitrevw: int  # 1759
MIPS_blez: int  # 104
MIPS_blezl: int  # 105
MIPS_bltc: int  # 1752
MIPS_bltic: int  # 1749
MIPS_bltiuc: int  # 1750
MIPS_bltuc: int  # 1753
MIPS_bltz: int  # 106
MIPS_bltzal: int  # 107
MIPS_bltzall: int  # 108
MIPS_bltzals: int  # 831
MIPS_bltzl: int  # 109
MIPS_bne: int  # 112
MIPS_bnec: int  # 1751
MIPS_bneic: int  # 1747
MIPS_bnel: int  # 113
MIPS_bnez: int  # 198
MIPS_bnezc: int  # 830
MIPS_bnezl: int  # 199
MIPS_bposge32: int  # 841
MIPS_bposge64: int  # 842
MIPS_break: int  # 80
MIPS_brsc: int  # 1757
MIPS_bs1f: int  # 735
MIPS_bset: int  # 742
MIPS_bteqz: int  # 439
MIPS_btnez: int  # 440
MIPS_btst: int  # 740
MIPS_byterevh: int  # 1763
MIPS_byterevw: int  # 1762
MIPS_cache: int  # 119
MIPS_cachee: int  # 1684
MIPS_cfc0: int  # 312
MIPS_cfc1: int  # 45
MIPS_cfc2: int  # 46
MIPS_cftc1: int  # 768
MIPS_cftc2: int  # 771
MIPS_cins: int  # 578
MIPS_cins32: int  # 579
MIPS_clo: int  # 498
MIPS_clz: int  # 499
MIPS_cmp: int  # 441
MIPS_cmp_eq_ph: int  # 886
MIPS_cmp_eq_pw: int  # 909
MIPS_cmp_eq_qh: int  # 908
MIPS_cmp_le_ph: int  # 892
MIPS_cmp_le_pw: int  # 915
MIPS_cmp_le_qh: int  # 914
MIPS_cmp_lt_ph: int  # 889
MIPS_cmp_lt_pw: int  # 912
MIPS_cmp_lt_qh: int  # 911
MIPS_cmpgdu_eq_qb: int  # 887
MIPS_cmpgdu_le_qb: int  # 893
MIPS_cmpgdu_lt_qb: int  # 890
MIPS_cmpgu_eq_ob: int  # 919
MIPS_cmpgu_eq_qb: int  # 896
MIPS_cmpgu_le_ob: int  # 925
MIPS_cmpgu_le_qb: int  # 902
MIPS_cmpgu_lt_ob: int  # 923
MIPS_cmpgu_lt_qb: int  # 899
MIPS_cmpi: int  # 442
MIPS_cmpu_eq_ob: int  # 907
MIPS_cmpu_eq_qb: int  # 885
MIPS_cmpu_le_ob: int  # 913
MIPS_cmpu_le_qb: int  # 891
MIPS_cmpu_lt_ob: int  # 910
MIPS_cmpu_lt_qb: int  # 888
MIPS_cop0: int  # 77
MIPS_cop1: int  # 78
MIPS_cop2: int  # 79
MIPS_copyw: int  # 1692
MIPS_crc32b: int  # 1700
MIPS_crc32cb: int  # 1703
MIPS_crc32ch: int  # 1704
MIPS_crc32cw: int  # 1705
MIPS_crc32h: int  # 1701
MIPS_crc32w: int  # 1702
MIPS_ctc0: int  # 313
MIPS_ctc1: int  # 47
MIPS_ctc2: int  # 48
MIPS_cttc1: int  # 782
MIPS_cttc2: int  # 785
MIPS_dadd: int  # 4
MIPS_daddi: int  # 32
MIPS_daddiu: int  # 33
MIPS_daddu: int  # 5
MIPS_dbreak: int  # 608
MIPS_dclo: int  # 558
MIPS_dclz: int  # 559
MIPS_ddiv: int  # 65
MIPS_ddivu: int  # 66
MIPS_deret: int  # 508
MIPS_dext: int  # 560
MIPS_dextm: int  # 561
MIPS_dextp: int  # 1081
MIPS_dextpdp: int  # 1082
MIPS_dextpdpv: int  # 1085
MIPS_dextpv: int  # 1084
MIPS_dextr_l: int  # 1078
MIPS_dextr_r_l: int  # 1088
MIPS_dextr_r_w: int  # 1087
MIPS_dextr_rs_l: int  # 1093
MIPS_dextr_rs_w: int  # 1091
MIPS_dextr_s_h: int  # 1092
MIPS_dextr_w: int  # 1077
MIPS_dextrv_l: int  # 1080
MIPS_dextrv_r_l: int  # 1090
MIPS_dextrv_r_w: int  # 1089
MIPS_dextrv_rs_l: int  # 1096
MIPS_dextrv_rs_w: int  # 1094
MIPS_dextrv_s_h: int  # 1095
MIPS_dextrv_w: int  # 1079
MIPS_dextu: int  # 562
MIPS_di: int  # 509
MIPS_dins: int  # 563
MIPS_dinsm: int  # 564
MIPS_dinsu: int  # 565
MIPS_dinsv: int  # 840
MIPS_div: int  # 67
MIPS_div1: int  # 333
MIPS_dive: int  # 745
MIPS_diveu: int  # 746
MIPS_divu: int  # 68
MIPS_divu1: int  # 334
MIPS_dla: int  # 495
MIPS_dli: int  # 838
MIPS_dlsa: int  # 1673
MIPS_dmadd: int  # 1038
MIPS_dmaddu: int  # 1051
MIPS_dmfc0: int  # 49
MIPS_dmfc1: int  # 542
MIPS_dmfc2: int  # 566
MIPS_dmsub: int  # 1039
MIPS_dmsubu: int  # 1059
MIPS_dmt: int  # 755
MIPS_dmtc0: int  # 51
MIPS_dmtc1: int  # 543
MIPS_dmtc2: int  # 567
MIPS_dmthlip: int  # 1097
MIPS_dmul: int  # 580
MIPS_dmult: int  # 69
MIPS_dmultu: int  # 70
MIPS_dneg: int  # 555
MIPS_dnegu: int  # 556
MIPS_dpa_w_ph: int  # 1014
MIPS_dpaq_s_w_ph: int  # 1027
MIPS_dpaq_s_w_qh: int  # 1044
MIPS_dpaq_sa_l_pw: int  # 1045
MIPS_dpaq_sa_l_w: int  # 1028
MIPS_dpaqx_s_w_ph: int  # 1017
MIPS_dpaqx_sa_w_ph: int  # 1023
MIPS_dpau_h_obl: int  # 1041
MIPS_dpau_h_obr: int  # 1056
MIPS_dpau_h_qbl: int  # 1024
MIPS_dpau_h_qbr: int  # 1034
MIPS_dpax_w_ph: int  # 1015
MIPS_dpop: int  # 581
MIPS_dps_w_ph: int  # 1018
MIPS_dpsq_s_w_ph: int  # 1030
MIPS_dpsq_s_w_qh: int  # 1048
MIPS_dpsq_sa_l_pw: int  # 1049
MIPS_dpsq_sa_l_w: int  # 1031
MIPS_dpsqx_s_w_ph: int  # 1020
MIPS_dpsqx_sa_w_ph: int  # 1026
MIPS_dpsu_h_obl: int  # 1042
MIPS_dpsu_h_obr: int  # 1057
MIPS_dpsu_h_qbl: int  # 1025
MIPS_dpsu_h_qbr: int  # 1035
MIPS_dpsx_w_ph: int  # 1019
MIPS_dret: int  # 609
MIPS_drotr: int  # 568
MIPS_drotr32: int  # 569
MIPS_drotrv: int  # 570
MIPS_dsbh: int  # 571
MIPS_dshd: int  # 572
MIPS_dshilo: int  # 1083
MIPS_dshilov: int  # 1086
MIPS_dsll: int  # 15
MIPS_dsll32: int  # 16
MIPS_dsllv: int  # 24
MIPS_dsra: int  # 17
MIPS_dsra32: int  # 18
MIPS_dsrav: int  # 25
MIPS_dsrl: int  # 19
MIPS_dsrl32: int  # 20
MIPS_dsrlv: int  # 26
MIPS_dsub: int  # 6
MIPS_dsubu: int  # 7
MIPS_dvp: int  # 1733
MIPS_dvpe: int  # 753
MIPS_ehb: int  # 510
MIPS_ei: int  # 511
MIPS_emt: int  # 756
MIPS_eret: int  # 153
MIPS_eretnc: int  # 1720
MIPS_evp: int  # 1734
MIPS_evpe: int  # 754
MIPS_ext: int  # 512
MIPS_extend: int  # 458
MIPS_extp: int  # 1062
MIPS_extpdp: int  # 1063
MIPS_extpdpv: int  # 1067
MIPS_extpv: int  # 1066
MIPS_extr_r_w: int  # 1070
MIPS_extr_rs_w: int  # 1072
MIPS_extr_s_h: int  # 1073
MIPS_extr_w: int  # 1060
MIPS_extrv_r_w: int  # 1071
MIPS_extrv_rs_w: int  # 1074
MIPS_extrv_s_h: int  # 1075
MIPS_extrv_w: int  # 1061
MIPS_exts: int  # 582
MIPS_exts32: int  # 583
MIPS_extw: int  # 1715
MIPS_fabs: int  # 162
MIPS_fadd: int  # 158
MIPS_fadda: int  # 318
MIPS_faddr: int  # 787
MIPS_fc_eq: int  # 180
MIPS_fc_f: int  # 178
MIPS_fc_le: int  # 192
MIPS_fc_lt: int  # 190
MIPS_fc_nge: int  # 191
MIPS_fc_ngl: int  # 189
MIPS_fc_ngle: int  # 187
MIPS_fc_ngt: int  # 193
MIPS_fc_ole: int  # 184
MIPS_fc_olt: int  # 182
MIPS_fc_seq: int  # 188
MIPS_fc_sf: int  # 186
MIPS_fc_ueq: int  # 181
MIPS_fc_ule: int  # 185
MIPS_fc_ult: int  # 183
MIPS_fc_un: int  # 179
MIPS_fcabs_eq: int  # 794
MIPS_fcabs_f: int  # 792
MIPS_fcabs_le: int  # 806
MIPS_fcabs_lt: int  # 804
MIPS_fcabs_nge: int  # 805
MIPS_fcabs_ngl: int  # 803
MIPS_fcabs_ngle: int  # 801
MIPS_fcabs_ngt: int  # 807
MIPS_fcabs_ole: int  # 798
MIPS_fcabs_olt: int  # 796
MIPS_fcabs_seq: int  # 802
MIPS_fcabs_sf: int  # 800
MIPS_fcabs_ueq: int  # 795
MIPS_fcabs_ule: int  # 799
MIPS_fcabs_ult: int  # 797
MIPS_fcabs_un: int  # 793
MIPS_fceil_l: int  # 169
MIPS_fceil_w: int  # 173
MIPS_fcvt_d: int  # 164
MIPS_fcvt_l: int  # 166
MIPS_fcvt_ps: int  # 513
MIPS_fcvt_ps_pw: int  # 809
MIPS_fcvt_pw_ps: int  # 808
MIPS_fcvt_s: int  # 163
MIPS_fcvt_s_pl: int  # 514
MIPS_fcvt_s_pu: int  # 515
MIPS_fcvt_w: int  # 165
MIPS_fdiv: int  # 161
MIPS_ffloor_l: int  # 170
MIPS_ffloor_w: int  # 174
MIPS_fmadd: int  # 323
MIPS_fmadda: int  # 321
MIPS_fmax: int  # 325
MIPS_fmin: int  # 326
MIPS_fmov: int  # 175
MIPS_fmovf: int  # 219
MIPS_fmovn: int  # 221
MIPS_fmovt: int  # 220
MIPS_fmovz: int  # 222
MIPS_fmsub: int  # 324
MIPS_fmsuba: int  # 322
MIPS_fmul: int  # 160
MIPS_fmula: int  # 320
MIPS_fmulr: int  # 810
MIPS_fneg: int  # 176
MIPS_fork: int  # 757
MIPS_frecip: int  # 228
MIPS_frecip1: int  # 811
MIPS_frecip2: int  # 812
MIPS_fround_l: int  # 167
MIPS_fround_w: int  # 171
MIPS_frsqrt: int  # 229
MIPS_frsqrt1: int  # 813
MIPS_frsqrt2: int  # 814
MIPS_fsqrt: int  # 177
MIPS_fsub: int  # 159
MIPS_fsuba: int  # 319
MIPS_ftrunc_l: int  # 168
MIPS_ftrunc_w: int  # 172
MIPS_ginvi: int  # 1719
MIPS_ginvt: int  # 1718
MIPS_ins: int  # 516
MIPS_insv: int  # 839
MIPS_j: int  # 115
MIPS_jal: int  # 117
MIPS_jalr: int  # 114
MIPS_jalr_hb: int  # 517
MIPS_jalrc: int  # 546
MIPS_jalrc_hb: int  # 1741
MIPS_jalrs: int  # 835
MIPS_jalrs_hb: int  # 836
MIPS_jals: int  # 821
MIPS_jalx: int  # 118
MIPS_jr: int  # 116
MIPS_jr_hb: int  # 518
MIPS_jraddiusp: int  # 834
MIPS_jrc: int  # 547
MIPS_la: int  # 205
MIPS_laa: int  # 1117
MIPS_laad: int  # 1118
MIPS_lac: int  # 1119
MIPS_lacd: int  # 1120
MIPS_lad: int  # 1121
MIPS_ladd: int  # 1122
MIPS_lai: int  # 1123
MIPS_laid: int  # 1124
MIPS_las: int  # 1125
MIPS_lasd: int  # 1126
MIPS_last: int  # 1766
MIPS_law: int  # 1127
MIPS_lawd: int  # 1128
MIPS_lb: int  # 120
MIPS_lbe: int  # 1674
MIPS_lbu: int  # 121
MIPS_lbue: int  # 1675
MIPS_lbux: int  # 1013
MIPS_lbv: int  # 230
MIPS_lbx: int  # 1129
MIPS_ld: int  # 126
MIPS_ldc1: int  # 128
MIPS_ldc2: int  # 129
MIPS_ldl: int  # 122
MIPS_ldm: int  # 825
MIPS_ldp: int  # 823
MIPS_ldr: int  # 123
MIPS_ldv: int  # 233
MIPS_ldx: int  # 1011
MIPS_ldxc1: int  # 207
MIPS_lfv: int  # 239
MIPS_lh: int  # 133
MIPS_lhe: int  # 1676
MIPS_lhu: int  # 134
MIPS_lhue: int  # 1677
MIPS_lhux: int  # 1130
MIPS_lhuxs: int  # 1712
MIPS_lhv: int  # 238
MIPS_lhx: int  # 1012
MIPS_lhxs: int  # 1711
MIPS_li: int  # 204
MIPS_li_d: int  # 554
MIPS_li_s: int  # 553
MIPS_ll: int  # 130
MIPS_lld: int  # 127
MIPS_lle: int  # 1682
MIPS_llv: int  # 232
MIPS_llwp: int  # 1724
MIPS_llwpe: int  # 1725
MIPS_lpv: int  # 236
MIPS_lq: int  # 424
MIPS_lqc2: int  # 426
MIPS_lqv: int  # 234
MIPS_lrv: int  # 235
MIPS_lsa: int  # 1672
MIPS_lsv: int  # 231
MIPS_ltv: int  # 241
MIPS_lui: int  # 135
MIPS_luv: int  # 237
MIPS_luxc1: int  # 519
MIPS_lw: int  # 131
MIPS_lwc1: int  # 136
MIPS_lwc2: int  # 137
MIPS_lwe: int  # 1678
MIPS_lwl: int  # 124
MIPS_lwle: int  # 1686
MIPS_lwm: int  # 824
MIPS_lwm2: int  # 1764
MIPS_lwp: int  # 822
MIPS_lwpc: int  # 1721
MIPS_lwr: int  # 125
MIPS_lwre: int  # 1687
MIPS_lwu: int  # 132
MIPS_lwux: int  # 1131
MIPS_lwv: int  # 240
MIPS_lwx: int  # 1010
MIPS_lwxc1: int  # 208
MIPS_lwxs: int  # 815
MIPS_madd: int  # 500
MIPS_madd1: int  # 342
MIPS_madd3: int  # 749
MIPS_madd_d: int  # 212
MIPS_madd_ps: int  # 520
MIPS_madd_r5900: int  # 428
MIPS_madd_s: int  # 211
MIPS_maddp: int  # 816
MIPS_maddu: int  # 501
MIPS_maddu1: int  # 343
MIPS_maddu3: int  # 750
MIPS_maddu_r5900: int  # 429
MIPS_maq_s_l_pwl: int  # 1047
MIPS_maq_s_l_pwr: int  # 1055
MIPS_maq_s_w_phl: int  # 1029
MIPS_maq_s_w_phr: int  # 1033
MIPS_maq_s_w_qhll: int  # 1046
MIPS_maq_s_w_qhlr: int  # 1050
MIPS_maq_s_w_qhrl: int  # 1054
MIPS_maq_s_w_qhrr: int  # 1058
MIPS_maq_sa_w_phl: int  # 1016
MIPS_maq_sa_w_phr: int  # 1022
MIPS_maq_sa_w_qhll: int  # 1036
MIPS_maq_sa_w_qhlr: int  # 1037
MIPS_maq_sa_w_qhrl: int  # 1040
MIPS_maq_sa_w_qhrr: int  # 1043
MIPS_max: int  # 748
MIPS_mfc0: int  # 53
MIPS_mfc1: int  # 54
MIPS_mfc2: int  # 55
MIPS_mfdr: int  # 610
MIPS_mfhc0: int  # 1713
MIPS_mfhc1: int  # 521
MIPS_mfhc2: int  # 522
MIPS_mfhi: int  # 75
MIPS_mfhi1: int  # 419
MIPS_mflhxu: int  # 817
MIPS_mflo: int  # 76
MIPS_mflo1: int  # 420
MIPS_mfsa: int  # 315
MIPS_mftacx: int  # 764
MIPS_mftc0: int  # 760
MIPS_mftc1: int  # 767
MIPS_mftc2: int  # 770
MIPS_mftdsp: int  # 765
MIPS_mftgpr: int  # 772
MIPS_mfthc0: int  # 761
MIPS_mfthc1: int  # 766
MIPS_mfthc2: int  # 769
MIPS_mfthi: int  # 763
MIPS_mftlo: int  # 762
MIPS_mftr: int  # 759
MIPS_min: int  # 747
MIPS_mod: int  # 1697
MIPS_modsub: int  # 850
MIPS_modu: int  # 1698
MIPS_mov: int  # 195
MIPS_move: int  # 473
MIPS_move_balc: int  # 1739
MIPS_movep: int  # 837
MIPS_movf: int  # 215
MIPS_movn: int  # 217
MIPS_movt: int  # 216
MIPS_movtn: int  # 1691
MIPS_movtz: int  # 1690
MIPS_movz: int  # 218
MIPS_msa_add_a_b: int  # 1318
MIPS_msa_add_a_d: int  # 1321
MIPS_msa_add_a_h: int  # 1319
MIPS_msa_add_a_w: int  # 1320
MIPS_msa_adds_a_b: int  # 1322
MIPS_msa_adds_a_d: int  # 1325
MIPS_msa_adds_a_h: int  # 1323
MIPS_msa_adds_a_w: int  # 1324
MIPS_msa_adds_s_b: int  # 1326
MIPS_msa_adds_s_d: int  # 1329
MIPS_msa_adds_s_h: int  # 1327
MIPS_msa_adds_s_w: int  # 1328
MIPS_msa_adds_u_b: int  # 1330
MIPS_msa_adds_u_d: int  # 1333
MIPS_msa_adds_u_h: int  # 1331
MIPS_msa_adds_u_w: int  # 1332
MIPS_msa_addv_b: int  # 1206
MIPS_msa_addv_d: int  # 1209
MIPS_msa_addv_h: int  # 1207
MIPS_msa_addv_w: int  # 1208
MIPS_msa_addvi_b: int  # 1210
MIPS_msa_addvi_d: int  # 1213
MIPS_msa_addvi_h: int  # 1211
MIPS_msa_addvi_w: int  # 1212
MIPS_msa_and_v: int  # 1492
MIPS_msa_andi_b: int  # 1493
MIPS_msa_asub_s_b: int  # 1366
MIPS_msa_asub_s_d: int  # 1369
MIPS_msa_asub_s_h: int  # 1367
MIPS_msa_asub_s_w: int  # 1368
MIPS_msa_asub_u_b: int  # 1370
MIPS_msa_asub_u_d: int  # 1373
MIPS_msa_asub_u_h: int  # 1371
MIPS_msa_asub_u_w: int  # 1372
MIPS_msa_ave_s_b: int  # 1334
MIPS_msa_ave_s_d: int  # 1337
MIPS_msa_ave_s_h: int  # 1335
MIPS_msa_ave_s_w: int  # 1336
MIPS_msa_ave_u_b: int  # 1338
MIPS_msa_ave_u_d: int  # 1341
MIPS_msa_ave_u_h: int  # 1339
MIPS_msa_ave_u_w: int  # 1340
MIPS_msa_aver_s_b: int  # 1342
MIPS_msa_aver_s_d: int  # 1345
MIPS_msa_aver_s_h: int  # 1343
MIPS_msa_aver_s_w: int  # 1344
MIPS_msa_aver_u_b: int  # 1346
MIPS_msa_aver_u_d: int  # 1349
MIPS_msa_aver_u_h: int  # 1347
MIPS_msa_aver_u_w: int  # 1348
MIPS_msa_bclr_b: int  # 1166
MIPS_msa_bclr_d: int  # 1169
MIPS_msa_bclr_h: int  # 1167
MIPS_msa_bclr_w: int  # 1168
MIPS_msa_bclri_b: int  # 1170
MIPS_msa_bclri_d: int  # 1173
MIPS_msa_bclri_h: int  # 1171
MIPS_msa_bclri_w: int  # 1172
MIPS_msa_binsl_b: int  # 1190
MIPS_msa_binsl_d: int  # 1193
MIPS_msa_binsl_h: int  # 1191
MIPS_msa_binsl_w: int  # 1192
MIPS_msa_binsli_b: int  # 1194
MIPS_msa_binsli_d: int  # 1197
MIPS_msa_binsli_h: int  # 1195
MIPS_msa_binsli_w: int  # 1196
MIPS_msa_binsr_b: int  # 1198
MIPS_msa_binsr_d: int  # 1201
MIPS_msa_binsr_h: int  # 1199
MIPS_msa_binsr_w: int  # 1200
MIPS_msa_binsri_b: int  # 1202
MIPS_msa_binsri_d: int  # 1205
MIPS_msa_binsri_h: int  # 1203
MIPS_msa_binsri_w: int  # 1204
MIPS_msa_bmnz_v: int  # 1500
MIPS_msa_bmnzi_b: int  # 1501
MIPS_msa_bmz_v: int  # 1502
MIPS_msa_bmzi_b: int  # 1503
MIPS_msa_bneg_b: int  # 1182
MIPS_msa_bneg_d: int  # 1185
MIPS_msa_bneg_h: int  # 1183
MIPS_msa_bneg_w: int  # 1184
MIPS_msa_bnegi_b: int  # 1186
MIPS_msa_bnegi_d: int  # 1189
MIPS_msa_bnegi_h: int  # 1187
MIPS_msa_bnegi_w: int  # 1188
MIPS_msa_bnz_b: int  # 1543
MIPS_msa_bnz_d: int  # 1546
MIPS_msa_bnz_h: int  # 1544
MIPS_msa_bnz_v: int  # 1509
MIPS_msa_bnz_w: int  # 1545
MIPS_msa_bsel_v: int  # 1504
MIPS_msa_bseli_b: int  # 1505
MIPS_msa_bset_b: int  # 1174
MIPS_msa_bset_d: int  # 1177
MIPS_msa_bset_h: int  # 1175
MIPS_msa_bset_w: int  # 1176
MIPS_msa_bseti_b: int  # 1178
MIPS_msa_bseti_d: int  # 1181
MIPS_msa_bseti_h: int  # 1179
MIPS_msa_bseti_w: int  # 1180
MIPS_msa_bz_b: int  # 1547
MIPS_msa_bz_d: int  # 1550
MIPS_msa_bz_h: int  # 1548
MIPS_msa_bz_v: int  # 1510
MIPS_msa_bz_w: int  # 1549
MIPS_msa_ceq_b: int  # 1262
MIPS_msa_ceq_d: int  # 1265
MIPS_msa_ceq_h: int  # 1263
MIPS_msa_ceq_w: int  # 1264
MIPS_msa_ceqi_b: int  # 1266
MIPS_msa_ceqi_d: int  # 1269
MIPS_msa_ceqi_h: int  # 1267
MIPS_msa_ceqi_w: int  # 1268
MIPS_msa_cfcmsa: int  # 1670
MIPS_msa_cle_s_b: int  # 1286
MIPS_msa_cle_s_d: int  # 1289
MIPS_msa_cle_s_h: int  # 1287
MIPS_msa_cle_s_w: int  # 1288
MIPS_msa_cle_u_b: int  # 1294
MIPS_msa_cle_u_d: int  # 1297
MIPS_msa_cle_u_h: int  # 1295
MIPS_msa_cle_u_w: int  # 1296
MIPS_msa_clei_s_b: int  # 1290
MIPS_msa_clei_s_d: int  # 1293
MIPS_msa_clei_s_h: int  # 1291
MIPS_msa_clei_s_w: int  # 1292
MIPS_msa_clei_u_b: int  # 1298
MIPS_msa_clei_u_d: int  # 1301
MIPS_msa_clei_u_h: int  # 1299
MIPS_msa_clei_u_w: int  # 1300
MIPS_msa_clt_s_b: int  # 1270
MIPS_msa_clt_s_d: int  # 1273
MIPS_msa_clt_s_h: int  # 1271
MIPS_msa_clt_s_w: int  # 1272
MIPS_msa_clt_u_b: int  # 1278
MIPS_msa_clt_u_d: int  # 1281
MIPS_msa_clt_u_h: int  # 1279
MIPS_msa_clt_u_w: int  # 1280
MIPS_msa_clti_s_b: int  # 1274
MIPS_msa_clti_s_d: int  # 1277
MIPS_msa_clti_s_h: int  # 1275
MIPS_msa_clti_s_w: int  # 1276
MIPS_msa_clti_u_b: int  # 1282
MIPS_msa_clti_u_d: int  # 1285
MIPS_msa_clti_u_h: int  # 1283
MIPS_msa_clti_u_w: int  # 1284
MIPS_msa_copy_s_b: int  # 1527
MIPS_msa_copy_s_d: int  # 1530
MIPS_msa_copy_s_h: int  # 1528
MIPS_msa_copy_s_w: int  # 1529
MIPS_msa_copy_u_b: int  # 1531
MIPS_msa_copy_u_d: int  # 1534
MIPS_msa_copy_u_h: int  # 1532
MIPS_msa_copy_u_w: int  # 1533
MIPS_msa_ctcmsa: int  # 1669
MIPS_msa_div_s_b: int  # 1386
MIPS_msa_div_s_d: int  # 1389
MIPS_msa_div_s_h: int  # 1387
MIPS_msa_div_s_w: int  # 1388
MIPS_msa_div_u_b: int  # 1390
MIPS_msa_div_u_d: int  # 1393
MIPS_msa_div_u_h: int  # 1391
MIPS_msa_div_u_w: int  # 1392
MIPS_msa_dotp_s_d: int  # 1404
MIPS_msa_dotp_s_h: int  # 1402
MIPS_msa_dotp_s_w: int  # 1403
MIPS_msa_dotp_u_d: int  # 1407
MIPS_msa_dotp_u_h: int  # 1405
MIPS_msa_dotp_u_w: int  # 1406
MIPS_msa_dpadd_s_d: int  # 1410
MIPS_msa_dpadd_s_h: int  # 1408
MIPS_msa_dpadd_s_w: int  # 1409
MIPS_msa_dpadd_u_d: int  # 1413
MIPS_msa_dpadd_u_h: int  # 1411
MIPS_msa_dpadd_u_w: int  # 1412
MIPS_msa_dpsub_s_d: int  # 1416
MIPS_msa_dpsub_s_h: int  # 1414
MIPS_msa_dpsub_s_w: int  # 1415
MIPS_msa_dpsub_u_d: int  # 1419
MIPS_msa_dpsub_u_h: int  # 1417
MIPS_msa_dpsub_u_w: int  # 1418
MIPS_msa_fadd_d: int  # 1588
MIPS_msa_fadd_w: int  # 1587
MIPS_msa_fcaf_d: int  # 1556
MIPS_msa_fcaf_w: int  # 1555
MIPS_msa_fceq_d: int  # 1560
MIPS_msa_fceq_w: int  # 1559
MIPS_msa_fclass_d: int  # 1638
MIPS_msa_fclass_w: int  # 1637
MIPS_msa_fcle_d: int  # 1568
MIPS_msa_fcle_w: int  # 1567
MIPS_msa_fclt_d: int  # 1564
MIPS_msa_fclt_w: int  # 1563
MIPS_msa_fcne_d: int  # 1618
MIPS_msa_fcne_w: int  # 1617
MIPS_msa_fcor_d: int  # 1614
MIPS_msa_fcor_w: int  # 1613
MIPS_msa_fcueq_d: int  # 1562
MIPS_msa_fcueq_w: int  # 1561
MIPS_msa_fcule_d: int  # 1570
MIPS_msa_fcule_w: int  # 1569
MIPS_msa_fcult_d: int  # 1566
MIPS_msa_fcult_w: int  # 1565
MIPS_msa_fcun_d: int  # 1558
MIPS_msa_fcun_w: int  # 1557
MIPS_msa_fcune_d: int  # 1616
MIPS_msa_fcune_w: int  # 1615
MIPS_msa_fdiv_d: int  # 1594
MIPS_msa_fdiv_w: int  # 1593
MIPS_msa_fexdo_h: int  # 1601
MIPS_msa_fexdo_w: int  # 1602
MIPS_msa_fexp2_d: int  # 1600
MIPS_msa_fexp2_w: int  # 1599
MIPS_msa_fexupl_d: int  # 1654
MIPS_msa_fexupl_w: int  # 1653
MIPS_msa_fexupr_d: int  # 1656
MIPS_msa_fexupr_w: int  # 1655
MIPS_msa_ffint_s_d: int  # 1666
MIPS_msa_ffint_s_w: int  # 1665
MIPS_msa_ffint_u_d: int  # 1668
MIPS_msa_ffint_u_w: int  # 1667
MIPS_msa_ffql_d: int  # 1658
MIPS_msa_ffql_w: int  # 1657
MIPS_msa_ffqr_d: int  # 1660
MIPS_msa_ffqr_w: int  # 1659
MIPS_msa_fill_b: int  # 1511
MIPS_msa_fill_d: int  # 1514
MIPS_msa_fill_h: int  # 1512
MIPS_msa_fill_w: int  # 1513
MIPS_msa_flog2_d: int  # 1652
MIPS_msa_flog2_w: int  # 1651
MIPS_msa_fmadd_d: int  # 1596
MIPS_msa_fmadd_w: int  # 1595
MIPS_msa_fmax_a_d: int  # 1612
MIPS_msa_fmax_a_w: int  # 1611
MIPS_msa_fmax_d: int  # 1610
MIPS_msa_fmax_w: int  # 1609
MIPS_msa_fmin_a_d: int  # 1608
MIPS_msa_fmin_a_w: int  # 1607
MIPS_msa_fmin_d: int  # 1606
MIPS_msa_fmin_w: int  # 1605
MIPS_msa_fmsub_d: int  # 1598
MIPS_msa_fmsub_w: int  # 1597
MIPS_msa_fmul_d: int  # 1592
MIPS_msa_fmul_w: int  # 1591
MIPS_msa_frcp_d: int  # 1648
MIPS_msa_frcp_w: int  # 1647
MIPS_msa_frint_d: int  # 1650
MIPS_msa_frint_w: int  # 1649
MIPS_msa_frsqrt_d: int  # 1646
MIPS_msa_frsqrt_w: int  # 1645
MIPS_msa_fsaf_d: int  # 1572
MIPS_msa_fsaf_w: int  # 1571
MIPS_msa_fseq_d: int  # 1576
MIPS_msa_fseq_w: int  # 1575
MIPS_msa_fsle_d: int  # 1584
MIPS_msa_fsle_w: int  # 1583
MIPS_msa_fslt_d: int  # 1580
MIPS_msa_fslt_w: int  # 1579
MIPS_msa_fsne_d: int  # 1630
MIPS_msa_fsne_w: int  # 1629
MIPS_msa_fsor_d: int  # 1626
MIPS_msa_fsor_w: int  # 1625
MIPS_msa_fsqrt_d: int  # 1644
MIPS_msa_fsqrt_w: int  # 1643
MIPS_msa_fsub_d: int  # 1590
MIPS_msa_fsub_w: int  # 1589
MIPS_msa_fsueq_d: int  # 1578
MIPS_msa_fsueq_w: int  # 1577
MIPS_msa_fsule_d: int  # 1586
MIPS_msa_fsule_w: int  # 1585
MIPS_msa_fsult_d: int  # 1582
MIPS_msa_fsult_w: int  # 1581
MIPS_msa_fsun_d: int  # 1574
MIPS_msa_fsun_w: int  # 1573
MIPS_msa_fsune_d: int  # 1628
MIPS_msa_fsune_w: int  # 1627
MIPS_msa_ftint_s_d: int  # 1662
MIPS_msa_ftint_s_w: int  # 1661
MIPS_msa_ftint_u_d: int  # 1664
MIPS_msa_ftint_u_w: int  # 1663
MIPS_msa_ftq_h: int  # 1603
MIPS_msa_ftq_w: int  # 1604
MIPS_msa_ftrunc_s_d: int  # 1640
MIPS_msa_ftrunc_s_w: int  # 1639
MIPS_msa_ftrunc_u_d: int  # 1642
MIPS_msa_ftrunc_u_w: int  # 1641
MIPS_msa_hadd_s_d: int  # 1482
MIPS_msa_hadd_s_h: int  # 1480
MIPS_msa_hadd_s_w: int  # 1481
MIPS_msa_hadd_u_d: int  # 1485
MIPS_msa_hadd_u_h: int  # 1483
MIPS_msa_hadd_u_w: int  # 1484
MIPS_msa_hsub_s_d: int  # 1488
MIPS_msa_hsub_s_h: int  # 1486
MIPS_msa_hsub_s_w: int  # 1487
MIPS_msa_hsub_u_d: int  # 1491
MIPS_msa_hsub_u_h: int  # 1489
MIPS_msa_hsub_u_w: int  # 1490
MIPS_msa_ilvev_b: int  # 1452
MIPS_msa_ilvev_d: int  # 1455
MIPS_msa_ilvev_h: int  # 1453
MIPS_msa_ilvev_w: int  # 1454
MIPS_msa_ilvl_b: int  # 1444
MIPS_msa_ilvl_d: int  # 1447
MIPS_msa_ilvl_h: int  # 1445
MIPS_msa_ilvl_w: int  # 1446
MIPS_msa_ilvod_b: int  # 1456
MIPS_msa_ilvod_d: int  # 1459
MIPS_msa_ilvod_h: int  # 1457
MIPS_msa_ilvod_w: int  # 1458
MIPS_msa_ilvr_b: int  # 1448
MIPS_msa_ilvr_d: int  # 1451
MIPS_msa_ilvr_h: int  # 1449
MIPS_msa_ilvr_w: int  # 1450
MIPS_msa_insert_b: int  # 1535
MIPS_msa_insert_d: int  # 1538
MIPS_msa_insert_h: int  # 1536
MIPS_msa_insert_w: int  # 1537
MIPS_msa_insve_b: int  # 1539
MIPS_msa_insve_d: int  # 1542
MIPS_msa_insve_h: int  # 1540
MIPS_msa_insve_w: int  # 1541
MIPS_msa_ld_b: int  # 1302
MIPS_msa_ld_d: int  # 1305
MIPS_msa_ld_h: int  # 1303
MIPS_msa_ld_w: int  # 1304
MIPS_msa_ldi_b: int  # 1551
MIPS_msa_ldi_d: int  # 1554
MIPS_msa_ldi_h: int  # 1552
MIPS_msa_ldi_w: int  # 1553
MIPS_msa_madd_q_h: int  # 1621
MIPS_msa_madd_q_w: int  # 1622
MIPS_msa_maddr_q_h: int  # 1633
MIPS_msa_maddr_q_w: int  # 1634
MIPS_msa_maddv_b: int  # 1378
MIPS_msa_maddv_d: int  # 1381
MIPS_msa_maddv_h: int  # 1379
MIPS_msa_maddv_w: int  # 1380
MIPS_msa_max_a_b: int  # 1254
MIPS_msa_max_a_d: int  # 1257
MIPS_msa_max_a_h: int  # 1255
MIPS_msa_max_a_w: int  # 1256
MIPS_msa_max_s_b: int  # 1222
MIPS_msa_max_s_d: int  # 1225
MIPS_msa_max_s_h: int  # 1223
MIPS_msa_max_s_w: int  # 1224
MIPS_msa_max_u_b: int  # 1230
MIPS_msa_max_u_d: int  # 1233
MIPS_msa_max_u_h: int  # 1231
MIPS_msa_max_u_w: int  # 1232
MIPS_msa_maxi_s_b: int  # 1226
MIPS_msa_maxi_s_d: int  # 1229
MIPS_msa_maxi_s_h: int  # 1227
MIPS_msa_maxi_s_w: int  # 1228
MIPS_msa_maxi_u_b: int  # 1234
MIPS_msa_maxi_u_d: int  # 1237
MIPS_msa_maxi_u_h: int  # 1235
MIPS_msa_maxi_u_w: int  # 1236
MIPS_msa_min_a_b: int  # 1258
MIPS_msa_min_a_d: int  # 1261
MIPS_msa_min_a_h: int  # 1259
MIPS_msa_min_a_w: int  # 1260
MIPS_msa_min_s_b: int  # 1238
MIPS_msa_min_s_d: int  # 1241
MIPS_msa_min_s_h: int  # 1239
MIPS_msa_min_s_w: int  # 1240
MIPS_msa_min_u_b: int  # 1246
MIPS_msa_min_u_d: int  # 1249
MIPS_msa_min_u_h: int  # 1247
MIPS_msa_min_u_w: int  # 1248
MIPS_msa_mini_s_b: int  # 1242
MIPS_msa_mini_s_d: int  # 1245
MIPS_msa_mini_s_h: int  # 1243
MIPS_msa_mini_s_w: int  # 1244
MIPS_msa_mini_u_b: int  # 1250
MIPS_msa_mini_u_d: int  # 1253
MIPS_msa_mini_u_h: int  # 1251
MIPS_msa_mini_u_w: int  # 1252
MIPS_msa_mod_s_b: int  # 1394
MIPS_msa_mod_s_d: int  # 1397
MIPS_msa_mod_s_h: int  # 1395
MIPS_msa_mod_s_w: int  # 1396
MIPS_msa_mod_u_b: int  # 1398
MIPS_msa_mod_u_d: int  # 1401
MIPS_msa_mod_u_h: int  # 1399
MIPS_msa_mod_u_w: int  # 1400
MIPS_msa_move_v: int  # 1671
MIPS_msa_msub_q_h: int  # 1623
MIPS_msa_msub_q_w: int  # 1624
MIPS_msa_msubr_q_h: int  # 1635
MIPS_msa_msubr_q_w: int  # 1636
MIPS_msa_msubv_b: int  # 1382
MIPS_msa_msubv_d: int  # 1385
MIPS_msa_msubv_h: int  # 1383
MIPS_msa_msubv_w: int  # 1384
MIPS_msa_mul_q_h: int  # 1619
MIPS_msa_mul_q_w: int  # 1620
MIPS_msa_mulr_q_h: int  # 1631
MIPS_msa_mulr_q_w: int  # 1632
MIPS_msa_mulv_b: int  # 1374
MIPS_msa_mulv_d: int  # 1377
MIPS_msa_mulv_h: int  # 1375
MIPS_msa_mulv_w: int  # 1376
MIPS_msa_nloc_b: int  # 1519
MIPS_msa_nloc_d: int  # 1522
MIPS_msa_nloc_h: int  # 1520
MIPS_msa_nloc_w: int  # 1521
MIPS_msa_nlzc_b: int  # 1523
MIPS_msa_nlzc_d: int  # 1526
MIPS_msa_nlzc_h: int  # 1524
MIPS_msa_nlzc_w: int  # 1525
MIPS_msa_nor_v: int  # 1496
MIPS_msa_nori_b: int  # 1497
MIPS_msa_or_v: int  # 1494
MIPS_msa_ori_b: int  # 1495
MIPS_msa_pckev_b: int  # 1436
MIPS_msa_pckev_d: int  # 1439
MIPS_msa_pckev_h: int  # 1437
MIPS_msa_pckev_w: int  # 1438
MIPS_msa_pckod_b: int  # 1440
MIPS_msa_pckod_d: int  # 1443
MIPS_msa_pckod_h: int  # 1441
MIPS_msa_pckod_w: int  # 1442
MIPS_msa_pcnt_b: int  # 1515
MIPS_msa_pcnt_d: int  # 1518
MIPS_msa_pcnt_h: int  # 1516
MIPS_msa_pcnt_w: int  # 1517
MIPS_msa_sat_s_b: int  # 1310
MIPS_msa_sat_s_d: int  # 1313
MIPS_msa_sat_s_h: int  # 1311
MIPS_msa_sat_s_w: int  # 1312
MIPS_msa_sat_u_b: int  # 1314
MIPS_msa_sat_u_d: int  # 1317
MIPS_msa_sat_u_h: int  # 1315
MIPS_msa_sat_u_w: int  # 1316
MIPS_msa_shf_b: int  # 1506
MIPS_msa_shf_h: int  # 1507
MIPS_msa_shf_w: int  # 1508
MIPS_msa_sld_b: int  # 1420
MIPS_msa_sld_d: int  # 1423
MIPS_msa_sld_h: int  # 1421
MIPS_msa_sld_w: int  # 1422
MIPS_msa_sldi_b: int  # 1424
MIPS_msa_sldi_d: int  # 1427
MIPS_msa_sldi_h: int  # 1425
MIPS_msa_sldi_w: int  # 1426
MIPS_msa_sll_b: int  # 1142
MIPS_msa_sll_d: int  # 1145
MIPS_msa_sll_h: int  # 1143
MIPS_msa_sll_w: int  # 1144
MIPS_msa_slli_b: int  # 1146
MIPS_msa_slli_d: int  # 1149
MIPS_msa_slli_h: int  # 1147
MIPS_msa_slli_w: int  # 1148
MIPS_msa_splat_b: int  # 1428
MIPS_msa_splat_d: int  # 1431
MIPS_msa_splat_h: int  # 1429
MIPS_msa_splat_w: int  # 1430
MIPS_msa_splati_b: int  # 1432
MIPS_msa_splati_d: int  # 1435
MIPS_msa_splati_h: int  # 1433
MIPS_msa_splati_w: int  # 1434
MIPS_msa_sra_b: int  # 1150
MIPS_msa_sra_d: int  # 1153
MIPS_msa_sra_h: int  # 1151
MIPS_msa_sra_w: int  # 1152
MIPS_msa_srai_b: int  # 1154
MIPS_msa_srai_d: int  # 1157
MIPS_msa_srai_h: int  # 1155
MIPS_msa_srai_w: int  # 1156
MIPS_msa_srar_b: int  # 1464
MIPS_msa_srar_d: int  # 1467
MIPS_msa_srar_h: int  # 1465
MIPS_msa_srar_w: int  # 1466
MIPS_msa_srari_b: int  # 1468
MIPS_msa_srari_d: int  # 1471
MIPS_msa_srari_h: int  # 1469
MIPS_msa_srari_w: int  # 1470
MIPS_msa_srl_b: int  # 1158
MIPS_msa_srl_d: int  # 1161
MIPS_msa_srl_h: int  # 1159
MIPS_msa_srl_w: int  # 1160
MIPS_msa_srli_b: int  # 1162
MIPS_msa_srli_d: int  # 1165
MIPS_msa_srli_h: int  # 1163
MIPS_msa_srli_w: int  # 1164
MIPS_msa_srlr_b: int  # 1472
MIPS_msa_srlr_d: int  # 1475
MIPS_msa_srlr_h: int  # 1473
MIPS_msa_srlr_w: int  # 1474
MIPS_msa_srlri_b: int  # 1476
MIPS_msa_srlri_d: int  # 1479
MIPS_msa_srlri_h: int  # 1477
MIPS_msa_srlri_w: int  # 1478
MIPS_msa_st_b: int  # 1306
MIPS_msa_st_d: int  # 1309
MIPS_msa_st_h: int  # 1307
MIPS_msa_st_w: int  # 1308
MIPS_msa_subs_s_b: int  # 1350
MIPS_msa_subs_s_d: int  # 1353
MIPS_msa_subs_s_h: int  # 1351
MIPS_msa_subs_s_w: int  # 1352
MIPS_msa_subs_u_b: int  # 1354
MIPS_msa_subs_u_d: int  # 1357
MIPS_msa_subs_u_h: int  # 1355
MIPS_msa_subs_u_w: int  # 1356
MIPS_msa_subsus_u_b: int  # 1358
MIPS_msa_subsus_u_d: int  # 1361
MIPS_msa_subsus_u_h: int  # 1359
MIPS_msa_subsus_u_w: int  # 1360
MIPS_msa_subsuu_s_b: int  # 1362
MIPS_msa_subsuu_s_d: int  # 1365
MIPS_msa_subsuu_s_h: int  # 1363
MIPS_msa_subsuu_s_w: int  # 1364
MIPS_msa_subv_b: int  # 1214
MIPS_msa_subv_d: int  # 1217
MIPS_msa_subv_h: int  # 1215
MIPS_msa_subv_w: int  # 1216
MIPS_msa_subvi_b: int  # 1218
MIPS_msa_subvi_d: int  # 1221
MIPS_msa_subvi_h: int  # 1219
MIPS_msa_subvi_w: int  # 1220
MIPS_msa_vshf_b: int  # 1460
MIPS_msa_vshf_d: int  # 1463
MIPS_msa_vshf_h: int  # 1461
MIPS_msa_vshf_w: int  # 1462
MIPS_msa_xor_v: int  # 1498
MIPS_msa_xori_b: int  # 1499
MIPS_msub: int  # 502
MIPS_msub3: int  # 751
MIPS_msub_d: int  # 214
MIPS_msub_ps: int  # 523
MIPS_msub_s: int  # 213
MIPS_msubu: int  # 503
MIPS_msubu3: int  # 752
MIPS_mtc0: int  # 56
MIPS_mtc1: int  # 57
MIPS_mtc2: int  # 58
MIPS_mtdr: int  # 611
MIPS_mthc0: int  # 1714
MIPS_mthc1: int  # 524
MIPS_mthc2: int  # 525
MIPS_mthi: int  # 73
MIPS_mthi1: int  # 328
MIPS_mthlip: int  # 1076
MIPS_mtlhx: int  # 818
MIPS_mtlo: int  # 74
MIPS_mtlo1: int  # 329
MIPS_mtm0: int  # 584
MIPS_mtm1: int  # 585
MIPS_mtm2: int  # 586
MIPS_mtp0: int  # 587
MIPS_mtp1: int  # 588
MIPS_mtp2: int  # 589
MIPS_mtsa: int  # 314
MIPS_mtsab: int  # 316
MIPS_mtsah: int  # 317
MIPS_mttacx: int  # 778
MIPS_mttc0: int  # 774
MIPS_mttc1: int  # 781
MIPS_mttc2: int  # 784
MIPS_mttdsp: int  # 779
MIPS_mttgpr: int  # 786
MIPS_mtthc0: int  # 775
MIPS_mtthc1: int  # 780
MIPS_mtthc2: int  # 783
MIPS_mtthi: int  # 777
MIPS_mttlo: int  # 776
MIPS_mttr: int  # 773
MIPS_muh: int  # 1694
MIPS_muhu: int  # 1696
MIPS_mul: int  # 504
MIPS_mul_ph: int  # 1110
MIPS_mul_s_ph: int  # 1111
MIPS_muleq_s_pw_qhl: int  # 875
MIPS_muleq_s_pw_qhr: int  # 877
MIPS_muleq_s_w_phl: int  # 855
MIPS_muleq_s_w_phr: int  # 858
MIPS_muleu_s_ph_qbl: int  # 859
MIPS_muleu_s_ph_qbr: int  # 863
MIPS_muleu_s_qh_obl: int  # 878
MIPS_muleu_s_qh_obr: int  # 881
MIPS_mulq_rs_ph: int  # 866
MIPS_mulq_rs_qh: int  # 884
MIPS_mulq_rs_w: int  # 1113
MIPS_mulq_s_ph: int  # 862
MIPS_mulq_s_w: int  # 1112
MIPS_mulsa_w_ph: int  # 1021
MIPS_mulsaq_s_l_pw: int  # 1053
MIPS_mulsaq_s_w_ph: int  # 1032
MIPS_mulsaq_s_w_qh: int  # 1052
MIPS_mult: int  # 71
MIPS_mult1: int  # 340
MIPS_mult3: int  # 430
MIPS_multp: int  # 819
MIPS_multu: int  # 72
MIPS_multu1: int  # 341
MIPS_multu3: int  # 431
MIPS_mulu: int  # 1695
MIPS_neg: int  # 196
MIPS_negu: int  # 197
MIPS_nmadd_d: int  # 224
MIPS_nmadd_ps: int  # 526
MIPS_nmadd_s: int  # 223
MIPS_nmsub_d: int  # 226
MIPS_nmsub_ps: int  # 527
MIPS_nmsub_s: int  # 225
MIPS_nop: int  # 194
MIPS_nor: int  # 8
MIPS_not: int  # 477
MIPS_null: int  # 0
MIPS_or: int  # 9
MIPS_ori: int  # 37
MIPS_pabsh: int  # 403
MIPS_pabsw: int  # 402
MIPS_packrl_ph: int  # 903
MIPS_packrl_pw: int  # 926
MIPS_paddb: int  # 361
MIPS_paddh: int  # 353
MIPS_paddsb: int  # 393
MIPS_paddsh: int  # 384
MIPS_paddsw: int  # 371
MIPS_paddub: int  # 394
MIPS_padduh: int  # 386
MIPS_padduw: int  # 373
MIPS_paddw: int  # 338
MIPS_padsbh: int  # 355
MIPS_pand: int  # 378
MIPS_pause: int  # 557
MIPS_pceqb: int  # 365
MIPS_pceqh: int  # 358
MIPS_pceqw: int  # 348
MIPS_pcgtb: int  # 363
MIPS_pcgth: int  # 357
MIPS_pcgtw: int  # 346
MIPS_pcpyh: int  # 407
MIPS_pcpyld: int  # 369
MIPS_pcpyud: int  # 370
MIPS_pdivbw: int  # 337
MIPS_pdivuw: int  # 336
MIPS_pdivw: int  # 335
MIPS_pexch: int  # 405
MIPS_pexcw: int  # 410
MIPS_pexoh: int  # 404
MIPS_pexow: int  # 409
MIPS_pext5: int  # 408
MIPS_pextlb: int  # 397
MIPS_pextlh: int  # 390
MIPS_pextlw: int  # 377
MIPS_pextub: int  # 398
MIPS_pextuh: int  # 391
MIPS_pextuw: int  # 379
MIPS_phmadh: int  # 375
MIPS_phmsbh: int  # 388
MIPS_pick_ob: int  # 916
MIPS_pick_ph: int  # 895
MIPS_pick_pw: int  # 918
MIPS_pick_qb: int  # 894
MIPS_pick_qh: int  # 917
MIPS_pinth: int  # 364
MIPS_pintoh: int  # 366
MIPS_pll: int  # 528
MIPS_plu: int  # 529
MIPS_plzcw: int  # 327
MIPS_pmaddh: int  # 372
MIPS_pmadduw: int  # 344
MIPS_pmaddw: int  # 339
MIPS_pmaxh: int  # 359
MIPS_pmaxw: int  # 349
MIPS_pmfhi: int  # 421
MIPS_pmfhl: int  # 423
MIPS_pmflo: int  # 422
MIPS_pminh: int  # 360
MIPS_pminw: int  # 351
MIPS_pmsubh: int  # 385
MIPS_pmsubw: int  # 354
MIPS_pmthi: int  # 331
MIPS_pmthl_lw: int  # 330
MIPS_pmtlo: int  # 332
MIPS_pmulth: int  # 401
MIPS_pmultuw: int  # 368
MIPS_pmultw: int  # 367
MIPS_pnor: int  # 383
MIPS_pop: int  # 590
MIPS_por: int  # 380
MIPS_ppac5: int  # 411
MIPS_ppacb: int  # 399
MIPS_ppach: int  # 392
MIPS_ppacw: int  # 381
MIPS_pperm: int  # 820
MIPS_preceq_pw_qhl: int  # 955
MIPS_preceq_pw_qhla: int  # 963
MIPS_preceq_pw_qhr: int  # 959
MIPS_preceq_pw_qhra: int  # 966
MIPS_preceq_s_l_pwl: int  # 956
MIPS_preceq_s_l_pwr: int  # 960
MIPS_preceq_w_phl: int  # 937
MIPS_preceq_w_phr: int  # 940
MIPS_precequ_ph_qbl: int  # 936
MIPS_precequ_ph_qbla: int  # 942
MIPS_precequ_ph_qbr: int  # 939
MIPS_precequ_ph_qbra: int  # 944
MIPS_precequ_pw_qhl: int  # 954
MIPS_precequ_pw_qhla: int  # 962
MIPS_precequ_pw_qhr: int  # 958
MIPS_precequ_pw_qhra: int  # 965
MIPS_preceu_ph_qbl: int  # 938
MIPS_preceu_ph_qbla: int  # 943
MIPS_preceu_ph_qbr: int  # 941
MIPS_preceu_ph_qbra: int  # 945
MIPS_preceu_qh_obl: int  # 957
MIPS_preceu_qh_obla: int  # 964
MIPS_preceu_qh_obr: int  # 961
MIPS_preceu_qh_obra: int  # 967
MIPS_precr_qb_ph: int  # 900
MIPS_precr_sra_ph_w: int  # 904
MIPS_precr_sra_r_ph_w: int  # 906
MIPS_precrq_ob_qh: int  # 920
MIPS_precrq_ph_w: int  # 898
MIPS_precrq_pw_l: int  # 922
MIPS_precrq_qb_ph: int  # 897
MIPS_precrq_qh_pw: int  # 921
MIPS_precrq_rs_ph_w: int  # 901
MIPS_precrq_rs_qh_pw: int  # 924
MIPS_precrqu_s_ob_qh: int  # 927
MIPS_precrqu_s_qb_ph: int  # 905
MIPS_pref: int  # 206
MIPS_prefe: int  # 1685
MIPS_prefx: int  # 227
MIPS_prepend: int  # 1116
MIPS_prevh: int  # 406
MIPS_prot3w: int  # 412
MIPS_psllh: int  # 413
MIPS_psllvw: int  # 347
MIPS_psllw: int  # 416
MIPS_psrah: int  # 415
MIPS_psravw: int  # 352
MIPS_psraw: int  # 418
MIPS_psrlh: int  # 414
MIPS_psrlvw: int  # 350
MIPS_psrlw: int  # 417
MIPS_psubb: int  # 362
MIPS_psubh: int  # 356
MIPS_psubsb: int  # 395
MIPS_psubsh: int  # 387
MIPS_psubsw: int  # 374
MIPS_psubub: int  # 396
MIPS_psubuh: int  # 389
MIPS_psubuw: int  # 376
MIPS_psubw: int  # 345
MIPS_pul: int  # 530
MIPS_puu: int  # 531
MIPS_pxor: int  # 382
MIPS_qfsrv: int  # 400
MIPS_qmac_00: int  # 1132
MIPS_qmac_01: int  # 1133
MIPS_qmac_02: int  # 1134
MIPS_qmac_03: int  # 1135
MIPS_qmacs_00: int  # 1136
MIPS_qmacs_01: int  # 1137
MIPS_qmacs_02: int  # 1138
MIPS_qmacs_03: int  # 1139
MIPS_qmfc2: int  # 50
MIPS_qmtc2: int  # 52
MIPS_raddu_l_ob: int  # 874
MIPS_raddu_w_qb: int  # 854
MIPS_rddsp: int  # 1064
MIPS_rdhwr: int  # 532
MIPS_rdpgpr: int  # 533
MIPS_repl_ob: int  # 948
MIPS_repl_ph: int  # 932
MIPS_repl_pw: int  # 950
MIPS_repl_qb: int  # 931
MIPS_repl_qh: int  # 949
MIPS_replv_ob: int  # 951
MIPS_replv_ph: int  # 934
MIPS_replv_pw: int  # 953
MIPS_replv_qb: int  # 933
MIPS_replv_qh: int  # 952
MIPS_restore: int  # 545
MIPS_restore_jrc: int  # 1738
MIPS_rotr: int  # 534
MIPS_rotrv: int  # 535
MIPS_rotx: int  # 1723
MIPS_saa: int  # 591
MIPS_saad: int  # 592
MIPS_sadd: int  # 738
MIPS_save: int  # 544
MIPS_sb: int  # 138
MIPS_sbe: int  # 1679
MIPS_sbv: int  # 242
MIPS_sbx: int  # 1706
MIPS_sc: int  # 147
MIPS_scd: int  # 143
MIPS_sce: int  # 1683
MIPS_scwp: int  # 1726
MIPS_scwpe: int  # 1727
MIPS_sd: int  # 144
MIPS_sdbbp: int  # 505
MIPS_sdc1: int  # 145
MIPS_sdc2: int  # 146
MIPS_sdl: int  # 139
MIPS_sdm: int  # 829
MIPS_sdp: int  # 827
MIPS_sdr: int  # 140
MIPS_sdv: int  # 245
MIPS_sdxc1: int  # 209
MIPS_seb: int  # 536
MIPS_seh: int  # 537
MIPS_seq: int  # 593
MIPS_seqi: int  # 594
MIPS_sew: int  # 548
MIPS_sfv: int  # 251
MIPS_sh: int  # 149
MIPS_she: int  # 1680
MIPS_shilo: int  # 1065
MIPS_shilov: int  # 1069
MIPS_shll_ob: int  # 990
MIPS_shll_ph: int  # 969
MIPS_shll_pw: int  # 992
MIPS_shll_qb: int  # 968
MIPS_shll_qh: int  # 991
MIPS_shll_s_ph: int  # 979
MIPS_shll_s_pw: int  # 1003
MIPS_shll_s_qh: int  # 1002
MIPS_shll_s_w: int  # 980
MIPS_shllv_ob: int  # 996
MIPS_shllv_ph: int  # 974
MIPS_shllv_pw: int  # 998
MIPS_shllv_qb: int  # 973
MIPS_shllv_qh: int  # 997
MIPS_shllv_s_ph: int  # 985
MIPS_shllv_s_pw: int  # 1007
MIPS_shllv_s_qh: int  # 1006
MIPS_shllv_s_w: int  # 986
MIPS_shra_ph: int  # 971
MIPS_shra_pw: int  # 995
MIPS_shra_qb: int  # 978
MIPS_shra_qh: int  # 994
MIPS_shra_r_ph: int  # 982
MIPS_shra_r_pw: int  # 1005
MIPS_shra_r_qb: int  # 981
MIPS_shra_r_qh: int  # 1004
MIPS_shra_r_w: int  # 983
MIPS_shrav_ph: int  # 976
MIPS_shrav_pw: int  # 1001
MIPS_shrav_qb: int  # 984
MIPS_shrav_qh: int  # 1000
MIPS_shrav_r_ph: int  # 988
MIPS_shrav_r_pw: int  # 1009
MIPS_shrav_r_qb: int  # 987
MIPS_shrav_r_qh: int  # 1008
MIPS_shrav_r_w: int  # 989
MIPS_shrl_ob: int  # 993
MIPS_shrl_ph: int  # 972
MIPS_shrl_qb: int  # 970
MIPS_shrlv_ob: int  # 999
MIPS_shrlv_ph: int  # 977
MIPS_shrlv_qb: int  # 975
MIPS_shv: int  # 250
MIPS_shx: int  # 1707
MIPS_shxs: int  # 1708
MIPS_sigrie: int  # 1735
MIPS_sll: int  # 21
MIPS_sllv: int  # 27
MIPS_slt: int  # 10
MIPS_slti: int  # 34
MIPS_sltiu: int  # 35
MIPS_sltu: int  # 11
MIPS_slv: int  # 244
MIPS_sne: int  # 595
MIPS_snei: int  # 596
MIPS_sov: int  # 1699
MIPS_spv: int  # 248
MIPS_sq: int  # 425
MIPS_sqc2: int  # 427
MIPS_sqv: int  # 246
MIPS_sra: int  # 22
MIPS_srav: int  # 28
MIPS_srl: int  # 23
MIPS_srlv: int  # 29
MIPS_srv: int  # 247
MIPS_ssnop: int  # 552
MIPS_ssub: int  # 739
MIPS_ssv: int  # 243
MIPS_stv: int  # 253
MIPS_sub: int  # 12
MIPS_subq_ph: int  # 851
MIPS_subq_pw: int  # 872
MIPS_subq_qh: int  # 871
MIPS_subq_s_ph: int  # 864
MIPS_subq_s_pw: int  # 883
MIPS_subq_s_qh: int  # 882
MIPS_subq_s_w: int  # 865
MIPS_subqh_ph: int  # 1102
MIPS_subqh_r_ph: int  # 1108
MIPS_subqh_r_w: int  # 1109
MIPS_subqh_w: int  # 1103
MIPS_subu: int  # 13
MIPS_subu_ob: int  # 868
MIPS_subu_ph: int  # 847
MIPS_subu_qb: int  # 846
MIPS_subu_s_ob: int  # 876
MIPS_subu_s_ph: int  # 857
MIPS_subu_s_qb: int  # 856
MIPS_subuh_qb: int  # 1101
MIPS_subuh_r_qb: int  # 1107
MIPS_suv: int  # 249
MIPS_suxc1: int  # 538
MIPS_sw: int  # 148
MIPS_swc1: int  # 150
MIPS_swc2: int  # 151
MIPS_swe: int  # 1681
MIPS_swl: int  # 141
MIPS_swle: int  # 1688
MIPS_swm: int  # 828
MIPS_swm2: int  # 1765
MIPS_swp: int  # 826
MIPS_swpc: int  # 1722
MIPS_swr: int  # 142
MIPS_swre: int  # 1689
MIPS_swv: int  # 252
MIPS_swx: int  # 1709
MIPS_swxc1: int  # 210
MIPS_swxs: int  # 1710
MIPS_sync: int  # 152
MIPS_synci: int  # 539
MIPS_syncie: int  # 1732
MIPS_synciobdma: int  # 597
MIPS_syncs: int  # 598
MIPS_syncw: int  # 599
MIPS_syncws: int  # 600
MIPS_syscall: int  # 81
MIPS_teq: int  # 39
MIPS_teqi: int  # 59
MIPS_tge: int  # 40
MIPS_tgei: int  # 60
MIPS_tgeiu: int  # 61
MIPS_tgeu: int  # 41
MIPS_tlbinv: int  # 1716
MIPS_tlbinvf: int  # 1717
MIPS_tlbp: int  # 154
MIPS_tlbr: int  # 155
MIPS_tlbwi: int  # 156
MIPS_tlbwr: int  # 157
MIPS_tlt: int  # 42
MIPS_tlti: int  # 62
MIPS_tltiu: int  # 63
MIPS_tltu: int  # 43
MIPS_tne: int  # 44
MIPS_tnei: int  # 64
MIPS_ualh: int  # 1730
MIPS_ualwm: int  # 1728
MIPS_uash: int  # 1731
MIPS_uaswm: int  # 1729
MIPS_ucopyw: int  # 1693
MIPS_uld: int  # 601
MIPS_ulw: int  # 602
MIPS_usd: int  # 603
MIPS_usw: int  # 604
MIPS_v3mulu: int  # 605
MIPS_vabs: int  # 273
MIPS_vaccb: int  # 278
MIPS_vadd: int  # 270
MIPS_vaddb: int  # 276
MIPS_vaddc: int  # 274
MIPS_vand: int  # 292
MIPS_vch: int  # 289
MIPS_vcl: int  # 288
MIPS_vcr: int  # 290
MIPS_veq: int  # 285
MIPS_vextn: int  # 311
MIPS_vextq: int  # 309
MIPS_vextt: int  # 307
MIPS_vge: int  # 287
MIPS_vinsn: int  # 310
MIPS_vinsq: int  # 308
MIPS_vinst: int  # 306
MIPS_vlt: int  # 284
MIPS_vmacf: int  # 255
MIPS_vmacq: int  # 261
MIPS_vmacu: int  # 257
MIPS_vmadh: int  # 263
MIPS_vmadl: int  # 269
MIPS_vmadm: int  # 265
MIPS_vmadn: int  # 267
MIPS_vmm0: int  # 606
MIPS_vmov: int  # 299
MIPS_vmrg: int  # 291
MIPS_vmudh: int  # 262
MIPS_vmudl: int  # 268
MIPS_vmudm: int  # 264
MIPS_vmudn: int  # 266
MIPS_vmulf: int  # 254
MIPS_vmulq: int  # 260
MIPS_vmulu: int  # 256
MIPS_vmulu_cn: int  # 607
MIPS_vnand: int  # 293
MIPS_vne: int  # 286
MIPS_vnoop: int  # 298
MIPS_vnor: int  # 295
MIPS_vnxor: int  # 297
MIPS_vor: int  # 294
MIPS_vrcp: int  # 300
MIPS_vrcph: int  # 302
MIPS_vrcpl: int  # 304
MIPS_vrndn: int  # 259
MIPS_vrndp: int  # 258
MIPS_vrsq: int  # 301
MIPS_vrsqh: int  # 303
MIPS_vrsql: int  # 305
MIPS_vsac: int  # 281
MIPS_vsad: int  # 280
MIPS_vsaw: int  # 283
MIPS_vsub: int  # 271
MIPS_vsubb: int  # 277
MIPS_vsubc: int  # 275
MIPS_vsucb: int  # 279
MIPS_vsum: int  # 282
MIPS_vsut: int  # 272
MIPS_vxor: int  # 296
MIPS_wait: int  # 506
MIPS_wrdsp: int  # 1068
MIPS_wrpgpr: int  # 540
MIPS_wsbh: int  # 541
MIPS_xor: int  # 14
MIPS_xori: int  # 38
MIPS_yield: int  # 758
MIPS_zcb: int  # 1140
MIPS_zcbt: int  # 1141
MIPS_zeb: int  # 549
MIPS_zeh: int  # 550
MIPS_zew: int  # 551
MLI_CLR_FLAGS: int  # 16
MLI_CMT: int  # 4
MLI_NAME: int  # 1
MLI_SET_FLAGS: int  # 8
MLI_TYPE: int  # 2
MMAT_CALLS: int  # 4
MMAT_GENERATED: int  # 1
MMAT_GLBOPT1: int  # 5
MMAT_GLBOPT2: int  # 6
MMAT_GLBOPT3: int  # 7
MMAT_LOCOPT: int  # 3
MMAT_LVARS: int  # 8
MMAT_PREOPTIMIZED: int  # 2
MMAT_ZERO: int  # 0
MMIDX_ARGS: int  # 4
MMIDX_GLBHIGH: int  # 5
MMIDX_GLBLOW: int  # 0
MMIDX_LVARS: int  # 1
MMIDX_RETADDR: int  # 2
MMIDX_SHADOW: int  # 3
MNG_CALC_VALID: int  # 1979711488
MNG_COMPILER_MSK: int  # 1879048192
MNG_DEFFAR: int  # 2
MNG_DEFHUGE: int  # 4
MNG_DEFNEAR: int  # 0
MNG_DEFNEARANY: int  # 1
MNG_DEFNONE: int  # 6
MNG_DEFPTR64: int  # 5
MNG_DROP_IMP: int  # 8388608
MNG_IGN_ANYWAY: int  # 33554432
MNG_IGN_JMP: int  # 67108864
MNG_LONG_FORM: int  # 104857607
MNG_MOVE_JMP: int  # 134217728
MNG_NOBASEDT: int  # 128
MNG_NOCALLC: int  # 256
MNG_NOCLOSUR: int  # 32768
MNG_NOCSVOL: int  # 16384
MNG_NODEFINIT: int  # 8
MNG_NOECSU: int  # 8192
MNG_NOMANAGE: int  # 131072
MNG_NOMODULE: int  # 262144
MNG_NOPOSTFC: int  # 512
MNG_NOPTRTYP: int  # 7
MNG_NOPTRTYP16: int  # 3
MNG_NORETTYPE: int  # 64
MNG_NOSCTYP: int  # 1024
MNG_NOSTVIR: int  # 4096
MNG_NOTHROW: int  # 2048
MNG_NOTYPE: int  # 32
MNG_NOUNALG: int  # 65536
MNG_NOUNDERSCORE: int  # 16
MNG_PTRMSK: int  # 7
MNG_SHORT_FORM: int  # 245612135
MNG_SHORT_S: int  # 1048576
MNG_SHORT_U: int  # 2097152
MNG_ZPT_SPACE: int  # 4194304
MODULE_ENTRY_IDP: str  # LPH
MODULE_ENTRY_LOADER: str  # LDSC
MODULE_ENTRY_PLUGIN: str  # PLUGIN
MOVBPT_BAD_TYPE: int  # 3
MOVBPT_DEST_BUSY: int  # 2
MOVBPT_NOT_FOUND: int  # 1
MOVBPT_OK: int  # 0
MOVE_FUNC_BADSTART: int  # 2
MOVE_FUNC_NOCODE: int  # 1
MOVE_FUNC_NOFUNC: int  # 3
MOVE_FUNC_OK: int  # 0
MOVE_FUNC_REFUSED: int  # 4
MOVE_SEGM_CHUNK: int  # -4
MOVE_SEGM_DEBUG: int  # -8
MOVE_SEGM_IDP: int  # -3
MOVE_SEGM_INVAL: int  # -11
MOVE_SEGM_LOADER: int  # -5
MOVE_SEGM_MAPPING: int  # -10
MOVE_SEGM_ODD: int  # -6
MOVE_SEGM_OK: int  # 0
MOVE_SEGM_ORPHAN: int  # -7
MOVE_SEGM_PARAM: int  # -1
MOVE_SEGM_ROOM: int  # -2
MOVE_SEGM_SOURCEFILES: int  # -9
MSF_FIXONCE: int  # 8
MSF_LDKEEP: int  # 4
MSF_NETNODES: int  # 128
MSF_NOFIX: int  # 2
MSF_PRIORITY: int  # 32
MSF_SILENT: int  # 1
MS_0TYPE: int  # 15728640
MS_1TYPE: int  # 251658240
MS_CLS: int  # 1536
MS_CODE: int  # -268435456
MS_COMM: int  # 1046528
MS_N_TYPE: int  # 15
MS_VAL: int  # 255
MTG_DOT_NODE: int  # 2
MTG_GROUP_NODE: int  # 1
MTG_NON_DISPLAYABLE_NODE: int  # 8
MT_BORLAN: int  # 536870912
MT_CASTING: int  # 4194304
MT_CDECL: int  # 2
MT_CLRCALL: int  # 11
MT_CLRCDTOR: int  # 5242880
MT_CONSTR: int  # 2097152
MT_DEFAULT: int  # 1
MT_DESTR: int  # 3145728
MT_DMDCALL: int  # 12
MT_FASTCALL: int  # 5
MT_FORTRAN: int  # 7
MT_GCC3: int  # 1610612736
MT_GNU: int  # 1342177280
MT_INTERRUPT: int  # 9
MT_LOCALNAME: int  # 15
MT_MEMBER: int  # 128
MT_MSCOMP: int  # 268435456
MT_MSFASTCALL: int  # 10
MT_OPERAT: int  # 1048576
MT_OTHER: int  # 1073741824
MT_PARMAX: int  # 255
MT_PARSHF: int  # 8
MT_PASCAL: int  # 3
MT_PRIVATE: int  # 64
MT_PROTECT: int  # 96
MT_PUBLIC: int  # 32
MT_REGCALL: int  # 14
MT_RTTI: int  # 192
MT_STDCALL: int  # 4
MT_SYSCALL: int  # 8
MT_THISCALL: int  # 6
MT_VECTORCALL: int  # 13
MT_VISAGE: int  # 1879048192
MT_VOIDARG: int  # 130816
MT_VTABLE: int  # 160
MT_WATCOM: int  # 805306368
MUST_ACCESS: int  # 0
M_ANONNSP: int  # 33554432
M_AUTOCRT: int  # 524288
M_CLASS: int  # 224
M_COMPILER: int  # 1879048192
M_DBGNAME: int  # 134217728
M_ELLIPSIS: int  # 65536
M_PARMSK: int  # 65280
M_PRCMSK: int  # 15
M_SAVEREGS: int  # 16
M_STATIC: int  # 131072
M_THUNK: int  # 16777216
M_TMPLNAM: int  # 67108864
M_TRUNCATE: int  # 8388608
M_TYPMASK: int  # 7340032
M_VIRTUAL: int  # 262144
NALT_ABSBASE: int  # 10
NALT_AFLAGS: int  # 8
NALT_ALIGN: int  # 17
NALT_COLOR: int  # 20
NALT_CREF_FROM: str  # x
NALT_CREF_TO: str  # X
NALT_DREF_FROM: str  # d
NALT_DREF_TO: str  # D
NALT_ENUM0: int  # 11
NALT_ENUM1: int  # 12
NALT_GR_LAYX: str  # p
NALT_LINNUM: int  # 9
NALT_PURGE: int  # 15
NALT_STRTYPE: int  # 16
NALT_STRUCT: int  # 3
NALT_SWITCH: int  # 1
NALT_VD: int  # 2
NDS_BLOB: int  # 32
NDS_EV_FUNC: int  # 128
NDS_EV_RANGE: int  # 64
NDS_INC: int  # 8192
NDS_IS_BOOL: int  # 1
NDS_IS_EA: int  # 2
NDS_IS_RELATIVE: int  # 4
NDS_IS_STR: int  # 8
NDS_MAP_IDX: int  # 256
NDS_MAP_VAL: int  # 512
NDS_SUPVAL: int  # 16
NDS_UI_ND: int  # 16384
NDS_VAL8: int  # 4096
NEC850_ABSF_D: int  # 129
NEC850_ABSF_S: int  # 130
NEC850_ABSF_S4: int  # 395
NEC850_ADD: int  # 71
NEC850_ADDF_D: int  # 131
NEC850_ADDF_S: int  # 132
NEC850_ADDF_S4: int  # 396
NEC850_ADDI: int  # 70
NEC850_ADDRF_S4: int  # 421
NEC850_ADDSUBF_S4: int  # 410
NEC850_ADDSUBNF_S4: int  # 411
NEC850_ADDSUBNXF_S4: int  # 417
NEC850_ADDSUBXF_S4: int  # 418
NEC850_ADDXF_S4: int  # 414
NEC850_ADF: int  # 100
NEC850_AND: int  # 69
NEC850_ANDI: int  # 68
NEC850_BGE: int  # 66
NEC850_BGT: int  # 67
NEC850_BH: int  # 63
NEC850_BINS: int  # 204
NEC850_BL: int  # 53
NEC850_BLE: int  # 59
NEC850_BLT: int  # 58
NEC850_BN: int  # 56
NEC850_BNC: int  # 61
NEC850_BNH: int  # 55
NEC850_BNV: int  # 60
NEC850_BNZ: int  # 62
NEC850_BP: int  # 64
NEC850_BR: int  # 57
NEC850_BREAKPOINT: int  # 1
NEC850_BSA: int  # 65
NEC850_BSH: int  # 93
NEC850_BSW: int  # 92
NEC850_BV: int  # 52
NEC850_BZ: int  # 54
NEC850_CACHE: int  # 212
NEC850_CALLT: int  # 79
NEC850_CAXI: int  # 109
NEC850_CEILF_DL: int  # 155
NEC850_CEILF_DUL: int  # 159
NEC850_CEILF_DUW: int  # 160
NEC850_CEILF_DW: int  # 156
NEC850_CEILF_SL: int  # 157
NEC850_CEILF_SUL: int  # 161
NEC850_CEILF_SUW: int  # 162
NEC850_CEILF_SUW4: int  # 426
NEC850_CEILF_SW: int  # 158
NEC850_CEILF_SW4: int  # 427
NEC850_CLIP_B: int  # 255
NEC850_CLIP_BU: int  # 256
NEC850_CLIP_H: int  # 257
NEC850_CLIP_HU: int  # 258
NEC850_CLL: int  # 211
NEC850_CLR1: int  # 51
NEC850_CMOV: int  # 95
NEC850_CMOVF_D: int  # 200
NEC850_CMOVF_S: int  # 199
NEC850_CMOVF_W4: int  # 393
NEC850_CMP: int  # 50
NEC850_CMPF_D: int  # 198
NEC850_CMPF_S: int  # 197
NEC850_CMPF_S4: int  # 440
NEC850_CNVQ15Q30: int  # 375
NEC850_CNVQ30Q15: int  # 377
NEC850_CNVQ31Q62: int  # 376
NEC850_CNVQ62Q31: int  # 378
NEC850_CTRET: int  # 82
NEC850_CVTF_DL: int  # 163
NEC850_CVTF_DS: int  # 164
NEC850_CVTF_DUL: int  # 165
NEC850_CVTF_DUW: int  # 166
NEC850_CVTF_DW: int  # 167
NEC850_CVTF_HS: int  # 216
NEC850_CVTF_HS4: int  # 428
NEC850_CVTF_LD: int  # 168
NEC850_CVTF_LS: int  # 169
NEC850_CVTF_SD: int  # 170
NEC850_CVTF_SH: int  # 217
NEC850_CVTF_SH4: int  # 429
NEC850_CVTF_SL: int  # 171
NEC850_CVTF_SUL: int  # 172
NEC850_CVTF_SUW: int  # 173
NEC850_CVTF_SUW4: int  # 430
NEC850_CVTF_SW: int  # 174
NEC850_CVTF_SW4: int  # 431
NEC850_CVTF_ULD: int  # 175
NEC850_CVTF_ULS: int  # 176
NEC850_CVTF_UWD: int  # 177
NEC850_CVTF_UWS: int  # 178
NEC850_CVTF_UWS4: int  # 432
NEC850_CVTF_WD: int  # 179
NEC850_CVTF_WS: int  # 180
NEC850_CVTF_WS4: int  # 433
NEC850_CVT_SW: int  # 121
NEC850_CVT_WS: int  # 123
NEC850_DBCP: int  # 223
NEC850_DBHVTRAP: int  # 225
NEC850_DBPUSH: int  # 222
NEC850_DBRET: int  # 81
NEC850_DBTAG: int  # 224
NEC850_DBTRAP: int  # 80
NEC850_DI: int  # 49
NEC850_DISPOSE_r: int  # 78
NEC850_DISPOSE_r0: int  # 77
NEC850_DIV: int  # 90
NEC850_DIVF_D: int  # 133
NEC850_DIVF_S: int  # 134
NEC850_DIVF_S4: int  # 397
NEC850_DIVH: int  # 48
NEC850_DIVHU: int  # 89
NEC850_DIVH_r3: int  # 88
NEC850_DIVQ: int  # 110
NEC850_DIVQU: int  # 111
NEC850_DIVU: int  # 91
NEC850_DST: int  # 227
NEC850_DUP_H: int  # 286
NEC850_DUP_W: int  # 287
NEC850_EI: int  # 47
NEC850_EIRET: int  # 112
NEC850_EST: int  # 226
NEC850_EXPQ31: int  # 379
NEC850_FERET: int  # 113
NEC850_FETRAP: int  # 114
NEC850_FLOORF_DL: int  # 181
NEC850_FLOORF_DUL: int  # 185
NEC850_FLOORF_DUW: int  # 186
NEC850_FLOORF_DW: int  # 182
NEC850_FLOORF_SL: int  # 183
NEC850_FLOORF_SUL: int  # 187
NEC850_FLOORF_SUW: int  # 188
NEC850_FLOORF_SUW4: int  # 434
NEC850_FLOORF_SW: int  # 184
NEC850_FLOORF_SW4: int  # 435
NEC850_FLPV_S4: int  # 383
NEC850_FMAF_S: int  # 218
NEC850_FMAF_S4: int  # 406
NEC850_FMSF_S: int  # 219
NEC850_FMSF_S4: int  # 407
NEC850_FNMAF_S: int  # 220
NEC850_FNMAF_S4: int  # 408
NEC850_FNMSF_S: int  # 221
NEC850_FNMSF_S4: int  # 409
NEC850_HALT: int  # 46
NEC850_HSH: int  # 101
NEC850_HSW: int  # 94
NEC850_HVCALL: int  # 229
NEC850_HVTRAP: int  # 228
NEC850_JARL: int  # 45
NEC850_JMP: int  # 44
NEC850_JR: int  # 43
NEC850_LAST_INSTRUCTION: int  # 441
NEC850_LDFC: int  # 124
NEC850_LDFF: int  # 125
NEC850_LDL_BU: int  # 259
NEC850_LDL_HU: int  # 260
NEC850_LDL_W: int  # 209
NEC850_LDM_MP: int  # 253
NEC850_LDSR: int  # 39
NEC850_LDTC_GR: int  # 232
NEC850_LDTC_PC: int  # 234
NEC850_LDTC_SR: int  # 236
NEC850_LDTC_VR: int  # 238
NEC850_LDVC_SR: int  # 230
NEC850_LDVZ_H4: int  # 388
NEC850_LDV_DW: int  # 385
NEC850_LDV_QW: int  # 386
NEC850_LDV_W: int  # 387
NEC850_LD_B: int  # 40
NEC850_LD_BU: int  # 98
NEC850_LD_DW: int  # 207
NEC850_LD_H: int  # 41
NEC850_LD_HU: int  # 99
NEC850_LD_W: int  # 42
NEC850_LOOP: int  # 206
NEC850_MAC: int  # 102
NEC850_MACU: int  # 103
NEC850_MADDF_S: int  # 151
NEC850_MAXF_D: int  # 135
NEC850_MAXF_S: int  # 136
NEC850_MAXF_S4: int  # 398
NEC850_MAXRF_S4: int  # 422
NEC850_MINF_D: int  # 137
NEC850_MINF_S: int  # 138
NEC850_MINF_S4: int  # 399
NEC850_MINRF_S4: int  # 423
NEC850_MODADD: int  # 312
NEC850_MOV: int  # 38
NEC850_MOVEA: int  # 37
NEC850_MOVHI: int  # 36
NEC850_MOVV_W4: int  # 382
NEC850_MOV_DW: int  # 290
NEC850_MOV_H: int  # 288
NEC850_MOV_W: int  # 289
NEC850_MSUBF_S: int  # 152
NEC850_MUL: int  # 86
NEC850_MULF_D: int  # 139
NEC850_MULF_S: int  # 140
NEC850_MULF_S4: int  # 400
NEC850_MULH: int  # 35
NEC850_MULHI: int  # 34
NEC850_MULRF_S4: int  # 424
NEC850_MULU: int  # 87
NEC850_MULXF_S4: int  # 415
NEC850_NEGF_D: int  # 141
NEC850_NEGF_S: int  # 142
NEC850_NEGF_S4: int  # 401
NEC850_NMADDF_S: int  # 153
NEC850_NMSUBF_S: int  # 154
NEC850_NOP: int  # 33
NEC850_NOT: int  # 32
NEC850_NOT1: int  # 31
NEC850_NULL: int  # 0
NEC850_OR: int  # 30
NEC850_ORI: int  # 29
NEC850_PKI16I32: int  # 368
NEC850_PKI16UI8: int  # 370
NEC850_PKI32I16: int  # 371
NEC850_PKI64I32: int  # 374
NEC850_PKQ15Q31: int  # 369
NEC850_PKQ30Q31: int  # 373
NEC850_PKQ31Q15: int  # 372
NEC850_PKUI8I16: int  # 367
NEC850_POPSP: int  # 215
NEC850_PREF: int  # 213
NEC850_PREPARE_i: int  # 85
NEC850_PREPARE_sp: int  # 84
NEC850_PUSHSP: int  # 214
NEC850_RECIPF_D: int  # 143
NEC850_RECIPF_S: int  # 144
NEC850_RECIPF_S4: int  # 402
NEC850_RESBANK: int  # 261
NEC850_RETI: int  # 28
NEC850_RIE: int  # 116
NEC850_RMTRAP: int  # 115
NEC850_ROTL: int  # 205
NEC850_ROUNDF_DL: int  # 245
NEC850_ROUNDF_DUL: int  # 247
NEC850_ROUNDF_DUW: int  # 248
NEC850_ROUNDF_DW: int  # 246
NEC850_ROUNDF_SL: int  # 249
NEC850_ROUNDF_SUL: int  # 251
NEC850_ROUNDF_SUW: int  # 252
NEC850_ROUNDF_SUW4: int  # 436
NEC850_ROUNDF_SW: int  # 250
NEC850_ROUNDF_SW4: int  # 437
NEC850_RSQRTF_D: int  # 145
NEC850_RSQRTF_S: int  # 146
NEC850_RSQRTF_S4: int  # 403
NEC850_SAR: int  # 27
NEC850_SASF: int  # 83
NEC850_SATADD: int  # 26
NEC850_SATSUB: int  # 25
NEC850_SATSUBI: int  # 24
NEC850_SATSUBR: int  # 23
NEC850_SBF: int  # 104
NEC850_SCH0L: int  # 105
NEC850_SCH0R: int  # 106
NEC850_SCH1L: int  # 107
NEC850_SCH1R: int  # 108
NEC850_SET1: int  # 21
NEC850_SETF: int  # 22
NEC850_SHFLV_W4: int  # 384
NEC850_SHL: int  # 20
NEC850_SHR: int  # 19
NEC850_SLD_B: int  # 16
NEC850_SLD_BU: int  # 96
NEC850_SLD_H: int  # 17
NEC850_SLD_HU: int  # 97
NEC850_SLD_W: int  # 18
NEC850_SNOOZE: int  # 203
NEC850_SQRTF_D: int  # 147
NEC850_SQRTF_S: int  # 148
NEC850_SQRTF_S4: int  # 404
NEC850_SST_B: int  # 13
NEC850_SST_H: int  # 14
NEC850_SST_W: int  # 15
NEC850_STC_B: int  # 262
NEC850_STC_H: int  # 263
NEC850_STC_W: int  # 210
NEC850_STFC: int  # 126
NEC850_STFF: int  # 127
NEC850_STM_MP: int  # 254
NEC850_STSR: int  # 9
NEC850_STTC_GR: int  # 233
NEC850_STTC_PC: int  # 235
NEC850_STTC_SR: int  # 237
NEC850_STTC_VR: int  # 239
NEC850_STVC_SR: int  # 231
NEC850_STVZ_H4: int  # 392
NEC850_STV_DW: int  # 389
NEC850_STV_QW: int  # 390
NEC850_STV_W: int  # 391
NEC850_ST_B: int  # 10
NEC850_ST_DW: int  # 208
NEC850_ST_H: int  # 11
NEC850_ST_W: int  # 12
NEC850_SUB: int  # 8
NEC850_SUBADDF_S4: int  # 412
NEC850_SUBADDNF_S4: int  # 413
NEC850_SUBADDNXF_S4: int  # 419
NEC850_SUBADDXF_S4: int  # 420
NEC850_SUBF_D: int  # 149
NEC850_SUBF_S: int  # 150
NEC850_SUBF_S4: int  # 405
NEC850_SUBR: int  # 7
NEC850_SUBRF_S4: int  # 425
NEC850_SUBXF_S4: int  # 416
NEC850_SWITCH: int  # 72
NEC850_SXB: int  # 74
NEC850_SXH: int  # 76
NEC850_SYNCE: int  # 117
NEC850_SYNCI: int  # 202
NEC850_SYNCM: int  # 118
NEC850_SYNCP: int  # 119
NEC850_SYSCALL: int  # 120
NEC850_TLBAI: int  # 240
NEC850_TLBR: int  # 241
NEC850_TLBS: int  # 242
NEC850_TLBVI: int  # 243
NEC850_TLBW: int  # 244
NEC850_TRAP: int  # 6
NEC850_TRFF: int  # 128
NEC850_TRFSR: int  # 201
NEC850_TRFSRV_W4: int  # 394
NEC850_TRNCF_DL: int  # 189
NEC850_TRNCF_DUL: int  # 190
NEC850_TRNCF_DUW: int  # 191
NEC850_TRNCF_DW: int  # 192
NEC850_TRNCF_SL: int  # 193
NEC850_TRNCF_SUL: int  # 194
NEC850_TRNCF_SUW: int  # 195
NEC850_TRNCF_SUW4: int  # 438
NEC850_TRNCF_SW: int  # 196
NEC850_TRNCF_SW4: int  # 439
NEC850_TRNC_SW: int  # 122
NEC850_TST: int  # 5
NEC850_TST1: int  # 4
NEC850_VABS_H: int  # 341
NEC850_VABS_W: int  # 342
NEC850_VADDSAT_H: int  # 319
NEC850_VADDSAT_W: int  # 320
NEC850_VADDS_H: int  # 323
NEC850_VADDS_W: int  # 324
NEC850_VADD_DW: int  # 315
NEC850_VADD_H: int  # 313
NEC850_VADD_W: int  # 314
NEC850_VAND: int  # 264
NEC850_VBIQ_H: int  # 366
NEC850_VBSWAP_DW: int  # 283
NEC850_VBSWAP_H: int  # 284
NEC850_VBSWAP_W: int  # 285
NEC850_VCALCH: int  # 380
NEC850_VCALCW: int  # 381
NEC850_VCMOV: int  # 311
NEC850_VCMPEQ_H: int  # 333
NEC850_VCMPEQ_W: int  # 334
NEC850_VCMPLE_H: int  # 337
NEC850_VCMPLE_W: int  # 338
NEC850_VCMPLT_H: int  # 335
NEC850_VCMPLT_W: int  # 336
NEC850_VCMPNE_H: int  # 339
NEC850_VCMPNE_W: int  # 340
NEC850_VCONCAT_B: int  # 277
NEC850_VITLVHW_H: int  # 280
NEC850_VITLVWH_H: int  # 281
NEC850_VITLV_H: int  # 278
NEC850_VITLV_W: int  # 279
NEC850_VLD_B: int  # 291
NEC850_VLD_B_FMT3: int  # 292
NEC850_VLD_B_FMT4: int  # 293
NEC850_VLD_DW: int  # 298
NEC850_VLD_DW_FMT3: int  # 299
NEC850_VLD_DW_FMT4: int  # 300
NEC850_VLD_DW_FMT5: int  # 301
NEC850_VLD_H: int  # 294
NEC850_VLD_H_FMT4: int  # 295
NEC850_VLD_W: int  # 296
NEC850_VLD_W_FMT4: int  # 297
NEC850_VMADRN_H: int  # 355
NEC850_VMADRN_W: int  # 356
NEC850_VMADSAT_H: int  # 353
NEC850_VMADSAT_W: int  # 354
NEC850_VMAXGE_H: int  # 346
NEC850_VMAXGE_W: int  # 350
NEC850_VMAXGT_H: int  # 345
NEC850_VMAXGT_W: int  # 349
NEC850_VMINLE_H: int  # 348
NEC850_VMINLE_W: int  # 352
NEC850_VMINLT_H: int  # 347
NEC850_VMINLT_W: int  # 351
NEC850_VMSUMADIM_H: int  # 363
NEC850_VMSUMADIM_W: int  # 364
NEC850_VMSUMADRE_H: int  # 361
NEC850_VMSUMADRE_W: int  # 362
NEC850_VMSUMADRN_H: int  # 365
NEC850_VMSUMAD_H: int  # 359
NEC850_VMSUMAD_W: int  # 360
NEC850_VMSUM_H: int  # 357
NEC850_VMSUM_W: int  # 358
NEC850_VMULCX_H: int  # 331
NEC850_VMULCX_W: int  # 332
NEC850_VMULT_H: int  # 329
NEC850_VMULT_W: int  # 330
NEC850_VMUL_H: int  # 327
NEC850_VMUL_W: int  # 328
NEC850_VNEG_H: int  # 343
NEC850_VNEG_W: int  # 344
NEC850_VNOT: int  # 267
NEC850_VOR: int  # 265
NEC850_VSAR_DW: int  # 270
NEC850_VSAR_H: int  # 268
NEC850_VSAR_W: int  # 269
NEC850_VSHL_DW: int  # 276
NEC850_VSHL_H: int  # 274
NEC850_VSHL_W: int  # 275
NEC850_VSHR_DW: int  # 273
NEC850_VSHR_H: int  # 271
NEC850_VSHR_W: int  # 272
NEC850_VSHUFL_B: int  # 282
NEC850_VST_B: int  # 302
NEC850_VST_B_FMT4: int  # 303
NEC850_VST_DW: int  # 308
NEC850_VST_DW_FMT6: int  # 310
NEC850_VST_DW_FMT_4_5: int  # 309
NEC850_VST_H: int  # 304
NEC850_VST_H_FMT_4_5: int  # 305
NEC850_VST_W: int  # 306
NEC850_VST_W_FMT_4_5: int  # 307
NEC850_VSUBSAT_H: int  # 321
NEC850_VSUBSAT_W: int  # 322
NEC850_VSUBS_H: int  # 325
NEC850_VSUBS_W: int  # 326
NEC850_VSUB_DW: int  # 318
NEC850_VSUB_H: int  # 316
NEC850_VSUB_W: int  # 317
NEC850_VXOR: int  # 266
NEC850_XOR: int  # 3
NEC850_XORI: int  # 2
NEC850_ZXB: int  # 73
NEC850_ZXH: int  # 75
NEC_78K_0S_DI: int  # 43
NEC_78K_0S_EI: int  # 42
NEC_78K_0S_HALT: int  # 44
NEC_78K_0S_STOP: int  # 45
NEC_78K_0S_add: int  # 5
NEC_78K_0S_addc: int  # 7
NEC_78K_0S_addw: int  # 10
NEC_78K_0S_and: int  # 3
NEC_78K_0S_bc: int  # 34
NEC_78K_0S_bf: int  # 39
NEC_78K_0S_bnc: int  # 35
NEC_78K_0S_bnz: int  # 37
NEC_78K_0S_br: int  # 33
NEC_78K_0S_bt: int  # 38
NEC_78K_0S_bz: int  # 36
NEC_78K_0S_call: int  # 20
NEC_78K_0S_callt: int  # 21
NEC_78K_0S_clr1: int  # 28
NEC_78K_0S_cmp: int  # 1
NEC_78K_0S_cmpw: int  # 11
NEC_78K_0S_dbnz: int  # 40
NEC_78K_0S_dec: int  # 13
NEC_78K_0S_decw: int  # 15
NEC_78K_0S_inc: int  # 12
NEC_78K_0S_incw: int  # 14
NEC_78K_0S_last: int  # 46
NEC_78K_0S_mov: int  # 24
NEC_78K_0S_movw: int  # 32
NEC_78K_0S_nop: int  # 41
NEC_78K_0S_not1: int  # 29
NEC_78K_0S_null: int  # 0
NEC_78K_0S_or: int  # 4
NEC_78K_0S_pop: int  # 31
NEC_78K_0S_push: int  # 30
NEC_78K_0S_ret: int  # 22
NEC_78K_0S_reti: int  # 23
NEC_78K_0S_rol: int  # 17
NEC_78K_0S_rolc: int  # 19
NEC_78K_0S_ror: int  # 16
NEC_78K_0S_rorc: int  # 18
NEC_78K_0S_set1: int  # 27
NEC_78K_0S_sub: int  # 6
NEC_78K_0S_subc: int  # 8
NEC_78K_0S_subw: int  # 9
NEC_78K_0S_xch: int  # 25
NEC_78K_0S_xchw: int  # 26
NEC_78K_0S_xor: int  # 2
NEC_78K_0_DI: int  # 58
NEC_78K_0_EI: int  # 57
NEC_78K_0_HALT: int  # 59
NEC_78K_0_STOP: int  # 60
NEC_78K_0_add: int  # 5
NEC_78K_0_addc: int  # 6
NEC_78K_0_addw: int  # 13
NEC_78K_0_adjba: int  # 28
NEC_78K_0_adjbs: int  # 29
NEC_78K_0_and: int  # 9
NEC_78K_0_and1: int  # 31
NEC_78K_0_bc: int  # 47
NEC_78K_0_bf: int  # 52
NEC_78K_0_bnc: int  # 48
NEC_78K_0_bnz: int  # 50
NEC_78K_0_br: int  # 46
NEC_78K_0_brk: int  # 40
NEC_78K_0_bt: int  # 51
NEC_78K_0_btclr: int  # 53
NEC_78K_0_bz: int  # 49
NEC_78K_0_call: int  # 37
NEC_78K_0_callf: int  # 38
NEC_78K_0_callt: int  # 39
NEC_78K_0_clr1: int  # 35
NEC_78K_0_cmp: int  # 12
NEC_78K_0_cmpw: int  # 15
NEC_78K_0_dbnz: int  # 54
NEC_78K_0_dec: int  # 19
NEC_78K_0_decw: int  # 21
NEC_78K_0_divuw: int  # 17
NEC_78K_0_inc: int  # 18
NEC_78K_0_incw: int  # 20
NEC_78K_0_last: int  # 61
NEC_78K_0_mov: int  # 1
NEC_78K_0_mov1: int  # 30
NEC_78K_0_movw: int  # 3
NEC_78K_0_mulu: int  # 16
NEC_78K_0_nop: int  # 56
NEC_78K_0_not1: int  # 36
NEC_78K_0_null: int  # 0
NEC_78K_0_or: int  # 10
NEC_78K_0_or1: int  # 32
NEC_78K_0_pop: int  # 45
NEC_78K_0_push: int  # 44
NEC_78K_0_ret: int  # 41
NEC_78K_0_retb: int  # 42
NEC_78K_0_reti: int  # 43
NEC_78K_0_rol: int  # 23
NEC_78K_0_rol4: int  # 27
NEC_78K_0_rolc: int  # 25
NEC_78K_0_ror: int  # 22
NEC_78K_0_ror4: int  # 26
NEC_78K_0_rorc: int  # 24
NEC_78K_0_sel: int  # 55
NEC_78K_0_set1: int  # 34
NEC_78K_0_sub: int  # 7
NEC_78K_0_subc: int  # 8
NEC_78K_0_subw: int  # 14
NEC_78K_0_xch: int  # 2
NEC_78K_0_xchw: int  # 4
NEC_78K_0_xor: int  # 11
NEC_78K_0_xor1: int  # 33
NEF_CODE: int  # 256
NEF_FILL: int  # 16
NEF_FIRST: int  # 128
NEF_FLAT: int  # 1024
NEF_IMPS: int  # 32
NEF_LALL: int  # 8192
NEF_LOPT: int  # 4096
NEF_MAN: int  # 8
NEF_MINI: int  # 2048
NEF_NAME: int  # 4
NEF_RELOAD: int  # 512
NEF_RSCS: int  # 2
NEF_SEGS: int  # 1
NETMAP_IDX: int  # 256
NETMAP_STR: int  # 1024
NETMAP_V8: int  # 4096
NETMAP_VAL: int  # 512
NETMAP_VAL_NDX: int  # 8192
NETMAP_X8: int  # 2048
NET_add: int  # 1
NET_add_ovf: int  # 2
NET_add_ovf_un: int  # 3
NET_and: int  # 4
NET_ann_arg: int  # 5
NET_ann_call: int  # 6
NET_ann_catch: int  # 7
NET_ann_data: int  # 8
NET_ann_data_s: int  # 9
NET_ann_dead: int  # 10
NET_ann_def: int  # 11
NET_ann_hoisted: int  # 12
NET_ann_hoisted_call: int  # 13
NET_ann_lab: int  # 14
NET_ann_live: int  # 15
NET_ann_phi: int  # 16
NET_ann_ref: int  # 17
NET_ann_ref_s: int  # 18
NET_arglist: int  # 19
NET_beq: int  # 20
NET_beq_s: int  # 21
NET_bge: int  # 22
NET_bge_s: int  # 23
NET_bge_un: int  # 24
NET_bge_un_s: int  # 25
NET_bgt: int  # 26
NET_bgt_s: int  # 27
NET_bgt_un: int  # 28
NET_bgt_un_s: int  # 29
NET_ble: int  # 30
NET_ble_s: int  # 31
NET_ble_un: int  # 32
NET_ble_un_s: int  # 33
NET_blt: int  # 34
NET_blt_s: int  # 35
NET_blt_un: int  # 36
NET_blt_un_s: int  # 37
NET_bne_un: int  # 38
NET_bne_un_s: int  # 39
NET_box: int  # 40
NET_br: int  # 41
NET_br_s: int  # 42
NET_break: int  # 43
NET_brfalse: int  # 44
NET_brfalse_s: int  # 45
NET_brtrue: int  # 46
NET_brtrue_s: int  # 47
NET_call: int  # 48
NET_calli: int  # 49
NET_callvirt: int  # 50
NET_castclass: int  # 51
NET_ceq: int  # 52
NET_cgt: int  # 53
NET_cgt_un: int  # 54
NET_ckfinite: int  # 55
NET_clt: int  # 56
NET_clt_un: int  # 57
NET_constrained_: int  # 231
NET_conv_i: int  # 58
NET_conv_i1: int  # 59
NET_conv_i2: int  # 60
NET_conv_i4: int  # 61
NET_conv_i8: int  # 62
NET_conv_ovf_i: int  # 63
NET_conv_ovf_i1: int  # 64
NET_conv_ovf_i1_un: int  # 65
NET_conv_ovf_i2: int  # 66
NET_conv_ovf_i2_un: int  # 67
NET_conv_ovf_i4: int  # 68
NET_conv_ovf_i4_un: int  # 69
NET_conv_ovf_i8: int  # 70
NET_conv_ovf_i8_un: int  # 71
NET_conv_ovf_i_un: int  # 72
NET_conv_ovf_u: int  # 73
NET_conv_ovf_u1: int  # 74
NET_conv_ovf_u1_un: int  # 75
NET_conv_ovf_u2: int  # 76
NET_conv_ovf_u2_un: int  # 77
NET_conv_ovf_u4: int  # 78
NET_conv_ovf_u4_un: int  # 79
NET_conv_ovf_u8: int  # 80
NET_conv_ovf_u8_un: int  # 81
NET_conv_ovf_u_un: int  # 82
NET_conv_r4: int  # 83
NET_conv_r8: int  # 84
NET_conv_r_un: int  # 85
NET_conv_u: int  # 86
NET_conv_u1: int  # 87
NET_conv_u2: int  # 88
NET_conv_u4: int  # 89
NET_conv_u8: int  # 90
NET_cpblk: int  # 91
NET_cpobj: int  # 92
NET_div: int  # 93
NET_div_un: int  # 94
NET_dup: int  # 95
NET_endfilter: int  # 96
NET_endfinally: int  # 97
NET_initblk: int  # 98
NET_initobj: int  # 99
NET_isinst: int  # 100
NET_jmp: int  # 101
NET_last: int  # 234
NET_ldarg: int  # 102
NET_ldarg_0: int  # 103
NET_ldarg_1: int  # 104
NET_ldarg_2: int  # 105
NET_ldarg_3: int  # 106
NET_ldarg_s: int  # 107
NET_ldarga: int  # 108
NET_ldarga_s: int  # 109
NET_ldc_i4: int  # 110
NET_ldc_i4_0: int  # 111
NET_ldc_i4_1: int  # 112
NET_ldc_i4_2: int  # 113
NET_ldc_i4_3: int  # 114
NET_ldc_i4_4: int  # 115
NET_ldc_i4_5: int  # 116
NET_ldc_i4_6: int  # 117
NET_ldc_i4_7: int  # 118
NET_ldc_i4_8: int  # 119
NET_ldc_i4_m1: int  # 120
NET_ldc_i4_s: int  # 121
NET_ldc_i8: int  # 122
NET_ldc_r4: int  # 123
NET_ldc_r8: int  # 124
NET_ldelem: int  # 228
NET_ldelem_i: int  # 125
NET_ldelem_i1: int  # 126
NET_ldelem_i2: int  # 127
NET_ldelem_i4: int  # 128
NET_ldelem_i8: int  # 129
NET_ldelem_r4: int  # 130
NET_ldelem_r8: int  # 131
NET_ldelem_ref: int  # 132
NET_ldelem_u1: int  # 133
NET_ldelem_u2: int  # 134
NET_ldelem_u4: int  # 135
NET_ldelema: int  # 136
NET_ldfld: int  # 137
NET_ldflda: int  # 138
NET_ldftn: int  # 139
NET_ldind_i: int  # 140
NET_ldind_i1: int  # 141
NET_ldind_i2: int  # 142
NET_ldind_i4: int  # 143
NET_ldind_i8: int  # 144
NET_ldind_r4: int  # 145
NET_ldind_r8: int  # 146
NET_ldind_ref: int  # 147
NET_ldind_u1: int  # 148
NET_ldind_u2: int  # 149
NET_ldind_u4: int  # 150
NET_ldlen: int  # 151
NET_ldloc: int  # 152
NET_ldloc_0: int  # 153
NET_ldloc_1: int  # 154
NET_ldloc_2: int  # 155
NET_ldloc_3: int  # 156
NET_ldloc_s: int  # 157
NET_ldloca: int  # 158
NET_ldloca_s: int  # 159
NET_ldnull: int  # 160
NET_ldobj: int  # 161
NET_ldsfld: int  # 162
NET_ldsflda: int  # 163
NET_ldstr: int  # 164
NET_ldtoken: int  # 165
NET_ldvirtftn: int  # 166
NET_leave: int  # 167
NET_leave_s: int  # 168
NET_localloc: int  # 169
NET_mkrefany: int  # 170
NET_mul: int  # 171
NET_mul_ovf: int  # 172
NET_mul_ovf_un: int  # 173
NET_neg: int  # 174
NET_newarr: int  # 175
NET_newobj: int  # 176
NET_no_: int  # 232
NET_nop: int  # 177
NET_not: int  # 178
NET_null: int  # 0
NET_or: int  # 179
NET_pop: int  # 180
NET_readonly_: int  # 233
NET_refanytype: int  # 181
NET_refanyval: int  # 182
NET_rem: int  # 183
NET_rem_un: int  # 184
NET_ret: int  # 185
NET_rethrow: int  # 186
NET_shl: int  # 187
NET_shr: int  # 188
NET_shr_un: int  # 189
NET_sizeof: int  # 190
NET_starg: int  # 191
NET_starg_s: int  # 192
NET_stelem: int  # 229
NET_stelem_i: int  # 193
NET_stelem_i1: int  # 194
NET_stelem_i2: int  # 195
NET_stelem_i4: int  # 196
NET_stelem_i8: int  # 197
NET_stelem_r4: int  # 198
NET_stelem_r8: int  # 199
NET_stelem_ref: int  # 200
NET_stfld: int  # 201
NET_stind_i: int  # 202
NET_stind_i1: int  # 203
NET_stind_i2: int  # 204
NET_stind_i4: int  # 205
NET_stind_i8: int  # 206
NET_stind_r4: int  # 207
NET_stind_r8: int  # 208
NET_stind_ref: int  # 209
NET_stloc: int  # 210
NET_stloc_0: int  # 211
NET_stloc_1: int  # 212
NET_stloc_2: int  # 213
NET_stloc_3: int  # 214
NET_stloc_s: int  # 215
NET_stobj: int  # 216
NET_stsfld: int  # 217
NET_sub: int  # 218
NET_sub_ovf: int  # 219
NET_sub_ovf_un: int  # 220
NET_switch: int  # 221
NET_tail_: int  # 222
NET_throw: int  # 223
NET_unaligned_: int  # 224
NET_unbox: int  # 225
NET_unbox_any: int  # 230
NET_volatile_: int  # 226
NET_xor: int  # 227
NF_BINVDONE: int  # 4
NF_BITNOT: int  # 16
NF_FIXED: int  # 1
NF_NEGATE: int  # 8
NF_NEGDONE: int  # 2
NF_VALID: int  # 32
NIFF_SHOW_CONTENTS: int  # 1
NIF_ALL: int  # 31
NIF_BG_COLOR: int  # 1
NIF_EA: int  # 4
NIF_FLAGS: int  # 16
NIF_FRAME_COLOR: int  # 2
NIF_TEXT: int  # 8
NM_EA: int  # 6
NM_EA4: int  # 7
NM_EA8: int  # 8
NM_NAM_EA: int  # 5
NM_NAM_OFF: int  # 2
NM_PTR_EA: int  # 4
NM_PTR_OFF: int  # 1
NM_REL_EA: int  # 3
NM_REL_OFF: int  # 0
NM_SERIAL: int  # 10
NM_SHORT: int  # 9
NN_aaa: int  # 1
NN_aad: int  # 2
NN_aam: int  # 3
NN_aas: int  # 4
NN_adc: int  # 5
NN_adcx: int  # 743
NN_add: int  # 6
NN_addpd: int  # 519
NN_addps: int  # 424
NN_addsd: int  # 520
NN_addss: int  # 425
NN_addsubpd: int  # 596
NN_addsubps: int  # 597
NN_adox: int  # 744
NN_aesdec: int  # 731
NN_aesdeclast: int  # 732
NN_aesenc: int  # 729
NN_aesenclast: int  # 730
NN_aesimc: int  # 733
NN_aeskeygenassist: int  # 734
NN_and: int  # 7
NN_andn: int  # 745
NN_andnpd: int  # 521
NN_andnps: int  # 426
NN_andpd: int  # 522
NN_andps: int  # 427
NN_arpl: int  # 8
NN_bextr: int  # 746
NN_blendpd: int  # 652
NN_blendps: int  # 653
NN_blendvpd: int  # 654
NN_blendvps: int  # 655
NN_blsi: int  # 747
NN_blsmsk: int  # 748
NN_blsr: int  # 749
NN_bndcl: int  # 1160
NN_bndcn: int  # 1162
NN_bndcu: int  # 1161
NN_bndldx: int  # 1164
NN_bndmk: int  # 1159
NN_bndmov: int  # 1163
NN_bndstx: int  # 1165
NN_bound: int  # 9
NN_bsf: int  # 10
NN_bsr: int  # 11
NN_bswap: int  # 218
NN_bt: int  # 12
NN_btc: int  # 13
NN_btr: int  # 14
NN_bts: int  # 15
NN_bzhi: int  # 750
NN_call: int  # 16
NN_callfi: int  # 17
NN_callni: int  # 18
NN_cbw: int  # 19
NN_cdq: int  # 30
NN_cdqe: int  # 21
NN_clac: int  # 751
NN_clc: int  # 22
NN_cld: int  # 23
NN_cldemote: int  # 1783
NN_clflush: int  # 523
NN_clflushopt: int  # 1170
NN_clgi: int  # 717
NN_cli: int  # 24
NN_clrssbsy: int  # 1774
NN_clts: int  # 25
NN_clui: int  # 1935
NN_clwb: int  # 1171
NN_clzero: int  # 1751
NN_cmc: int  # 26
NN_cmova: int  # 229
NN_cmovb: int  # 230
NN_cmovbe: int  # 231
NN_cmovg: int  # 232
NN_cmovge: int  # 233
NN_cmovl: int  # 234
NN_cmovle: int  # 235
NN_cmovnb: int  # 236
NN_cmovno: int  # 237
NN_cmovnp: int  # 238
NN_cmovns: int  # 239
NN_cmovnz: int  # 240
NN_cmovo: int  # 241
NN_cmovp: int  # 242
NN_cmovs: int  # 243
NN_cmovz: int  # 244
NN_cmp: int  # 27
NN_cmpeqpd: int  # 636
NN_cmpeqps: int  # 489
NN_cmpeqsd: int  # 644
NN_cmpeqss: int  # 497
NN_cmplepd: int  # 638
NN_cmpleps: int  # 491
NN_cmplesd: int  # 646
NN_cmpless: int  # 499
NN_cmpltpd: int  # 637
NN_cmpltps: int  # 490
NN_cmpltsd: int  # 645
NN_cmpltss: int  # 498
NN_cmpneqpd: int  # 640
NN_cmpneqps: int  # 493
NN_cmpneqsd: int  # 648
NN_cmpneqss: int  # 501
NN_cmpnlepd: int  # 642
NN_cmpnleps: int  # 495
NN_cmpnlesd: int  # 650
NN_cmpnless: int  # 503
NN_cmpnltpd: int  # 641
NN_cmpnltps: int  # 494
NN_cmpnltsd: int  # 649
NN_cmpnltss: int  # 502
NN_cmpordpd: int  # 643
NN_cmpordps: int  # 496
NN_cmpordsd: int  # 651
NN_cmpordss: int  # 504
NN_cmppd: int  # 524
NN_cmpps: int  # 428
NN_cmps: int  # 28
NN_cmpsd: int  # 525
NN_cmpss: int  # 429
NN_cmpunordpd: int  # 639
NN_cmpunordps: int  # 492
NN_cmpunordsd: int  # 647
NN_cmpunordss: int  # 500
NN_cmpxchg: int  # 217
NN_cmpxchg16b: int  # 595
NN_cmpxchg8b: int  # 226
NN_comisd: int  # 526
NN_comiss: int  # 430
NN_cpuid: int  # 225
NN_cqo: int  # 31
NN_crc32: int  # 700
NN_cvtdq2pd: int  # 527
NN_cvtdq2ps: int  # 528
NN_cvtpd2dq: int  # 529
NN_cvtpd2pi: int  # 530
NN_cvtpd2ps: int  # 531
NN_cvtpi2pd: int  # 532
NN_cvtpi2ps: int  # 431
NN_cvtps2dq: int  # 533
NN_cvtps2pd: int  # 534
NN_cvtps2pi: int  # 432
NN_cvtsd2si: int  # 535
NN_cvtsd2ss: int  # 536
NN_cvtsi2sd: int  # 537
NN_cvtsi2ss: int  # 433
NN_cvtss2sd: int  # 538
NN_cvtss2si: int  # 434
NN_cvttpd2dq: int  # 539
NN_cvttpd2pi: int  # 540
NN_cvttps2dq: int  # 541
NN_cvttps2pi: int  # 435
NN_cvttsd2si: int  # 542
NN_cvttss2si: int  # 436
NN_cwd: int  # 29
NN_cwde: int  # 20
NN_daa: int  # 32
NN_das: int  # 33
NN_dec: int  # 34
NN_div: int  # 35
NN_divpd: int  # 543
NN_divps: int  # 437
NN_divsd: int  # 544
NN_divss: int  # 438
NN_dppd: int  # 656
NN_dpps: int  # 657
NN_emms: int  # 351
NN_encls: int  # 1628
NN_enclu: int  # 1629
NN_enclv: int  # 1784
NN_endbr32: int  # 1776
NN_endbr64: int  # 1775
NN_enqcmd: int  # 1779
NN_enqcmds: int  # 1780
NN_enter: int  # 37
NN_enterd: int  # 38
NN_enterq: int  # 39
NN_enterw: int  # 36
NN_extractps: int  # 658
NN_extrq: int  # 707
NN_f2xm1: int  # 301
NN_fabs: int  # 290
NN_fadd: int  # 267
NN_faddp: int  # 268
NN_fbld: int  # 265
NN_fbstp: int  # 266
NN_fchs: int  # 291
NN_fclex: int  # 319
NN_fcmovb: int  # 245
NN_fcmovbe: int  # 247
NN_fcmove: int  # 246
NN_fcmovnb: int  # 249
NN_fcmovnbe: int  # 251
NN_fcmovne: int  # 250
NN_fcmovnu: int  # 252
NN_fcmovu: int  # 248
NN_fcom: int  # 292
NN_fcom2: int  # 511
NN_fcomi: int  # 253
NN_fcomip: int  # 255
NN_fcomp: int  # 293
NN_fcomp3: int  # 512
NN_fcomp5: int  # 514
NN_fcompp: int  # 294
NN_fcos: int  # 338
NN_fdecstp: int  # 328
NN_fdisi: int  # 333
NN_fdiv: int  # 279
NN_fdivp: int  # 280
NN_fdivr: int  # 282
NN_fdivrp: int  # 283
NN_femms: int  # 421
NN_feni: int  # 331
NN_ffree: int  # 329
NN_ffreep: int  # 515
NN_fiadd: int  # 269
NN_ficom: int  # 295
NN_ficomp: int  # 296
NN_fidiv: int  # 281
NN_fidivr: int  # 284
NN_fild: int  # 262
NN_fimul: int  # 278
NN_fincstp: int  # 327
NN_finit: int  # 311
NN_fist: int  # 263
NN_fistp: int  # 264
NN_fisttp: int  # 604
NN_fisub: int  # 272
NN_fisubr: int  # 275
NN_fld: int  # 258
NN_fld1: int  # 305
NN_fldcw: int  # 314
NN_fldenv: int  # 323
NN_fldl2e: int  # 308
NN_fldl2t: int  # 307
NN_fldlg2: int  # 309
NN_fldln2: int  # 310
NN_fldpi: int  # 306
NN_fldz: int  # 304
NN_fmul: int  # 276
NN_fmulp: int  # 277
NN_fnclex: int  # 320
NN_fndisi: int  # 334
NN_fneni: int  # 332
NN_fninit: int  # 312
NN_fnop: int  # 330
NN_fnsave: int  # 325
NN_fnstcw: int  # 316
NN_fnstenv: int  # 322
NN_fnstsw: int  # 318
NN_fpatan: int  # 300
NN_fprem: int  # 287
NN_fprem1: int  # 335
NN_fptan: int  # 299
NN_frndint: int  # 288
NN_frstor: int  # 326
NN_fsave: int  # 324
NN_fscale: int  # 286
NN_fsetpm: int  # 313
NN_fsin: int  # 337
NN_fsincos: int  # 336
NN_fsqrt: int  # 285
NN_fst: int  # 259
NN_fstcw: int  # 315
NN_fstenv: int  # 321
NN_fstp: int  # 260
NN_fstp1: int  # 510
NN_fstp8: int  # 517
NN_fstp9: int  # 518
NN_fstsw: int  # 317
NN_fsub: int  # 270
NN_fsubp: int  # 271
NN_fsubr: int  # 273
NN_fsubrp: int  # 274
NN_ftst: int  # 297
NN_fucom: int  # 339
NN_fucomi: int  # 254
NN_fucomip: int  # 256
NN_fucomp: int  # 340
NN_fucompp: int  # 341
NN_fxam: int  # 298
NN_fxch: int  # 261
NN_fxch4: int  # 513
NN_fxch7: int  # 516
NN_fxrstor: int  # 399
NN_fxrstor64: int  # 1800
NN_fxsave: int  # 398
NN_fxsave64: int  # 1799
NN_fxtract: int  # 289
NN_fyl2x: int  # 302
NN_fyl2xp1: int  # 303
NN_getsec: int  # 716
NN_gf2p8affineinvqb: int  # 1795
NN_gf2p8affineqb: int  # 1794
NN_gf2p8mulb: int  # 1793
NN_haddpd: int  # 598
NN_haddps: int  # 599
NN_hlt: int  # 40
NN_hreset: int  # 1940
NN_hsubpd: int  # 600
NN_hsubps: int  # 601
NN_icebp: int  # 349
NN_idiv: int  # 41
NN_imul: int  # 42
NN_in: int  # 43
NN_inc: int  # 44
NN_incsspd: int  # 1763
NN_incsspq: int  # 1764
NN_ins: int  # 45
NN_insertps: int  # 659
NN_insertq: int  # 708
NN_int: int  # 46
NN_int3: int  # 48
NN_into: int  # 47
NN_invd: int  # 220
NN_invept: int  # 726
NN_invlpg: int  # 222
NN_invlpga: int  # 718
NN_invpcid: int  # 762
NN_invvpid: int  # 727
NN_iret: int  # 50
NN_iretd: int  # 51
NN_iretq: int  # 52
NN_iretw: int  # 49
NN_ja: int  # 53
NN_jae: int  # 54
NN_jb: int  # 55
NN_jbe: int  # 56
NN_jc: int  # 57
NN_jcxz: int  # 58
NN_je: int  # 61
NN_jecxz: int  # 59
NN_jg: int  # 62
NN_jge: int  # 63
NN_jl: int  # 64
NN_jle: int  # 65
NN_jmp: int  # 86
NN_jmpfi: int  # 87
NN_jmpni: int  # 88
NN_jmpshort: int  # 89
NN_jna: int  # 66
NN_jnae: int  # 67
NN_jnb: int  # 68
NN_jnbe: int  # 69
NN_jnc: int  # 70
NN_jne: int  # 71
NN_jng: int  # 72
NN_jnge: int  # 73
NN_jnl: int  # 74
NN_jnle: int  # 75
NN_jno: int  # 76
NN_jnp: int  # 77
NN_jns: int  # 78
NN_jnz: int  # 79
NN_jo: int  # 80
NN_jp: int  # 81
NN_jpe: int  # 82
NN_jpo: int  # 83
NN_jrcxz: int  # 60
NN_js: int  # 84
NN_jz: int  # 85
NN_kaddb: int  # 1571
NN_kaddd: int  # 1573
NN_kaddq: int  # 1572
NN_kaddw: int  # 1570
NN_kandb: int  # 1575
NN_kandd: int  # 1577
NN_kandnb: int  # 1579
NN_kandnd: int  # 1581
NN_kandnq: int  # 1580
NN_kandnw: int  # 1578
NN_kandq: int  # 1576
NN_kandw: int  # 1574
NN_kmovb: int  # 1583
NN_kmovd: int  # 1585
NN_kmovq: int  # 1584
NN_kmovw: int  # 1582
NN_knotb: int  # 1590
NN_knotd: int  # 1592
NN_knotq: int  # 1591
NN_knotw: int  # 1589
NN_korb: int  # 1594
NN_kord: int  # 1596
NN_korq: int  # 1595
NN_kortestb: int  # 1598
NN_kortestd: int  # 1600
NN_kortestq: int  # 1599
NN_kortestw: int  # 1597
NN_korw: int  # 1593
NN_kshiftlb: int  # 1602
NN_kshiftld: int  # 1604
NN_kshiftlq: int  # 1603
NN_kshiftlw: int  # 1601
NN_kshiftrb: int  # 1606
NN_kshiftrd: int  # 1608
NN_kshiftrq: int  # 1607
NN_kshiftrw: int  # 1605
NN_ktestb: int  # 1614
NN_ktestd: int  # 1616
NN_ktestq: int  # 1615
NN_ktestw: int  # 1613
NN_kunpckbw: int  # 1586
NN_kunpckdq: int  # 1588
NN_kunpckwd: int  # 1587
NN_kxnorb: int  # 1610
NN_kxnord: int  # 1612
NN_kxnorq: int  # 1611
NN_kxnorw: int  # 1609
NN_kxorb: int  # 1618
NN_kxord: int  # 1620
NN_kxorq: int  # 1619
NN_kxorw: int  # 1617
NN_lahf: int  # 90
NN_lar: int  # 91
NN_last: int  # 1941
NN_lddqu: int  # 605
NN_ldmxcsr: int  # 439
NN_lds: int  # 101
NN_lea: int  # 92
NN_leave: int  # 94
NN_leaved: int  # 95
NN_leaveq: int  # 96
NN_leavew: int  # 93
NN_les: int  # 102
NN_lfence: int  # 545
NN_lfs: int  # 103
NN_lgdt: int  # 97
NN_lgs: int  # 99
NN_lidt: int  # 98
NN_lldt: int  # 104
NN_lmsw: int  # 105
NN_loadall: int  # 350
NN_lock: int  # 106
NN_lods: int  # 107
NN_loop: int  # 109
NN_loopd: int  # 110
NN_loopde: int  # 114
NN_loopdne: int  # 118
NN_loope: int  # 113
NN_loopne: int  # 117
NN_loopq: int  # 111
NN_loopqe: int  # 115
NN_loopqne: int  # 119
NN_loopw: int  # 108
NN_loopwe: int  # 112
NN_loopwne: int  # 116
NN_lsl: int  # 120
NN_lss: int  # 100
NN_ltr: int  # 121
NN_lzcnt: int  # 711
NN_maskmovdqu: int  # 546
NN_maskmovq: int  # 481
NN_maxpd: int  # 547
NN_maxps: int  # 440
NN_maxsd: int  # 548
NN_maxss: int  # 441
NN_mcommit: int  # 1781
NN_mfence: int  # 549
NN_minpd: int  # 550
NN_minps: int  # 442
NN_minsd: int  # 551
NN_minss: int  # 443
NN_monitor: int  # 602
NN_monitorx: int  # 1749
NN_mov: int  # 122
NN_movapd: int  # 552
NN_movaps: int  # 444
NN_movbe: int  # 728
NN_movd: int  # 352
NN_movddup: int  # 591
NN_movdir64b: int  # 1786
NN_movdiri: int  # 1785
NN_movdq2q: int  # 553
NN_movdqa: int  # 554
NN_movdqu: int  # 555
NN_movhlps: int  # 445
NN_movhpd: int  # 556
NN_movhps: int  # 446
NN_movlhps: int  # 447
NN_movlpd: int  # 557
NN_movlps: int  # 448
NN_movmskpd: int  # 558
NN_movmskps: int  # 449
NN_movntdq: int  # 559
NN_movntdqa: int  # 660
NN_movnti: int  # 560
NN_movntpd: int  # 561
NN_movntps: int  # 482
NN_movntq: int  # 483
NN_movntsd: int  # 709
NN_movntss: int  # 710
NN_movq: int  # 353
NN_movq2dq: int  # 562
NN_movs: int  # 124
NN_movsd: int  # 563
NN_movshdup: int  # 592
NN_movsldup: int  # 593
NN_movsp: int  # 123
NN_movss: int  # 450
NN_movsx: int  # 125
NN_movsxd: int  # 594
NN_movupd: int  # 564
NN_movups: int  # 451
NN_movzx: int  # 126
NN_mpsadbw: int  # 661
NN_mul: int  # 127
NN_mulpd: int  # 565
NN_mulps: int  # 452
NN_mulsd: int  # 566
NN_mulss: int  # 453
NN_mulx: int  # 752
NN_mwait: int  # 603
NN_mwaitx: int  # 1750
NN_neg: int  # 128
NN_nop: int  # 129
NN_not: int  # 130
NN_null: int  # 0
NN_or: int  # 131
NN_orpd: int  # 567
NN_orps: int  # 454
NN_out: int  # 132
NN_outs: int  # 133
NN_pabsb: int  # 619
NN_pabsd: int  # 621
NN_pabsw: int  # 620
NN_packssdw: int  # 355
NN_packsswb: int  # 354
NN_packusdw: int  # 662
NN_packuswb: int  # 356
NN_paddb: int  # 357
NN_paddd: int  # 359
NN_paddq: int  # 568
NN_paddsb: int  # 360
NN_paddsw: int  # 361
NN_paddusb: int  # 362
NN_paddusw: int  # 363
NN_paddw: int  # 358
NN_palignr: int  # 618
NN_pand: int  # 364
NN_pandn: int  # 365
NN_pause: int  # 569
NN_pavgb: int  # 469
NN_pavgusb: int  # 402
NN_pavgw: int  # 470
NN_pblendvb: int  # 663
NN_pblendw: int  # 664
NN_pclmulqdq: int  # 735
NN_pcmpeqb: int  # 366
NN_pcmpeqd: int  # 368
NN_pcmpeqq: int  # 665
NN_pcmpeqw: int  # 367
NN_pcmpestri: int  # 701
NN_pcmpestrm: int  # 702
NN_pcmpgtb: int  # 369
NN_pcmpgtd: int  # 371
NN_pcmpgtq: int  # 705
NN_pcmpgtw: int  # 370
NN_pcmpistri: int  # 703
NN_pcmpistrm: int  # 704
NN_pcommit: int  # 1172
NN_pdep: int  # 753
NN_pext: int  # 754
NN_pextrb: int  # 666
NN_pextrd: int  # 667
NN_pextrq: int  # 668
NN_pextrw: int  # 471
NN_pf2id: int  # 413
NN_pf2iw: int  # 505
NN_pfacc: int  # 406
NN_pfadd: int  # 403
NN_pfcmpeq: int  # 409
NN_pfcmpge: int  # 407
NN_pfcmpgt: int  # 408
NN_pfmax: int  # 411
NN_pfmin: int  # 410
NN_pfmul: int  # 416
NN_pfnacc: int  # 506
NN_pfpnacc: int  # 507
NN_pfrcp: int  # 414
NN_pfrcpit1: int  # 417
NN_pfrcpit2: int  # 419
NN_pfrcpv: int  # 634
NN_pfrsqit1: int  # 418
NN_pfrsqrt: int  # 415
NN_pfrsqrtv: int  # 635
NN_pfsub: int  # 404
NN_pfsubr: int  # 405
NN_phaddd: int  # 615
NN_phaddsw: int  # 613
NN_phaddw: int  # 614
NN_phminposuw: int  # 669
NN_phsubd: int  # 617
NN_phsubsw: int  # 612
NN_phsubw: int  # 616
NN_pi2fd: int  # 412
NN_pi2fw: int  # 508
NN_pinsrb: int  # 670
NN_pinsrd: int  # 671
NN_pinsrq: int  # 672
NN_pinsrw: int  # 472
NN_pmaddubsw: int  # 611
NN_pmaddwd: int  # 372
NN_pmaxsb: int  # 673
NN_pmaxsd: int  # 674
NN_pmaxsw: int  # 473
NN_pmaxub: int  # 474
NN_pmaxud: int  # 675
NN_pmaxuw: int  # 676
NN_pminsb: int  # 677
NN_pminsd: int  # 678
NN_pminsw: int  # 475
NN_pminub: int  # 476
NN_pminud: int  # 679
NN_pminuw: int  # 680
NN_pmovmskb: int  # 477
NN_pmovsxbd: int  # 682
NN_pmovsxbq: int  # 683
NN_pmovsxbw: int  # 681
NN_pmovsxdq: int  # 686
NN_pmovsxwd: int  # 684
NN_pmovsxwq: int  # 685
NN_pmovzxbd: int  # 688
NN_pmovzxbq: int  # 689
NN_pmovzxbw: int  # 687
NN_pmovzxdq: int  # 692
NN_pmovzxwd: int  # 690
NN_pmovzxwq: int  # 691
NN_pmuldq: int  # 693
NN_pmulhrsw: int  # 610
NN_pmulhrw: int  # 420
NN_pmulhuw: int  # 478
NN_pmulhw: int  # 373
NN_pmulld: int  # 694
NN_pmullw: int  # 374
NN_pmuludq: int  # 570
NN_pop: int  # 134
NN_popa: int  # 136
NN_popad: int  # 137
NN_popaq: int  # 138
NN_popaw: int  # 135
NN_popcnt: int  # 706
NN_popf: int  # 140
NN_popfd: int  # 141
NN_popfq: int  # 142
NN_popfw: int  # 139
NN_por: int  # 375
NN_prefetch: int  # 422
NN_prefetchnta: int  # 487
NN_prefetcht0: int  # 484
NN_prefetcht1: int  # 485
NN_prefetcht2: int  # 486
NN_prefetchw: int  # 423
NN_prefetchwt1: int  # 1169
NN_psadbw: int  # 479
NN_pshufb: int  # 609
NN_pshufd: int  # 571
NN_pshufhw: int  # 572
NN_pshuflw: int  # 573
NN_pshufw: int  # 480
NN_psignb: int  # 606
NN_psignd: int  # 608
NN_psignw: int  # 607
NN_pslld: int  # 377
NN_pslldq: int  # 574
NN_psllq: int  # 378
NN_psllw: int  # 376
NN_psrad: int  # 380
NN_psraw: int  # 379
NN_psrld: int  # 382
NN_psrldq: int  # 575
NN_psrlq: int  # 383
NN_psrlw: int  # 381
NN_psubb: int  # 384
NN_psubd: int  # 386
NN_psubq: int  # 576
NN_psubsb: int  # 387
NN_psubsw: int  # 388
NN_psubusb: int  # 389
NN_psubusw: int  # 390
NN_psubw: int  # 385
NN_pswapd: int  # 509
NN_ptest: int  # 695
NN_ptwrite: int  # 1752
NN_punpckhbw: int  # 391
NN_punpckhdq: int  # 393
NN_punpckhqdq: int  # 577
NN_punpckhwd: int  # 392
NN_punpcklbw: int  # 394
NN_punpckldq: int  # 396
NN_punpcklqdq: int  # 578
NN_punpcklwd: int  # 395
NN_push: int  # 143
NN_pusha: int  # 145
NN_pushad: int  # 146
NN_pushaq: int  # 147
NN_pushaw: int  # 144
NN_pushf: int  # 149
NN_pushfd: int  # 150
NN_pushfq: int  # 151
NN_pushfw: int  # 148
NN_pxor: int  # 397
NN_rcl: int  # 152
NN_rcpps: int  # 455
NN_rcpss: int  # 456
NN_rcr: int  # 153
NN_rdfsbase: int  # 764
NN_rdgsbase: int  # 765
NN_rdmsr: int  # 223
NN_rdpid: int  # 1761
NN_rdpkru: int  # 1173
NN_rdpmc: int  # 257
NN_rdpru: int  # 1782
NN_rdrand: int  # 742
NN_rdseed: int  # 763
NN_rdsspd: int  # 1765
NN_rdsspq: int  # 1766
NN_rdtsc: int  # 227
NN_rdtscp: int  # 633
NN_rep: int  # 156
NN_repe: int  # 157
NN_repne: int  # 158
NN_retf: int  # 160
NN_retfd: int  # 740
NN_retfq: int  # 741
NN_retfw: int  # 739
NN_retn: int  # 159
NN_retnd: int  # 737
NN_retnq: int  # 738
NN_retnw: int  # 736
NN_rol: int  # 154
NN_ror: int  # 155
NN_rorx: int  # 755
NN_roundpd: int  # 696
NN_roundps: int  # 697
NN_roundsd: int  # 698
NN_roundss: int  # 699
NN_rsdc: int  # 344
NN_rsldt: int  # 346
NN_rsm: int  # 228
NN_rsqrtps: int  # 457
NN_rsqrtss: int  # 458
NN_rstorssp: int  # 1768
NN_rsts: int  # 348
NN_sahf: int  # 161
NN_sal: int  # 162
NN_sar: int  # 163
NN_sarx: int  # 756
NN_saveprevssp: int  # 1767
NN_sbb: int  # 166
NN_scas: int  # 167
NN_senduipi: int  # 1939
NN_serialize: int  # 1790
NN_seta: int  # 168
NN_setae: int  # 169
NN_setalc: int  # 342
NN_setb: int  # 170
NN_setbe: int  # 171
NN_setc: int  # 172
NN_sete: int  # 173
NN_setg: int  # 174
NN_setge: int  # 175
NN_setl: int  # 176
NN_setle: int  # 177
NN_setna: int  # 178
NN_setnae: int  # 179
NN_setnb: int  # 180
NN_setnbe: int  # 181
NN_setnc: int  # 182
NN_setne: int  # 183
NN_setng: int  # 184
NN_setnge: int  # 185
NN_setnl: int  # 186
NN_setnle: int  # 187
NN_setno: int  # 188
NN_setnp: int  # 189
NN_setns: int  # 190
NN_setnz: int  # 191
NN_seto: int  # 192
NN_setp: int  # 193
NN_setpe: int  # 194
NN_setpo: int  # 195
NN_sets: int  # 196
NN_setssbsy: int  # 1773
NN_setz: int  # 197
NN_sfence: int  # 488
NN_sgdt: int  # 198
NN_sha1msg1: int  # 1623
NN_sha1msg2: int  # 1624
NN_sha1nexte: int  # 1622
NN_sha1rnds4: int  # 1621
NN_sha256msg1: int  # 1626
NN_sha256msg2: int  # 1627
NN_sha256rnds2: int  # 1625
NN_shl: int  # 164
NN_shld: int  # 200
NN_shlx: int  # 757
NN_shr: int  # 165
NN_shrd: int  # 201
NN_shrx: int  # 758
NN_shufpd: int  # 579
NN_shufps: int  # 459
NN_sidt: int  # 199
NN_skinit: int  # 719
NN_sldt: int  # 202
NN_smsw: int  # 203
NN_sqrtpd: int  # 580
NN_sqrtps: int  # 460
NN_sqrtsd: int  # 581
NN_sqrtss: int  # 461
NN_stac: int  # 759
NN_stc: int  # 204
NN_std: int  # 205
NN_stgi: int  # 720
NN_sti: int  # 206
NN_stmxcsr: int  # 462
NN_stos: int  # 207
NN_str: int  # 208
NN_stui: int  # 1936
NN_sub: int  # 209
NN_subpd: int  # 582
NN_subps: int  # 463
NN_subsd: int  # 583
NN_subss: int  # 464
NN_svdc: int  # 343
NN_svldt: int  # 345
NN_svts: int  # 347
NN_swapgs: int  # 590
NN_syscall: int  # 588
NN_sysenter: int  # 400
NN_sysexit: int  # 401
NN_sysret: int  # 589
NN_test: int  # 210
NN_testui: int  # 1937
NN_tpause: int  # 1787
NN_tzcnt: int  # 760
NN_ucomisd: int  # 584
NN_ucomiss: int  # 465
NN_ud0: int  # 1777
NN_ud1: int  # 1778
NN_ud2: int  # 632
NN_uiret: int  # 1938
NN_umonitor: int  # 1788
NN_umwait: int  # 1789
NN_unpckhpd: int  # 585
NN_unpckhps: int  # 466
NN_unpcklpd: int  # 586
NN_unpcklps: int  # 467
NN_v4fmaddps: int  # 1753
NN_v4fmaddss: int  # 1755
NN_v4fnmaddps: int  # 1754
NN_v4fnmaddss: int  # 1756
NN_vaddpd: int  # 768
NN_vaddph: int  # 1829
NN_vaddps: int  # 769
NN_vaddsd: int  # 770
NN_vaddsh: int  # 1890
NN_vaddss: int  # 771
NN_vaddsubpd: int  # 772
NN_vaddsubps: int  # 773
NN_vaesdec: int  # 774
NN_vaesdeclast: int  # 775
NN_vaesenc: int  # 776
NN_vaesenclast: int  # 777
NN_vaesimc: int  # 778
NN_vaeskeygenassist: int  # 779
NN_valignd: int  # 1303
NN_valignq: int  # 1304
NN_vandnpd: int  # 780
NN_vandnps: int  # 781
NN_vandpd: int  # 782
NN_vandps: int  # 783
NN_vblendmpd: int  # 1305
NN_vblendmps: int  # 1306
NN_vblendpd: int  # 784
NN_vblendps: int  # 785
NN_vblendvpd: int  # 786
NN_vblendvps: int  # 787
NN_vbroadcastf128: int  # 788
NN_vbroadcastf32x2: int  # 1311
NN_vbroadcastf32x4: int  # 1312
NN_vbroadcastf32x8: int  # 1314
NN_vbroadcastf64x2: int  # 1313
NN_vbroadcastf64x4: int  # 1315
NN_vbroadcasti128: int  # 789
NN_vbroadcasti32x2: int  # 1316
NN_vbroadcasti32x4: int  # 1317
NN_vbroadcasti32x8: int  # 1319
NN_vbroadcasti64x2: int  # 1318
NN_vbroadcasti64x4: int  # 1320
NN_vbroadcastsd: int  # 790
NN_vbroadcastss: int  # 791
NN_vcmpeq_ospd: int  # 1191
NN_vcmpeq_osps: int  # 1223
NN_vcmpeq_ossd: int  # 1255
NN_vcmpeq_osss: int  # 1287
NN_vcmpeq_uqpd: int  # 1183
NN_vcmpeq_uqps: int  # 1215
NN_vcmpeq_uqsd: int  # 1247
NN_vcmpeq_uqss: int  # 1279
NN_vcmpeq_uspd: int  # 1199
NN_vcmpeq_usps: int  # 1231
NN_vcmpeq_ussd: int  # 1263
NN_vcmpeq_usss: int  # 1295
NN_vcmpeqpd: int  # 1175
NN_vcmpeqps: int  # 1207
NN_vcmpeqsd: int  # 1239
NN_vcmpeqss: int  # 1271
NN_vcmpfalse_ospd: int  # 1202
NN_vcmpfalse_osps: int  # 1234
NN_vcmpfalse_ossd: int  # 1266
NN_vcmpfalse_osss: int  # 1298
NN_vcmpfalsepd: int  # 1186
NN_vcmpfalseps: int  # 1218
NN_vcmpfalsesd: int  # 1250
NN_vcmpfalsess: int  # 1282
NN_vcmpge_oqpd: int  # 1204
NN_vcmpge_oqps: int  # 1236
NN_vcmpge_oqsd: int  # 1268
NN_vcmpge_oqss: int  # 1300
NN_vcmpgepd: int  # 1188
NN_vcmpgeps: int  # 1220
NN_vcmpgesd: int  # 1252
NN_vcmpgess: int  # 1284
NN_vcmpgt_oqpd: int  # 1205
NN_vcmpgt_oqps: int  # 1237
NN_vcmpgt_oqsd: int  # 1269
NN_vcmpgt_oqss: int  # 1301
NN_vcmpgtpd: int  # 1189
NN_vcmpgtps: int  # 1221
NN_vcmpgtsd: int  # 1253
NN_vcmpgtss: int  # 1285
NN_vcmple_oqpd: int  # 1193
NN_vcmple_oqps: int  # 1225
NN_vcmple_oqsd: int  # 1257
NN_vcmple_oqss: int  # 1289
NN_vcmplepd: int  # 1177
NN_vcmpleps: int  # 1209
NN_vcmplesd: int  # 1241
NN_vcmpless: int  # 1273
NN_vcmplt_oqpd: int  # 1192
NN_vcmplt_oqps: int  # 1224
NN_vcmplt_oqsd: int  # 1256
NN_vcmplt_oqss: int  # 1288
NN_vcmpltpd: int  # 1176
NN_vcmpltps: int  # 1208
NN_vcmpltsd: int  # 1240
NN_vcmpltss: int  # 1272
NN_vcmpneq_oqpd: int  # 1187
NN_vcmpneq_oqps: int  # 1219
NN_vcmpneq_oqsd: int  # 1251
NN_vcmpneq_oqss: int  # 1283
NN_vcmpneq_ospd: int  # 1203
NN_vcmpneq_osps: int  # 1235
NN_vcmpneq_ossd: int  # 1267
NN_vcmpneq_osss: int  # 1299
NN_vcmpneq_uspd: int  # 1195
NN_vcmpneq_usps: int  # 1227
NN_vcmpneq_ussd: int  # 1259
NN_vcmpneq_usss: int  # 1291
NN_vcmpneqpd: int  # 1179
NN_vcmpneqps: int  # 1211
NN_vcmpneqsd: int  # 1243
NN_vcmpneqss: int  # 1275
NN_vcmpnge_uqpd: int  # 1200
NN_vcmpnge_uqps: int  # 1232
NN_vcmpnge_uqsd: int  # 1264
NN_vcmpnge_uqss: int  # 1296
NN_vcmpngepd: int  # 1184
NN_vcmpngeps: int  # 1216
NN_vcmpngesd: int  # 1248
NN_vcmpngess: int  # 1280
NN_vcmpngt_uqpd: int  # 1201
NN_vcmpngt_uqps: int  # 1233
NN_vcmpngt_uqsd: int  # 1265
NN_vcmpngt_uqss: int  # 1297
NN_vcmpngtpd: int  # 1185
NN_vcmpngtps: int  # 1217
NN_vcmpngtsd: int  # 1249
NN_vcmpngtss: int  # 1281
NN_vcmpnle_uqpd: int  # 1197
NN_vcmpnle_uqps: int  # 1229
NN_vcmpnle_uqsd: int  # 1261
NN_vcmpnle_uqss: int  # 1293
NN_vcmpnlepd: int  # 1181
NN_vcmpnleps: int  # 1213
NN_vcmpnlesd: int  # 1245
NN_vcmpnless: int  # 1277
NN_vcmpnlt_uqpd: int  # 1196
NN_vcmpnlt_uqps: int  # 1228
NN_vcmpnlt_uqsd: int  # 1260
NN_vcmpnlt_uqss: int  # 1292
NN_vcmpnltpd: int  # 1180
NN_vcmpnltps: int  # 1212
NN_vcmpnltsd: int  # 1244
NN_vcmpnltss: int  # 1276
NN_vcmpord_spd: int  # 1198
NN_vcmpord_sps: int  # 1230
NN_vcmpord_ssd: int  # 1262
NN_vcmpord_sss: int  # 1294
NN_vcmpordpd: int  # 1182
NN_vcmpordps: int  # 1214
NN_vcmpordsd: int  # 1246
NN_vcmpordss: int  # 1278
NN_vcmppd: int  # 792
NN_vcmpph: int  # 1830
NN_vcmpps: int  # 793
NN_vcmpsd: int  # 794
NN_vcmpsh: int  # 1891
NN_vcmpss: int  # 795
NN_vcmptrue_uspd: int  # 1206
NN_vcmptrue_usps: int  # 1238
NN_vcmptrue_ussd: int  # 1270
NN_vcmptrue_usss: int  # 1302
NN_vcmptruepd: int  # 1190
NN_vcmptrueps: int  # 1222
NN_vcmptruesd: int  # 1254
NN_vcmptruess: int  # 1286
NN_vcmpunord_spd: int  # 1194
NN_vcmpunord_sps: int  # 1226
NN_vcmpunord_ssd: int  # 1258
NN_vcmpunord_sss: int  # 1290
NN_vcmpunordpd: int  # 1178
NN_vcmpunordps: int  # 1210
NN_vcmpunordsd: int  # 1242
NN_vcmpunordss: int  # 1274
NN_vcomisd: int  # 796
NN_vcomish: int  # 1892
NN_vcomiss: int  # 797
NN_vcompresspd: int  # 1321
NN_vcompressps: int  # 1322
NN_vcvtdq2pd: int  # 798
NN_vcvtdq2ph: int  # 1831
NN_vcvtdq2ps: int  # 799
NN_vcvtne2ps2bf16: int  # 1826
NN_vcvtneps2bf16: int  # 1827
NN_vcvtpd2dq: int  # 800
NN_vcvtpd2ph: int  # 1832
NN_vcvtpd2ps: int  # 801
NN_vcvtpd2qq: int  # 1323
NN_vcvtpd2udq: int  # 1324
NN_vcvtpd2uqq: int  # 1325
NN_vcvtph2dq: int  # 1833
NN_vcvtph2pd: int  # 1834
NN_vcvtph2ps: int  # 802
NN_vcvtph2psx: int  # 1835
NN_vcvtph2qq: int  # 1836
NN_vcvtph2udq: int  # 1837
NN_vcvtph2uqq: int  # 1838
NN_vcvtph2uw: int  # 1839
NN_vcvtph2w: int  # 1840
NN_vcvtps2dq: int  # 803
NN_vcvtps2pd: int  # 804
NN_vcvtps2ph: int  # 805
NN_vcvtps2phx: int  # 1841
NN_vcvtps2qq: int  # 1327
NN_vcvtps2udq: int  # 1326
NN_vcvtps2uqq: int  # 1328
NN_vcvtqq2pd: int  # 1329
NN_vcvtqq2ph: int  # 1842
NN_vcvtqq2ps: int  # 1330
NN_vcvtsd2sh: int  # 1893
NN_vcvtsd2si: int  # 806
NN_vcvtsd2ss: int  # 807
NN_vcvtsd2usi: int  # 1331
NN_vcvtsh2sd: int  # 1894
NN_vcvtsh2si: int  # 1895
NN_vcvtsh2ss: int  # 1896
NN_vcvtsh2usi: int  # 1897
NN_vcvtsi2sd: int  # 808
NN_vcvtsi2sh: int  # 1898
NN_vcvtsi2ss: int  # 809
NN_vcvtss2sd: int  # 810
NN_vcvtss2sh: int  # 1899
NN_vcvtss2si: int  # 811
NN_vcvtss2usi: int  # 1332
NN_vcvttpd2dq: int  # 812
NN_vcvttpd2qq: int  # 1333
NN_vcvttpd2udq: int  # 1334
NN_vcvttpd2uqq: int  # 1335
NN_vcvttph2dq: int  # 1843
NN_vcvttph2qq: int  # 1844
NN_vcvttph2udq: int  # 1845
NN_vcvttph2uqq: int  # 1846
NN_vcvttph2uw: int  # 1847
NN_vcvttph2w: int  # 1848
NN_vcvttps2dq: int  # 813
NN_vcvttps2qq: int  # 1337
NN_vcvttps2udq: int  # 1336
NN_vcvttps2uqq: int  # 1338
NN_vcvttsd2si: int  # 814
NN_vcvttsd2usi: int  # 1339
NN_vcvttsh2si: int  # 1900
NN_vcvttsh2usi: int  # 1901
NN_vcvttss2si: int  # 815
NN_vcvttss2usi: int  # 1340
NN_vcvtudq2pd: int  # 1341
NN_vcvtudq2ph: int  # 1849
NN_vcvtudq2ps: int  # 1342
NN_vcvtuqq2pd: int  # 1343
NN_vcvtuqq2ph: int  # 1850
NN_vcvtuqq2ps: int  # 1344
NN_vcvtusi2sd: int  # 1345
NN_vcvtusi2sh: int  # 1902
NN_vcvtusi2ss: int  # 1346
NN_vcvtuw2ph: int  # 1851
NN_vcvtw2ph: int  # 1852
NN_vdbpsadbw: int  # 1347
NN_vdivpd: int  # 816
NN_vdivph: int  # 1853
NN_vdivps: int  # 817
NN_vdivsd: int  # 818
NN_vdivsh: int  # 1903
NN_vdivss: int  # 819
NN_vdpbf16ps: int  # 1828
NN_vdppd: int  # 820
NN_vdpps: int  # 821
NN_verr: int  # 211
NN_verw: int  # 212
NN_vexp2pd: int  # 1522
NN_vexp2ps: int  # 1523
NN_vexpandpd: int  # 1348
NN_vexpandps: int  # 1349
NN_vextractf128: int  # 822
NN_vextractf32x4: int  # 1350
NN_vextractf32x8: int  # 1352
NN_vextractf64x2: int  # 1351
NN_vextractf64x4: int  # 1353
NN_vextracti128: int  # 823
NN_vextracti32x4: int  # 1354
NN_vextracti32x8: int  # 1356
NN_vextracti64x2: int  # 1355
NN_vextracti64x4: int  # 1357
NN_vextractps: int  # 824
NN_vfcmaddcph: int  # 1854
NN_vfcmaddcsh: int  # 1904
NN_vfcmulcph: int  # 1855
NN_vfcmulcsh: int  # 1905
NN_vfixupimmpd: int  # 1358
NN_vfixupimmps: int  # 1359
NN_vfixupimmsd: int  # 1360
NN_vfixupimmss: int  # 1361
NN_vfmadd132pd: int  # 825
NN_vfmadd132ph: int  # 1856
NN_vfmadd132ps: int  # 826
NN_vfmadd132sd: int  # 827
NN_vfmadd132sh: int  # 1906
NN_vfmadd132ss: int  # 828
NN_vfmadd213pd: int  # 829
NN_vfmadd213ph: int  # 1857
NN_vfmadd213ps: int  # 830
NN_vfmadd213sd: int  # 831
NN_vfmadd213sh: int  # 1907
NN_vfmadd213ss: int  # 832
NN_vfmadd231pd: int  # 833
NN_vfmadd231ph: int  # 1858
NN_vfmadd231ps: int  # 834
NN_vfmadd231sd: int  # 835
NN_vfmadd231sh: int  # 1908
NN_vfmadd231ss: int  # 836
NN_vfmaddcph: int  # 1859
NN_vfmaddcsh: int  # 1909
NN_vfmaddpd: int  # 1144
NN_vfmaddps: int  # 1143
NN_vfmaddsd: int  # 1146
NN_vfmaddss: int  # 1145
NN_vfmaddsub132pd: int  # 837
NN_vfmaddsub132ph: int  # 1860
NN_vfmaddsub132ps: int  # 838
NN_vfmaddsub213pd: int  # 839
NN_vfmaddsub213ph: int  # 1861
NN_vfmaddsub213ps: int  # 840
NN_vfmaddsub231pd: int  # 841
NN_vfmaddsub231ph: int  # 1862
NN_vfmaddsub231ps: int  # 842
NN_vfmaddsubpd: int  # 1140
NN_vfmaddsubps: int  # 1139
NN_vfmsub132pd: int  # 843
NN_vfmsub132ph: int  # 1863
NN_vfmsub132ps: int  # 844
NN_vfmsub132sd: int  # 845
NN_vfmsub132sh: int  # 1910
NN_vfmsub132ss: int  # 846
NN_vfmsub213pd: int  # 847
NN_vfmsub213ph: int  # 1864
NN_vfmsub213ps: int  # 848
NN_vfmsub213sd: int  # 849
NN_vfmsub213sh: int  # 1911
NN_vfmsub213ss: int  # 850
NN_vfmsub231pd: int  # 851
NN_vfmsub231ph: int  # 1865
NN_vfmsub231ps: int  # 852
NN_vfmsub231sd: int  # 853
NN_vfmsub231sh: int  # 1912
NN_vfmsub231ss: int  # 854
NN_vfmsubadd132pd: int  # 855
NN_vfmsubadd132ph: int  # 1866
NN_vfmsubadd132ps: int  # 856
NN_vfmsubadd213pd: int  # 857
NN_vfmsubadd213ph: int  # 1867
NN_vfmsubadd213ps: int  # 858
NN_vfmsubadd231pd: int  # 859
NN_vfmsubadd231ph: int  # 1868
NN_vfmsubadd231ps: int  # 860
NN_vfmsubaddpd: int  # 1142
NN_vfmsubaddps: int  # 1141
NN_vfmsubpd: int  # 1148
NN_vfmsubps: int  # 1147
NN_vfmsubsd: int  # 1150
NN_vfmsubss: int  # 1149
NN_vfmulcph: int  # 1869
NN_vfmulcsh: int  # 1913
NN_vfnmadd132pd: int  # 861
NN_vfnmadd132ph: int  # 1870
NN_vfnmadd132ps: int  # 862
NN_vfnmadd132sd: int  # 863
NN_vfnmadd132sh: int  # 1914
NN_vfnmadd132ss: int  # 864
NN_vfnmadd213pd: int  # 865
NN_vfnmadd213ph: int  # 1871
NN_vfnmadd213ps: int  # 866
NN_vfnmadd213sd: int  # 867
NN_vfnmadd213sh: int  # 1915
NN_vfnmadd213ss: int  # 868
NN_vfnmadd231pd: int  # 869
NN_vfnmadd231ph: int  # 1872
NN_vfnmadd231ps: int  # 870
NN_vfnmadd231sd: int  # 871
NN_vfnmadd231sh: int  # 1916
NN_vfnmadd231ss: int  # 872
NN_vfnmaddpd: int  # 1152
NN_vfnmaddps: int  # 1151
NN_vfnmaddsd: int  # 1154
NN_vfnmaddss: int  # 1153
NN_vfnmsub132pd: int  # 873
NN_vfnmsub132ph: int  # 1873
NN_vfnmsub132ps: int  # 874
NN_vfnmsub132sd: int  # 875
NN_vfnmsub132sh: int  # 1917
NN_vfnmsub132ss: int  # 876
NN_vfnmsub213pd: int  # 877
NN_vfnmsub213ph: int  # 1874
NN_vfnmsub213ps: int  # 878
NN_vfnmsub213sd: int  # 879
NN_vfnmsub213sh: int  # 1918
NN_vfnmsub213ss: int  # 880
NN_vfnmsub231pd: int  # 881
NN_vfnmsub231ph: int  # 1875
NN_vfnmsub231ps: int  # 882
NN_vfnmsub231sd: int  # 883
NN_vfnmsub231sh: int  # 1919
NN_vfnmsub231ss: int  # 884
NN_vfnmsubpd: int  # 1156
NN_vfnmsubps: int  # 1155
NN_vfnmsubsd: int  # 1158
NN_vfnmsubss: int  # 1157
NN_vfpclasspd: int  # 1362
NN_vfpclassph: int  # 1876
NN_vfpclassps: int  # 1363
NN_vfpclasssd: int  # 1364
NN_vfpclasssh: int  # 1920
NN_vfpclassss: int  # 1365
NN_vfrczpd: int  # 1630
NN_vfrczps: int  # 1631
NN_vfrczsd: int  # 1632
NN_vfrczss: int  # 1633
NN_vgatherdpd: int  # 886
NN_vgatherdps: int  # 885
NN_vgatherpf0dpd: int  # 1534
NN_vgatherpf0dps: int  # 1532
NN_vgatherpf0qpd: int  # 1535
NN_vgatherpf0qps: int  # 1533
NN_vgatherpf1dpd: int  # 1538
NN_vgatherpf1dps: int  # 1536
NN_vgatherpf1qpd: int  # 1539
NN_vgatherpf1qps: int  # 1537
NN_vgatherqpd: int  # 888
NN_vgatherqps: int  # 887
NN_vgetexppd: int  # 1366
NN_vgetexpph: int  # 1877
NN_vgetexpps: int  # 1367
NN_vgetexpsd: int  # 1368
NN_vgetexpsh: int  # 1921
NN_vgetexpss: int  # 1369
NN_vgetmantpd: int  # 1370
NN_vgetmantph: int  # 1878
NN_vgetmantps: int  # 1371
NN_vgetmantsd: int  # 1372
NN_vgetmantsh: int  # 1922
NN_vgetmantss: int  # 1373
NN_vgf2p8affineinvqb: int  # 1798
NN_vgf2p8affineqb: int  # 1797
NN_vgf2p8mulb: int  # 1796
NN_vhaddpd: int  # 889
NN_vhaddps: int  # 890
NN_vhsubpd: int  # 891
NN_vhsubps: int  # 892
NN_vinsertf128: int  # 893
NN_vinsertf32x4: int  # 1374
NN_vinsertf32x8: int  # 1376
NN_vinsertf64x2: int  # 1375
NN_vinsertf64x4: int  # 1377
NN_vinserti128: int  # 894
NN_vinserti32x4: int  # 1378
NN_vinserti32x8: int  # 1380
NN_vinserti64x2: int  # 1379
NN_vinserti64x4: int  # 1381
NN_vinsertps: int  # 895
NN_vlddqu: int  # 896
NN_vldmxcsr: int  # 897
NN_vmaskmovdqu: int  # 898
NN_vmaskmovpd: int  # 899
NN_vmaskmovps: int  # 900
NN_vmaxpd: int  # 901
NN_vmaxph: int  # 1879
NN_vmaxps: int  # 902
NN_vmaxsd: int  # 903
NN_vmaxsh: int  # 1923
NN_vmaxss: int  # 904
NN_vmcall: int  # 622
NN_vmclear: int  # 623
NN_vmcli: int  # 1130
NN_vmcpuid: int  # 1125
NN_vmdxdsbl: int  # 1123
NN_vmdxenbl: int  # 1124
NN_vmexit: int  # 721
NN_vmfunc: int  # 1762
NN_vmgetinfo: int  # 1121
NN_vmhlt: int  # 1126
NN_vminpd: int  # 905
NN_vminph: int  # 1880
NN_vminps: int  # 906
NN_vminsd: int  # 907
NN_vminsh: int  # 1924
NN_vminss: int  # 908
NN_vmiretd: int  # 1132
NN_vmlaunch: int  # 624
NN_vmload: int  # 722
NN_vmmcall: int  # 723
NN_vmovapd: int  # 909
NN_vmovaps: int  # 910
NN_vmovd: int  # 911
NN_vmovddup: int  # 912
NN_vmovdqa: int  # 913
NN_vmovdqa32: int  # 1382
NN_vmovdqa64: int  # 1383
NN_vmovdqu: int  # 914
NN_vmovdqu16: int  # 1385
NN_vmovdqu32: int  # 1386
NN_vmovdqu64: int  # 1387
NN_vmovdqu8: int  # 1384
NN_vmovhlps: int  # 915
NN_vmovhpd: int  # 916
NN_vmovhps: int  # 917
NN_vmovlhps: int  # 918
NN_vmovlpd: int  # 919
NN_vmovlps: int  # 920
NN_vmovmskpd: int  # 921
NN_vmovmskps: int  # 922
NN_vmovntdq: int  # 923
NN_vmovntdqa: int  # 924
NN_vmovntpd: int  # 925
NN_vmovntps: int  # 926
NN_vmovq: int  # 927
NN_vmovsd: int  # 928
NN_vmovsh: int  # 1925
NN_vmovshdup: int  # 929
NN_vmovsldup: int  # 930
NN_vmovss: int  # 931
NN_vmovupd: int  # 932
NN_vmovups: int  # 933
NN_vmovw: int  # 1889
NN_vmpopfd: int  # 1129
NN_vmpsadbw: int  # 934
NN_vmptrld: int  # 626
NN_vmptrst: int  # 627
NN_vmpushfd: int  # 1128
NN_vmread: int  # 628
NN_vmresume: int  # 625
NN_vmrun: int  # 724
NN_vmsave: int  # 725
NN_vmsdte: int  # 1137
NN_vmsetinfo: int  # 1122
NN_vmsgdt: int  # 1133
NN_vmsidt: int  # 1134
NN_vmsldt: int  # 1135
NN_vmsplaf: int  # 1127
NN_vmsti: int  # 1131
NN_vmstr: int  # 1136
NN_vmulpd: int  # 935
NN_vmulph: int  # 1881
NN_vmulps: int  # 936
NN_vmulsd: int  # 937
NN_vmulsh: int  # 1926
NN_vmulss: int  # 938
NN_vmwrite: int  # 629
NN_vmxoff: int  # 630
NN_vmxon: int  # 631
NN_vorpd: int  # 939
NN_vorps: int  # 940
NN_vp2intersectd: int  # 1824
NN_vp2intersectq: int  # 1825
NN_vp4dpwssd: int  # 1757
NN_vp4dpwssds: int  # 1758
NN_vpabsb: int  # 941
NN_vpabsd: int  # 942
NN_vpabsq: int  # 1388
NN_vpabsw: int  # 943
NN_vpackssdw: int  # 944
NN_vpacksswb: int  # 945
NN_vpackusdw: int  # 946
NN_vpackuswb: int  # 947
NN_vpaddb: int  # 948
NN_vpaddd: int  # 949
NN_vpaddq: int  # 950
NN_vpaddsb: int  # 951
NN_vpaddsw: int  # 952
NN_vpaddusb: int  # 953
NN_vpaddusw: int  # 954
NN_vpaddw: int  # 955
NN_vpalignr: int  # 956
NN_vpand: int  # 957
NN_vpandd: int  # 1389
NN_vpandn: int  # 958
NN_vpandnd: int  # 1391
NN_vpandnq: int  # 1392
NN_vpandq: int  # 1390
NN_vpavgb: int  # 959
NN_vpavgw: int  # 960
NN_vpblendd: int  # 961
NN_vpblendmb: int  # 1307
NN_vpblendmd: int  # 1309
NN_vpblendmq: int  # 1310
NN_vpblendmw: int  # 1308
NN_vpblendvb: int  # 962
NN_vpblendw: int  # 963
NN_vpbroadcastb: int  # 964
NN_vpbroadcastd: int  # 965
NN_vpbroadcastmb2q: int  # 1393
NN_vpbroadcastmw2d: int  # 1394
NN_vpbroadcastq: int  # 966
NN_vpbroadcastw: int  # 967
NN_vpcext: int  # 1138
NN_vpclmulqdq: int  # 968
NN_vpcmov: int  # 1634
NN_vpcmpb: int  # 1395
NN_vpcmpd: int  # 1397
NN_vpcmpeqb: int  # 969
NN_vpcmpeqd: int  # 970
NN_vpcmpeqq: int  # 971
NN_vpcmpequd: int  # 1553
NN_vpcmpequq: int  # 1564
NN_vpcmpeqw: int  # 972
NN_vpcmpestri: int  # 973
NN_vpcmpestrm: int  # 974
NN_vpcmpgtb: int  # 975
NN_vpcmpgtd: int  # 976
NN_vpcmpgtq: int  # 977
NN_vpcmpgtw: int  # 978
NN_vpcmpistri: int  # 979
NN_vpcmpistrm: int  # 980
NN_vpcmpled: int  # 1549
NN_vpcmpleq: int  # 1560
NN_vpcmpleud: int  # 1555
NN_vpcmpleuq: int  # 1566
NN_vpcmpltd: int  # 1548
NN_vpcmpltq: int  # 1559
NN_vpcmpltud: int  # 1554
NN_vpcmpltuq: int  # 1565
NN_vpcmpneqd: int  # 1550
NN_vpcmpneqq: int  # 1561
NN_vpcmpnequd: int  # 1556
NN_vpcmpnequq: int  # 1567
NN_vpcmpnled: int  # 1552
NN_vpcmpnleq: int  # 1563
NN_vpcmpnleud: int  # 1558
NN_vpcmpnleuq: int  # 1569
NN_vpcmpnltd: int  # 1551
NN_vpcmpnltq: int  # 1562
NN_vpcmpnltud: int  # 1557
NN_vpcmpnltuq: int  # 1568
NN_vpcmpq: int  # 1399
NN_vpcmpub: int  # 1396
NN_vpcmpud: int  # 1398
NN_vpcmpuq: int  # 1400
NN_vpcmpuw: int  # 1402
NN_vpcmpw: int  # 1401
NN_vpcomb: int  # 1635
NN_vpcomd: int  # 1636
NN_vpcomeqb: int  # 1689
NN_vpcomeqd: int  # 1705
NN_vpcomeqq: int  # 1713
NN_vpcomequb: int  # 1721
NN_vpcomequd: int  # 1737
NN_vpcomequq: int  # 1745
NN_vpcomequw: int  # 1729
NN_vpcomeqw: int  # 1697
NN_vpcomfalseb: int  # 1691
NN_vpcomfalsed: int  # 1707
NN_vpcomfalseq: int  # 1715
NN_vpcomfalseub: int  # 1723
NN_vpcomfalseud: int  # 1739
NN_vpcomfalseuq: int  # 1747
NN_vpcomfalseuw: int  # 1731
NN_vpcomfalsew: int  # 1699
NN_vpcomgeb: int  # 1688
NN_vpcomged: int  # 1704
NN_vpcomgeq: int  # 1712
NN_vpcomgeub: int  # 1720
NN_vpcomgeud: int  # 1736
NN_vpcomgeuq: int  # 1744
NN_vpcomgeuw: int  # 1728
NN_vpcomgew: int  # 1696
NN_vpcomgtb: int  # 1687
NN_vpcomgtd: int  # 1703
NN_vpcomgtq: int  # 1711
NN_vpcomgtub: int  # 1719
NN_vpcomgtud: int  # 1735
NN_vpcomgtuq: int  # 1743
NN_vpcomgtuw: int  # 1727
NN_vpcomgtw: int  # 1695
NN_vpcomleb: int  # 1686
NN_vpcomled: int  # 1702
NN_vpcomleq: int  # 1710
NN_vpcomleub: int  # 1718
NN_vpcomleud: int  # 1734
NN_vpcomleuq: int  # 1742
NN_vpcomleuw: int  # 1726
NN_vpcomlew: int  # 1694
NN_vpcomltb: int  # 1685
NN_vpcomltd: int  # 1701
NN_vpcomltq: int  # 1709
NN_vpcomltub: int  # 1717
NN_vpcomltud: int  # 1733
NN_vpcomltuq: int  # 1741
NN_vpcomltuw: int  # 1725
NN_vpcomltw: int  # 1693
NN_vpcomneqb: int  # 1690
NN_vpcomneqd: int  # 1706
NN_vpcomneqq: int  # 1714
NN_vpcomnequb: int  # 1722
NN_vpcomnequd: int  # 1738
NN_vpcomnequq: int  # 1746
NN_vpcomnequw: int  # 1730
NN_vpcomneqw: int  # 1698
NN_vpcompressb: int  # 1805
NN_vpcompressd: int  # 1403
NN_vpcompressq: int  # 1404
NN_vpcompressw: int  # 1806
NN_vpcomq: int  # 1637
NN_vpcomtrueb: int  # 1692
NN_vpcomtrued: int  # 1708
NN_vpcomtrueq: int  # 1716
NN_vpcomtrueub: int  # 1724
NN_vpcomtrueud: int  # 1740
NN_vpcomtrueuq: int  # 1748
NN_vpcomtrueuw: int  # 1732
NN_vpcomtruew: int  # 1700
NN_vpcomub: int  # 1638
NN_vpcomud: int  # 1639
NN_vpcomuq: int  # 1640
NN_vpcomuw: int  # 1641
NN_vpcomw: int  # 1642
NN_vpconflictd: int  # 1405
NN_vpconflictq: int  # 1406
NN_vpdpbusd: int  # 1801
NN_vpdpbusds: int  # 1802
NN_vpdpwssd: int  # 1803
NN_vpdpwssds: int  # 1804
NN_vperm2f128: int  # 981
NN_vperm2i128: int  # 982
NN_vpermb: int  # 1407
NN_vpermd: int  # 983
NN_vpermi2b: int  # 1409
NN_vpermi2d: int  # 1411
NN_vpermi2pd: int  # 1414
NN_vpermi2ps: int  # 1413
NN_vpermi2q: int  # 1412
NN_vpermi2w: int  # 1410
NN_vpermil2pd: int  # 1643
NN_vpermil2ps: int  # 1644
NN_vpermilpd: int  # 984
NN_vpermilps: int  # 985
NN_vpermpd: int  # 986
NN_vpermps: int  # 987
NN_vpermq: int  # 988
NN_vpermt2b: int  # 1415
NN_vpermt2d: int  # 1417
NN_vpermt2pd: int  # 1420
NN_vpermt2ps: int  # 1419
NN_vpermt2q: int  # 1418
NN_vpermt2w: int  # 1416
NN_vpermw: int  # 1408
NN_vpexpandb: int  # 1807
NN_vpexpandd: int  # 1421
NN_vpexpandq: int  # 1422
NN_vpexpandw: int  # 1808
NN_vpextrb: int  # 989
NN_vpextrd: int  # 990
NN_vpextrq: int  # 991
NN_vpextrw: int  # 992
NN_vpgatherdd: int  # 993
NN_vpgatherdq: int  # 994
NN_vpgatherqd: int  # 995
NN_vpgatherqq: int  # 996
NN_vphaddbd: int  # 1645
NN_vphaddbq: int  # 1646
NN_vphaddbw: int  # 1647
NN_vphaddd: int  # 997
NN_vphadddq: int  # 1648
NN_vphaddsw: int  # 998
NN_vphaddubd: int  # 1649
NN_vphaddubq: int  # 1650
NN_vphaddubw: int  # 1651
NN_vphaddudq: int  # 1652
NN_vphadduwd: int  # 1653
NN_vphadduwq: int  # 1654
NN_vphaddw: int  # 999
NN_vphaddwd: int  # 1655
NN_vphaddwq: int  # 1656
NN_vphminposuw: int  # 1000
NN_vphsubbw: int  # 1657
NN_vphsubd: int  # 1001
NN_vphsubdq: int  # 1658
NN_vphsubsw: int  # 1002
NN_vphsubw: int  # 1003
NN_vphsubwd: int  # 1659
NN_vpinsrb: int  # 1004
NN_vpinsrd: int  # 1005
NN_vpinsrq: int  # 1006
NN_vpinsrw: int  # 1007
NN_vplzcntd: int  # 1423
NN_vplzcntq: int  # 1424
NN_vpmacsdd: int  # 1660
NN_vpmacsdqh: int  # 1661
NN_vpmacsdql: int  # 1662
NN_vpmacssdd: int  # 1663
NN_vpmacssdqh: int  # 1664
NN_vpmacssdql: int  # 1665
NN_vpmacsswd: int  # 1666
NN_vpmacssww: int  # 1667
NN_vpmacswd: int  # 1668
NN_vpmacsww: int  # 1669
NN_vpmadcsswd: int  # 1670
NN_vpmadcswd: int  # 1671
NN_vpmadd52huq: int  # 1426
NN_vpmadd52luq: int  # 1425
NN_vpmaddubsw: int  # 1008
NN_vpmaddwd: int  # 1009
NN_vpmaskmovd: int  # 1010
NN_vpmaskmovq: int  # 1011
NN_vpmaxsb: int  # 1012
NN_vpmaxsd: int  # 1013
NN_vpmaxsq: int  # 1427
NN_vpmaxsw: int  # 1014
NN_vpmaxub: int  # 1015
NN_vpmaxud: int  # 1016
NN_vpmaxuq: int  # 1428
NN_vpmaxuw: int  # 1017
NN_vpminsb: int  # 1018
NN_vpminsd: int  # 1019
NN_vpminsq: int  # 1429
NN_vpminsw: int  # 1020
NN_vpminub: int  # 1021
NN_vpminud: int  # 1022
NN_vpminuq: int  # 1430
NN_vpminuw: int  # 1023
NN_vpmovb2m: int  # 1435
NN_vpmovd2m: int  # 1437
NN_vpmovdb: int  # 1448
NN_vpmovdw: int  # 1451
NN_vpmovm2b: int  # 1431
NN_vpmovm2d: int  # 1433
NN_vpmovm2q: int  # 1434
NN_vpmovm2w: int  # 1432
NN_vpmovmskb: int  # 1024
NN_vpmovq2m: int  # 1438
NN_vpmovqb: int  # 1439
NN_vpmovqd: int  # 1445
NN_vpmovqw: int  # 1442
NN_vpmovsdb: int  # 1449
NN_vpmovsdw: int  # 1452
NN_vpmovsqb: int  # 1440
NN_vpmovsqd: int  # 1446
NN_vpmovsqw: int  # 1443
NN_vpmovswb: int  # 1455
NN_vpmovsxbd: int  # 1025
NN_vpmovsxbq: int  # 1026
NN_vpmovsxbw: int  # 1027
NN_vpmovsxdq: int  # 1028
NN_vpmovsxwd: int  # 1029
NN_vpmovsxwq: int  # 1030
NN_vpmovusdb: int  # 1450
NN_vpmovusdw: int  # 1453
NN_vpmovusqb: int  # 1441
NN_vpmovusqd: int  # 1447
NN_vpmovusqw: int  # 1444
NN_vpmovuswb: int  # 1456
NN_vpmovw2m: int  # 1436
NN_vpmovwb: int  # 1454
NN_vpmovzxbd: int  # 1031
NN_vpmovzxbq: int  # 1032
NN_vpmovzxbw: int  # 1033
NN_vpmovzxdq: int  # 1034
NN_vpmovzxwd: int  # 1035
NN_vpmovzxwq: int  # 1036
NN_vpmuldq: int  # 1037
NN_vpmulhrsw: int  # 1038
NN_vpmulhuw: int  # 1039
NN_vpmulhw: int  # 1040
NN_vpmulld: int  # 1041
NN_vpmullq: int  # 1457
NN_vpmullw: int  # 1042
NN_vpmultishiftqb: int  # 1458
NN_vpmuludq: int  # 1043
NN_vpopcntb: int  # 1821
NN_vpopcntd: int  # 1759
NN_vpopcntq: int  # 1760
NN_vpopcntw: int  # 1822
NN_vpor: int  # 1044
NN_vpord: int  # 1459
NN_vporq: int  # 1460
NN_vpperm: int  # 1672
NN_vprold: int  # 1461
NN_vprolq: int  # 1463
NN_vprolvd: int  # 1462
NN_vprolvq: int  # 1464
NN_vprord: int  # 1465
NN_vprorq: int  # 1467
NN_vprorvd: int  # 1466
NN_vprorvq: int  # 1468
NN_vprotb: int  # 1673
NN_vprotd: int  # 1674
NN_vprotq: int  # 1675
NN_vprotw: int  # 1676
NN_vpsadbw: int  # 1045
NN_vpscatterdd: int  # 1469
NN_vpscatterdq: int  # 1470
NN_vpscatterqd: int  # 1471
NN_vpscatterqq: int  # 1472
NN_vpshab: int  # 1677
NN_vpshad: int  # 1678
NN_vpshaq: int  # 1679
NN_vpshaw: int  # 1680
NN_vpshlb: int  # 1681
NN_vpshld: int  # 1682
NN_vpshldd: int  # 1810
NN_vpshldq: int  # 1811
NN_vpshldvd: int  # 1813
NN_vpshldvq: int  # 1814
NN_vpshldvw: int  # 1812
NN_vpshldw: int  # 1809
NN_vpshlq: int  # 1683
NN_vpshlw: int  # 1684
NN_vpshrdd: int  # 1816
NN_vpshrdq: int  # 1817
NN_vpshrdvd: int  # 1819
NN_vpshrdvq: int  # 1820
NN_vpshrdvw: int  # 1818
NN_vpshrdw: int  # 1815
NN_vpshufb: int  # 1046
NN_vpshufbitqmb: int  # 1823
NN_vpshufd: int  # 1047
NN_vpshufhw: int  # 1048
NN_vpshuflw: int  # 1049
NN_vpsignb: int  # 1050
NN_vpsignd: int  # 1051
NN_vpsignw: int  # 1052
NN_vpslld: int  # 1053
NN_vpslldq: int  # 1054
NN_vpsllq: int  # 1055
NN_vpsllvd: int  # 1056
NN_vpsllvq: int  # 1057
NN_vpsllvw: int  # 1474
NN_vpsllw: int  # 1058
NN_vpsrad: int  # 1059
NN_vpsraq: int  # 1473
NN_vpsravd: int  # 1060
NN_vpsravq: int  # 1491
NN_vpsravw: int  # 1490
NN_vpsraw: int  # 1061
NN_vpsrld: int  # 1062
NN_vpsrldq: int  # 1063
NN_vpsrlq: int  # 1064
NN_vpsrlvd: int  # 1065
NN_vpsrlvq: int  # 1066
NN_vpsrlvw: int  # 1475
NN_vpsrlw: int  # 1067
NN_vpsubb: int  # 1068
NN_vpsubd: int  # 1069
NN_vpsubq: int  # 1070
NN_vpsubsb: int  # 1071
NN_vpsubsw: int  # 1072
NN_vpsubusb: int  # 1073
NN_vpsubusw: int  # 1074
NN_vpsubw: int  # 1075
NN_vpternlogd: int  # 1484
NN_vpternlogq: int  # 1485
NN_vptest: int  # 1076
NN_vptestmb: int  # 1486
NN_vptestmd: int  # 1488
NN_vptestmq: int  # 1489
NN_vptestmw: int  # 1487
NN_vptestnmb: int  # 1476
NN_vptestnmd: int  # 1478
NN_vptestnmq: int  # 1479
NN_vptestnmw: int  # 1477
NN_vpunpckhbw: int  # 1077
NN_vpunpckhdq: int  # 1078
NN_vpunpckhqdq: int  # 1079
NN_vpunpckhwd: int  # 1080
NN_vpunpcklbw: int  # 1081
NN_vpunpckldq: int  # 1082
NN_vpunpcklqdq: int  # 1083
NN_vpunpcklwd: int  # 1084
NN_vpxor: int  # 1085
NN_vpxord: int  # 1492
NN_vpxorq: int  # 1493
NN_vrangepd: int  # 1494
NN_vrangeps: int  # 1495
NN_vrangesd: int  # 1496
NN_vrangess: int  # 1497
NN_vrcp14pd: int  # 1498
NN_vrcp14ps: int  # 1500
NN_vrcp14sd: int  # 1499
NN_vrcp14ss: int  # 1501
NN_vrcp28pd: int  # 1524
NN_vrcp28ps: int  # 1526
NN_vrcp28sd: int  # 1525
NN_vrcp28ss: int  # 1527
NN_vrcpph: int  # 1882
NN_vrcpps: int  # 1086
NN_vrcpsh: int  # 1927
NN_vrcpss: int  # 1087
NN_vreducepd: int  # 1502
NN_vreduceph: int  # 1883
NN_vreduceps: int  # 1504
NN_vreducesd: int  # 1503
NN_vreducesh: int  # 1928
NN_vreducess: int  # 1505
NN_vrndscalepd: int  # 1506
NN_vrndscaleph: int  # 1884
NN_vrndscaleps: int  # 1508
NN_vrndscalesd: int  # 1507
NN_vrndscalesh: int  # 1929
NN_vrndscaless: int  # 1509
NN_vroundpd: int  # 1088
NN_vroundps: int  # 1089
NN_vroundsd: int  # 1090
NN_vroundss: int  # 1091
NN_vrsqrt14pd: int  # 1510
NN_vrsqrt14ps: int  # 1512
NN_vrsqrt14sd: int  # 1511
NN_vrsqrt14ss: int  # 1513
NN_vrsqrt28pd: int  # 1528
NN_vrsqrt28ps: int  # 1530
NN_vrsqrt28sd: int  # 1529
NN_vrsqrt28ss: int  # 1531
NN_vrsqrtph: int  # 1885
NN_vrsqrtps: int  # 1092
NN_vrsqrtsh: int  # 1930
NN_vrsqrtss: int  # 1093
NN_vscalefpd: int  # 1514
NN_vscalefph: int  # 1886
NN_vscalefps: int  # 1516
NN_vscalefsd: int  # 1515
NN_vscalefsh: int  # 1931
NN_vscalefss: int  # 1517
NN_vscatterdpd: int  # 1519
NN_vscatterdps: int  # 1518
NN_vscatterpf0dpd: int  # 1542
NN_vscatterpf0dps: int  # 1540
NN_vscatterpf0qpd: int  # 1543
NN_vscatterpf0qps: int  # 1541
NN_vscatterpf1dpd: int  # 1546
NN_vscatterpf1dps: int  # 1544
NN_vscatterpf1qpd: int  # 1547
NN_vscatterpf1qps: int  # 1545
NN_vscatterqpd: int  # 1521
NN_vscatterqps: int  # 1520
NN_vshuff32x4: int  # 1480
NN_vshuff64x2: int  # 1481
NN_vshufi32x4: int  # 1482
NN_vshufi64x2: int  # 1483
NN_vshufpd: int  # 1094
NN_vshufps: int  # 1095
NN_vsqrtpd: int  # 1096
NN_vsqrtph: int  # 1887
NN_vsqrtps: int  # 1097
NN_vsqrtsd: int  # 1098
NN_vsqrtsh: int  # 1932
NN_vsqrtss: int  # 1099
NN_vstmxcsr: int  # 1100
NN_vsubpd: int  # 1101
NN_vsubph: int  # 1888
NN_vsubps: int  # 1102
NN_vsubsd: int  # 1103
NN_vsubsh: int  # 1933
NN_vsubss: int  # 1104
NN_vtestpd: int  # 1105
NN_vtestps: int  # 1106
NN_vucomisd: int  # 1107
NN_vucomish: int  # 1934
NN_vucomiss: int  # 1108
NN_vunpckhpd: int  # 1109
NN_vunpckhps: int  # 1110
NN_vunpcklpd: int  # 1111
NN_vunpcklps: int  # 1112
NN_vxorpd: int  # 1113
NN_vxorps: int  # 1114
NN_vzeroall: int  # 1115
NN_vzeroupper: int  # 1116
NN_wait: int  # 213
NN_wbinvd: int  # 221
NN_wrfsbase: int  # 766
NN_wrgsbase: int  # 767
NN_wrmsr: int  # 224
NN_wrpkru: int  # 1174
NN_wrssd: int  # 1769
NN_wrssq: int  # 1770
NN_wrussd: int  # 1771
NN_wrussq: int  # 1772
NN_xabort: int  # 1117
NN_xadd: int  # 219
NN_xbegin: int  # 1118
NN_xchg: int  # 214
NN_xend: int  # 1119
NN_xgetbv: int  # 712
NN_xlat: int  # 215
NN_xor: int  # 216
NN_xorpd: int  # 587
NN_xorps: int  # 468
NN_xresldtrk: int  # 1791
NN_xrstor: int  # 713
NN_xrstors: int  # 1166
NN_xsave: int  # 714
NN_xsavec: int  # 1167
NN_xsaveopt: int  # 761
NN_xsaves: int  # 1168
NN_xsetbv: int  # 715
NN_xsusldtrk: int  # 1792
NN_xtest: int  # 1120
NORET_FORBID_ANALYSIS: int  # 2
NORET_IGNORE_WAS_NORET_ICALL: int  # 1
NOSIZE: int  # -1
NO_ACCESS: int  # 0
NO_CURLY_BRACES: int  # 1
NO_EVENT: int  # 0
NO_PROCESS: int  # 4294967295
NO_SIDEFF: int  # 0
NO_THREAD: int  # 0
NSUP_ARGEAS: int  # 30
NSUP_ARRAY: int  # 5
NSUP_CMT: int  # 0
NSUP_CUSTDT: int  # 28
NSUP_EX_FLAGS: int  # 37
NSUP_FOP1: int  # 2
NSUP_FOP2: int  # 3
NSUP_FOP3: int  # 7
NSUP_FOP4: int  # 18
NSUP_FOP5: int  # 19
NSUP_FOP6: int  # 20
NSUP_FOP7: int  # 31
NSUP_FOP8: int  # 32
NSUP_FRAME: int  # 1089536
NSUP_FTAILS: int  # 28672
NSUP_GROUP: int  # 32768
NSUP_GROUPS: int  # 29
NSUP_GR_INFO: str  # g
NSUP_GR_LAYT: str  # l
NSUP_JINFO: int  # 4
NSUP_LLABEL: int  # 20480
NSUP_MANUAL: int  # 8192
NSUP_OMFGRP: int  # 6
NSUP_OPTYPES: int  # 36864
NSUP_OREF0: int  # 12
NSUP_OREF1: int  # 13
NSUP_OREF2: int  # 14
NSUP_OREF3: int  # 24
NSUP_OREF4: int  # 25
NSUP_OREF5: int  # 26
NSUP_OREF6: int  # 35
NSUP_OREF7: int  # 36
NSUP_ORIGFMD: int  # 1085440
NSUP_POINTS: int  # 4096
NSUP_REF0: int  # 9
NSUP_REF1: int  # 10
NSUP_REF2: int  # 11
NSUP_REF3: int  # 21
NSUP_REF4: int  # 22
NSUP_REF5: int  # 23
NSUP_REF6: int  # 33
NSUP_REF7: int  # 34
NSUP_REGARG: int  # 24576
NSUP_REGVAR: int  # 16384
NSUP_REPCMT: int  # 1
NSUP_SEGTRANS: int  # 17
NSUP_STROFF0: int  # 15
NSUP_STROFF1: int  # 16
NSUP_SWITCH: int  # 8
NSUP_TYPEINFO: int  # 12288
NSUP_XREFPOS: int  # 27
NTF_64BIT: int  # 64
NTF_CHKSYNC: int  # 512
NTF_COPY: int  # 4096
NTF_FIXNAME: int  # 128
NTF_IDBENC: int  # 256
NTF_NOBASE: int  # 2
NTF_NOCUR: int  # 32
NTF_NO_NAMECHK: int  # 1024
NTF_REPLACE: int  # 4
NTF_SYMM: int  # 0
NTF_SYMU: int  # 8
NTF_TYPE: int  # 1
NTF_UMANGLED: int  # 8
NT_ABS: int  # 5
NT_BMASK: int  # 8
NT_BYTE: int  # 1
NT_ENUM: int  # 4
NT_LOCAL: int  # 2
NT_NONE: int  # 0
NT_REGVAR: int  # 9
NT_SEG: int  # 6
NT_STKVAR: int  # 3
NT_STROFF: int  # 7
NULL_PIPE_HANDLE: int  # -1
NW_CLOSEIDB: int  # 2
NW_INITIDA: int  # 4
NW_OPENIDB: int  # 1
NW_REMOVE: int  # 16
NW_TERMIDA: int  # 8
OAK_Dsp_add: int  # 5
OAK_Dsp_addh: int  # 11
OAK_Dsp_addl: int  # 12
OAK_Dsp_addv: int  # 39
OAK_Dsp_alb_tst0: int  # 40
OAK_Dsp_alb_tst1: int  # 41
OAK_Dsp_alm_msu: int  # 10
OAK_Dsp_alm_tst0: int  # 6
OAK_Dsp_alm_tst1: int  # 7
OAK_Dsp_and: int  # 3
OAK_Dsp_banke: int  # 71
OAK_Dsp_bkrep: int  # 73
OAK_Dsp_br: int  # 75
OAK_Dsp_br_u: int  # 77
OAK_Dsp_break: int  # 74
OAK_Dsp_brr: int  # 76
OAK_Dsp_brr_u: int  # 78
OAK_Dsp_call: int  # 79
OAK_Dsp_calla: int  # 81
OAK_Dsp_callr: int  # 80
OAK_Dsp_chng: int  # 38
OAK_Dsp_clr: int  # 24
OAK_Dsp_clrr: int  # 30
OAK_Dsp_cmp: int  # 8
OAK_Dsp_cmpu: int  # 17
OAK_Dsp_cmpv: int  # 42
OAK_Dsp_cntx: int  # 89
OAK_Dsp_copy: int  # 33
OAK_Dsp_dec: int  # 32
OAK_Dsp_dint: int  # 92
OAK_Dsp_divs: int  # 35
OAK_Dsp_eint: int  # 93
OAK_Dsp_exp: int  # 61
OAK_Dsp_inc: int  # 31
OAK_Dsp_last: int  # 98
OAK_Dsp_lim: int  # 47
OAK_Dsp_load: int  # 96
OAK_Dsp_lpg: int  # 95
OAK_Dsp_maa: int  # 52
OAK_Dsp_maasu: int  # 55
OAK_Dsp_mac: int  # 50
OAK_Dsp_macsu: int  # 54
OAK_Dsp_macus: int  # 51
OAK_Dsp_macuu: int  # 53
OAK_Dsp_max: int  # 45
OAK_Dsp_maxd: int  # 44
OAK_Dsp_min: int  # 46
OAK_Dsp_mod_reserved: int  # 25
OAK_Dsp_modr: int  # 91
OAK_Dsp_mov: int  # 62
OAK_Dsp_mov_eu: int  # 97
OAK_Dsp_movd: int  # 67
OAK_Dsp_movp: int  # 63
OAK_Dsp_movr: int  # 66
OAK_Dsp_movs: int  # 64
OAK_Dsp_movsi: int  # 65
OAK_Dsp_mpy: int  # 48
OAK_Dsp_mpyi: int  # 56
OAK_Dsp_mpysu: int  # 49
OAK_Dsp_msu: int  # 57
OAK_Dsp_neg: int  # 27
OAK_Dsp_nop: int  # 90
OAK_Dsp_norm: int  # 34
OAK_Dsp_not: int  # 26
OAK_Dsp_null: int  # 0
OAK_Dsp_or: int  # 2
OAK_Dsp_pacr: int  # 29
OAK_Dsp_pop: int  # 69
OAK_Dsp_proc: int  # 1
OAK_Dsp_push: int  # 68
OAK_Dsp_rep: int  # 72
OAK_Dsp_ret: int  # 82
OAK_Dsp_ret_u: int  # 83
OAK_Dsp_retd: int  # 84
OAK_Dsp_reti: int  # 85
OAK_Dsp_reti_u: int  # 86
OAK_Dsp_retid: int  # 87
OAK_Dsp_rets: int  # 88
OAK_Dsp_rnd: int  # 28
OAK_Dsp_rol: int  # 23
OAK_Dsp_ror: int  # 22
OAK_Dsp_rst: int  # 37
OAK_Dsp_set: int  # 36
OAK_Dsp_shfc: int  # 59
OAK_Dsp_shfi: int  # 60
OAK_Dsp_shl: int  # 20
OAK_Dsp_shl4: int  # 21
OAK_Dsp_shr: int  # 18
OAK_Dsp_shr4: int  # 19
OAK_Dsp_sqr: int  # 15
OAK_Dsp_sqra: int  # 16
OAK_Dsp_sub: int  # 9
OAK_Dsp_subh: int  # 13
OAK_Dsp_subl: int  # 14
OAK_Dsp_subv: int  # 43
OAK_Dsp_swap: int  # 70
OAK_Dsp_trap: int  # 94
OAK_Dsp_tstb: int  # 58
OAK_Dsp_xor: int  # 4
OFILE_ASM: int  # 4
OFILE_DIF: int  # 5
OFILE_EXE: int  # 1
OFILE_IDC: int  # 2
OFILE_LST: int  # 3
OFILE_MAP: int  # 0
OFLG_GEN_ASSUME: int  # 512
OFLG_GEN_NULL: int  # 16
OFLG_GEN_ORG: int  # 256
OFLG_GEN_TRYBLKS: int  # 1024
OFLG_LZERO: int  # 128
OFLG_PREF_SEG: int  # 64
OFLG_SHOW_AUTO: int  # 4
OFLG_SHOW_PREF: int  # 32
OFLG_SHOW_VOID: int  # 2
OF_NO_BASE_DISP: int  # 128
OF_NUMBER: int  # 16
OF_OUTER_DISP: int  # 64
OF_SHOW: int  # 8
ONE_ACCESS_TYPE: int  # 32
ONLY_SIDEFF: int  # 2
OOFS_IFSIGN: int  # 0
OOFS_NEEDSIGN: int  # 2
OOFS_NOSIGN: int  # 1
OOFW_16: int  # 32
OOFW_24: int  # 48
OOFW_32: int  # 64
OOFW_64: int  # 80
OOFW_8: int  # 16
OOFW_IMM: int  # 0
OOF_ADDR: int  # 128
OOF_ANYSERIAL: int  # 4096
OOF_LZEROES: int  # 8192
OOF_NOBNOT: int  # 1024
OOF_NO_LZEROES: int  # 16384
OOF_NUMBER: int  # 8
OOF_OUTER: int  # 256
OOF_SIGNED: int  # 4
OOF_SIGNMASK: int  # 3
OOF_SPACES: int  # 2048
OOF_WIDTHMASK: int  # 112
OOF_ZSTROFF: int  # 512
OPF_NEW_WINDOW: int  # 1
OPF_NO_WAIT: int  # 8
OPF_REUSE: int  # 0
OPF_REUSE_ACTIVE: int  # 2
OPF_WINDOW_MGMT_MASK: int  # 7
OPND_ALL: int  # 15
OPND_MASK: int  # 15
OPND_OUTER: int  # 128
OPROP_ABI: int  # 64
OPROP_CCFLAGS: int  # 8
OPROP_FLOAT: int  # 4
OPROP_IMPDONE: int  # 1
OPROP_LOWADDR: int  # 32
OPROP_UDEFVAL: int  # 16
OPROP_UDT: int  # 2
OPTI_ADDREXPRS: int  # 1
OPTI_COMBINSNS: int  # 4
OPTI_MINSTKREF: int  # 2
OPTI_NO_LDXOPT: int  # 8
OPTI_NO_VALRNG: int  # 16
OP_FP_BASED: int  # 0
OP_SP_ADD: int  # 0
OP_SP_BASED: int  # 1
OP_SP_SUB: int  # 2
OSTYPE_MSDOS: int  # 1
OSTYPE_NETW: int  # 8
OSTYPE_OS2: int  # 4
OSTYPE_OTHER: int  # 32
OSTYPE_UNIX: int  # 16
OSTYPE_WIN: int  # 2
PACK_FORM_DEF: int  # 32
PALETTE_SIZE: int  # 53
PATCH_TAG: str  # P
PATH_TYPE_CMD: int  # 0
PATH_TYPE_ID0: int  # 2
PATH_TYPE_IDB: int  # 1
PBSENC_ALL: int  # -1
PBSENC_DEF1BPU: int  # 0
PCF_EA_CAPABLE: int  # 1
PCF_MAKEPLACE_ALLOCATES: int  # 2
PDF_DEF_BASE: int  # 4
PDF_DEF_FWD: int  # 2
PDF_HEADER_CMT: int  # 8
PDF_INCL_DEPS: int  # 1
PIC16_ADD: int  # 9
PIC16_ADDC: int  # 10
PIC16_AND: int  # 26
PIC16_ASR: int  # 33
PIC16_BCLR: int  # 40
PIC16_BRA: int  # 62
PIC16_BREAK: int  # 91
PIC16_BSET: int  # 41
PIC16_BSW: int  # 42
PIC16_BTG: int  # 43
PIC16_BTSC: int  # 49
PIC16_BTSS: int  # 50
PIC16_BTST: int  # 44
PIC16_BTSTS: int  # 45
PIC16_CALL: int  # 63
PIC16_CLR: int  # 27
PIC16_CLR1: int  # 84
PIC16_CLRWDT: int  # 75
PIC16_COM: int  # 28
PIC16_CP: int  # 51
PIC16_CP0: int  # 52
PIC16_CPB: int  # 53
PIC16_CPBEQ: int  # 58
PIC16_CPBGT: int  # 60
PIC16_CPBLT: int  # 61
PIC16_CPBNE: int  # 59
PIC16_CPSEQ: int  # 54
PIC16_CPSGT: int  # 55
PIC16_CPSLT: int  # 56
PIC16_CPSNE: int  # 57
PIC16_DAWB: int  # 11
PIC16_DEC: int  # 12
PIC16_DEC2: int  # 13
PIC16_DISI: int  # 76
PIC16_DIV: int  # 14
PIC16_DIVF: int  # 25
PIC16_DO: int  # 70
PIC16_ED: int  # 85
PIC16_EDAC: int  # 86
PIC16_EXCH: int  # 1
PIC16_FBCL: int  # 46
PIC16_FEX: int  # 94
PIC16_FF1L: int  # 47
PIC16_FF1R: int  # 48
PIC16_GOTO: int  # 64
PIC16_INC: int  # 15
PIC16_INC2: int  # 16
PIC16_IOR: int  # 29
PIC16_LAC: int  # 81
PIC16_LNK: int  # 71
PIC16_LSR: int  # 34
PIC16_MAC: int  # 87
PIC16_MOV: int  # 2
PIC16_MOVPAG: int  # 8
PIC16_MOVSAC: int  # 88
PIC16_MPY: int  # 89
PIC16_MSC: int  # 90
PIC16_MUL: int  # 17
PIC16_MULW: int  # 24
PIC16_NEG: int  # 30
PIC16_NOP: int  # 77
PIC16_NOPR: int  # 78
PIC16_POP: int  # 72
PIC16_PUSH: int  # 73
PIC16_PWRSAV: int  # 79
PIC16_RCALL: int  # 65
PIC16_REPEAT: int  # 66
PIC16_RESET: int  # 80
PIC16_RETFIE: int  # 67
PIC16_RETLW: int  # 68
PIC16_RETURN: int  # 69
PIC16_RLC: int  # 35
PIC16_RLNC: int  # 36
PIC16_RRC: int  # 37
PIC16_RRNC: int  # 38
PIC16_SAC: int  # 82
PIC16_SE: int  # 18
PIC16_SETM: int  # 31
PIC16_SFTAC: int  # 83
PIC16_SL: int  # 39
PIC16_SSTEP: int  # 93
PIC16_SUB: int  # 19
PIC16_SUBB: int  # 20
PIC16_SUBBR: int  # 21
PIC16_SUBR: int  # 22
PIC16_SWAP: int  # 3
PIC16_TBLRDH: int  # 4
PIC16_TBLRDL: int  # 5
PIC16_TBLWTH: int  # 6
PIC16_TBLWTL: int  # 7
PIC16_ULNK: int  # 74
PIC16_URUN: int  # 92
PIC16_XOR: int  # 32
PIC16_ZE: int  # 23
PIC16_last: int  # 95
PIC16_null: int  # 0
PIC_addcf: int  # 60
PIC_adddcf: int  # 61
PIC_addfsr: int  # 130
PIC_addlw: int  # 23
PIC_addwf: int  # 1
PIC_addwf3: int  # 63
PIC_addwfc: int  # 127
PIC_addwfc3: int  # 64
PIC_andlw: int  # 24
PIC_andwf: int  # 2
PIC_andwf3: int  # 65
PIC_asrf: int  # 131
PIC_b: int  # 41
PIC_bc: int  # 54
PIC_bc1: int  # 99
PIC_bcf: int  # 19
PIC_bcf3: int  # 94
PIC_bdc: int  # 55
PIC_bn1: int  # 100
PIC_bnc: int  # 56
PIC_bnc1: int  # 101
PIC_bndc: int  # 57
PIC_bnn1: int  # 102
PIC_bnov1: int  # 103
PIC_bnz: int  # 58
PIC_bnz1: int  # 104
PIC_bov1: int  # 105
PIC_bra: int  # 135
PIC_bra1: int  # 106
PIC_brw: int  # 136
PIC_bsf: int  # 20
PIC_bsf3: int  # 95
PIC_btfsc: int  # 21
PIC_btfsc3: int  # 96
PIC_btfss: int  # 22
PIC_btfss3: int  # 97
PIC_btg3: int  # 98
PIC_bz: int  # 59
PIC_bz1: int  # 107
PIC_call: int  # 25
PIC_call2: int  # 108
PIC_callw: int  # 137
PIC_clrc: int  # 42
PIC_clrdc: int  # 43
PIC_clrf: int  # 3
PIC_clrf2: int  # 66
PIC_clrw: int  # 4
PIC_clrwdt: int  # 26
PIC_clrz: int  # 44
PIC_comf: int  # 5
PIC_comf3: int  # 67
PIC_cpfseq2: int  # 68
PIC_cpfsgt2: int  # 69
PIC_cpfslt2: int  # 70
PIC_daw0: int  # 109
PIC_dcfsnz3: int  # 73
PIC_decf: int  # 6
PIC_decf3: int  # 71
PIC_decfsz: int  # 7
PIC_decfsz3: int  # 72
PIC_goto: int  # 27
PIC_incf: int  # 8
PIC_incf3: int  # 74
PIC_incfsz: int  # 9
PIC_incfsz3: int  # 75
PIC_infsnz3: int  # 76
PIC_iorlw: int  # 28
PIC_iorwf: int  # 10
PIC_iorwf3: int  # 77
PIC_last: int  # 141
PIC_lfsr2: int  # 116
PIC_lslf: int  # 132
PIC_lsrf: int  # 133
PIC_movf: int  # 11
PIC_movf3: int  # 78
PIC_movff2: int  # 79
PIC_movfw: int  # 38
PIC_moviw: int  # 139
PIC_movlb: int  # 129
PIC_movlb1: int  # 117
PIC_movlp: int  # 128
PIC_movlw: int  # 29
PIC_movwf: int  # 12
PIC_movwf2: int  # 80
PIC_movwi: int  # 140
PIC_mullw1: int  # 118
PIC_mulwf2: int  # 81
PIC_negf: int  # 40
PIC_negf2: int  # 82
PIC_nop: int  # 13
PIC_null: int  # 0
PIC_option: int  # 36
PIC_pop0: int  # 110
PIC_push0: int  # 111
PIC_rcall1: int  # 112
PIC_reset: int  # 138
PIC_reset0: int  # 113
PIC_retfie: int  # 30
PIC_retfie1: int  # 114
PIC_retlw: int  # 31
PIC_return: int  # 32
PIC_return1: int  # 115
PIC_rlcf3: int  # 83
PIC_rlf: int  # 14
PIC_rlncf3: int  # 84
PIC_rrcf3: int  # 85
PIC_rrf: int  # 15
PIC_rrncf3: int  # 86
PIC_setc: int  # 45
PIC_setdc: int  # 46
PIC_setf2: int  # 87
PIC_setz: int  # 47
PIC_skpc: int  # 48
PIC_skpdc: int  # 49
PIC_skpnc: int  # 50
PIC_skpndc: int  # 51
PIC_skpnz: int  # 52
PIC_skpz: int  # 53
PIC_sleep: int  # 33
PIC_subcf: int  # 62
PIC_subfwb3: int  # 88
PIC_sublw: int  # 34
PIC_subwf: int  # 16
PIC_subwf3: int  # 89
PIC_subwfb: int  # 134
PIC_subwfb3: int  # 90
PIC_swapf: int  # 17
PIC_swapf3: int  # 91
PIC_tblrd0: int  # 119
PIC_tblrd0m: int  # 121
PIC_tblrd0p: int  # 120
PIC_tblrdp0: int  # 122
PIC_tblwt0: int  # 123
PIC_tblwt0m: int  # 125
PIC_tblwt0p: int  # 124
PIC_tblwtp0: int  # 126
PIC_tris: int  # 37
PIC_tstf: int  # 39
PIC_tstfsz2: int  # 92
PIC_xorlw: int  # 35
PIC_xorwf: int  # 18
PIC_xorwf3: int  # 93
PIO_IGNORE_PTRS: int  # 8
PIO_NOATTR_FAIL: int  # 4
PLFM_386: int  # 0
PLFM_6502: int  # 5
PLFM_65C816: int  # 61
PLFM_6800: int  # 9
PLFM_68K: int  # 7
PLFM_80196: int  # 16
PLFM_8051: int  # 3
PLFM_AD2106X: int  # 68
PLFM_AD218X: int  # 48
PLFM_ALPHA: int  # 24
PLFM_ARC: int  # 63
PLFM_ARM: int  # 13
PLFM_AVR: int  # 20
PLFM_C166: int  # 29
PLFM_C39: int  # 51
PLFM_CR16: int  # 52
PLFM_DALVIK: int  # 60
PLFM_DSP56K: int  # 28
PLFM_DSP96K: int  # 66
PLFM_EBC: int  # 57
PLFM_F2MC: int  # 33
PLFM_FR: int  # 43
PLFM_H8: int  # 21
PLFM_H8500: int  # 26
PLFM_HPPA: int  # 25
PLFM_I860: int  # 2
PLFM_I960: int  # 32
PLFM_IA64: int  # 31
PLFM_JAVA: int  # 8
PLFM_KR1878: int  # 47
PLFM_M16C: int  # 62
PLFM_M32R: int  # 37
PLFM_M740: int  # 40
PLFM_M7700: int  # 41
PLFM_M7900: int  # 45
PLFM_MC6812: int  # 11
PLFM_MC6816: int  # 44
PLFM_MIPS: int  # 12
PLFM_MN102L00: int  # 53
PLFM_MSP430: int  # 58
PLFM_NEC_78K0: int  # 38
PLFM_NEC_78K0S: int  # 39
PLFM_NEC_V850X: int  # 55
PLFM_NET: int  # 19
PLFM_OAKDSP: int  # 49
PLFM_PDP: int  # 6
PLFM_PIC: int  # 22
PLFM_PIC16: int  # 69
PLFM_PPC: int  # 15
PLFM_RISCV: int  # 72
PLFM_RL78: int  # 73
PLFM_RX: int  # 74
PLFM_S390: int  # 70
PLFM_SCR_ADPT: int  # 56
PLFM_SH: int  # 18
PLFM_SPARC: int  # 23
PLFM_SPC700: int  # 67
PLFM_SPU: int  # 59
PLFM_ST20: int  # 30
PLFM_ST7: int  # 10
PLFM_ST9: int  # 42
PLFM_TLCS900: int  # 50
PLFM_TMS: int  # 4
PLFM_TMS320C1X: int  # 54
PLFM_TMS320C28: int  # 65
PLFM_TMS320C3: int  # 46
PLFM_TMS320C54: int  # 34
PLFM_TMS320C55: int  # 35
PLFM_TMSC6: int  # 14
PLFM_TRICORE: int  # 27
PLFM_TRIMEDIA: int  # 36
PLFM_UNSP: int  # 64
PLFM_WASM: int  # 75
PLFM_XTENSA: int  # 71
PLFM_Z8: int  # 17
PLFM_Z80: int  # 1
PLG_SUBDIR: str  # plugins
PLUGIN_DBG: int  # 32
PLUGIN_DLL: str  # *.so
PLUGIN_DRAW: int  # 2
PLUGIN_FIX: int  # 128
PLUGIN_HIDE: int  # 16
PLUGIN_KEEP: int  # 2
PLUGIN_MOD: int  # 1
PLUGIN_MULTI: int  # 256
PLUGIN_OK: int  # 1
PLUGIN_PROC: int  # 64
PLUGIN_SEG: int  # 4
PLUGIN_SKIP: int  # 0
PLUGIN_UNL: int  # 8
PM96_IFcc: int  # 7
PM96_Long: int  # 5
PM96_NoMove: int  # 0
PM96_R2R: int  # 1
PM96_Update: int  # 2
PM96_XY: int  # 6
PM96_XYMem: int  # 3
PM96_XYmemR: int  # 4
POF_IS_F64: int  # 4
POF_VALID_AFLAGS: int  # 2
POF_VALID_TI: int  # 1
PPC_abs: int  # 362
PPC_abssb: int  # 2238
PPC_abssh: int  # 2244
PPC_abssw: int  # 2250
PPC_absub: int  # 2239
PPC_absuh: int  # 2245
PPC_absuw: int  # 2251
PPC_add: int  # 1
PPC_add16i: int  # 1155
PPC_add2i: int  # 1156
PPC_add2is: int  # 1157
PPC_addb: int  # 2479
PPC_addbss: int  # 2217
PPC_addbu: int  # 2480
PPC_addbus: int  # 2220
PPC_addc: int  # 2
PPC_adde: int  # 3
PPC_addex: int  # 2440
PPC_addg6s: int  # 681
PPC_addh: int  # 2481
PPC_addhss: int  # 2218
PPC_addhu: int  # 2482
PPC_addhus: int  # 2221
PPC_addi: int  # 4
PPC_addic: int  # 5
PPC_addis: int  # 6
PPC_addme: int  # 7
PPC_addpcis: int  # 2256
PPC_addwss: int  # 2219
PPC_addwus: int  # 2222
PPC_addze: int  # 8
PPC_and: int  # 9
PPC_and2i: int  # 1158
PPC_and2is: int  # 1159
PPC_andc: int  # 10
PPC_andi: int  # 11
PPC_andis: int  # 12
PPC_b: int  # 13
PPC_balways: int  # 320
PPC_bc: int  # 14
PPC_bcctr: int  # 15
PPC_bcdadd: int  # 2152
PPC_bcdcfn: int  # 2290
PPC_bcdcfsq: int  # 2295
PPC_bcdcfz: int  # 2291
PPC_bcdcpsgn: int  # 2297
PPC_bcdctn: int  # 2292
PPC_bcdctsq: int  # 2294
PPC_bcdctz: int  # 2293
PPC_bcds: int  # 2298
PPC_bcdsetsgn: int  # 2296
PPC_bcdsr: int  # 2300
PPC_bcdsub: int  # 2153
PPC_bcdtrunc: int  # 2301
PPC_bcdus: int  # 2299
PPC_bcdutrunc: int  # 2302
PPC_bclr: int  # 16
PPC_bclri: int  # 1171
PPC_bctar: int  # 2082
PPC_bdnz: int  # 323
PPC_bdnzf: int  # 325
PPC_bdnzt: int  # 324
PPC_bdz: int  # 326
PPC_bdzf: int  # 328
PPC_bdzt: int  # 327
PPC_beq: int  # 331
PPC_bf: int  # 322
PPC_bge: int  # 332
PPC_bgeni: int  # 1172
PPC_bgt: int  # 333
PPC_ble: int  # 330
PPC_blt: int  # 329
PPC_bmaski: int  # 1173
PPC_bne: int  # 334
PPC_bns: int  # 336
PPC_bpermd: int  # 665
PPC_brd: int  # 3248
PPC_brh: int  # 3249
PPC_brinc: int  # 417
PPC_brw: int  # 3250
PPC_bseti: int  # 1174
PPC_bso: int  # 335
PPC_bt: int  # 321
PPC_btsti: int  # 1175
PPC_byterevh: int  # 2488
PPC_byterevw: int  # 2487
PPC_cbcdtd: int  # 682
PPC_cdtbcd: int  # 683
PPC_cfuged: int  # 3251
PPC_circinc: int  # 1565
PPC_clcs: int  # 363
PPC_clf: int  # 364
PPC_cli: int  # 365
PPC_clrbhrb: int  # 2083
PPC_clrldi: int  # 1193
PPC_clrlsldi: int  # 1195
PPC_clrlslwi: int  # 348
PPC_clrlwi: int  # 346
PPC_clrrdi: int  # 1194
PPC_clrrwi: int  # 347
PPC_cmp: int  # 17
PPC_cmp16i: int  # 1160
PPC_cmpb: int  # 671
PPC_cmpd: int  # 234
PPC_cmpdi: int  # 233
PPC_cmpeqb: int  # 2259
PPC_cmph: int  # 1161
PPC_cmph16i: int  # 1162
PPC_cmphl: int  # 1163
PPC_cmphl16i: int  # 1164
PPC_cmpi: int  # 18
PPC_cmpl: int  # 19
PPC_cmpl16i: int  # 1165
PPC_cmpld: int  # 236
PPC_cmpldi: int  # 235
PPC_cmpli: int  # 20
PPC_cmplw: int  # 232
PPC_cmplwi: int  # 231
PPC_cmprb: int  # 2260
PPC_cmpw: int  # 230
PPC_cmpwi: int  # 229
PPC_cntlzd: int  # 21
PPC_cntlzdm: int  # 3252
PPC_cntlzw: int  # 22
PPC_cnttzd: int  # 2262
PPC_cnttzdm: int  # 3253
PPC_cnttzw: int  # 2261
PPC_copy: int  # 2280
PPC_cpabort: int  # 2286
PPC_crand: int  # 23
PPC_crandc: int  # 24
PPC_crclr: int  # 290
PPC_creqv: int  # 25
PPC_crmove: int  # 289
PPC_crnand: int  # 26
PPC_crnor: int  # 27
PPC_crnot: int  # 288
PPC_cror: int  # 28
PPC_crorc: int  # 29
PPC_crset: int  # 287
PPC_crxor: int  # 30
PPC_dadd: int  # 684
PPC_daddq: int  # 685
PPC_darn: int  # 2263
PPC_dcba: int  # 31
PPC_dcbf: int  # 32
PPC_dcbfep: int  # 759
PPC_dcbfl: int  # 1198
PPC_dcbflp: int  # 1199
PPC_dcbi: int  # 33
PPC_dcblc: int  # 408
PPC_dcblq: int  # 2198
PPC_dcbst: int  # 34
PPC_dcbstep: int  # 760
PPC_dcbt: int  # 35
PPC_dcbtep: int  # 761
PPC_dcbtls: int  # 409
PPC_dcbtst: int  # 36
PPC_dcbtstep: int  # 762
PPC_dcbtstls: int  # 410
PPC_dcbtstt: int  # 1201
PPC_dcbtt: int  # 1200
PPC_dcbz: int  # 37
PPC_dcbz128: int  # 1215
PPC_dcbz_l: int  # 1262
PPC_dcbzep: int  # 763
PPC_dccci: int  # 349
PPC_dcffix: int  # 686
PPC_dcffixq: int  # 687
PPC_dcffixqq: int  # 3254
PPC_dci: int  # 748
PPC_dclst: int  # 366
PPC_dcmpo: int  # 688
PPC_dcmpoq: int  # 689
PPC_dcmpu: int  # 690
PPC_dcmpuq: int  # 691
PPC_dcread: int  # 350
PPC_dctdp: int  # 692
PPC_dctfix: int  # 693
PPC_dctfixq: int  # 694
PPC_dctfixqq: int  # 3255
PPC_dctqpq: int  # 695
PPC_ddedpd: int  # 696
PPC_ddedpdq: int  # 697
PPC_ddiv: int  # 698
PPC_ddivq: int  # 699
PPC_denbcd: int  # 700
PPC_denbcdq: int  # 701
PPC_diex: int  # 702
PPC_diexq: int  # 703
PPC_div: int  # 367
PPC_divd: int  # 38
PPC_divde: int  # 666
PPC_divdeu: int  # 667
PPC_divdu: int  # 39
PPC_divs: int  # 368
PPC_divw: int  # 40
PPC_divwe: int  # 672
PPC_divweu: int  # 673
PPC_divwu: int  # 41
PPC_dlmzb: int  # 831
PPC_dmul: int  # 704
PPC_dmulq: int  # 705
PPC_dnh: int  # 754
PPC_dni: int  # 2252
PPC_doz: int  # 369
PPC_doze: int  # 834
PPC_dozi: int  # 370
PPC_dqua: int  # 706
PPC_dquai: int  # 707
PPC_dquaiq: int  # 708
PPC_dquaq: int  # 709
PPC_drdpq: int  # 710
PPC_drintn: int  # 711
PPC_drintnq: int  # 712
PPC_drintx: int  # 713
PPC_drintxq: int  # 714
PPC_drrnd: int  # 715
PPC_drrndq: int  # 716
PPC_drsp: int  # 717
PPC_dscli: int  # 718
PPC_dscliq: int  # 719
PPC_dscri: int  # 720
PPC_dscriq: int  # 721
PPC_dsn: int  # 734
PPC_dsncb: int  # 2460
PPC_dss: int  # 1141
PPC_dssall: int  # 1142
PPC_dst: int  # 1143
PPC_dstst: int  # 1145
PPC_dststt: int  # 1146
PPC_dstt: int  # 1144
PPC_dsub: int  # 722
PPC_dsubq: int  # 723
PPC_dtstdc: int  # 724
PPC_dtstdcq: int  # 725
PPC_dtstdg: int  # 726
PPC_dtstdgq: int  # 727
PPC_dtstex: int  # 728
PPC_dtstexq: int  # 729
PPC_dtstsf: int  # 730
PPC_dtstsfi: int  # 2288
PPC_dtstsfiq: int  # 2289
PPC_dtstsfq: int  # 731
PPC_dxex: int  # 732
PPC_dxexq: int  # 733
PPC_eciwx: int  # 42
PPC_ecowx: int  # 43
PPC_efdabs: int  # 590
PPC_efdadd: int  # 591
PPC_efdcfh: int  # 2500
PPC_efdcfs: int  # 592
PPC_efdcfsf: int  # 593
PPC_efdcfsi: int  # 594
PPC_efdcfsid: int  # 595
PPC_efdcfuf: int  # 596
PPC_efdcfui: int  # 597
PPC_efdcfuid: int  # 598
PPC_efdcmpeq: int  # 599
PPC_efdcmpgt: int  # 600
PPC_efdcmplt: int  # 601
PPC_efdcth: int  # 2501
PPC_efdctsf: int  # 602
PPC_efdctsi: int  # 603
PPC_efdctsidz: int  # 604
PPC_efdctsiz: int  # 605
PPC_efdctuf: int  # 606
PPC_efdctui: int  # 607
PPC_efdctuidz: int  # 608
PPC_efdctuiz: int  # 609
PPC_efddiv: int  # 610
PPC_efdmax: int  # 2497
PPC_efdmin: int  # 2498
PPC_efdmul: int  # 611
PPC_efdnabs: int  # 612
PPC_efdneg: int  # 613
PPC_efdsqrt: int  # 2499
PPC_efdsub: int  # 614
PPC_efdtsteq: int  # 615
PPC_efdtstgt: int  # 616
PPC_efdtstlt: int  # 617
PPC_efsabs: int  # 619
PPC_efsadd: int  # 620
PPC_efscfd: int  # 618
PPC_efscfh: int  # 1296
PPC_efscfsf: int  # 621
PPC_efscfsi: int  # 622
PPC_efscfuf: int  # 623
PPC_efscfui: int  # 624
PPC_efscmpeq: int  # 625
PPC_efscmpgt: int  # 626
PPC_efscmplt: int  # 627
PPC_efscth: int  # 1297
PPC_efsctsf: int  # 628
PPC_efsctsi: int  # 629
PPC_efsctsiz: int  # 630
PPC_efsctuf: int  # 631
PPC_efsctui: int  # 632
PPC_efsctuiz: int  # 633
PPC_efsdiv: int  # 634
PPC_efsmadd: int  # 1291
PPC_efsmax: int  # 1289
PPC_efsmin: int  # 1290
PPC_efsmsub: int  # 1292
PPC_efsmul: int  # 635
PPC_efsnabs: int  # 636
PPC_efsneg: int  # 637
PPC_efsnmadd: int  # 1294
PPC_efsnmsub: int  # 1295
PPC_efssqrt: int  # 1293
PPC_efssub: int  # 638
PPC_efststeq: int  # 639
PPC_efststgt: int  # 640
PPC_efststlt: int  # 641
PPC_ehpriv: int  # 755
PPC_eieio: int  # 44
PPC_eqv: int  # 45
PPC_evabs: int  # 418
PPC_evabsb: int  # 1522
PPC_evabsbs: int  # 1526
PPC_evabsd: int  # 1524
PPC_evabsdifsb: int  # 2006
PPC_evabsdifsh: int  # 2008
PPC_evabsdifsw: int  # 2004
PPC_evabsdifub: int  # 2005
PPC_evabsdifuh: int  # 2007
PPC_evabsdifuw: int  # 2003
PPC_evabsds: int  # 1528
PPC_evabsh: int  # 1523
PPC_evabshs: int  # 1527
PPC_evabss: int  # 1525
PPC_evadd2subf2h: int  # 1849
PPC_evadd2subf2hss: int  # 1850
PPC_evaddb: int  # 1829
PPC_evaddbss: int  # 1830
PPC_evaddbus: int  # 1842
PPC_evaddd: int  # 1825
PPC_evadddss: int  # 1826
PPC_evadddus: int  # 1841
PPC_evaddh: int  # 1817
PPC_evaddhhisw: int  # 1909
PPC_evaddhhiuw: int  # 1908
PPC_evaddhlosw: int  # 1913
PPC_evaddhlouw: int  # 1912
PPC_evaddhss: int  # 1818
PPC_evaddhus: int  # 1853
PPC_evaddhx: int  # 1821
PPC_evaddhxss: int  # 1822
PPC_evaddhxus: int  # 1854
PPC_evaddib: int  # 1519
PPC_evaddih: int  # 1518
PPC_evaddiw: int  # 419
PPC_evaddsmiaa: int  # 1815
PPC_evaddsmiaaw: int  # 420
PPC_evaddssiaa: int  # 1812
PPC_evaddssiaaw: int  # 421
PPC_evaddsubfh: int  # 1833
PPC_evaddsubfhss: int  # 1834
PPC_evaddsubfhx: int  # 1837
PPC_evaddsubfhxss: int  # 1838
PPC_evaddsubfw: int  # 1863
PPC_evaddsubfwss: int  # 1864
PPC_evaddsubfwx: int  # 1867
PPC_evaddsubfwxss: int  # 1868
PPC_evaddumiaaw: int  # 422
PPC_evaddusiaa: int  # 1811
PPC_evaddusiaaw: int  # 423
PPC_evaddw: int  # 424
PPC_evaddwegsf: int  # 1901
PPC_evaddwegsi: int  # 1900
PPC_evaddwogsf: int  # 1905
PPC_evaddwogsi: int  # 1904
PPC_evaddwss: int  # 1857
PPC_evaddwus: int  # 1845
PPC_evaddwx: int  # 1859
PPC_evaddwxss: int  # 1860
PPC_evaddwxus: int  # 1846
PPC_evand: int  # 425
PPC_evandc: int  # 426
PPC_evavgbs: int  # 2065
PPC_evavgbsr: int  # 2073
PPC_evavgbu: int  # 2064
PPC_evavgbur: int  # 2072
PPC_evavgds: int  # 2069
PPC_evavgdsr: int  # 2077
PPC_evavgdu: int  # 2068
PPC_evavgdur: int  # 2076
PPC_evavghs: int  # 2067
PPC_evavghsr: int  # 2075
PPC_evavghu: int  # 2066
PPC_evavghur: int  # 2074
PPC_evavgws: int  # 2063
PPC_evavgwsr: int  # 2071
PPC_evavgwu: int  # 2062
PPC_evavgwur: int  # 2070
PPC_evclrbe: int  # 1653
PPC_evclrbo: int  # 1654
PPC_evclrh: int  # 1656
PPC_evcmpeq: int  # 427
PPC_evcmpeqd: int  # 1639
PPC_evcmpgtds: int  # 1636
PPC_evcmpgtdu: int  # 1635
PPC_evcmpgts: int  # 428
PPC_evcmpgtu: int  # 429
PPC_evcmpltds: int  # 1638
PPC_evcmpltdu: int  # 1637
PPC_evcmplts: int  # 430
PPC_evcmpltu: int  # 431
PPC_evcntlsh: int  # 1563
PPC_evcntlsw: int  # 432
PPC_evcntlzh: int  # 1562
PPC_evcntlzw: int  # 433
PPC_evdiff2his: int  # 1878
PPC_evdiff2hisa: int  # 1886
PPC_evdiff2hisaaw: int  # 1894
PPC_evdivs: int  # 1898
PPC_evdivu: int  # 1899
PPC_evdivws: int  # 434
PPC_evdivwsf: int  # 1896
PPC_evdivwu: int  # 435
PPC_evdivwuf: int  # 1897
PPC_evdlveb: int  # 2038
PPC_evdlveh: int  # 2039
PPC_evdlveob: int  # 2040
PPC_evdlveoh: int  # 2041
PPC_evdlvob: int  # 2042
PPC_evdlvoeb: int  # 2044
PPC_evdlvoeh: int  # 2045
PPC_evdlvoh: int  # 2043
PPC_evdotp4hgasmf: int  # 1439
PPC_evdotp4hgasmfa: int  # 1465
PPC_evdotp4hgasmfaa: int  # 1478
PPC_evdotp4hgasmfaa3: int  # 1452
PPC_evdotp4hgasmi: int  # 1437
PPC_evdotp4hgasmia: int  # 1463
PPC_evdotp4hgasmiaa: int  # 1476
PPC_evdotp4hgasmiaa3: int  # 1450
PPC_evdotp4hgasumi: int  # 1438
PPC_evdotp4hgasumia: int  # 1464
PPC_evdotp4hgasumiaa: int  # 1477
PPC_evdotp4hgasumiaa3: int  # 1451
PPC_evdotp4hgaumi: int  # 1436
PPC_evdotp4hgaumia: int  # 1462
PPC_evdotp4hgaumiaa: int  # 1475
PPC_evdotp4hgaumiaa3: int  # 1449
PPC_evdotp4hgssmf: int  # 1441
PPC_evdotp4hgssmfa: int  # 1467
PPC_evdotp4hgssmfaa: int  # 1480
PPC_evdotp4hgssmfaa3: int  # 1454
PPC_evdotp4hgssmi: int  # 1440
PPC_evdotp4hgssmia: int  # 1466
PPC_evdotp4hgssmiaa: int  # 1479
PPC_evdotp4hgssmiaa3: int  # 1453
PPC_evdotp4hxgasmf: int  # 1443
PPC_evdotp4hxgasmfa: int  # 1469
PPC_evdotp4hxgasmfaa: int  # 1482
PPC_evdotp4hxgasmfaa3: int  # 1456
PPC_evdotp4hxgasmi: int  # 1442
PPC_evdotp4hxgasmia: int  # 1468
PPC_evdotp4hxgasmiaa: int  # 1481
PPC_evdotp4hxgasmiaa3: int  # 1455
PPC_evdotp4hxgssmf: int  # 1448
PPC_evdotp4hxgssmfa: int  # 1474
PPC_evdotp4hxgssmfaa: int  # 1487
PPC_evdotp4hxgssmfaa3: int  # 1461
PPC_evdotp4hxgssmi: int  # 1447
PPC_evdotp4hxgssmia: int  # 1473
PPC_evdotp4hxgssmiaa: int  # 1486
PPC_evdotp4hxgssmiaa3: int  # 1460
PPC_evdotpbasmi: int  # 1445
PPC_evdotpbasmia: int  # 1471
PPC_evdotpbasmiaaw: int  # 1484
PPC_evdotpbasmiaaw3: int  # 1458
PPC_evdotpbasumi: int  # 1446
PPC_evdotpbasumia: int  # 1472
PPC_evdotpbasumiaaw: int  # 1485
PPC_evdotpbasumiaaw3: int  # 1459
PPC_evdotpbaumi: int  # 1444
PPC_evdotpbaumia: int  # 1470
PPC_evdotpbaumiaaw: int  # 1483
PPC_evdotpbaumiaaw3: int  # 1457
PPC_evdotphasmi: int  # 1396
PPC_evdotphasmia: int  # 1419
PPC_evdotphasmiaaw: int  # 1431
PPC_evdotphasmiaaw3: int  # 1408
PPC_evdotphassf: int  # 1393
PPC_evdotphassfa: int  # 1416
PPC_evdotphassfaaw: int  # 1427
PPC_evdotphassfaaw3: int  # 1404
PPC_evdotphassfr: int  # 1398
PPC_evdotphassfra: int  # 1421
PPC_evdotphassfraaw: int  # 1433
PPC_evdotphassfraaw3: int  # 1410
PPC_evdotphassi: int  # 1391
PPC_evdotphassia: int  # 1414
PPC_evdotphassiaaw: int  # 1425
PPC_evdotphassiaaw3: int  # 1402
PPC_evdotphasumi: int  # 1397
PPC_evdotphasumia: int  # 1420
PPC_evdotphasumiaaw: int  # 1432
PPC_evdotphasumiaaw3: int  # 1409
PPC_evdotphasusi: int  # 1392
PPC_evdotphasusia: int  # 1415
PPC_evdotphasusiaaw: int  # 1426
PPC_evdotphasusiaaw3: int  # 1403
PPC_evdotphaumi: int  # 1395
PPC_evdotphaumia: int  # 1418
PPC_evdotphaumiaaw: int  # 1430
PPC_evdotphaumiaaw3: int  # 1407
PPC_evdotphausi: int  # 1390
PPC_evdotphausia: int  # 1413
PPC_evdotphausiaaw: int  # 1424
PPC_evdotphausiaaw3: int  # 1401
PPC_evdotphihcsmi: int  # 1362
PPC_evdotphihcsmia: int  # 1378
PPC_evdotphihcsmiaaw: int  # 1386
PPC_evdotphihcsmiaaw3: int  # 1370
PPC_evdotphihcssf: int  # 1360
PPC_evdotphihcssfa: int  # 1376
PPC_evdotphihcssfaaw: int  # 1384
PPC_evdotphihcssfaaw3: int  # 1368
PPC_evdotphihcssfr: int  # 1364
PPC_evdotphihcssfra: int  # 1380
PPC_evdotphihcssfraaw: int  # 1388
PPC_evdotphihcssfraaw3: int  # 1372
PPC_evdotphihcssi: int  # 1358
PPC_evdotphihcssia: int  # 1374
PPC_evdotphihcssiaaw: int  # 1382
PPC_evdotphihcssiaaw3: int  # 1366
PPC_evdotphssmi: int  # 1399
PPC_evdotphssmia: int  # 1422
PPC_evdotphssmiaaw: int  # 1434
PPC_evdotphssmiaaw3: int  # 1411
PPC_evdotphsssf: int  # 1394
PPC_evdotphsssfa: int  # 1417
PPC_evdotphsssfaaw: int  # 1429
PPC_evdotphsssfaaw3: int  # 1406
PPC_evdotphsssfr: int  # 1400
PPC_evdotphsssfra: int  # 1423
PPC_evdotphsssfraaw: int  # 1435
PPC_evdotphsssfraaw3: int  # 1412
PPC_evdotphsssiaaw: int  # 1428
PPC_evdotphsssiaaw3: int  # 1405
PPC_evdotplohcsmi: int  # 1363
PPC_evdotplohcsmia: int  # 1379
PPC_evdotplohcsmiaaw: int  # 1387
PPC_evdotplohcsmiaaw3: int  # 1371
PPC_evdotplohcssf: int  # 1361
PPC_evdotplohcssfa: int  # 1377
PPC_evdotplohcssfaaw: int  # 1385
PPC_evdotplohcssfaaw3: int  # 1369
PPC_evdotplohcssfr: int  # 1365
PPC_evdotplohcssfra: int  # 1381
PPC_evdotplohcssfraaw: int  # 1389
PPC_evdotplohcssfraaw3: int  # 1373
PPC_evdotplohcssi: int  # 1359
PPC_evdotplohcssia: int  # 1375
PPC_evdotplohcssiaaw: int  # 1383
PPC_evdotplohcssiaaw3: int  # 1367
PPC_evdotpwasmi: int  # 1492
PPC_evdotpwasmia: int  # 1507
PPC_evdotpwasmiaa: int  # 1515
PPC_evdotpwasmiaa3: int  # 1500
PPC_evdotpwassi: int  # 1489
PPC_evdotpwassia: int  # 1504
PPC_evdotpwassiaa: int  # 1511
PPC_evdotpwassiaa3: int  # 1496
PPC_evdotpwasumi: int  # 1493
PPC_evdotpwasumia: int  # 1508
PPC_evdotpwasumiaa: int  # 1516
PPC_evdotpwasumiaa3: int  # 1501
PPC_evdotpwasusi: int  # 1490
PPC_evdotpwasusia: int  # 1505
PPC_evdotpwasusiaa: int  # 1512
PPC_evdotpwasusiaa3: int  # 1497
PPC_evdotpwaumi: int  # 1491
PPC_evdotpwaumia: int  # 1506
PPC_evdotpwaumiaa: int  # 1514
PPC_evdotpwaumiaa3: int  # 1499
PPC_evdotpwausi: int  # 1488
PPC_evdotpwausia: int  # 1503
PPC_evdotpwausiaa: int  # 1510
PPC_evdotpwausiaa3: int  # 1495
PPC_evdotpwcsmi: int  # 1311
PPC_evdotpwcsmia: int  # 1335
PPC_evdotpwcsmiaaw: int  # 1347
PPC_evdotpwcsmiaaw3: int  # 1323
PPC_evdotpwcssf: int  # 1313
PPC_evdotpwcssfa: int  # 1337
PPC_evdotpwcssfaaw: int  # 1349
PPC_evdotpwcssfaaw3: int  # 1325
PPC_evdotpwcssfr: int  # 1312
PPC_evdotpwcssfra: int  # 1336
PPC_evdotpwcssfraaw: int  # 1348
PPC_evdotpwcssfraaw3: int  # 1324
PPC_evdotpwcssi: int  # 1310
PPC_evdotpwcssia: int  # 1334
PPC_evdotpwcssiaaw: int  # 1346
PPC_evdotpwcssiaaw3: int  # 1322
PPC_evdotpwgasmf: int  # 1314
PPC_evdotpwgasmfa: int  # 1338
PPC_evdotpwgasmfaa: int  # 1350
PPC_evdotpwgasmfaa3: int  # 1326
PPC_evdotpwgasmfr: int  # 1316
PPC_evdotpwgasmfra: int  # 1340
PPC_evdotpwgasmfraa: int  # 1352
PPC_evdotpwgasmfraa3: int  # 1328
PPC_evdotpwgssmf: int  # 1318
PPC_evdotpwgssmfa: int  # 1342
PPC_evdotpwgssmfaa: int  # 1354
PPC_evdotpwgssmfaa3: int  # 1330
PPC_evdotpwgssmfr: int  # 1320
PPC_evdotpwgssmfra: int  # 1344
PPC_evdotpwgssmfraa: int  # 1356
PPC_evdotpwgssmfraa3: int  # 1332
PPC_evdotpwssmi: int  # 1494
PPC_evdotpwssmia: int  # 1509
PPC_evdotpwssmiaa: int  # 1517
PPC_evdotpwssmiaa3: int  # 1502
PPC_evdotpwsssiaa: int  # 1513
PPC_evdotpwsssiaa3: int  # 1498
PPC_evdotpwxgasmf: int  # 1315
PPC_evdotpwxgasmfa: int  # 1339
PPC_evdotpwxgasmfaa: int  # 1351
PPC_evdotpwxgasmfaa3: int  # 1327
PPC_evdotpwxgasmfr: int  # 1317
PPC_evdotpwxgasmfra: int  # 1341
PPC_evdotpwxgasmfraa: int  # 1353
PPC_evdotpwxgasmfraa3: int  # 1329
PPC_evdotpwxgssmf: int  # 1319
PPC_evdotpwxgssmfa: int  # 1343
PPC_evdotpwxgssmfaa: int  # 1355
PPC_evdotpwxgssmfaa3: int  # 1331
PPC_evdotpwxgssmfr: int  # 1321
PPC_evdotpwxgssmfra: int  # 1345
PPC_evdotpwxgssmfraa: int  # 1357
PPC_evdotpwxgssmfraa3: int  # 1333
PPC_eveqv: int  # 436
PPC_evextsb: int  # 437
PPC_evextsbh: int  # 1543
PPC_evextsh: int  # 438
PPC_evextsw: int  # 1544
PPC_evextzb: int  # 1542
PPC_evfsabs: int  # 642
PPC_evfsadd: int  # 643
PPC_evfsaddsub: int  # 1274
PPC_evfsaddsubx: int  # 1282
PPC_evfsaddx: int  # 1280
PPC_evfscfh: int  # 1287
PPC_evfscfsf: int  # 644
PPC_evfscfsi: int  # 645
PPC_evfscfuf: int  # 646
PPC_evfscfui: int  # 647
PPC_evfscmpeq: int  # 648
PPC_evfscmpgt: int  # 649
PPC_evfscmplt: int  # 650
PPC_evfscth: int  # 1288
PPC_evfsctsf: int  # 651
PPC_evfsctsi: int  # 652
PPC_evfsctsiz: int  # 653
PPC_evfsctuf: int  # 654
PPC_evfsctui: int  # 655
PPC_evfsctuiz: int  # 656
PPC_evfsdiff: int  # 1277
PPC_evfsdiffsum: int  # 1279
PPC_evfsdiv: int  # 657
PPC_evfsmadd: int  # 1267
PPC_evfsmax: int  # 1272
PPC_evfsmin: int  # 1273
PPC_evfsmsub: int  # 1268
PPC_evfsmul: int  # 658
PPC_evfsmule: int  # 1285
PPC_evfsmulo: int  # 1286
PPC_evfsmulx: int  # 1284
PPC_evfsnabs: int  # 659
PPC_evfsneg: int  # 660
PPC_evfsnmadd: int  # 1270
PPC_evfsnmsub: int  # 1271
PPC_evfssqrt: int  # 1269
PPC_evfssub: int  # 661
PPC_evfssubadd: int  # 1275
PPC_evfssubaddx: int  # 1283
PPC_evfssubx: int  # 1281
PPC_evfssum: int  # 1276
PPC_evfssumdiff: int  # 1278
PPC_evfststeq: int  # 662
PPC_evfststgt: int  # 663
PPC_evfststlt: int  # 664
PPC_evilveh: int  # 2030
PPC_evilveoh: int  # 2031
PPC_evilvhih: int  # 2032
PPC_evilvhiloh: int  # 2033
PPC_evilvloh: int  # 2034
PPC_evilvlohih: int  # 2035
PPC_evilvoeh: int  # 2036
PPC_evilvoh: int  # 2037
PPC_evinsb: int  # 1648
PPC_evinsh: int  # 1652
PPC_evlbbsplatb: int  # 1698
PPC_evlbbsplatbmx: int  # 1745
PPC_evlbbsplatbu: int  # 1746
PPC_evlbbsplatbx: int  # 1697
PPC_evldb: int  # 1690
PPC_evldbmx: int  # 1721
PPC_evldbu: int  # 1722
PPC_evldbx: int  # 1689
PPC_evldd: int  # 439
PPC_evlddepx: int  # 764
PPC_evlddmx: int  # 1715
PPC_evlddu: int  # 1716
PPC_evlddx: int  # 440
PPC_evldh: int  # 441
PPC_evldhmx: int  # 1719
PPC_evldhu: int  # 1720
PPC_evldhx: int  # 442
PPC_evldw: int  # 443
PPC_evldwmx: int  # 1717
PPC_evldwu: int  # 1718
PPC_evldwx: int  # 444
PPC_evlhhesplat: int  # 445
PPC_evlhhesplatmx: int  # 1723
PPC_evlhhesplatu: int  # 1724
PPC_evlhhesplatx: int  # 446
PPC_evlhhossplat: int  # 447
PPC_evlhhossplatmx: int  # 1729
PPC_evlhhossplatu: int  # 1730
PPC_evlhhossplatx: int  # 448
PPC_evlhhousplat: int  # 449
PPC_evlhhousplatmx: int  # 1727
PPC_evlhhousplatu: int  # 1728
PPC_evlhhousplatx: int  # 450
PPC_evlhhsplath: int  # 1692
PPC_evlhhsplathmx: int  # 1725
PPC_evlhhsplathu: int  # 1726
PPC_evlhhsplathx: int  # 1691
PPC_evlvsl: int  # 1684
PPC_evlvsr: int  # 1685
PPC_evlwbe: int  # 1702
PPC_evlwbemx: int  # 1755
PPC_evlwbeu: int  # 1756
PPC_evlwbex: int  # 1701
PPC_evlwbos: int  # 1706
PPC_evlwbosmx: int  # 1759
PPC_evlwbosu: int  # 1760
PPC_evlwbosx: int  # 1705
PPC_evlwbou: int  # 1704
PPC_evlwboumx: int  # 1757
PPC_evlwbouu: int  # 1758
PPC_evlwboux: int  # 1703
PPC_evlwbsplatw: int  # 1694
PPC_evlwbsplatwmx: int  # 1733
PPC_evlwbsplatwu: int  # 1734
PPC_evlwbsplatwx: int  # 1693
PPC_evlwhe: int  # 451
PPC_evlwhemx: int  # 1731
PPC_evlwheu: int  # 1732
PPC_evlwhex: int  # 452
PPC_evlwhos: int  # 453
PPC_evlwhosmx: int  # 1737
PPC_evlwhosu: int  # 1738
PPC_evlwhosx: int  # 454
PPC_evlwhou: int  # 455
PPC_evlwhoumx: int  # 1735
PPC_evlwhouu: int  # 1736
PPC_evlwhoux: int  # 456
PPC_evlwhsplat: int  # 457
PPC_evlwhsplatmx: int  # 1743
PPC_evlwhsplatu: int  # 1744
PPC_evlwhsplatw: int  # 1696
PPC_evlwhsplatwmx: int  # 1741
PPC_evlwhsplatwu: int  # 1742
PPC_evlwhsplatwx: int  # 1695
PPC_evlwhsplatx: int  # 458
PPC_evlwwsplat: int  # 459
PPC_evlwwsplatmx: int  # 1739
PPC_evlwwsplatu: int  # 1740
PPC_evlwwsplatx: int  # 460
PPC_evmar: int  # 1871
PPC_evmaxbpsh: int  # 1597
PPC_evmaxbpuh: int  # 1596
PPC_evmaxbs: int  # 2047
PPC_evmaxbu: int  # 2046
PPC_evmaxds: int  # 2053
PPC_evmaxdu: int  # 2052
PPC_evmaxhpsw: int  # 1595
PPC_evmaxhpuw: int  # 1594
PPC_evmaxhs: int  # 2049
PPC_evmaxhu: int  # 2048
PPC_evmaxmagws: int  # 1606
PPC_evmaxwpsd: int  # 1599
PPC_evmaxwpud: int  # 1598
PPC_evmaxws: int  # 2051
PPC_evmaxwu: int  # 2050
PPC_evmbesmi: int  # 1786
PPC_evmbesmia: int  # 1794
PPC_evmbesmiaah: int  # 1927
PPC_evmbesmianh: int  # 1957
PPC_evmbessiaah: int  # 1921
PPC_evmbessianh: int  # 1951
PPC_evmbesumi: int  # 1787
PPC_evmbesumia: int  # 1795
PPC_evmbesumiaah: int  # 1928
PPC_evmbesumianh: int  # 1958
PPC_evmbesusiaah: int  # 1922
PPC_evmbesusianh: int  # 1952
PPC_evmbeumi: int  # 1785
PPC_evmbeumia: int  # 1793
PPC_evmbeumiaah: int  # 1926
PPC_evmbeumianh: int  # 1956
PPC_evmbeusiaah: int  # 1920
PPC_evmbeusianh: int  # 1950
PPC_evmbosmi: int  # 1789
PPC_evmbosmia: int  # 1797
PPC_evmbosmiaah: int  # 1930
PPC_evmbosmianh: int  # 1960
PPC_evmbossiaah: int  # 1924
PPC_evmbossianh: int  # 1954
PPC_evmbosumi: int  # 1790
PPC_evmbosumia: int  # 1798
PPC_evmbosumiaah: int  # 1931
PPC_evmbosumianh: int  # 1961
PPC_evmbosusiaah: int  # 1925
PPC_evmbosusianh: int  # 1955
PPC_evmboumi: int  # 1788
PPC_evmboumia: int  # 1796
PPC_evmboumiaah: int  # 1929
PPC_evmboumianh: int  # 1959
PPC_evmbousiaah: int  # 1923
PPC_evmbousianh: int  # 1953
PPC_evmergehi: int  # 461
PPC_evmergehilo: int  # 462
PPC_evmergelo: int  # 463
PPC_evmergelohi: int  # 464
PPC_evmhegsmfaa: int  # 465
PPC_evmhegsmfan: int  # 466
PPC_evmhegsmiaa: int  # 467
PPC_evmhegsmian: int  # 468
PPC_evmhegumiaa: int  # 469
PPC_evmhegumian: int  # 470
PPC_evmhesmf: int  # 471
PPC_evmhesmfa: int  # 472
PPC_evmhesmfaaw: int  # 473
PPC_evmhesmfanw: int  # 474
PPC_evmhesmi: int  # 475
PPC_evmhesmia: int  # 476
PPC_evmhesmiaaw: int  # 477
PPC_evmhesmianw: int  # 478
PPC_evmhessf: int  # 479
PPC_evmhessfa: int  # 480
PPC_evmhessfaaw: int  # 481
PPC_evmhessfanw: int  # 482
PPC_evmhessiaaw: int  # 483
PPC_evmhessianw: int  # 484
PPC_evmhesumi: int  # 1783
PPC_evmhesumia: int  # 1791
PPC_evmhesumiaaw: int  # 1918
PPC_evmhesumianw: int  # 1948
PPC_evmhesusiaaw: int  # 1916
PPC_evmhesusianw: int  # 1946
PPC_evmheumi: int  # 485
PPC_evmheumia: int  # 486
PPC_evmheumiaaw: int  # 487
PPC_evmheumianw: int  # 488
PPC_evmheusiaaw: int  # 489
PPC_evmheusianw: int  # 490
PPC_evmhogsmfaa: int  # 491
PPC_evmhogsmfan: int  # 492
PPC_evmhogsmiaa: int  # 493
PPC_evmhogsmian: int  # 494
PPC_evmhogumiaa: int  # 495
PPC_evmhogumian: int  # 496
PPC_evmhosmf: int  # 497
PPC_evmhosmfa: int  # 498
PPC_evmhosmfaaw: int  # 499
PPC_evmhosmfanw: int  # 500
PPC_evmhosmi: int  # 501
PPC_evmhosmia: int  # 502
PPC_evmhosmiaaw: int  # 503
PPC_evmhosmianw: int  # 504
PPC_evmhossf: int  # 505
PPC_evmhossfa: int  # 506
PPC_evmhossfaaw: int  # 507
PPC_evmhossfanw: int  # 508
PPC_evmhossiaaw: int  # 509
PPC_evmhossianw: int  # 510
PPC_evmhosumi: int  # 1784
PPC_evmhosumia: int  # 1792
PPC_evmhosumiaaw: int  # 1919
PPC_evmhosumianw: int  # 1949
PPC_evmhosusiaaw: int  # 1917
PPC_evmhosusianw: int  # 1947
PPC_evmhoumi: int  # 511
PPC_evmhoumia: int  # 512
PPC_evmhoumiaaw: int  # 513
PPC_evmhoumianw: int  # 514
PPC_evmhousiaaw: int  # 515
PPC_evmhousianw: int  # 516
PPC_evmhssf: int  # 1780
PPC_evmhssfr: int  # 1782
PPC_evmhssi: int  # 1778
PPC_evmhsusi: int  # 1779
PPC_evmhumi: int  # 1781
PPC_evmhusi: int  # 1777
PPC_evminbpsh: int  # 1603
PPC_evminbpuh: int  # 1602
PPC_evminbs: int  # 2055
PPC_evminbu: int  # 2054
PPC_evminds: int  # 2061
PPC_evmindu: int  # 2060
PPC_evminhpsw: int  # 1601
PPC_evminhpuw: int  # 1600
PPC_evminhs: int  # 2057
PPC_evminhu: int  # 2056
PPC_evminwpsd: int  # 1605
PPC_evminwpud: int  # 1604
PPC_evminws: int  # 2059
PPC_evminwu: int  # 2058
PPC_evmr: int  # 1206
PPC_evmra: int  # 517
PPC_evmwehgsmf: int  # 1803
PPC_evmwehgsmfa: int  # 1808
PPC_evmwehgsmfaa: int  # 1943
PPC_evmwehgsmfan: int  # 1973
PPC_evmwehgsmfr: int  # 1802
PPC_evmwehgsmfra: int  # 1807
PPC_evmwehgsmfraa: int  # 1942
PPC_evmwehgsmfran: int  # 1972
PPC_evmwhsmf: int  # 518
PPC_evmwhsmfa: int  # 519
PPC_evmwhsmi: int  # 520
PPC_evmwhsmia: int  # 521
PPC_evmwhssf: int  # 522
PPC_evmwhssfa: int  # 523
PPC_evmwhssfaaw: int  # 1937
PPC_evmwhssfaaw3: int  # 1935
PPC_evmwhssfanw: int  # 1967
PPC_evmwhssfanw3: int  # 1965
PPC_evmwhssfr: int  # 1801
PPC_evmwhssfra: int  # 1806
PPC_evmwhssfraaw: int  # 1936
PPC_evmwhssfraaw3: int  # 1934
PPC_evmwhssfranw: int  # 1966
PPC_evmwhssfranw3: int  # 1964
PPC_evmwhumi: int  # 524
PPC_evmwhumia: int  # 525
PPC_evmwlsmiaaw: int  # 526
PPC_evmwlsmiaaw3: int  # 1939
PPC_evmwlsmianw: int  # 527
PPC_evmwlsmianw3: int  # 1969
PPC_evmwlssiaaw: int  # 528
PPC_evmwlssiaaw3: int  # 1933
PPC_evmwlssianw: int  # 529
PPC_evmwlssianw3: int  # 1963
PPC_evmwlumi: int  # 530
PPC_evmwlumia: int  # 531
PPC_evmwlumiaaw: int  # 532
PPC_evmwlumiaaw3: int  # 1938
PPC_evmwlumianw: int  # 533
PPC_evmwlumianw3: int  # 1968
PPC_evmwlusiaaw: int  # 534
PPC_evmwlusiaaw3: int  # 1932
PPC_evmwlusianw: int  # 535
PPC_evmwlusianw3: int  # 1962
PPC_evmwohgsmf: int  # 1805
PPC_evmwohgsmfa: int  # 1810
PPC_evmwohgsmfaa: int  # 1945
PPC_evmwohgsmfan: int  # 1975
PPC_evmwohgsmfr: int  # 1804
PPC_evmwohgsmfra: int  # 1809
PPC_evmwohgsmfraa: int  # 1944
PPC_evmwohgsmfran: int  # 1974
PPC_evmwsmf: int  # 536
PPC_evmwsmfa: int  # 537
PPC_evmwsmfaa: int  # 538
PPC_evmwsmfan: int  # 539
PPC_evmwsmi: int  # 540
PPC_evmwsmia: int  # 541
PPC_evmwsmiaa: int  # 542
PPC_evmwsmian: int  # 543
PPC_evmwssf: int  # 544
PPC_evmwssfa: int  # 545
PPC_evmwssfaa: int  # 546
PPC_evmwssfan: int  # 547
PPC_evmwssiaa: int  # 1941
PPC_evmwssian: int  # 1971
PPC_evmwssiw: int  # 1800
PPC_evmwumi: int  # 548
PPC_evmwumia: int  # 549
PPC_evmwumiaa: int  # 550
PPC_evmwumian: int  # 551
PPC_evmwusiaa: int  # 1940
PPC_evmwusian: int  # 1970
PPC_evmwusiw: int  # 1799
PPC_evnand: int  # 552
PPC_evneg: int  # 553
PPC_evnegb: int  # 1530
PPC_evnegbo: int  # 1531
PPC_evnegbos: int  # 1538
PPC_evnegbs: int  # 1537
PPC_evnegd: int  # 1534
PPC_evnegds: int  # 1541
PPC_evnegh: int  # 1532
PPC_evnegho: int  # 1533
PPC_evneghos: int  # 1540
PPC_evneghs: int  # 1539
PPC_evnegs: int  # 1535
PPC_evnegwo: int  # 1529
PPC_evnegwos: int  # 1536
PPC_evnor: int  # 554
PPC_evnot: int  # 1207
PPC_evor: int  # 555
PPC_evorc: int  # 556
PPC_evperm: int  # 1660
PPC_evperm2: int  # 1661
PPC_evperm3: int  # 1662
PPC_evpksdshefrs: int  # 2026
PPC_evpksdswfrs: int  # 2025
PPC_evpksdsws: int  # 2028
PPC_evpkshsbs: int  # 2016
PPC_evpkshubs: int  # 2015
PPC_evpkswgshefrs: int  # 2022
PPC_evpkswgswfrs: int  # 2029
PPC_evpkswshfrs: int  # 2023
PPC_evpkswshilvfrs: int  # 2024
PPC_evpkswshilvs: int  # 2021
PPC_evpkswshs: int  # 2018
PPC_evpkswuhs: int  # 2017
PPC_evpkuduws: int  # 2027
PPC_evpkuhubs: int  # 2019
PPC_evpkuwuhs: int  # 2020
PPC_evpopcntb: int  # 1564
PPC_evrlb: int  # 1669
PPC_evrlbi: int  # 1671
PPC_evrlh: int  # 1677
PPC_evrlhi: int  # 1679
PPC_evrlw: int  # 557
PPC_evrlwi: int  # 558
PPC_evrnddnw: int  # 1555
PPC_evrnddnwss: int  # 1561
PPC_evrnddnwus: int  # 1560
PPC_evrnddw: int  # 1546
PPC_evrnddwss: int  # 1552
PPC_evrnddwus: int  # 1551
PPC_evrndhb: int  # 1545
PPC_evrndhbss: int  # 1550
PPC_evrndhbus: int  # 1549
PPC_evrndhnb: int  # 1554
PPC_evrndhnbss: int  # 1559
PPC_evrndhnbus: int  # 1558
PPC_evrndw: int  # 559
PPC_evrndwhss: int  # 1548
PPC_evrndwhus: int  # 1547
PPC_evrndwnh: int  # 1553
PPC_evrndwnhss: int  # 1557
PPC_evrndwnhus: int  # 1556
PPC_evsad2sh: int  # 1996
PPC_evsad2sha: int  # 2002
PPC_evsad2shaaw: int  # 2014
PPC_evsad2uh: int  # 1995
PPC_evsad2uha: int  # 2001
PPC_evsad2uhaaw: int  # 2013
PPC_evsad4sb: int  # 1994
PPC_evsad4sba: int  # 2000
PPC_evsad4sbaaw: int  # 2012
PPC_evsad4ub: int  # 1993
PPC_evsad4uba: int  # 1999
PPC_evsad4ubaaw: int  # 2011
PPC_evsadsw: int  # 1992
PPC_evsadswa: int  # 1998
PPC_evsadswaa: int  # 2010
PPC_evsaduw: int  # 1991
PPC_evsaduwa: int  # 1997
PPC_evsaduwaa: int  # 2009
PPC_evsatsbub: int  # 1592
PPC_evsatsdsw: int  # 1579
PPC_evsatsduw: int  # 1578
PPC_evsatshsb: int  # 1581
PPC_evsatshub: int  # 1580
PPC_evsatshuh: int  # 1588
PPC_evsatswgsdf: int  # 1591
PPC_evsatswsh: int  # 1583
PPC_evsatswuh: int  # 1584
PPC_evsatswuw: int  # 1590
PPC_evsatubsb: int  # 1593
PPC_evsatuduw: int  # 1586
PPC_evsatuhsh: int  # 1589
PPC_evsatuhub: int  # 1585
PPC_evsatuwsw: int  # 1587
PPC_evsatuwuh: int  # 1582
PPC_evsel: int  # 560
PPC_evselbit: int  # 1659
PPC_evselbitm0: int  # 1657
PPC_evselbitm1: int  # 1658
PPC_evseteqb: int  # 1976
PPC_evseteqh: int  # 1977
PPC_evseteqw: int  # 1978
PPC_evsetgtbs: int  # 1984
PPC_evsetgtbu: int  # 1983
PPC_evsetgths: int  # 1980
PPC_evsetgthu: int  # 1979
PPC_evsetgtws: int  # 1982
PPC_evsetgtwu: int  # 1981
PPC_evsetltbs: int  # 1986
PPC_evsetltbu: int  # 1985
PPC_evsetlths: int  # 1988
PPC_evsetlthu: int  # 1987
PPC_evsetltws: int  # 1990
PPC_evsetltwu: int  # 1989
PPC_evsl: int  # 1607
PPC_evslb: int  # 1668
PPC_evslbi: int  # 1670
PPC_evslh: int  # 1676
PPC_evslhi: int  # 1678
PPC_evsli: int  # 1608
PPC_evsloi: int  # 1687
PPC_evslw: int  # 561
PPC_evslwi: int  # 562
PPC_evsplatb: int  # 1651
PPC_evsplatfi: int  # 563
PPC_evsplatfia: int  # 1628
PPC_evsplatfib: int  # 1623
PPC_evsplatfiba: int  # 1630
PPC_evsplatfibo: int  # 1624
PPC_evsplatfiboa: int  # 1631
PPC_evsplatfid: int  # 1627
PPC_evsplatfida: int  # 1634
PPC_evsplatfih: int  # 1625
PPC_evsplatfiha: int  # 1632
PPC_evsplatfiho: int  # 1626
PPC_evsplatfihoa: int  # 1633
PPC_evsplatfio: int  # 1622
PPC_evsplatfioa: int  # 1629
PPC_evsplath: int  # 1650
PPC_evsplati: int  # 564
PPC_evsplatia: int  # 1615
PPC_evsplatib: int  # 1610
PPC_evsplatiba: int  # 1617
PPC_evsplatibe: int  # 1611
PPC_evsplatibea: int  # 1618
PPC_evsplatid: int  # 1614
PPC_evsplatida: int  # 1621
PPC_evsplatie: int  # 1609
PPC_evsplatiea: int  # 1616
PPC_evsplatih: int  # 1612
PPC_evsplatiha: int  # 1619
PPC_evsplatihe: int  # 1613
PPC_evsplatihea: int  # 1620
PPC_evsrbis: int  # 1667
PPC_evsrbiu: int  # 1666
PPC_evsrbs: int  # 1665
PPC_evsrbu: int  # 1664
PPC_evsrhis: int  # 1675
PPC_evsrhiu: int  # 1674
PPC_evsrhs: int  # 1673
PPC_evsrhu: int  # 1672
PPC_evsris: int  # 1683
PPC_evsriu: int  # 1682
PPC_evsrois: int  # 1688
PPC_evsroiu: int  # 1686
PPC_evsrs: int  # 1681
PPC_evsru: int  # 1680
PPC_evsrwis: int  # 565
PPC_evsrwiu: int  # 566
PPC_evsrws: int  # 567
PPC_evsrwu: int  # 568
PPC_evstdb: int  # 1700
PPC_evstdbmx: int  # 1753
PPC_evstdbu: int  # 1754
PPC_evstdbx: int  # 1699
PPC_evstdd: int  # 569
PPC_evstddepx: int  # 765
PPC_evstddmx: int  # 1747
PPC_evstddu: int  # 1748
PPC_evstddx: int  # 570
PPC_evstdh: int  # 571
PPC_evstdhmx: int  # 1751
PPC_evstdhu: int  # 1752
PPC_evstdhx: int  # 572
PPC_evstdw: int  # 573
PPC_evstdwmx: int  # 1749
PPC_evstdwu: int  # 1750
PPC_evstdwx: int  # 574
PPC_evsthb: int  # 1714
PPC_evsthbmx: int  # 1775
PPC_evsthbu: int  # 1776
PPC_evsthbx: int  # 1713
PPC_evstwb: int  # 1712
PPC_evstwbe: int  # 1708
PPC_evstwbemx: int  # 1763
PPC_evstwbeu: int  # 1764
PPC_evstwbex: int  # 1707
PPC_evstwbmx: int  # 1771
PPC_evstwbo: int  # 1710
PPC_evstwbomx: int  # 1767
PPC_evstwbou: int  # 1768
PPC_evstwbox: int  # 1709
PPC_evstwbu: int  # 1772
PPC_evstwbx: int  # 1711
PPC_evstwhe: int  # 575
PPC_evstwhemx: int  # 1761
PPC_evstwheu: int  # 1762
PPC_evstwhex: int  # 576
PPC_evstwho: int  # 577
PPC_evstwhomx: int  # 1765
PPC_evstwhou: int  # 1766
PPC_evstwhox: int  # 578
PPC_evstwwe: int  # 579
PPC_evstwwemx: int  # 1769
PPC_evstwweu: int  # 1770
PPC_evstwwex: int  # 580
PPC_evstwwo: int  # 581
PPC_evstwwomx: int  # 1773
PPC_evstwwou: int  # 1774
PPC_evstwwox: int  # 582
PPC_evsubf2add2h: int  # 1851
PPC_evsubf2add2hss: int  # 1852
PPC_evsubfaddh: int  # 1835
PPC_evsubfaddhss: int  # 1836
PPC_evsubfaddhx: int  # 1839
PPC_evsubfaddhxss: int  # 1840
PPC_evsubfaddw: int  # 1865
PPC_evsubfaddwss: int  # 1866
PPC_evsubfaddwx: int  # 1869
PPC_evsubfaddwxss: int  # 1870
PPC_evsubfb: int  # 1831
PPC_evsubfbss: int  # 1832
PPC_evsubfbus: int  # 1844
PPC_evsubfd: int  # 1827
PPC_evsubfdss: int  # 1828
PPC_evsubfdus: int  # 1843
PPC_evsubfh: int  # 1819
PPC_evsubfhhisw: int  # 1911
PPC_evsubfhhiuw: int  # 1910
PPC_evsubfhlosw: int  # 1915
PPC_evsubfhlouw: int  # 1914
PPC_evsubfhss: int  # 1820
PPC_evsubfhus: int  # 1855
PPC_evsubfhx: int  # 1823
PPC_evsubfhxss: int  # 1824
PPC_evsubfhxus: int  # 1856
PPC_evsubfsmiaa: int  # 1816
PPC_evsubfsmiaaw: int  # 583
PPC_evsubfssiaa: int  # 1814
PPC_evsubfssiaaw: int  # 584
PPC_evsubfumiaaw: int  # 585
PPC_evsubfusiaa: int  # 1813
PPC_evsubfusiaaw: int  # 586
PPC_evsubfw: int  # 587
PPC_evsubfwegsf: int  # 1903
PPC_evsubfwegsi: int  # 1902
PPC_evsubfwogsf: int  # 1907
PPC_evsubfwogsi: int  # 1906
PPC_evsubfwss: int  # 1858
PPC_evsubfwus: int  # 1847
PPC_evsubfwx: int  # 1861
PPC_evsubfwxss: int  # 1862
PPC_evsubfwxus: int  # 1848
PPC_evsubifb: int  # 1521
PPC_evsubifh: int  # 1520
PPC_evsubifw: int  # 588
PPC_evsum2his: int  # 1879
PPC_evsum2hisa: int  # 1887
PPC_evsum2hisaaw: int  # 1895
PPC_evsum2hs: int  # 1877
PPC_evsum2hsa: int  # 1885
PPC_evsum2hsaaw: int  # 1893
PPC_evsum2hu: int  # 1876
PPC_evsum2hua: int  # 1884
PPC_evsum2huaaw: int  # 1892
PPC_evsum4bs: int  # 1875
PPC_evsum4bsa: int  # 1883
PPC_evsum4bsaaw: int  # 1891
PPC_evsum4bu: int  # 1874
PPC_evsum4bua: int  # 1882
PPC_evsum4buaaw: int  # 1890
PPC_evsumws: int  # 1873
PPC_evsumwsa: int  # 1881
PPC_evsumwsaa: int  # 1889
PPC_evsumwu: int  # 1872
PPC_evsumwua: int  # 1880
PPC_evsumwuaa: int  # 1888
PPC_evswapbhilo: int  # 1640
PPC_evswapblohi: int  # 1641
PPC_evswaphe: int  # 1644
PPC_evswaphhi: int  # 1645
PPC_evswaphhilo: int  # 1642
PPC_evswaphlo: int  # 1646
PPC_evswaphlohi: int  # 1643
PPC_evswapho: int  # 1647
PPC_evunpkhibsi: int  # 1567
PPC_evunpkhibui: int  # 1566
PPC_evunpkhihf: int  # 1575
PPC_evunpkhihsi: int  # 1569
PPC_evunpkhihui: int  # 1568
PPC_evunpkhiwgsf: int  # 1577
PPC_evunpklobsi: int  # 1571
PPC_evunpklobui: int  # 1570
PPC_evunpklohf: int  # 1574
PPC_evunpklohsi: int  # 1573
PPC_evunpklohui: int  # 1572
PPC_evunpklowgsf: int  # 1576
PPC_evxor: int  # 589
PPC_evxtrb: int  # 1649
PPC_evxtrd: int  # 1663
PPC_evxtrh: int  # 1655
PPC_extldi: int  # 1185
PPC_extlwi: int  # 337
PPC_extrdi: int  # 1186
PPC_extrwi: int  # 338
PPC_extsb: int  # 46
PPC_extsh: int  # 47
PPC_extsw: int  # 48
PPC_extswsli: int  # 2264
PPC_extzb: int  # 1176
PPC_extzh: int  # 1177
PPC_fabs: int  # 49
PPC_fadd: int  # 50
PPC_fadds: int  # 51
PPC_fcfid: int  # 52
PPC_fcfids: int  # 786
PPC_fcfidu: int  # 787
PPC_fcfidus: int  # 788
PPC_fcmpo: int  # 53
PPC_fcmpu: int  # 54
PPC_fcpsgn: int  # 801
PPC_fctid: int  # 55
PPC_fctidu: int  # 789
PPC_fctiduz: int  # 790
PPC_fctidz: int  # 56
PPC_fctiw: int  # 57
PPC_fctiwu: int  # 791
PPC_fctiwuz: int  # 792
PPC_fctiwz: int  # 58
PPC_fdiv: int  # 59
PPC_fdivs: int  # 60
PPC_fmadd: int  # 61
PPC_fmadds: int  # 62
PPC_fmr: int  # 63
PPC_fmrgew: int  # 2091
PPC_fmrgow: int  # 2092
PPC_fmsub: int  # 64
PPC_fmsubs: int  # 65
PPC_fmul: int  # 66
PPC_fmuls: int  # 67
PPC_fnabs: int  # 68
PPC_fneg: int  # 69
PPC_fnmadd: int  # 70
PPC_fnmadds: int  # 71
PPC_fnmsub: int  # 72
PPC_fnmsubs: int  # 73
PPC_fre: int  # 802
PPC_fres: int  # 74
PPC_frim: int  # 803
PPC_frin: int  # 804
PPC_frip: int  # 805
PPC_friz: int  # 806
PPC_frsp: int  # 75
PPC_frsqrte: int  # 76
PPC_frsqrtes: int  # 371
PPC_fsel: int  # 77
PPC_fsqrt: int  # 78
PPC_fsqrts: int  # 79
PPC_fsub: int  # 80
PPC_fsubs: int  # 81
PPC_ftdiv: int  # 793
PPC_ftsqrt: int  # 794
PPC_hnop: int  # 1197
PPC_hrfid: int  # 372
PPC_hwaccel: int  # 2489
PPC_hwacceli: int  # 2490
PPC_icbi: int  # 82
PPC_icbiep: int  # 766
PPC_icblc: int  # 411
PPC_icblq: int  # 2199
PPC_icbt: int  # 351
PPC_icbtls: int  # 412
PPC_iccci: int  # 352
PPC_ici: int  # 749
PPC_icread: int  # 353
PPC_illegal: int  # 1178
PPC_inslwi: int  # 339
PPC_insrdi: int  # 1187
PPC_insrwi: int  # 340
PPC_isel: int  # 404
PPC_iseleq: int  # 407
PPC_iselgt: int  # 406
PPC_isellt: int  # 405
PPC_isync: int  # 83
PPC_last: int  # 3430
PPC_last_basic: int  # 228
PPC_lbarx: int  # 674
PPC_lbcbx: int  # 2454
PPC_lbdcbx: int  # 2448
PPC_lbdx: int  # 735
PPC_lbepx: int  # 767
PPC_lbz: int  # 84
PPC_lbzcix: int  # 835
PPC_lbzu: int  # 85
PPC_lbzux: int  # 86
PPC_lbzx: int  # 87
PPC_ld: int  # 88
PPC_ldarx: int  # 89
PPC_ldat: int  # 2282
PPC_ldbrw: int  # 2466
PPC_ldbrx: int  # 668
PPC_ldcix: int  # 836
PPC_lddx: int  # 736
PPC_ldepx: int  # 779
PPC_ldu: int  # 90
PPC_ldux: int  # 91
PPC_ldw: int  # 2461
PPC_ldwar: int  # 2477
PPC_ldwbrw: int  # 2467
PPC_ldwcb: int  # 2465
PPC_ldx: int  # 92
PPC_lfd: int  # 93
PPC_lfddx: int  # 737
PPC_lfdepx: int  # 768
PPC_lfdp: int  # 797
PPC_lfdpx: int  # 798
PPC_lfdu: int  # 94
PPC_lfdux: int  # 95
PPC_lfdx: int  # 96
PPC_lfiwax: int  # 795
PPC_lfiwzx: int  # 796
PPC_lfs: int  # 97
PPC_lfsu: int  # 98
PPC_lfsux: int  # 99
PPC_lfsx: int  # 100
PPC_lha: int  # 101
PPC_lharx: int  # 675
PPC_lhau: int  # 102
PPC_lhaux: int  # 103
PPC_lhax: int  # 104
PPC_lhbr: int  # 2474
PPC_lhbrx: int  # 105
PPC_lhcbx: int  # 2455
PPC_lhdcbx: int  # 2449
PPC_lhdx: int  # 738
PPC_lhepx: int  # 769
PPC_lhz: int  # 106
PPC_lhzcix: int  # 837
PPC_lhzu: int  # 107
PPC_lhzux: int  # 108
PPC_lhzx: int  # 109
PPC_li: int  # 285
PPC_lis: int  # 286
PPC_lmvcsrrw: int  # 1304
PPC_lmvdsrrw: int  # 1306
PPC_lmvgprw: int  # 1298
PPC_lmvmcsrrw: int  # 1308
PPC_lmvsprw: int  # 1300
PPC_lmvsrrw: int  # 1302
PPC_lmw: int  # 110
PPC_lnia: int  # 2257
PPC_lq: int  # 832
PPC_lqarx: int  # 2182
PPC_lqdbrw: int  # 2471
PPC_lqw: int  # 2463
PPC_lscbx: int  # 373
PPC_lswi: int  # 111
PPC_lswx: int  # 112
PPC_lvebx: int  # 848
PPC_lvehx: int  # 849
PPC_lvepx: int  # 770
PPC_lvepxl: int  # 771
PPC_lvewx: int  # 850
PPC_lvlx: int  # 1147
PPC_lvlxl: int  # 1148
PPC_lvrx: int  # 1149
PPC_lvrxl: int  # 1150
PPC_lvsl: int  # 851
PPC_lvsr: int  # 852
PPC_lvx: int  # 853
PPC_lvxl: int  # 854
PPC_lwa: int  # 113
PPC_lwarx: int  # 114
PPC_lwat: int  # 2283
PPC_lwaux: int  # 115
PPC_lwax: int  # 116
PPC_lwbr: int  # 2473
PPC_lwbrx: int  # 117
PPC_lwcbx: int  # 2456
PPC_lwdcbx: int  # 2450
PPC_lwdx: int  # 739
PPC_lwepx: int  # 772
PPC_lwsync: int  # 1202
PPC_lwz: int  # 118
PPC_lwzcix: int  # 838
PPC_lwzu: int  # 119
PPC_lwzux: int  # 120
PPC_lwzx: int  # 121
PPC_lxsd: int  # 2354
PPC_lxsdx: int  # 1004
PPC_lxsibzx: int  # 2356
PPC_lxsihzx: int  # 2357
PPC_lxsiwax: int  # 2154
PPC_lxsiwzx: int  # 2156
PPC_lxssp: int  # 2355
PPC_lxsspx: int  # 2155
PPC_lxv: int  # 2358
PPC_lxvb16x: int  # 2359
PPC_lxvd2x: int  # 1005
PPC_lxvdsx: int  # 1006
PPC_lxvh8x: int  # 2360
PPC_lxvkq: int  # 3256
PPC_lxvl: int  # 2361
PPC_lxvll: int  # 2362
PPC_lxvp: int  # 3257
PPC_lxvpx: int  # 3258
PPC_lxvrbx: int  # 3259
PPC_lxvrdx: int  # 3260
PPC_lxvrhx: int  # 3261
PPC_lxvrwx: int  # 3262
PPC_lxvw4x: int  # 1007
PPC_lxvwsx: int  # 2363
PPC_lxvx: int  # 2364
PPC_macchw: int  # 807
PPC_macchws: int  # 808
PPC_macchwsu: int  # 809
PPC_macchwu: int  # 810
PPC_machhw: int  # 811
PPC_machhws: int  # 812
PPC_machhwsu: int  # 813
PPC_machhwu: int  # 814
PPC_maclhw: int  # 815
PPC_maclhws: int  # 816
PPC_maclhwsu: int  # 817
PPC_maclhwu: int  # 818
PPC_maddhd: int  # 2265
PPC_maddhdu: int  # 2266
PPC_maddld: int  # 2267
PPC_maskg: int  # 374
PPC_maskir: int  # 375
PPC_mbar: int  # 745
PPC_mcrf: int  # 122
PPC_mcrfs: int  # 123
PPC_mcrxr: int  # 124
PPC_mcrxrx: int  # 2268
PPC_mdoio: int  # 2214
PPC_mdoom: int  # 2215
PPC_mfar: int  # 1179
PPC_mfbhrbe: int  # 2084
PPC_mfcr: int  # 125
PPC_mfctr: int  # 307
PPC_mfdar: int  # 309
PPC_mfdcr: int  # 354
PPC_mfdcrux: int  # 750
PPC_mfdcrx: int  # 751
PPC_mfdec: int  # 310
PPC_mfdsisr: int  # 308
PPC_mffs: int  # 126
PPC_mffscdrn: int  # 2443
PPC_mffscdrni: int  # 2444
PPC_mffsce: int  # 2442
PPC_mffscrn: int  # 2445
PPC_mffscrni: int  # 2446
PPC_mffsl: int  # 2447
PPC_mfic: int  # 2210
PPC_mflr: int  # 306
PPC_mfmsr: int  # 127
PPC_mfocrf: int  # 403
PPC_mfpmr: int  # 781
PPC_mfppr: int  # 2206
PPC_mfppr32: int  # 2208
PPC_mfpvr: int  # 319
PPC_mfspr: int  # 128
PPC_mfsprg0: int  # 313
PPC_mfsprg1: int  # 314
PPC_mfsprg2: int  # 315
PPC_mfsprg3: int  # 316
PPC_mfsr: int  # 129
PPC_mfsri: int  # 376
PPC_mfsrin: int  # 130
PPC_mfsrr0: int  # 311
PPC_mfsrr1: int  # 312
PPC_mftb: int  # 131
PPC_mftbl: int  # 317
PPC_mftbu: int  # 318
PPC_mftmr: int  # 783
PPC_mfvscr: int  # 855
PPC_mfvsrd: int  # 2086
PPC_mfvsrld: int  # 2274
PPC_mfvsrwz: int  # 2087
PPC_mfvtb: int  # 2212
PPC_mfxer: int  # 305
PPC_miso: int  # 2213
PPC_modsd: int  # 2270
PPC_modsw: int  # 2272
PPC_modud: int  # 2271
PPC_moduw: int  # 2273
PPC_mpure: int  # 2494
PPC_mpusync: int  # 2496
PPC_mpuwe: int  # 2495
PPC_mr: int  # 281
PPC_msgclr: int  # 757
PPC_msgclrp: int  # 2197
PPC_msgclru: int  # 3190
PPC_msgsnd: int  # 758
PPC_msgsndp: int  # 2196
PPC_msgsndu: int  # 3191
PPC_msgsync: int  # 2439
PPC_mtar: int  # 1180
PPC_mtcr: int  # 1208
PPC_mtcrf: int  # 132
PPC_mtctr: int  # 293
PPC_mtdar: int  # 295
PPC_mtdcr: int  # 355
PPC_mtdcrux: int  # 752
PPC_mtdcrx: int  # 753
PPC_mtdec: int  # 296
PPC_mtdsisr: int  # 294
PPC_mtfsb0: int  # 133
PPC_mtfsb1: int  # 134
PPC_mtfsf: int  # 135
PPC_mtfsfi: int  # 136
PPC_mtic: int  # 2209
PPC_mtlr: int  # 292
PPC_mtmsr: int  # 137
PPC_mtmsrd: int  # 138
PPC_mtmsree: int  # 1216
PPC_mtocrf: int  # 402
PPC_mtpmr: int  # 782
PPC_mtppr: int  # 2205
PPC_mtppr32: int  # 2207
PPC_mtsle: int  # 2085
PPC_mtspr: int  # 139
PPC_mtsprg0: int  # 299
PPC_mtsprg1: int  # 300
PPC_mtsprg2: int  # 301
PPC_mtsprg3: int  # 302
PPC_mtsr: int  # 140
PPC_mtsrd: int  # 141
PPC_mtsrdin: int  # 142
PPC_mtsrin: int  # 143
PPC_mtsrr0: int  # 297
PPC_mtsrr1: int  # 298
PPC_mttbl: int  # 303
PPC_mttbu: int  # 304
PPC_mttmr: int  # 784
PPC_mtvscr: int  # 856
PPC_mtvsrbm: int  # 3263
PPC_mtvsrbmi: int  # 3264
PPC_mtvsrd: int  # 2088
PPC_mtvsrdd: int  # 2275
PPC_mtvsrdm: int  # 3265
PPC_mtvsrhm: int  # 3266
PPC_mtvsrqm: int  # 3267
PPC_mtvsrwa: int  # 2089
PPC_mtvsrwm: int  # 3268
PPC_mtvsrws: int  # 2276
PPC_mtvsrwz: int  # 2090
PPC_mtvtb: int  # 2211
PPC_mtxer: int  # 291
PPC_mul: int  # 377
PPC_mulchw: int  # 819
PPC_mulchwu: int  # 820
PPC_mulhd: int  # 144
PPC_mulhdu: int  # 145
PPC_mulhhw: int  # 821
PPC_mulhhwu: int  # 822
PPC_mulhss: int  # 2223
PPC_mulhus: int  # 2225
PPC_mulhw: int  # 146
PPC_mulhwu: int  # 147
PPC_mull2i: int  # 1166
PPC_mulld: int  # 148
PPC_mullhw: int  # 823
PPC_mullhwu: int  # 824
PPC_mulli: int  # 149
PPC_mullw: int  # 150
PPC_mulwss: int  # 2224
PPC_mulwus: int  # 2226
PPC_nabs: int  # 378
PPC_nand: int  # 151
PPC_nap: int  # 839
PPC_neg: int  # 152
PPC_nmacchw: int  # 825
PPC_nmacchws: int  # 826
PPC_nmachhw: int  # 827
PPC_nmachhws: int  # 828
PPC_nmaclhw: int  # 829
PPC_nmaclhws: int  # 830
PPC_nop: int  # 279
PPC_nor: int  # 153
PPC_not: int  # 280
PPC_null: int  # 0
PPC_or: int  # 154
PPC_or2i: int  # 1167
PPC_or2is: int  # 1168
PPC_orc: int  # 155
PPC_ordhwaccel: int  # 2491
PPC_ordhwacceli: int  # 2492
PPC_ori: int  # 156
PPC_oris: int  # 157
PPC_osmcmd: int  # 2493
PPC_paddi: int  # 3193
PPC_paste: int  # 2281
PPC_pdepd: int  # 3269
PPC_pextd: int  # 3270
PPC_plbz: int  # 3194
PPC_pld: int  # 3195
PPC_plfd: int  # 3196
PPC_plfs: int  # 3197
PPC_plha: int  # 3198
PPC_plhz: int  # 3199
PPC_plq: int  # 3200
PPC_plwa: int  # 3201
PPC_plwz: int  # 3202
PPC_plxsd: int  # 3203
PPC_plxssp: int  # 3204
PPC_plxv: int  # 3205
PPC_plxvp: int  # 3206
PPC_pmxvbf16ger2: int  # 3207
PPC_pmxvbf16ger2nn: int  # 3208
PPC_pmxvbf16ger2np: int  # 3209
PPC_pmxvbf16ger2pn: int  # 3210
PPC_pmxvbf16ger2pp: int  # 3211
PPC_pmxvf16ger2: int  # 3212
PPC_pmxvf16ger2nn: int  # 3213
PPC_pmxvf16ger2np: int  # 3214
PPC_pmxvf16ger2pn: int  # 3215
PPC_pmxvf16ger2pp: int  # 3216
PPC_pmxvf32ger: int  # 3217
PPC_pmxvf32gernn: int  # 3218
PPC_pmxvf32gernp: int  # 3219
PPC_pmxvf32gerpn: int  # 3220
PPC_pmxvf32gerpp: int  # 3221
PPC_pmxvf64ger: int  # 3222
PPC_pmxvf64gernn: int  # 3223
PPC_pmxvf64gernp: int  # 3224
PPC_pmxvf64gerpn: int  # 3225
PPC_pmxvf64gerpp: int  # 3226
PPC_pmxvi16ger2: int  # 3227
PPC_pmxvi16ger2pp: int  # 3228
PPC_pmxvi16ger2s: int  # 3229
PPC_pmxvi16ger2spp: int  # 3230
PPC_pmxvi4ger8: int  # 3231
PPC_pmxvi4ger8pp: int  # 3232
PPC_pmxvi8ger4: int  # 3233
PPC_pmxvi8ger4pp: int  # 3234
PPC_pmxvi8ger4spp: int  # 3235
PPC_pnop: int  # 3236
PPC_popcntb: int  # 379
PPC_popcntd: int  # 676
PPC_popcntw: int  # 677
PPC_prtyd: int  # 669
PPC_prtyw: int  # 678
PPC_ps_abs: int  # 1257
PPC_ps_add: int  # 1240
PPC_ps_cmpo0: int  # 1249
PPC_ps_cmpo1: int  # 1255
PPC_ps_cmpu0: int  # 1229
PPC_ps_cmpu1: int  # 1253
PPC_ps_div: int  # 1238
PPC_ps_madd: int  # 1246
PPC_ps_madds0: int  # 1236
PPC_ps_madds1: int  # 1237
PPC_ps_merge00: int  # 1258
PPC_ps_merge01: int  # 1259
PPC_ps_merge10: int  # 1260
PPC_ps_merge11: int  # 1261
PPC_ps_mr: int  # 1254
PPC_ps_msub: int  # 1245
PPC_ps_mul: int  # 1243
PPC_ps_muls0: int  # 1234
PPC_ps_muls1: int  # 1235
PPC_ps_nabs: int  # 1256
PPC_ps_neg: int  # 1252
PPC_ps_nmadd: int  # 1248
PPC_ps_nmsub: int  # 1247
PPC_ps_res: int  # 1242
PPC_ps_rsqrte: int  # 1244
PPC_ps_sel: int  # 1241
PPC_ps_sub: int  # 1239
PPC_ps_sum0: int  # 1232
PPC_ps_sum1: int  # 1233
PPC_psq_l: int  # 1263
PPC_psq_lu: int  # 1264
PPC_psq_lux: int  # 1250
PPC_psq_lx: int  # 1230
PPC_psq_st: int  # 1265
PPC_psq_stu: int  # 1266
PPC_psq_stux: int  # 1251
PPC_psq_stx: int  # 1231
PPC_pstb: int  # 3237
PPC_pstd: int  # 3238
PPC_pstfd: int  # 3239
PPC_pstfs: int  # 3240
PPC_psth: int  # 3241
PPC_pstq: int  # 3242
PPC_pstw: int  # 3243
PPC_pstxsd: int  # 3244
PPC_pstxssp: int  # 3245
PPC_pstxv: int  # 3246
PPC_pstxvp: int  # 3247
PPC_ptesync: int  # 1203
PPC_rac: int  # 380
PPC_rfci: int  # 356
PPC_rfdi: int  # 414
PPC_rfebb: int  # 2193
PPC_rfgi: int  # 756
PPC_rfi: int  # 158
PPC_rfid: int  # 159
PPC_rfmci: int  # 746
PPC_rfscv: int  # 2278
PPC_rfsvc: int  # 381
PPC_rldcl: int  # 160
PPC_rldcr: int  # 161
PPC_rldic: int  # 162
PPC_rldicl: int  # 163
PPC_rldicr: int  # 164
PPC_rldimi: int  # 165
PPC_rlmi: int  # 382
PPC_rlw: int  # 1169
PPC_rlwi: int  # 1170
PPC_rlwimi: int  # 166
PPC_rlwinm: int  # 167
PPC_rlwnm: int  # 168
PPC_rotld: int  # 1190
PPC_rotldi: int  # 1188
PPC_rotlw: int  # 343
PPC_rotlwi: int  # 341
PPC_rotrdi: int  # 1189
PPC_rotrwi: int  # 342
PPC_rrib: int  # 383
PPC_rvwinkle: int  # 840
PPC_sat: int  # 2227
PPC_satsbs: int  # 2234
PPC_satsbu: int  # 2236
PPC_satshs: int  # 2240
PPC_satshu: int  # 2242
PPC_satsws: int  # 2246
PPC_satswu: int  # 2248
PPC_satubs: int  # 2235
PPC_satubu: int  # 2237
PPC_satuhs: int  # 2241
PPC_satuhu: int  # 2243
PPC_satuws: int  # 2247
PPC_satuwu: int  # 2249
PPC_sc: int  # 169
PPC_scv: int  # 2277
PPC_setb: int  # 2269
PPC_setbc: int  # 3271
PPC_setbcr: int  # 3272
PPC_setnbc: int  # 3273
PPC_setnbcr: int  # 3274
PPC_slbfee: int  # 841
PPC_slbia: int  # 170
PPC_slbiag: int  # 2254
PPC_slbie: int  # 171
PPC_slbieg: int  # 2253
PPC_slbmfee: int  # 384
PPC_slbmfev: int  # 385
PPC_slbmte: int  # 386
PPC_slbsync: int  # 2255
PPC_sld: int  # 172
PPC_sldi: int  # 1191
PPC_sle: int  # 387
PPC_sleep: int  # 842
PPC_sleq: int  # 388
PPC_sliq: int  # 389
PPC_slliq: int  # 390
PPC_sllq: int  # 391
PPC_slq: int  # 392
PPC_slw: int  # 173
PPC_slwi: int  # 344
PPC_srad: int  # 174
PPC_sradi: int  # 175
PPC_sraiq: int  # 393
PPC_sraq: int  # 394
PPC_sraw: int  # 176
PPC_srawi: int  # 177
PPC_srd: int  # 178
PPC_srdi: int  # 1192
PPC_sre: int  # 395
PPC_srea: int  # 396
PPC_sreq: int  # 397
PPC_sriq: int  # 398
PPC_srliq: int  # 399
PPC_srlq: int  # 400
PPC_srq: int  # 401
PPC_srw: int  # 179
PPC_srwi: int  # 345
PPC_stb: int  # 180
PPC_stbcix: int  # 843
PPC_stbcx: int  # 679
PPC_stbdcbx: int  # 2451
PPC_stbdx: int  # 740
PPC_stbepx: int  # 773
PPC_stbu: int  # 181
PPC_stbux: int  # 182
PPC_stbwtx: int  # 2457
PPC_stbx: int  # 183
PPC_std: int  # 184
PPC_stdat: int  # 2284
PPC_stdbrw: int  # 2469
PPC_stdbrx: int  # 670
PPC_stdcix: int  # 844
PPC_stdcx: int  # 185
PPC_stddx: int  # 741
PPC_stdepx: int  # 780
PPC_stdu: int  # 186
PPC_stdux: int  # 187
PPC_stdw: int  # 2462
PPC_stdwbrw: int  # 2470
PPC_stdwc: int  # 2478
PPC_stdwwt: int  # 2468
PPC_stdx: int  # 188
PPC_stfd: int  # 189
PPC_stfddx: int  # 742
PPC_stfdepx: int  # 774
PPC_stfdp: int  # 799
PPC_stfdpx: int  # 800
PPC_stfdu: int  # 190
PPC_stfdux: int  # 191
PPC_stfdx: int  # 192
PPC_stfiwx: int  # 193
PPC_stfs: int  # 194
PPC_stfsu: int  # 195
PPC_stfsux: int  # 196
PPC_stfsx: int  # 197
PPC_sth: int  # 198
PPC_sthbr: int  # 2476
PPC_sthbrx: int  # 199
PPC_sthcix: int  # 845
PPC_sthcx: int  # 680
PPC_sthdcbx: int  # 2452
PPC_sthdx: int  # 743
PPC_sthepx: int  # 775
PPC_sthu: int  # 200
PPC_sthux: int  # 201
PPC_sthwtx: int  # 2458
PPC_sthx: int  # 202
PPC_stmvcsrrw: int  # 1305
PPC_stmvdsrrw: int  # 1307
PPC_stmvgprw: int  # 1299
PPC_stmvmcsrrw: int  # 1309
PPC_stmvsprw: int  # 1301
PPC_stmvsrrw: int  # 1303
PPC_stmw: int  # 203
PPC_stop: int  # 2279
PPC_stq: int  # 833
PPC_stqcx: int  # 2183
PPC_stqdbrw: int  # 2472
PPC_stqw: int  # 2464
PPC_stswi: int  # 204
PPC_stswx: int  # 205
PPC_stvebx: int  # 857
PPC_stvehx: int  # 858
PPC_stvepx: int  # 776
PPC_stvepxl: int  # 777
PPC_stvewx: int  # 859
PPC_stvlx: int  # 1151
PPC_stvlxl: int  # 1152
PPC_stvrx: int  # 1153
PPC_stvrxl: int  # 1154
PPC_stvx: int  # 860
PPC_stvxl: int  # 861
PPC_stw: int  # 206
PPC_stwat: int  # 2285
PPC_stwbr: int  # 2475
PPC_stwbrx: int  # 207
PPC_stwcix: int  # 846
PPC_stwcx: int  # 208
PPC_stwdcbx: int  # 2453
PPC_stwdx: int  # 744
PPC_stwepx: int  # 778
PPC_stwu: int  # 209
PPC_stwux: int  # 210
PPC_stwwtx: int  # 2459
PPC_stwx: int  # 211
PPC_stxsd: int  # 2365
PPC_stxsdx: int  # 1008
PPC_stxsibx: int  # 2366
PPC_stxsihx: int  # 2367
PPC_stxsiwx: int  # 2157
PPC_stxssp: int  # 2368
PPC_stxsspx: int  # 2158
PPC_stxv: int  # 2369
PPC_stxvb16x: int  # 2370
PPC_stxvd2x: int  # 1009
PPC_stxvh8x: int  # 2371
PPC_stxvl: int  # 2372
PPC_stxvll: int  # 2373
PPC_stxvp: int  # 3275
PPC_stxvpx: int  # 3276
PPC_stxvrbx: int  # 3277
PPC_stxvrdx: int  # 3278
PPC_stxvrhx: int  # 3279
PPC_stxvrwx: int  # 3280
PPC_stxvw4x: int  # 1010
PPC_stxvx: int  # 2374
PPC_sub: int  # 1181
PPC_sub16i: int  # 1182
PPC_sub2i: int  # 1183
PPC_sub2is: int  # 1184
PPC_subf: int  # 212
PPC_subfb: int  # 2483
PPC_subfbss: int  # 2228
PPC_subfbu: int  # 2484
PPC_subfbus: int  # 2231
PPC_subfc: int  # 213
PPC_subfe: int  # 214
PPC_subfh: int  # 2485
PPC_subfhss: int  # 2229
PPC_subfhu: int  # 2486
PPC_subfhus: int  # 2232
PPC_subfic: int  # 215
PPC_subfme: int  # 216
PPC_subfwss: int  # 2230
PPC_subfwus: int  # 2233
PPC_subfze: int  # 217
PPC_subi: int  # 282
PPC_subic: int  # 283
PPC_subis: int  # 284
PPC_subpcis: int  # 2258
PPC_sync: int  # 218
PPC_tabort: int  # 2186
PPC_tabortdc: int  # 2189
PPC_tabortdci: int  # 2190
PPC_tabortwc: int  # 2187
PPC_tabortwci: int  # 2188
PPC_tbegin: int  # 2184
PPC_tcheck: int  # 2192
PPC_td: int  # 219
PPC_tdeq: int  # 261
PPC_tdeqi: int  # 271
PPC_tdge: int  # 265
PPC_tdgei: int  # 275
PPC_tdgt: int  # 264
PPC_tdgti: int  # 274
PPC_tdi: int  # 220
PPC_tdle: int  # 267
PPC_tdlei: int  # 277
PPC_tdlge: int  # 262
PPC_tdlgei: int  # 272
PPC_tdlgt: int  # 259
PPC_tdlgti: int  # 269
PPC_tdlle: int  # 263
PPC_tdllei: int  # 273
PPC_tdllt: int  # 260
PPC_tdllti: int  # 270
PPC_tdlt: int  # 266
PPC_tdlti: int  # 276
PPC_tdne: int  # 268
PPC_tdnei: int  # 278
PPC_tdu: int  # 2079
PPC_tdui: int  # 2078
PPC_tend: int  # 2185
PPC_tendall: int  # 2202
PPC_tlbia: int  # 221
PPC_tlbie: int  # 222
PPC_tlbiel: int  # 847
PPC_tlbilx: int  # 747
PPC_tlbivax: int  # 413
PPC_tlbld: int  # 415
PPC_tlbli: int  # 416
PPC_tlbre: int  # 357
PPC_tlbsrx: int  # 785
PPC_tlbsx: int  # 358
PPC_tlbsync: int  # 223
PPC_tlbwe: int  # 359
PPC_trap: int  # 237
PPC_trapd: int  # 238
PPC_trechkpt: int  # 2195
PPC_treclaim: int  # 2194
PPC_tresume: int  # 2204
PPC_tsr: int  # 2191
PPC_tsuspend: int  # 2203
PPC_tw: int  # 224
PPC_tweq: int  # 241
PPC_tweqi: int  # 251
PPC_twge: int  # 245
PPC_twgei: int  # 255
PPC_twgt: int  # 244
PPC_twgti: int  # 254
PPC_twi: int  # 225
PPC_twle: int  # 247
PPC_twlei: int  # 257
PPC_twlge: int  # 242
PPC_twlgei: int  # 252
PPC_twlgt: int  # 239
PPC_twlgti: int  # 249
PPC_twlle: int  # 243
PPC_twllei: int  # 253
PPC_twllt: int  # 240
PPC_twllti: int  # 250
PPC_twlt: int  # 246
PPC_twlti: int  # 256
PPC_twne: int  # 248
PPC_twnei: int  # 258
PPC_twu: int  # 2081
PPC_twui: int  # 2080
PPC_urfid: int  # 3192
PPC_vabsdub: int  # 2303
PPC_vabsduh: int  # 2304
PPC_vabsduw: int  # 2305
PPC_vaddcuq: int  # 2104
PPC_vaddcuw: int  # 862
PPC_vaddecuq: int  # 2105
PPC_vaddeuqm: int  # 2103
PPC_vaddfp: int  # 863
PPC_vaddsbs: int  # 864
PPC_vaddshs: int  # 865
PPC_vaddsws: int  # 866
PPC_vaddubm: int  # 867
PPC_vaddubs: int  # 868
PPC_vaddudm: int  # 2101
PPC_vadduhm: int  # 869
PPC_vadduhs: int  # 870
PPC_vadduqm: int  # 2102
PPC_vadduwm: int  # 871
PPC_vadduws: int  # 872
PPC_vand: int  # 873
PPC_vandc: int  # 874
PPC_vavgsb: int  # 875
PPC_vavgsh: int  # 876
PPC_vavgsw: int  # 877
PPC_vavgub: int  # 878
PPC_vavguh: int  # 879
PPC_vavguw: int  # 880
PPC_vbpermd: int  # 2306
PPC_vbpermq: int  # 2151
PPC_vcfpsxws: int  # 1217
PPC_vcfpuxws: int  # 1218
PPC_vcfsx: int  # 881
PPC_vcfuged: int  # 3281
PPC_vcfux: int  # 882
PPC_vcipher: int  # 2130
PPC_vcipherlast: int  # 2131
PPC_vclrlb: int  # 3282
PPC_vclrrb: int  # 3283
PPC_vclzb: int  # 2143
PPC_vclzd: int  # 2146
PPC_vclzdm: int  # 3284
PPC_vclzh: int  # 2144
PPC_vclzlsbb: int  # 2307
PPC_vclzw: int  # 2145
PPC_vcmpbfp: int  # 883
PPC_vcmpeqfp: int  # 884
PPC_vcmpequb: int  # 885
PPC_vcmpequd: int  # 2120
PPC_vcmpequh: int  # 886
PPC_vcmpequq: int  # 3285
PPC_vcmpequw: int  # 887
PPC_vcmpgefp: int  # 888
PPC_vcmpgtfp: int  # 889
PPC_vcmpgtsb: int  # 890
PPC_vcmpgtsd: int  # 2121
PPC_vcmpgtsh: int  # 891
PPC_vcmpgtsq: int  # 3286
PPC_vcmpgtsw: int  # 892
PPC_vcmpgtub: int  # 893
PPC_vcmpgtud: int  # 2122
PPC_vcmpgtuh: int  # 894
PPC_vcmpgtuq: int  # 3287
PPC_vcmpgtuw: int  # 895
PPC_vcmpneb: int  # 2309
PPC_vcmpneh: int  # 2311
PPC_vcmpnew: int  # 2313
PPC_vcmpnezb: int  # 2310
PPC_vcmpnezh: int  # 2312
PPC_vcmpnezw: int  # 2314
PPC_vcmpsq: int  # 3288
PPC_vcmpuq: int  # 3289
PPC_vcntmbb: int  # 3290
PPC_vcntmbd: int  # 3291
PPC_vcntmbh: int  # 3292
PPC_vcntmbw: int  # 3293
PPC_vcsxwfp: int  # 1219
PPC_vctsxs: int  # 896
PPC_vctuxs: int  # 897
PPC_vctzb: int  # 2315
PPC_vctzd: int  # 2318
PPC_vctzdm: int  # 3294
PPC_vctzh: int  # 2316
PPC_vctzlsbb: int  # 2308
PPC_vctzw: int  # 2317
PPC_vcuxwfp: int  # 1220
PPC_vdivesd: int  # 3295
PPC_vdivesq: int  # 3296
PPC_vdivesw: int  # 3297
PPC_vdiveud: int  # 3298
PPC_vdiveuq: int  # 3299
PPC_vdiveuw: int  # 3300
PPC_vdivsd: int  # 3301
PPC_vdivsq: int  # 3302
PPC_vdivsw: int  # 3303
PPC_vdivud: int  # 3304
PPC_vdivuq: int  # 3305
PPC_vdivuw: int  # 3306
PPC_veqv: int  # 2123
PPC_vexpandbm: int  # 3307
PPC_vexpanddm: int  # 3308
PPC_vexpandhm: int  # 3309
PPC_vexpandqm: int  # 3310
PPC_vexpandwm: int  # 3311
PPC_vexptefp: int  # 898
PPC_vextddvlx: int  # 3312
PPC_vextddvrx: int  # 3313
PPC_vextdubvlx: int  # 3314
PPC_vextdubvrx: int  # 3315
PPC_vextduhvlx: int  # 3316
PPC_vextduhvrx: int  # 3317
PPC_vextduwvlx: int  # 3318
PPC_vextduwvrx: int  # 3319
PPC_vextractbm: int  # 3320
PPC_vextractd: int  # 2322
PPC_vextractdm: int  # 3321
PPC_vextracthm: int  # 3322
PPC_vextractqm: int  # 3323
PPC_vextractub: int  # 2319
PPC_vextractuh: int  # 2320
PPC_vextractuw: int  # 2321
PPC_vextractwm: int  # 3324
PPC_vextsb2d: int  # 2324
PPC_vextsb2w: int  # 2323
PPC_vextsd2q: int  # 3325
PPC_vextsh2d: int  # 2326
PPC_vextsh2w: int  # 2325
PPC_vextsw2d: int  # 2327
PPC_vextublx: int  # 2328
PPC_vextubrx: int  # 2329
PPC_vextuhlx: int  # 2330
PPC_vextuhrx: int  # 2331
PPC_vextuwlx: int  # 2332
PPC_vextuwrx: int  # 2333
PPC_vgbbd: int  # 2142
PPC_vgnb: int  # 3326
PPC_vinsblx: int  # 3327
PPC_vinsbrx: int  # 3328
PPC_vinsbvlx: int  # 3329
PPC_vinsbvrx: int  # 3330
PPC_vinsd: int  # 3331
PPC_vinsdlx: int  # 3332
PPC_vinsdrx: int  # 3333
PPC_vinsertb: int  # 2334
PPC_vinsertd: int  # 2337
PPC_vinserth: int  # 2335
PPC_vinsertw: int  # 2336
PPC_vinshlx: int  # 3334
PPC_vinshrx: int  # 3335
PPC_vinshvlx: int  # 3336
PPC_vinshvrx: int  # 3337
PPC_vinsw: int  # 3338
PPC_vinswlx: int  # 3339
PPC_vinswrx: int  # 3340
PPC_vinswvlx: int  # 3341
PPC_vinswvrx: int  # 3342
PPC_vlogefp: int  # 899
PPC_vmaddcfp: int  # 1221
PPC_vmaddfp: int  # 900
PPC_vmaxfp: int  # 901
PPC_vmaxsb: int  # 902
PPC_vmaxsd: int  # 2116
PPC_vmaxsh: int  # 903
PPC_vmaxsw: int  # 904
PPC_vmaxub: int  # 905
PPC_vmaxud: int  # 2117
PPC_vmaxuh: int  # 906
PPC_vmaxuw: int  # 907
PPC_vmhaddshs: int  # 908
PPC_vmhraddshs: int  # 909
PPC_vminfp: int  # 910
PPC_vminsb: int  # 911
PPC_vminsd: int  # 2118
PPC_vminsh: int  # 912
PPC_vminsw: int  # 913
PPC_vminub: int  # 914
PPC_vminud: int  # 2119
PPC_vminuh: int  # 915
PPC_vminuw: int  # 916
PPC_vmladduhm: int  # 917
PPC_vmodsd: int  # 3343
PPC_vmodsq: int  # 3344
PPC_vmodsw: int  # 3345
PPC_vmodud: int  # 3346
PPC_vmoduq: int  # 3347
PPC_vmoduw: int  # 3348
PPC_vmr: int  # 2200
PPC_vmrgew: int  # 2099
PPC_vmrghb: int  # 918
PPC_vmrghh: int  # 919
PPC_vmrghw: int  # 920
PPC_vmrglb: int  # 921
PPC_vmrglh: int  # 922
PPC_vmrglw: int  # 923
PPC_vmrgow: int  # 2100
PPC_vmsum3fp: int  # 1222
PPC_vmsum4fp: int  # 1223
PPC_vmsumcud: int  # 3349
PPC_vmsummbm: int  # 924
PPC_vmsumshm: int  # 925
PPC_vmsumshs: int  # 926
PPC_vmsumubm: int  # 927
PPC_vmsumudm: int  # 2441
PPC_vmsumuhm: int  # 928
PPC_vmsumuhs: int  # 929
PPC_vmul10cuq: int  # 2340
PPC_vmul10ecuq: int  # 2341
PPC_vmul10euq: int  # 2339
PPC_vmul10uq: int  # 2338
PPC_vmulesb: int  # 930
PPC_vmulesd: int  # 3350
PPC_vmulesh: int  # 931
PPC_vmulesw: int  # 2111
PPC_vmuleub: int  # 932
PPC_vmuleud: int  # 3351
PPC_vmuleuh: int  # 933
PPC_vmuleuw: int  # 2112
PPC_vmulfp: int  # 1224
PPC_vmulhsd: int  # 3352
PPC_vmulhsw: int  # 3353
PPC_vmulhud: int  # 3354
PPC_vmulhuw: int  # 3355
PPC_vmulld: int  # 3356
PPC_vmulosb: int  # 934
PPC_vmulosd: int  # 3357
PPC_vmulosh: int  # 935
PPC_vmulosw: int  # 2113
PPC_vmuloub: int  # 936
PPC_vmuloud: int  # 3358
PPC_vmulouh: int  # 937
PPC_vmulouw: int  # 2114
PPC_vmuluwm: int  # 2115
PPC_vnand: int  # 2124
PPC_vncipher: int  # 2132
PPC_vncipherlast: int  # 2133
PPC_vnegd: int  # 2343
PPC_vnegw: int  # 2342
PPC_vnmsubfp: int  # 938
PPC_vnor: int  # 939
PPC_vnot: int  # 2201
PPC_vor: int  # 940
PPC_vorc: int  # 2125
PPC_vpdepd: int  # 3359
PPC_vperm: int  # 941
PPC_vpermr: int  # 2344
PPC_vpermwi: int  # 1225
PPC_vpermxor: int  # 2141
PPC_vpextd: int  # 3360
PPC_vpkd3d: int  # 1226
PPC_vpkpx: int  # 942
PPC_vpksdss: int  # 2093
PPC_vpksdus: int  # 2094
PPC_vpkshss: int  # 943
PPC_vpkshus: int  # 944
PPC_vpkswss: int  # 945
PPC_vpkswus: int  # 946
PPC_vpkudum: int  # 2096
PPC_vpkudus: int  # 2095
PPC_vpkuhum: int  # 947
PPC_vpkuhus: int  # 948
PPC_vpkuwum: int  # 949
PPC_vpkuwus: int  # 950
PPC_vpmsumb: int  # 2137
PPC_vpmsumd: int  # 2138
PPC_vpmsumh: int  # 2139
PPC_vpmsumw: int  # 2140
PPC_vpopcntb: int  # 2147
PPC_vpopcntd: int  # 2148
PPC_vpopcnth: int  # 2149
PPC_vpopcntw: int  # 2150
PPC_vprtybd: int  # 2346
PPC_vprtybq: int  # 2347
PPC_vprtybw: int  # 2345
PPC_vrefp: int  # 951
PPC_vrfim: int  # 952
PPC_vrfin: int  # 953
PPC_vrfip: int  # 954
PPC_vrfiz: int  # 955
PPC_vrlb: int  # 956
PPC_vrld: int  # 2126
PPC_vrldmi: int  # 2351
PPC_vrldnm: int  # 2350
PPC_vrlh: int  # 957
PPC_vrlimi: int  # 1227
PPC_vrlq: int  # 3361
PPC_vrlqmi: int  # 3362
PPC_vrlqnm: int  # 3363
PPC_vrlw: int  # 958
PPC_vrlwmi: int  # 2349
PPC_vrlwnm: int  # 2348
PPC_vrsqrtefp: int  # 959
PPC_vsbox: int  # 2134
PPC_vsel: int  # 960
PPC_vshasigmad: int  # 2135
PPC_vshasigmaw: int  # 2136
PPC_vsl: int  # 961
PPC_vslb: int  # 962
PPC_vsld: int  # 2127
PPC_vsldbi: int  # 3364
PPC_vsldoi: int  # 963
PPC_vslh: int  # 964
PPC_vslo: int  # 965
PPC_vslq: int  # 3365
PPC_vslv: int  # 2352
PPC_vslw: int  # 966
PPC_vspltb: int  # 967
PPC_vsplth: int  # 968
PPC_vspltisb: int  # 969
PPC_vspltish: int  # 970
PPC_vspltisw: int  # 971
PPC_vspltw: int  # 972
PPC_vsr: int  # 973
PPC_vsrab: int  # 974
PPC_vsrad: int  # 2129
PPC_vsrah: int  # 975
PPC_vsraq: int  # 3366
PPC_vsraw: int  # 976
PPC_vsrb: int  # 977
PPC_vsrd: int  # 2128
PPC_vsrdbi: int  # 3367
PPC_vsrh: int  # 978
PPC_vsro: int  # 979
PPC_vsrq: int  # 3368
PPC_vsrv: int  # 2353
PPC_vsrw: int  # 980
PPC_vstribl: int  # 3369
PPC_vstribr: int  # 3370
PPC_vstrihl: int  # 3371
PPC_vstrihr: int  # 3372
PPC_vsubcuq: int  # 2109
PPC_vsubcuw: int  # 981
PPC_vsubecuq: int  # 2110
PPC_vsubeuqm: int  # 2108
PPC_vsubfp: int  # 982
PPC_vsubsbs: int  # 983
PPC_vsubshs: int  # 984
PPC_vsubsws: int  # 985
PPC_vsububm: int  # 986
PPC_vsububs: int  # 987
PPC_vsubudm: int  # 2106
PPC_vsubuhm: int  # 988
PPC_vsubuhs: int  # 989
PPC_vsubuqm: int  # 2107
PPC_vsubuwm: int  # 990
PPC_vsubuws: int  # 991
PPC_vsum2sws: int  # 992
PPC_vsum4sbs: int  # 993
PPC_vsum4shs: int  # 994
PPC_vsum4ubs: int  # 995
PPC_vsumsws: int  # 996
PPC_vupkd3d: int  # 1228
PPC_vupkhpx: int  # 997
PPC_vupkhsb: int  # 998
PPC_vupkhsh: int  # 999
PPC_vupkhsw: int  # 2097
PPC_vupklpx: int  # 1000
PPC_vupklsb: int  # 1001
PPC_vupklsh: int  # 1002
PPC_vupklsw: int  # 2098
PPC_vxor: int  # 1003
PPC_wait: int  # 1140
PPC_wait30: int  # 2287
PPC_waitimpl: int  # 1205
PPC_waitrsv: int  # 1204
PPC_wrtee: int  # 360
PPC_wrteei: int  # 361
PPC_xnop: int  # 1196
PPC_xor: int  # 226
PPC_xori: int  # 227
PPC_xoris: int  # 228
PPC_xsabsdp: int  # 1011
PPC_xsabsqp: int  # 2375
PPC_xsadddp: int  # 1012
PPC_xsaddqp: int  # 2376
PPC_xsaddsp: int  # 2159
PPC_xscmpeqdp: int  # 2405
PPC_xscmpeqqp: int  # 3373
PPC_xscmpexpdp: int  # 2406
PPC_xscmpexpqp: int  # 2377
PPC_xscmpgedp: int  # 2407
PPC_xscmpgeqp: int  # 3374
PPC_xscmpgtdp: int  # 2408
PPC_xscmpgtqp: int  # 3375
PPC_xscmpodp: int  # 1013
PPC_xscmpoqp: int  # 2378
PPC_xscmpudp: int  # 1014
PPC_xscmpuqp: int  # 2379
PPC_xscpsgndp: int  # 1015
PPC_xscpsgnqp: int  # 2380
PPC_xscvdphp: int  # 2427
PPC_xscvdpqp: int  # 2381
PPC_xscvdpsp: int  # 1016
PPC_xscvdpspn: int  # 2160
PPC_xscvdpsxds: int  # 1017
PPC_xscvdpsxws: int  # 1018
PPC_xscvdpuxds: int  # 1019
PPC_xscvdpuxws: int  # 1020
PPC_xscvhpdp: int  # 2428
PPC_xscvqpdp: int  # 2382
PPC_xscvqpsdz: int  # 2383
PPC_xscvqpsqz: int  # 3376
PPC_xscvqpswz: int  # 2384
PPC_xscvqpudz: int  # 2385
PPC_xscvqpuqz: int  # 3377
PPC_xscvqpuwz: int  # 2386
PPC_xscvsdqp: int  # 2387
PPC_xscvspdp: int  # 1021
PPC_xscvspdpn: int  # 2161
PPC_xscvsqqp: int  # 3378
PPC_xscvsxddp: int  # 1022
PPC_xscvsxdsp: int  # 2162
PPC_xscvudqp: int  # 2388
PPC_xscvuqqp: int  # 3379
PPC_xscvuxddp: int  # 1023
PPC_xscvuxdsp: int  # 2163
PPC_xsdivdp: int  # 1024
PPC_xsdivqp: int  # 2389
PPC_xsdivsp: int  # 2164
PPC_xsiexpdp: int  # 2409
PPC_xsiexpqp: int  # 2390
PPC_xsmaddadp: int  # 1025
PPC_xsmaddasp: int  # 2165
PPC_xsmaddmdp: int  # 1026
PPC_xsmaddmsp: int  # 2166
PPC_xsmaddqp: int  # 2391
PPC_xsmaxcdp: int  # 2410
PPC_xsmaxcqp: int  # 3380
PPC_xsmaxdp: int  # 1027
PPC_xsmaxjdp: int  # 2411
PPC_xsmincdp: int  # 2412
PPC_xsmincqp: int  # 3381
PPC_xsmindp: int  # 1028
PPC_xsminjdp: int  # 2413
PPC_xsmsubadp: int  # 1029
PPC_xsmsubasp: int  # 2167
PPC_xsmsubmdp: int  # 1030
PPC_xsmsubmsp: int  # 2168
PPC_xsmsubqp: int  # 2392
PPC_xsmuldp: int  # 1031
PPC_xsmulqp: int  # 2393
PPC_xsmulsp: int  # 2169
PPC_xsnabsdp: int  # 1032
PPC_xsnabsqp: int  # 2394
PPC_xsnegdp: int  # 1033
PPC_xsnegqp: int  # 2395
PPC_xsnmaddadp: int  # 1034
PPC_xsnmaddasp: int  # 2170
PPC_xsnmaddmdp: int  # 1035
PPC_xsnmaddmsp: int  # 2171
PPC_xsnmaddqp: int  # 2396
PPC_xsnmsubadp: int  # 1036
PPC_xsnmsubasp: int  # 2172
PPC_xsnmsubmdp: int  # 1037
PPC_xsnmsubmsp: int  # 2173
PPC_xsnmsubqp: int  # 2397
PPC_xsrdpi: int  # 1038
PPC_xsrdpic: int  # 1039
PPC_xsrdpim: int  # 1040
PPC_xsrdpip: int  # 1041
PPC_xsrdpiz: int  # 1042
PPC_xsredp: int  # 1043
PPC_xsresp: int  # 2174
PPC_xsrqpi: int  # 2404
PPC_xsrqpxp: int  # 2403
PPC_xsrsp: int  # 2175
PPC_xsrsqrtedp: int  # 1044
PPC_xsrsqrtesp: int  # 2176
PPC_xssqrtdp: int  # 1045
PPC_xssqrtqp: int  # 2398
PPC_xssqrtsp: int  # 2177
PPC_xssubdp: int  # 1046
PPC_xssubqp: int  # 2399
PPC_xssubsp: int  # 2178
PPC_xstdivdp: int  # 1047
PPC_xstsqrtdp: int  # 1048
PPC_xststdcdp: int  # 2421
PPC_xststdcqp: int  # 2402
PPC_xststdcsp: int  # 2422
PPC_xsxexpdp: int  # 2425
PPC_xsxexpqp: int  # 2400
PPC_xsxsigdp: int  # 2426
PPC_xsxsigqp: int  # 2401
PPC_xvabsdp: int  # 1049
PPC_xvabssp: int  # 1050
PPC_xvadddp: int  # 1051
PPC_xvaddsp: int  # 1052
PPC_xvbf16ger2: int  # 3382
PPC_xvbf16ger2nn: int  # 3383
PPC_xvbf16ger2np: int  # 3384
PPC_xvbf16ger2pn: int  # 3385
PPC_xvbf16ger2pp: int  # 3386
PPC_xvcmpeqdp: int  # 1053
PPC_xvcmpeqsp: int  # 1054
PPC_xvcmpgedp: int  # 1055
PPC_xvcmpgesp: int  # 1056
PPC_xvcmpgtdp: int  # 1057
PPC_xvcmpgtsp: int  # 1058
PPC_xvcpsgndp: int  # 1059
PPC_xvcpsgnsp: int  # 1060
PPC_xvcvbf16spn: int  # 3387
PPC_xvcvdpsp: int  # 1061
PPC_xvcvdpsxds: int  # 1062
PPC_xvcvdpsxws: int  # 1063
PPC_xvcvdpuxds: int  # 1064
PPC_xvcvdpuxws: int  # 1065
PPC_xvcvhpsp: int  # 2437
PPC_xvcvspbf16: int  # 3388
PPC_xvcvspdp: int  # 1066
PPC_xvcvsphp: int  # 2438
PPC_xvcvspsxds: int  # 1067
PPC_xvcvspsxws: int  # 1068
PPC_xvcvspuxds: int  # 1069
PPC_xvcvspuxws: int  # 1070
PPC_xvcvsxddp: int  # 1071
PPC_xvcvsxdsp: int  # 1072
PPC_xvcvsxwdp: int  # 1073
PPC_xvcvsxwsp: int  # 1074
PPC_xvcvuxddp: int  # 1075
PPC_xvcvuxdsp: int  # 1076
PPC_xvcvuxwdp: int  # 1077
PPC_xvcvuxwsp: int  # 1078
PPC_xvdivdp: int  # 1079
PPC_xvdivsp: int  # 1080
PPC_xvf16ger2: int  # 3389
PPC_xvf16ger2nn: int  # 3390
PPC_xvf16ger2np: int  # 3391
PPC_xvf16ger2pn: int  # 3392
PPC_xvf16ger2pp: int  # 3393
PPC_xvf32ger: int  # 3394
PPC_xvf32gernn: int  # 3395
PPC_xvf32gernp: int  # 3396
PPC_xvf32gerpn: int  # 3397
PPC_xvf32gerpp: int  # 3398
PPC_xvf64ger: int  # 3399
PPC_xvf64gernn: int  # 3400
PPC_xvf64gernp: int  # 3401
PPC_xvf64gerpn: int  # 3402
PPC_xvf64gerpp: int  # 3403
PPC_xvi16ger2: int  # 3404
PPC_xvi16ger2pp: int  # 3405
PPC_xvi16ger2s: int  # 3406
PPC_xvi16ger2spp: int  # 3407
PPC_xvi4ger8: int  # 3408
PPC_xvi4ger8pp: int  # 3409
PPC_xvi8ger4: int  # 3410
PPC_xvi8ger4pp: int  # 3411
PPC_xvi8ger4spp: int  # 3412
PPC_xviexpdp: int  # 2414
PPC_xviexpsp: int  # 2415
PPC_xvmaddadp: int  # 1081
PPC_xvmaddasp: int  # 1082
PPC_xvmaddmdp: int  # 1083
PPC_xvmaddmsp: int  # 1084
PPC_xvmaxdp: int  # 1085
PPC_xvmaxsp: int  # 1086
PPC_xvmindp: int  # 1087
PPC_xvminsp: int  # 1088
PPC_xvmovdp: int  # 1209
PPC_xvmovsp: int  # 1210
PPC_xvmsubadp: int  # 1089
PPC_xvmsubasp: int  # 1090
PPC_xvmsubmdp: int  # 1091
PPC_xvmsubmsp: int  # 1092
PPC_xvmuldp: int  # 1093
PPC_xvmulsp: int  # 1094
PPC_xvnabsdp: int  # 1095
PPC_xvnabssp: int  # 1096
PPC_xvnegdp: int  # 1097
PPC_xvnegsp: int  # 1098
PPC_xvnmaddadp: int  # 1099
PPC_xvnmaddasp: int  # 1100
PPC_xvnmaddmdp: int  # 1101
PPC_xvnmaddmsp: int  # 1102
PPC_xvnmsubadp: int  # 1103
PPC_xvnmsubasp: int  # 1104
PPC_xvnmsubmdp: int  # 1105
PPC_xvnmsubmsp: int  # 1106
PPC_xvrdpi: int  # 1107
PPC_xvrdpic: int  # 1108
PPC_xvrdpim: int  # 1109
PPC_xvrdpip: int  # 1110
PPC_xvrdpiz: int  # 1111
PPC_xvredp: int  # 1112
PPC_xvresp: int  # 1113
PPC_xvrspi: int  # 1114
PPC_xvrspic: int  # 1115
PPC_xvrspim: int  # 1116
PPC_xvrspip: int  # 1117
PPC_xvrspiz: int  # 1118
PPC_xvrsqrtedp: int  # 1119
PPC_xvrsqrtesp: int  # 1120
PPC_xvsqrtdp: int  # 1121
PPC_xvsqrtsp: int  # 1122
PPC_xvsubdp: int  # 1123
PPC_xvsubsp: int  # 1124
PPC_xvtdivdp: int  # 1125
PPC_xvtdivsp: int  # 1126
PPC_xvtlsbb: int  # 3413
PPC_xvtsqrtdp: int  # 1127
PPC_xvtsqrtsp: int  # 1128
PPC_xvtstdcdp: int  # 2423
PPC_xvtstdcsp: int  # 2424
PPC_xvxexpdp: int  # 2429
PPC_xvxexpsp: int  # 2430
PPC_xvxsigdp: int  # 2431
PPC_xvxsigsp: int  # 2432
PPC_xxblendvb: int  # 3414
PPC_xxblendvd: int  # 3415
PPC_xxblendvh: int  # 3416
PPC_xxblendvw: int  # 3417
PPC_xxbrd: int  # 2433
PPC_xxbrh: int  # 2434
PPC_xxbrq: int  # 2435
PPC_xxbrw: int  # 2436
PPC_xxeval: int  # 3418
PPC_xxextractuw: int  # 2416
PPC_xxgenpcvbm: int  # 3419
PPC_xxgenpcvdm: int  # 3420
PPC_xxgenpcvhm: int  # 3421
PPC_xxgenpcvwm: int  # 3422
PPC_xxinsertw: int  # 2417
PPC_xxland: int  # 1129
PPC_xxlandc: int  # 1130
PPC_xxleqv: int  # 2179
PPC_xxlnand: int  # 2180
PPC_xxlnor: int  # 1131
PPC_xxlor: int  # 1132
PPC_xxlorc: int  # 2181
PPC_xxlxor: int  # 1133
PPC_xxmfacc: int  # 3423
PPC_xxmrghd: int  # 1212
PPC_xxmrghw: int  # 1134
PPC_xxmrgld: int  # 1213
PPC_xxmrglw: int  # 1135
PPC_xxmtacc: int  # 3424
PPC_xxperm: int  # 2418
PPC_xxpermdi: int  # 1136
PPC_xxpermr: int  # 2419
PPC_xxpermx: int  # 3425
PPC_xxsel: int  # 1137
PPC_xxsetaccz: int  # 3426
PPC_xxsldwi: int  # 1138
PPC_xxspltd: int  # 1211
PPC_xxsplti32dx: int  # 3427
PPC_xxspltib: int  # 2420
PPC_xxspltidp: int  # 3428
PPC_xxspltiw: int  # 3429
PPC_xxspltw: int  # 1139
PPC_xxswapd: int  # 1214
PPC_yield: int  # 2216
PPC_zabsw: int  # 2506
PPC_zabsws: int  # 2507
PPC_zaddd: int  # 2508
PPC_zadddss: int  # 2509
PPC_zadddus: int  # 2510
PPC_zaddhesw: int  # 2521
PPC_zaddheuw: int  # 2522
PPC_zaddhosw: int  # 2523
PPC_zaddhouw: int  # 2524
PPC_zaddwgsf: int  # 2528
PPC_zaddwgsi: int  # 2529
PPC_zaddwgui: int  # 2530
PPC_zaddwss: int  # 2531
PPC_zaddwus: int  # 2533
PPC_zbrminc: int  # 2502
PPC_zcircinc: int  # 2503
PPC_zcntlsw: int  # 2541
PPC_zdivwsf: int  # 2543
PPC_zldd: int  # 2625
PPC_zlddmx: int  # 2628
PPC_zlddu: int  # 2626
PPC_zlddx: int  # 2627
PPC_zldh: int  # 2629
PPC_zldhmx: int  # 2632
PPC_zldhu: int  # 2630
PPC_zldhx: int  # 2631
PPC_zldw: int  # 2633
PPC_zldwmx: int  # 2636
PPC_zldwu: int  # 2634
PPC_zldwx: int  # 2635
PPC_zlhgwsf: int  # 2637
PPC_zlhgwsfmx: int  # 2640
PPC_zlhgwsfu: int  # 2638
PPC_zlhgwsfx: int  # 2639
PPC_zlhhe: int  # 2641
PPC_zlhhemx: int  # 2644
PPC_zlhheu: int  # 2642
PPC_zlhhex: int  # 2643
PPC_zlhhos: int  # 2645
PPC_zlhhosmx: int  # 2648
PPC_zlhhosu: int  # 2646
PPC_zlhhosx: int  # 2647
PPC_zlhhou: int  # 2649
PPC_zlhhoumx: int  # 2652
PPC_zlhhouu: int  # 2650
PPC_zlhhoux: int  # 2651
PPC_zlhhsplat: int  # 2653
PPC_zlhhsplatmx: int  # 2656
PPC_zlhhsplatu: int  # 2654
PPC_zlhhsplatx: int  # 2655
PPC_zlwgsfd: int  # 2657
PPC_zlwgsfdmx: int  # 2660
PPC_zlwgsfdu: int  # 2658
PPC_zlwgsfdx: int  # 2659
PPC_zlwh: int  # 2661
PPC_zlwhed: int  # 2665
PPC_zlwhedmx: int  # 2668
PPC_zlwhedu: int  # 2666
PPC_zlwhedx: int  # 2667
PPC_zlwhgwsfd: int  # 2669
PPC_zlwhgwsfdmx: int  # 2672
PPC_zlwhgwsfdu: int  # 2670
PPC_zlwhgwsfdx: int  # 2671
PPC_zlwhmx: int  # 2664
PPC_zlwhosd: int  # 2673
PPC_zlwhosdmx: int  # 2676
PPC_zlwhosdu: int  # 2674
PPC_zlwhosdx: int  # 2675
PPC_zlwhoud: int  # 2677
PPC_zlwhoudmx: int  # 2680
PPC_zlwhoudu: int  # 2678
PPC_zlwhoudx: int  # 2679
PPC_zlwhsplatd: int  # 2681
PPC_zlwhsplatdmx: int  # 2684
PPC_zlwhsplatdu: int  # 2682
PPC_zlwhsplatdx: int  # 2683
PPC_zlwhsplatwd: int  # 2685
PPC_zlwhsplatwdmx: int  # 2688
PPC_zlwhsplatwdu: int  # 2686
PPC_zlwhsplatwdx: int  # 2687
PPC_zlwhu: int  # 2662
PPC_zlwhx: int  # 2663
PPC_zlww: int  # 2689
PPC_zlwwmx: int  # 2692
PPC_zlwwosd: int  # 2693
PPC_zlwwosdmx: int  # 2696
PPC_zlwwosdu: int  # 2694
PPC_zlwwosdx: int  # 2695
PPC_zlwwu: int  # 2690
PPC_zlwwx: int  # 2691
PPC_zmhegsi: int  # 2734
PPC_zmhegsiaa: int  # 2747
PPC_zmhegsian: int  # 2748
PPC_zmhegsmf: int  # 2736
PPC_zmhegsmfaa: int  # 2751
PPC_zmhegsmfan: int  # 2752
PPC_zmhegsui: int  # 2735
PPC_zmhegsuiaa: int  # 2749
PPC_zmhegsuian: int  # 2750
PPC_zmhegui: int  # 2733
PPC_zmheguiaa: int  # 2745
PPC_zmheguian: int  # 2746
PPC_zmhegwsmf: int  # 2769
PPC_zmhegwsmfaa: int  # 2775
PPC_zmhegwsmfan: int  # 2778
PPC_zmhegwsmfr: int  # 2772
PPC_zmhegwsmfraa: int  # 2781
PPC_zmhegwsmfran: int  # 2784
PPC_zmheogsi: int  # 2738
PPC_zmheogsiaa: int  # 2755
PPC_zmheogsian: int  # 2756
PPC_zmheogsmf: int  # 2740
PPC_zmheogsmfaa: int  # 2759
PPC_zmheogsmfan: int  # 2760
PPC_zmheogsui: int  # 2739
PPC_zmheogsuiaa: int  # 2757
PPC_zmheogsuian: int  # 2758
PPC_zmheogui: int  # 2737
PPC_zmheoguiaa: int  # 2753
PPC_zmheoguian: int  # 2754
PPC_zmheogwsmf: int  # 2770
PPC_zmheogwsmfaa: int  # 2776
PPC_zmheogwsmfan: int  # 2779
PPC_zmheogwsmfr: int  # 2773
PPC_zmheogwsmfraa: int  # 2782
PPC_zmheogwsmfran: int  # 2785
PPC_zmheosf: int  # 2788
PPC_zmheosfaas: int  # 2794
PPC_zmheosfans: int  # 2797
PPC_zmheosfr: int  # 2791
PPC_zmheosfraas: int  # 2800
PPC_zmheosfrans: int  # 2803
PPC_zmheosi: int  # 2806
PPC_zmheosiaa: int  # 2815
PPC_zmheosiaas: int  # 2833
PPC_zmheosian: int  # 2818
PPC_zmheosians: int  # 2836
PPC_zmheosui: int  # 2809
PPC_zmheosuiaa: int  # 2821
PPC_zmheosuiaas: int  # 2839
PPC_zmheosuian: int  # 2824
PPC_zmheosuians: int  # 2842
PPC_zmheoui: int  # 2812
PPC_zmheouiaa: int  # 2827
PPC_zmheouiaas: int  # 2845
PPC_zmheouian: int  # 2830
PPC_zmheouians: int  # 2848
PPC_zmhesf: int  # 2787
PPC_zmhesfaas: int  # 2793
PPC_zmhesfans: int  # 2796
PPC_zmhesfr: int  # 2790
PPC_zmhesfraas: int  # 2799
PPC_zmhesfrans: int  # 2802
PPC_zmhesi: int  # 2805
PPC_zmhesiaa: int  # 2814
PPC_zmhesiaas: int  # 2832
PPC_zmhesian: int  # 2817
PPC_zmhesians: int  # 2835
PPC_zmhesui: int  # 2808
PPC_zmhesuiaa: int  # 2820
PPC_zmhesuiaas: int  # 2838
PPC_zmhesuian: int  # 2823
PPC_zmhesuians: int  # 2841
PPC_zmheui: int  # 2811
PPC_zmheuiaa: int  # 2826
PPC_zmheuiaas: int  # 2844
PPC_zmheuian: int  # 2829
PPC_zmheuians: int  # 2847
PPC_zmhogsi: int  # 2742
PPC_zmhogsiaa: int  # 2763
PPC_zmhogsian: int  # 2764
PPC_zmhogsmf: int  # 2744
PPC_zmhogsmfaa: int  # 2767
PPC_zmhogsmfan: int  # 2768
PPC_zmhogsui: int  # 2743
PPC_zmhogsuiaa: int  # 2765
PPC_zmhogsuian: int  # 2766
PPC_zmhogui: int  # 2741
PPC_zmhoguiaa: int  # 2761
PPC_zmhoguian: int  # 2762
PPC_zmhogwsmf: int  # 2771
PPC_zmhogwsmfaa: int  # 2777
PPC_zmhogwsmfan: int  # 2780
PPC_zmhogwsmfr: int  # 2774
PPC_zmhogwsmfraa: int  # 2783
PPC_zmhogwsmfran: int  # 2786
PPC_zmhosf: int  # 2789
PPC_zmhosfaas: int  # 2795
PPC_zmhosfans: int  # 2798
PPC_zmhosfr: int  # 2792
PPC_zmhosfraas: int  # 2801
PPC_zmhosfrans: int  # 2804
PPC_zmhosi: int  # 2807
PPC_zmhosiaa: int  # 2816
PPC_zmhosiaas: int  # 2834
PPC_zmhosian: int  # 2819
PPC_zmhosians: int  # 2837
PPC_zmhosui: int  # 2810
PPC_zmhosuiaa: int  # 2822
PPC_zmhosuiaas: int  # 2840
PPC_zmhosuian: int  # 2825
PPC_zmhosuians: int  # 2843
PPC_zmhoui: int  # 2813
PPC_zmhouiaa: int  # 2828
PPC_zmhouiaas: int  # 2846
PPC_zmhouian: int  # 2831
PPC_zmhouians: int  # 2849
PPC_zmwgsi: int  # 2874
PPC_zmwgsiaa: int  # 2877
PPC_zmwgsiaas: int  # 2883
PPC_zmwgsian: int  # 2878
PPC_zmwgsians: int  # 2884
PPC_zmwgsmf: int  # 2889
PPC_zmwgsmfaa: int  # 2891
PPC_zmwgsmfan: int  # 2892
PPC_zmwgsmfr: int  # 2890
PPC_zmwgsmfraa: int  # 2893
PPC_zmwgsmfran: int  # 2894
PPC_zmwgsui: int  # 2875
PPC_zmwgsuiaa: int  # 2879
PPC_zmwgsuiaas: int  # 2885
PPC_zmwgsuian: int  # 2880
PPC_zmwgsuians: int  # 2886
PPC_zmwgui: int  # 2876
PPC_zmwguiaa: int  # 2881
PPC_zmwguiaas: int  # 2887
PPC_zmwguian: int  # 2882
PPC_zmwguians: int  # 2888
PPC_zmwlsiaa: int  # 2898
PPC_zmwlsiaas: int  # 2904
PPC_zmwlsian: int  # 2901
PPC_zmwlsians: int  # 2907
PPC_zmwlsis: int  # 2895
PPC_zmwlsuiaa: int  # 2899
PPC_zmwlsuiaas: int  # 2905
PPC_zmwlsuian: int  # 2902
PPC_zmwlsuians: int  # 2908
PPC_zmwlsuis: int  # 2896
PPC_zmwluiaa: int  # 2900
PPC_zmwluiaas: int  # 2906
PPC_zmwluian: int  # 2903
PPC_zmwluians: int  # 2909
PPC_zmwluis: int  # 2897
PPC_zmwsf: int  # 2910
PPC_zmwsfaas: int  # 2912
PPC_zmwsfans: int  # 2913
PPC_zmwsfr: int  # 2911
PPC_zmwsfraas: int  # 2914
PPC_zmwsfrans: int  # 2915
PPC_znegws: int  # 2552
PPC_zpkswgshfrs: int  # 2554
PPC_zpkswgswfrs: int  # 2555
PPC_zrndwh: int  # 2562
PPC_zrndwhss: int  # 2563
PPC_zsatsdsw: int  # 2564
PPC_zsatsduw: int  # 2565
PPC_zsatswsh: int  # 2567
PPC_zsatswuh: int  # 2568
PPC_zsatswuw: int  # 2569
PPC_zsatuduw: int  # 2570
PPC_zsatuwsh: int  # 2573
PPC_zsatuwsw: int  # 2572
PPC_zsatuwuh: int  # 2574
PPC_zslwiss: int  # 2583
PPC_zslwius: int  # 2585
PPC_zslwss: int  # 2582
PPC_zslwus: int  # 2584
PPC_zstdd: int  # 2697
PPC_zstddmx: int  # 2700
PPC_zstddu: int  # 2698
PPC_zstddx: int  # 2699
PPC_zstdh: int  # 2701
PPC_zstdhmx: int  # 2704
PPC_zstdhu: int  # 2702
PPC_zstdhx: int  # 2703
PPC_zstdw: int  # 2705
PPC_zstdwmx: int  # 2708
PPC_zstdwu: int  # 2706
PPC_zstdwx: int  # 2707
PPC_zsthe: int  # 2709
PPC_zsthemx: int  # 2712
PPC_zstheu: int  # 2710
PPC_zsthex: int  # 2711
PPC_zstho: int  # 2713
PPC_zsthomx: int  # 2716
PPC_zsthou: int  # 2714
PPC_zsthox: int  # 2715
PPC_zstwh: int  # 2717
PPC_zstwhed: int  # 2721
PPC_zstwhedmx: int  # 2724
PPC_zstwhedu: int  # 2722
PPC_zstwhedx: int  # 2723
PPC_zstwhmx: int  # 2720
PPC_zstwhod: int  # 2725
PPC_zstwhodmx: int  # 2728
PPC_zstwhodu: int  # 2726
PPC_zstwhodx: int  # 2727
PPC_zstwhu: int  # 2718
PPC_zstwhx: int  # 2719
PPC_zstww: int  # 2729
PPC_zstwwmx: int  # 2732
PPC_zstwwu: int  # 2730
PPC_zstwwx: int  # 2731
PPC_zsubfd: int  # 2596
PPC_zsubfdss: int  # 2597
PPC_zsubfdus: int  # 2598
PPC_zsubfhesw: int  # 2600
PPC_zsubfheuw: int  # 2601
PPC_zsubfhosw: int  # 2602
PPC_zsubfhouw: int  # 2603
PPC_zsubfwgsf: int  # 2611
PPC_zsubfwgsi: int  # 2612
PPC_zsubfwgui: int  # 2613
PPC_zsubfwss: int  # 2614
PPC_zsubfwus: int  # 2616
PPC_zunpkwgsf: int  # 2623
PPC_zvabsh: int  # 2504
PPC_zvabshs: int  # 2505
PPC_zvaddh: int  # 2511
PPC_zvaddhss: int  # 2512
PPC_zvaddhus: int  # 2513
PPC_zvaddhx: int  # 2514
PPC_zvaddhxss: int  # 2515
PPC_zvaddih: int  # 2516
PPC_zvaddsubfh: int  # 2517
PPC_zvaddsubfhss: int  # 2518
PPC_zvaddsubfhx: int  # 2519
PPC_zvaddsubfhxss: int  # 2520
PPC_zvaddsubfw: int  # 2526
PPC_zvaddsubfwss: int  # 2527
PPC_zvaddw: int  # 2525
PPC_zvaddwss: int  # 2532
PPC_zvaddwus: int  # 2534
PPC_zvcmpeqh: int  # 2535
PPC_zvcmpgths: int  # 2536
PPC_zvcmpgthu: int  # 2537
PPC_zvcmplths: int  # 2538
PPC_zvcmplthu: int  # 2539
PPC_zvcntlsh: int  # 2540
PPC_zvcntlzh: int  # 2542
PPC_zvdotphasfaas: int  # 3104
PPC_zvdotphasfans: int  # 3106
PPC_zvdotphasfraas: int  # 3108
PPC_zvdotphasfrans: int  # 3110
PPC_zvdotphasfrs: int  # 3102
PPC_zvdotphasfs: int  # 3100
PPC_zvdotphasi: int  # 3114
PPC_zvdotphasiaa: int  # 3120
PPC_zvdotphasiaas: int  # 3138
PPC_zvdotphasian: int  # 3126
PPC_zvdotphasians: int  # 3144
PPC_zvdotphasis: int  # 3132
PPC_zvdotphasui: int  # 3116
PPC_zvdotphasuiaa: int  # 3122
PPC_zvdotphasuiaas: int  # 3140
PPC_zvdotphasuian: int  # 3128
PPC_zvdotphasuians: int  # 3146
PPC_zvdotphasuis: int  # 3134
PPC_zvdotphaui: int  # 3112
PPC_zvdotphauiaa: int  # 3118
PPC_zvdotphauiaas: int  # 3136
PPC_zvdotphauian: int  # 3124
PPC_zvdotphauians: int  # 3142
PPC_zvdotphauis: int  # 3130
PPC_zvdotphgasi: int  # 3066
PPC_zvdotphgasiaa: int  # 3074
PPC_zvdotphgasian: int  # 3082
PPC_zvdotphgasmf: int  # 3070
PPC_zvdotphgasmfaa: int  # 3078
PPC_zvdotphgasmfan: int  # 3086
PPC_zvdotphgasui: int  # 3068
PPC_zvdotphgasuiaa: int  # 3076
PPC_zvdotphgasuian: int  # 3084
PPC_zvdotphgaui: int  # 3064
PPC_zvdotphgauiaa: int  # 3072
PPC_zvdotphgauian: int  # 3080
PPC_zvdotphgssi: int  # 3089
PPC_zvdotphgssiaa: int  # 3093
PPC_zvdotphgssian: int  # 3097
PPC_zvdotphgssmf: int  # 3091
PPC_zvdotphgssmfaa: int  # 3095
PPC_zvdotphgssmfan: int  # 3099
PPC_zvdotphgssui: int  # 3090
PPC_zvdotphgssuiaa: int  # 3094
PPC_zvdotphgssuian: int  # 3098
PPC_zvdotphgsui: int  # 3088
PPC_zvdotphgsuiaa: int  # 3092
PPC_zvdotphgsuian: int  # 3096
PPC_zvdotphgwasmf: int  # 3172
PPC_zvdotphgwasmfaa: int  # 3176
PPC_zvdotphgwasmfan: int  # 3178
PPC_zvdotphgwasmfr: int  # 3174
PPC_zvdotphgwasmfraa: int  # 3180
PPC_zvdotphgwasmfran: int  # 3182
PPC_zvdotphgwssmf: int  # 3184
PPC_zvdotphgwssmfaa: int  # 3186
PPC_zvdotphgwssmfan: int  # 3187
PPC_zvdotphgwssmfr: int  # 3185
PPC_zvdotphgwssmfraa: int  # 3188
PPC_zvdotphgwssmfran: int  # 3189
PPC_zvdotphssfaas: int  # 3150
PPC_zvdotphssfans: int  # 3151
PPC_zvdotphssfraas: int  # 3152
PPC_zvdotphssfrans: int  # 3153
PPC_zvdotphssfrs: int  # 3149
PPC_zvdotphssfs: int  # 3148
PPC_zvdotphssi: int  # 3155
PPC_zvdotphssiaa: int  # 3158
PPC_zvdotphssiaas: int  # 3167
PPC_zvdotphssian: int  # 3161
PPC_zvdotphssians: int  # 3170
PPC_zvdotphssis: int  # 3164
PPC_zvdotphssui: int  # 3156
PPC_zvdotphssuiaa: int  # 3159
PPC_zvdotphssuiaas: int  # 3168
PPC_zvdotphssuian: int  # 3162
PPC_zvdotphssuians: int  # 3171
PPC_zvdotphssuis: int  # 3165
PPC_zvdotphsui: int  # 3154
PPC_zvdotphsuiaa: int  # 3157
PPC_zvdotphsuiaas: int  # 3166
PPC_zvdotphsuian: int  # 3160
PPC_zvdotphsuians: int  # 3169
PPC_zvdotphsuis: int  # 3163
PPC_zvdotphxasfaas: int  # 3105
PPC_zvdotphxasfans: int  # 3107
PPC_zvdotphxasfraas: int  # 3109
PPC_zvdotphxasfrans: int  # 3111
PPC_zvdotphxasfrs: int  # 3103
PPC_zvdotphxasfs: int  # 3101
PPC_zvdotphxasi: int  # 3115
PPC_zvdotphxasiaa: int  # 3121
PPC_zvdotphxasiaas: int  # 3139
PPC_zvdotphxasian: int  # 3127
PPC_zvdotphxasians: int  # 3145
PPC_zvdotphxasis: int  # 3133
PPC_zvdotphxasui: int  # 3117
PPC_zvdotphxasuiaa: int  # 3123
PPC_zvdotphxasuiaas: int  # 3141
PPC_zvdotphxasuian: int  # 3129
PPC_zvdotphxasuians: int  # 3147
PPC_zvdotphxasuis: int  # 3135
PPC_zvdotphxaui: int  # 3113
PPC_zvdotphxauiaa: int  # 3119
PPC_zvdotphxauiaas: int  # 3137
PPC_zvdotphxauian: int  # 3125
PPC_zvdotphxauians: int  # 3143
PPC_zvdotphxauis: int  # 3131
PPC_zvdotphxgasi: int  # 3067
PPC_zvdotphxgasiaa: int  # 3075
PPC_zvdotphxgasian: int  # 3083
PPC_zvdotphxgasmf: int  # 3071
PPC_zvdotphxgasmfaa: int  # 3079
PPC_zvdotphxgasmfan: int  # 3087
PPC_zvdotphxgasui: int  # 3069
PPC_zvdotphxgasuiaa: int  # 3077
PPC_zvdotphxgasuian: int  # 3085
PPC_zvdotphxgaui: int  # 3065
PPC_zvdotphxgauiaa: int  # 3073
PPC_zvdotphxgauian: int  # 3081
PPC_zvdotphxgwasmf: int  # 3173
PPC_zvdotphxgwasmfaa: int  # 3177
PPC_zvdotphxgwasmfan: int  # 3179
PPC_zvdotphxgwasmfr: int  # 3175
PPC_zvdotphxgwasmfraa: int  # 3181
PPC_zvdotphxgwasmfran: int  # 3183
PPC_zvmergehih: int  # 2544
PPC_zvmergehiloh: int  # 2545
PPC_zvmergeloh: int  # 2546
PPC_zvmergelohih: int  # 2547
PPC_zvmhllgwsmf: int  # 2917
PPC_zvmhllgwsmfaa: int  # 2925
PPC_zvmhllgwsmfan: int  # 2933
PPC_zvmhllgwsmfanp: int  # 2941
PPC_zvmhllgwsmfr: int  # 2921
PPC_zvmhllgwsmfraa: int  # 2929
PPC_zvmhllgwsmfran: int  # 2937
PPC_zvmhllgwsmfranp: int  # 2945
PPC_zvmhllsf: int  # 2949
PPC_zvmhllsfaas: int  # 2957
PPC_zvmhllsfanps: int  # 2965
PPC_zvmhllsfans: int  # 2961
PPC_zvmhllsfr: int  # 2953
PPC_zvmhllsfraas: int  # 2969
PPC_zvmhllsfranps: int  # 2977
PPC_zvmhllsfrans: int  # 2973
PPC_zvmhllsi: int  # 2981
PPC_zvmhllsiaa: int  # 2993
PPC_zvmhllsiaas: int  # 3029
PPC_zvmhllsian: int  # 2997
PPC_zvmhllsianp: int  # 3001
PPC_zvmhllsianps: int  # 3037
PPC_zvmhllsians: int  # 3033
PPC_zvmhllsui: int  # 2985
PPC_zvmhllsuiaa: int  # 3005
PPC_zvmhllsuiaas: int  # 3041
PPC_zvmhllsuian: int  # 3009
PPC_zvmhllsuianp: int  # 3013
PPC_zvmhllsuianps: int  # 3049
PPC_zvmhllsuians: int  # 3045
PPC_zvmhllui: int  # 2989
PPC_zvmhlluiaa: int  # 3017
PPC_zvmhlluiaas: int  # 3053
PPC_zvmhlluian: int  # 3021
PPC_zvmhlluianp: int  # 3025
PPC_zvmhlluianps: int  # 3061
PPC_zvmhlluians: int  # 3057
PPC_zvmhsfaahs: int  # 2852
PPC_zvmhsfanhs: int  # 2853
PPC_zvmhsfh: int  # 2850
PPC_zvmhsfraahs: int  # 2854
PPC_zvmhsfranhs: int  # 2855
PPC_zvmhsfrh: int  # 2851
PPC_zvmhsiaah: int  # 2862
PPC_zvmhsiaahs: int  # 2868
PPC_zvmhsianh: int  # 2865
PPC_zvmhsianhs: int  # 2871
PPC_zvmhsih: int  # 2856
PPC_zvmhsihs: int  # 2859
PPC_zvmhsuiaah: int  # 2863
PPC_zvmhsuiaahs: int  # 2869
PPC_zvmhsuianh: int  # 2866
PPC_zvmhsuianhs: int  # 2872
PPC_zvmhsuih: int  # 2857
PPC_zvmhsuihs: int  # 2860
PPC_zvmhuiaah: int  # 2864
PPC_zvmhuiaahs: int  # 2870
PPC_zvmhuianh: int  # 2867
PPC_zvmhuianhs: int  # 2873
PPC_zvmhuih: int  # 2858
PPC_zvmhuihs: int  # 2861
PPC_zvmhulgwsmf: int  # 2916
PPC_zvmhulgwsmfaa: int  # 2924
PPC_zvmhulgwsmfan: int  # 2932
PPC_zvmhulgwsmfanp: int  # 2940
PPC_zvmhulgwsmfr: int  # 2920
PPC_zvmhulgwsmfraa: int  # 2928
PPC_zvmhulgwsmfran: int  # 2936
PPC_zvmhulgwsmfranp: int  # 2944
PPC_zvmhulsf: int  # 2948
PPC_zvmhulsfaas: int  # 2956
PPC_zvmhulsfanps: int  # 2964
PPC_zvmhulsfans: int  # 2960
PPC_zvmhulsfr: int  # 2952
PPC_zvmhulsfraas: int  # 2968
PPC_zvmhulsfranps: int  # 2976
PPC_zvmhulsfrans: int  # 2972
PPC_zvmhulsi: int  # 2980
PPC_zvmhulsiaa: int  # 2992
PPC_zvmhulsiaas: int  # 3028
PPC_zvmhulsian: int  # 2996
PPC_zvmhulsianp: int  # 3000
PPC_zvmhulsianps: int  # 3036
PPC_zvmhulsians: int  # 3032
PPC_zvmhulsui: int  # 2984
PPC_zvmhulsuiaa: int  # 3004
PPC_zvmhulsuiaas: int  # 3040
PPC_zvmhulsuian: int  # 3008
PPC_zvmhulsuianp: int  # 3012
PPC_zvmhulsuianps: int  # 3048
PPC_zvmhulsuians: int  # 3044
PPC_zvmhului: int  # 2988
PPC_zvmhuluiaa: int  # 3016
PPC_zvmhuluiaas: int  # 3052
PPC_zvmhuluian: int  # 3020
PPC_zvmhuluianp: int  # 3024
PPC_zvmhuluianps: int  # 3060
PPC_zvmhuluians: int  # 3056
PPC_zvmhuugwsmf: int  # 2918
PPC_zvmhuugwsmfaa: int  # 2926
PPC_zvmhuugwsmfan: int  # 2934
PPC_zvmhuugwsmfanp: int  # 2942
PPC_zvmhuugwsmfr: int  # 2922
PPC_zvmhuugwsmfraa: int  # 2930
PPC_zvmhuugwsmfran: int  # 2938
PPC_zvmhuugwsmfranp: int  # 2946
PPC_zvmhuusf: int  # 2950
PPC_zvmhuusfaas: int  # 2958
PPC_zvmhuusfanps: int  # 2966
PPC_zvmhuusfans: int  # 2962
PPC_zvmhuusfr: int  # 2954
PPC_zvmhuusfraas: int  # 2970
PPC_zvmhuusfranps: int  # 2978
PPC_zvmhuusfrans: int  # 2974
PPC_zvmhuusi: int  # 2982
PPC_zvmhuusiaa: int  # 2994
PPC_zvmhuusiaas: int  # 3030
PPC_zvmhuusian: int  # 2998
PPC_zvmhuusianp: int  # 3002
PPC_zvmhuusianps: int  # 3038
PPC_zvmhuusians: int  # 3034
PPC_zvmhuusui: int  # 2986
PPC_zvmhuusuiaa: int  # 3006
PPC_zvmhuusuiaas: int  # 3042
PPC_zvmhuusuian: int  # 3010
PPC_zvmhuusuianp: int  # 3014
PPC_zvmhuusuianps: int  # 3050
PPC_zvmhuusuians: int  # 3046
PPC_zvmhuuui: int  # 2990
PPC_zvmhuuuiaa: int  # 3018
PPC_zvmhuuuiaas: int  # 3054
PPC_zvmhuuuian: int  # 3022
PPC_zvmhuuuianp: int  # 3026
PPC_zvmhuuuianps: int  # 3062
PPC_zvmhuuuians: int  # 3058
PPC_zvmhxlgwsmf: int  # 2919
PPC_zvmhxlgwsmfaa: int  # 2927
PPC_zvmhxlgwsmfan: int  # 2935
PPC_zvmhxlgwsmfanp: int  # 2943
PPC_zvmhxlgwsmfr: int  # 2923
PPC_zvmhxlgwsmfraa: int  # 2931
PPC_zvmhxlgwsmfran: int  # 2939
PPC_zvmhxlgwsmfranp: int  # 2947
PPC_zvmhxlsf: int  # 2951
PPC_zvmhxlsfaas: int  # 2959
PPC_zvmhxlsfanps: int  # 2967
PPC_zvmhxlsfans: int  # 2963
PPC_zvmhxlsfr: int  # 2955
PPC_zvmhxlsfraas: int  # 2971
PPC_zvmhxlsfranps: int  # 2979
PPC_zvmhxlsfrans: int  # 2975
PPC_zvmhxlsi: int  # 2983
PPC_zvmhxlsiaa: int  # 2995
PPC_zvmhxlsiaas: int  # 3031
PPC_zvmhxlsian: int  # 2999
PPC_zvmhxlsianp: int  # 3003
PPC_zvmhxlsianps: int  # 3039
PPC_zvmhxlsians: int  # 3035
PPC_zvmhxlsui: int  # 2987
PPC_zvmhxlsuiaa: int  # 3007
PPC_zvmhxlsuiaas: int  # 3043
PPC_zvmhxlsuian: int  # 3011
PPC_zvmhxlsuianp: int  # 3015
PPC_zvmhxlsuianps: int  # 3051
PPC_zvmhxlsuians: int  # 3047
PPC_zvmhxlui: int  # 2991
PPC_zvmhxluiaa: int  # 3019
PPC_zvmhxluiaas: int  # 3055
PPC_zvmhxluian: int  # 3023
PPC_zvmhxluianp: int  # 3027
PPC_zvmhxluianps: int  # 3063
PPC_zvmhxluians: int  # 3059
PPC_zvnegh: int  # 2548
PPC_zvnegho: int  # 2549
PPC_zvneghos: int  # 2550
PPC_zvneghs: int  # 2551
PPC_zvpkshgwshfrs: int  # 2553
PPC_zvpkswshfrs: int  # 2556
PPC_zvpkswshs: int  # 2557
PPC_zvpkswuhs: int  # 2558
PPC_zvpkuwuhs: int  # 2559
PPC_zvrlh: int  # 2560
PPC_zvrlhi: int  # 2561
PPC_zvsatshuh: int  # 2566
PPC_zvsatuhsh: int  # 2571
PPC_zvselh: int  # 2575
PPC_zvslh: int  # 2576
PPC_zvslhi: int  # 2577
PPC_zvslhiss: int  # 2579
PPC_zvslhius: int  # 2581
PPC_zvslhss: int  # 2578
PPC_zvslhus: int  # 2580
PPC_zvsplatfih: int  # 2586
PPC_zvsplatih: int  # 2587
PPC_zvsrhis: int  # 2588
PPC_zvsrhiu: int  # 2589
PPC_zvsrhs: int  # 2590
PPC_zvsrhu: int  # 2591
PPC_zvsubfaddh: int  # 2592
PPC_zvsubfaddhss: int  # 2593
PPC_zvsubfaddhx: int  # 2594
PPC_zvsubfaddhxss: int  # 2595
PPC_zvsubfaddw: int  # 2609
PPC_zvsubfaddwss: int  # 2610
PPC_zvsubfh: int  # 2599
PPC_zvsubfhss: int  # 2604
PPC_zvsubfhus: int  # 2605
PPC_zvsubfhx: int  # 2606
PPC_zvsubfhxss: int  # 2607
PPC_zvsubfw: int  # 2608
PPC_zvsubfwss: int  # 2615
PPC_zvsubfwus: int  # 2617
PPC_zvsubifh: int  # 2618
PPC_zvunpkhgwsf: int  # 2619
PPC_zvunpkhsf: int  # 2620
PPC_zvunpkhsi: int  # 2621
PPC_zvunpkhui: int  # 2622
PPC_zxtrw: int  # 2624
PR2_CODE16_BIT: int  # 8
PR2_FORCE_16BIT: int  # 128
PR2_IDP_OPTS: int  # 2
PR2_MACRO: int  # 16
PR2_MAPPINGS: int  # 1
PR2_REL_BITS: int  # 64
PR2_USE_CALCREL: int  # 32
PRALOC_STKOFF: int  # 2
PRALOC_VERIFY: int  # 1
PREF_FNCOFF: int  # 2
PREF_PFXTRUNC: int  # 8
PREF_SEGADR: int  # 1
PREF_STACK: int  # 4
PRN_BIN: int  # 192
PRN_DEC: int  # 128
PRN_HEX: int  # 0
PRN_OCT: int  # 64
PROCESS_ATTACHED: int  # 11
PROCESS_DETACHED: int  # 12
PROCESS_EXITED: int  # 2
PROCESS_STARTED: int  # 1
PROCESS_SUSPENDED: int  # 13
PRTYPE_1LINCMT: int  # 8192
PRTYPE_1LINE: int  # 0
PRTYPE_ARGLOCS: int  # 262144
PRTYPE_COLORED: int  # 2048
PRTYPE_CPP: int  # 16
PRTYPE_DEF: int  # 32
PRTYPE_HEADER: int  # 16384
PRTYPE_MAXSTR: int  # 65536
PRTYPE_METHODS: int  # 4096
PRTYPE_MULTI: int  # 1
PRTYPE_NOARGS: int  # 64
PRTYPE_NOARRS: int  # 128
PRTYPE_NOREGEX: int  # 1024
PRTYPE_NORES: int  # 256
PRTYPE_OFFSETS: int  # 32768
PRTYPE_PRAGMA: int  # 4
PRTYPE_RESTORE: int  # 512
PRTYPE_SEMI: int  # 8
PRTYPE_TAIL: int  # 131072
PRTYPE_TYPE: int  # 2
PR_ADJSEGS: int  # 32
PR_ALIGN: int  # 2048
PR_ALIGN_INSN: int  # 16777216
PR_ASSEMBLE: int  # 1024
PR_ATTN: int  # 12
PR_BADSTACK: int  # 11
PR_BINMEM: int  # 65536
PR_CHK_XREF: int  # 262144
PR_CNDINSNS: int  # 67108864
PR_COLLISION: int  # 15
PR_DECIMP: int  # 16
PR_DEFNUM: int  # 192
PR_DEFSEG32: int  # 4
PR_DEFSEG64: int  # 268435456
PR_DELAYED: int  # 8388608
PR_DISASM: int  # 7
PR_END: int  # 17
PR_FINAL: int  # 13
PR_HEAD: int  # 8
PR_ILLADDR: int  # 9
PR_JUMP: int  # 6
PR_MANYLINES: int  # 10
PR_NOBASE: int  # 1
PR_NOCHANGE: int  # 512
PR_NOCMT: int  # 4
PR_NOFOP: int  # 3
PR_NONAME: int  # 2
PR_NOXREFS: int  # 5
PR_NO_SEGMOVE: int  # 524288
PR_OUTER: int  # 536870912
PR_PURGING: int  # 33554432
PR_RNAMESOK: int  # 8
PR_ROLLED: int  # 14
PR_SCALE_STKVARS: int  # 4194304
PR_SEGS: int  # 1
PR_SEGTRANS: int  # 131072
PR_SGROTHER: int  # 16384
PR_STACK_UP: int  # 32768
PR_TYPEINFO: int  # 4096
PR_USE32: int  # 2
PR_USE64: int  # 8192
PR_USE_ARG_TYPES: int  # 2097152
PR_USE_TBYTE: int  # 134217728
PR_WORD_INS: int  # 256
PSP_bitrev: int  # 612
PSP_bvf: int  # 629
PSP_bvfl: int  # 631
PSP_bvt: int  # 630
PSP_bvtl: int  # 632
PSP_lv: int  # 619
PSP_lvl: int  # 620
PSP_lvr: int  # 621
PSP_max: int  # 613
PSP_mfic: int  # 615
PSP_mfv: int  # 625
PSP_mfvc: int  # 627
PSP_mfvme: int  # 732
PSP_min: int  # 614
PSP_mtic: int  # 616
PSP_mtv: int  # 626
PSP_mtvc: int  # 628
PSP_mtvme: int  # 733
PSP_sleep: int  # 618
PSP_sv: int  # 622
PSP_svl: int  # 623
PSP_svr: int  # 624
PSP_vabs: int  # 636
PSP_vadd: int  # 637
PSP_vasin: int  # 638
PSP_vavg: int  # 639
PSP_vbfy1: int  # 640
PSP_vbfy2: int  # 641
PSP_vc2i: int  # 642
PSP_vcmovf: int  # 643
PSP_vcmovt: int  # 644
PSP_vcmp: int  # 645
PSP_vcos: int  # 646
PSP_vcrs: int  # 647
PSP_vcrsp: int  # 648
PSP_vcst: int  # 649
PSP_vdet: int  # 650
PSP_vdiv: int  # 651
PSP_vdot: int  # 652
PSP_vexp2: int  # 653
PSP_vf2h: int  # 654
PSP_vf2id: int  # 655
PSP_vf2in: int  # 656
PSP_vf2iu: int  # 657
PSP_vf2iz: int  # 658
PSP_vfad: int  # 659
PSP_vfim: int  # 660
PSP_vflush: int  # 634
PSP_vh2f: int  # 661
PSP_vhdp: int  # 662
PSP_vhtfm2: int  # 663
PSP_vhtfm3: int  # 664
PSP_vhtfm4: int  # 665
PSP_vi2c: int  # 666
PSP_vi2f: int  # 667
PSP_vi2s: int  # 668
PSP_vi2uc: int  # 669
PSP_vi2us: int  # 670
PSP_vidt: int  # 671
PSP_viim: int  # 672
PSP_vlgb: int  # 673
PSP_vlog2: int  # 674
PSP_vmax: int  # 675
PSP_vmfvc: int  # 676
PSP_vmidt: int  # 677
PSP_vmin: int  # 678
PSP_vmmov: int  # 679
PSP_vmmul: int  # 680
PSP_vmone: int  # 681
PSP_vmov: int  # 682
PSP_vmscl: int  # 683
PSP_vmtvc: int  # 684
PSP_vmul: int  # 685
PSP_vmzero: int  # 686
PSP_vneg: int  # 687
PSP_vnop: int  # 633
PSP_vnrcp: int  # 688
PSP_vnsin: int  # 689
PSP_vocp: int  # 690
PSP_vone: int  # 691
PSP_vpfxd: int  # 692
PSP_vpfxs: int  # 693
PSP_vpfxt: int  # 694
PSP_vqmul: int  # 695
PSP_vrcp: int  # 696
PSP_vrexp2: int  # 697
PSP_vrndf1: int  # 698
PSP_vrndf2: int  # 699
PSP_vrndi: int  # 700
PSP_vrnds: int  # 701
PSP_vrot: int  # 702
PSP_vrsq: int  # 703
PSP_vs2i: int  # 704
PSP_vsat0: int  # 705
PSP_vsat1: int  # 706
PSP_vsbn: int  # 707
PSP_vsbz: int  # 708
PSP_vscl: int  # 709
PSP_vscmp: int  # 710
PSP_vsge: int  # 711
PSP_vsgn: int  # 712
PSP_vsin: int  # 713
PSP_vslt: int  # 714
PSP_vsocp: int  # 715
PSP_vsqrt: int  # 716
PSP_vsrt1: int  # 717
PSP_vsrt2: int  # 718
PSP_vsrt3: int  # 719
PSP_vsrt4: int  # 720
PSP_vsub: int  # 721
PSP_vsync: int  # 635
PSP_vt4444: int  # 722
PSP_vt5551: int  # 723
PSP_vt5650: int  # 724
PSP_vtfm2: int  # 725
PSP_vtfm3: int  # 726
PSP_vtfm4: int  # 727
PSP_vuc2i: int  # 728
PSP_vus2i: int  # 729
PSP_vwbn: int  # 730
PSP_vzero: int  # 731
PSP_wsbw: int  # 617
PSTF_ATTRIB: int  # 16
PSTF_ENC: int  # 8
PSTF_HOTKEY: int  # 4
PSTF_ONLY_ENC: int  # 11
PSTF_TBRIEF: int  # 1
PSTF_TINLIN: int  # 2
PSTF_TMASK: int  # 3
PSTF_TNORM: int  # 0
PT_EMPTY: int  # 8192
PT_FILE: int  # 65536
PT_HIGH: int  # 128
PT_LOWER: int  # 256
PT_NDC: int  # 2
PT_PACKMASK: int  # 112
PT_RAWARGS: int  # 1024
PT_RELAXED: int  # 4096
PT_REPLACE: int  # 512
PT_SEMICOLON: int  # 16384
PT_SIL: int  # 1
PT_STANDALONE: int  # 4194304
PT_SYMBOL: int  # 32768
PT_TYP: int  # 4
PT_VAR: int  # 8
PY_ICID_BYREF: int  # 1
PY_ICID_INT64: int  # 0
PY_ICID_OPAQUE: int  # 2
QMOVE_CROSS_FS: int  # 1
QMOVE_OVERWRITE: int  # 2
QMOVE_OVR_RO: int  # 4
QWCONTINUED: int  # 8
QWNOHANG: int  # 1
RANGE_KIND_FUNC: int  # 1
RANGE_KIND_HIDDEN_RANGE: int  # 3
RANGE_KIND_SEGMENT: int  # 2
RANGE_KIND_UNKNOWN: int  # 0
READ_ACCESS: int  # 2
REAL_ERROR_BADDATA: int  # -3
REAL_ERROR_BADSTR: int  # 3
REAL_ERROR_FORMAT: int  # -1
REAL_ERROR_FPOVER: int  # 2
REAL_ERROR_INTOVER: int  # 5
REAL_ERROR_OK: int  # 1
REAL_ERROR_RANGE: int  # -2
REAL_ERROR_ZERODIV: int  # 4
REFINFO_CUSTOM: int  # 64
REFINFO_NOBASE: int  # 128
REFINFO_NO_ONES: int  # 2048
REFINFO_NO_ZEROS: int  # 1024
REFINFO_PASTEND: int  # 32
REFINFO_RVAOFF: int  # 16
REFINFO_SELFREF: int  # 4096
REFINFO_SIGNEDOP: int  # 512
REFINFO_SUBTRACT: int  # 256
REFINFO_TYPE: int  # 15
REF_HIGH16: int  # 6
REF_HIGH8: int  # 5
REF_LAST: int  # 10
REF_LOW16: int  # 4
REF_LOW8: int  # 3
REF_OFF16: int  # 1
REF_OFF32: int  # 2
REF_OFF64: int  # 9
REF_OFF8: int  # 10
REGISTER_ADDRESS: int  # 16
REGISTER_CS: int  # 32
REGISTER_CUSTFMT: int  # 256
REGISTER_FP: int  # 8
REGISTER_IP: int  # 2
REGISTER_NOLF: int  # 128
REGISTER_READONLY: int  # 1
REGISTER_SP: int  # 4
REGISTER_SS: int  # 64
REGVAR_ERROR_ARG: int  # -1
REGVAR_ERROR_NAME: int  # -3
REGVAR_ERROR_OK: int  # 0
REGVAR_ERROR_RANGE: int  # -2
REG_HINTS_MARKER: str  # 
REG_HINTS_MARKER_LEN: int  # 2
REG_SPOIL: int  # -2147483648
RENADDR_HR: int  # 1
RENADDR_IDA: int  # 0
RESERVED_BYTE: int  # 255
RESMOD_BACKINTO: int  # 9
RESMOD_HANDLE: int  # 8
RESMOD_INTO: int  # 1
RESMOD_MAX: int  # 10
RESMOD_NONE: int  # 0
RESMOD_OUT: int  # 3
RESMOD_OVER: int  # 2
RESMOD_SRCINTO: int  # 4
RESMOD_SRCOUT: int  # 6
RESMOD_SRCOVER: int  # 5
RESMOD_USER: int  # 7
RETRIEVE_ALWAYS: int  # 1
RETRIEVE_ONCE: int  # 0
RIDX_ABINAME: int  # 1350
RIDX_ARCHIVE_PATH: int  # 1351
RIDX_C_MACROS: int  # 66
RIDX_DBG_BINPATHS: int  # 1328
RIDX_DUALOP_GRAPH: int  # 1300
RIDX_DUALOP_TEXT: int  # 1301
RIDX_FILE_FORMAT_NAME: int  # 1
RIDX_GROUPS: int  # 64
RIDX_H_PATH: int  # 65
RIDX_IDA_VERSION: int  # 1303
RIDX_INCLUDE: int  # 1100
RIDX_MD5: int  # 1302
RIDX_NOTEPAD: int  # 68
RIDX_PROBLEMS: int  # 1352
RIDX_SELECTORS: int  # 2
RIDX_SHA256: int  # 1349
RIDX_SMALL_IDC: int  # 1200
RIDX_SMALL_IDC_OLD: int  # 67
RIDX_SRCDBG_PATHS: int  # 1306
RIDX_SRCDBG_UNDESIRED: int  # 1353
RIDX_STR_ENCODINGS: int  # 1305
RISCV_add: int  # 28
RISCV_addi: int  # 19
RISCV_addiw: int  # 51
RISCV_addw: int  # 55
RISCV_aes: int  # 386
RISCV_aes64im: int  # 387
RISCV_aes64ks1i: int  # 388
RISCV_aes64ks2: int  # 389
RISCV_amoadd: int  # 84
RISCV_amoand: int  # 86
RISCV_amocas: int  # 92
RISCV_amomax: int  # 89
RISCV_amomaxu: int  # 91
RISCV_amomin: int  # 88
RISCV_amominu: int  # 90
RISCV_amoor: int  # 87
RISCV_amoswap: int  # 83
RISCV_amoxor: int  # 85
RISCV_and: int  # 37
RISCV_andi: int  # 24
RISCV_andn: int  # 339
RISCV_auipc: int  # 2
RISCV_bclr: int  # 340
RISCV_bclri: int  # 341
RISCV_beq: int  # 5
RISCV_beqz: int  # 134
RISCV_bext: int  # 342
RISCV_bexti: int  # 343
RISCV_bge: int  # 8
RISCV_bgeu: int  # 10
RISCV_bgez: int  # 137
RISCV_bgtz: int  # 139
RISCV_binv: int  # 344
RISCV_binvi: int  # 345
RISCV_blez: int  # 136
RISCV_blt: int  # 7
RISCV_bltu: int  # 9
RISCV_bltz: int  # 138
RISCV_bne: int  # 6
RISCV_bnez: int  # 135
RISCV_brev8: int  # 390
RISCV_bset: int  # 346
RISCV_bseti: int  # 347
RISCV_call: int  # 163
RISCV_cbo: int  # 383
RISCV_clmul: int  # 348
RISCV_clmulh: int  # 349
RISCV_clmulr: int  # 350
RISCV_clz: int  # 351
RISCV_clzw: int  # 352
RISCV_cpop: int  # 353
RISCV_cpopw: int  # 354
RISCV_csrc: int  # 152
RISCV_csrci: int  # 155
RISCV_csrr: int  # 149
RISCV_csrrc: int  # 64
RISCV_csrrci: int  # 67
RISCV_csrrs: int  # 63
RISCV_csrrsi: int  # 66
RISCV_csrrw: int  # 62
RISCV_csrrwi: int  # 65
RISCV_csrs: int  # 151
RISCV_csrsi: int  # 154
RISCV_csrw: int  # 150
RISCV_csrwi: int  # 153
RISCV_ctz: int  # 355
RISCV_ctzw: int  # 356
RISCV_div: int  # 72
RISCV_divu: int  # 73
RISCV_divuw: int  # 78
RISCV_divw: int  # 77
RISCV_ebreak: int  # 40
RISCV_ecall: int  # 39
RISCV_fabs: int  # 132
RISCV_fadd: int  # 99
RISCV_fclass: int  # 116
RISCV_fcvtf2f: int  # 109
RISCV_fcvtf2i: int  # 110
RISCV_fcvti2f: int  # 111
RISCV_fdiv: int  # 102
RISCV_fence: int  # 38
RISCV_fencei: int  # 61
RISCV_feq: int  # 113
RISCV_fld: int  # 117
RISCV_fle: int  # 115
RISCV_flh: int  # 375
RISCV_flq: int  # 119
RISCV_flt: int  # 114
RISCV_flw: int  # 93
RISCV_fmadd: int  # 95
RISCV_fmax: int  # 108
RISCV_fmin: int  # 107
RISCV_fmsub: int  # 96
RISCV_fmul: int  # 101
RISCV_fmv: int  # 112
RISCV_fneg: int  # 133
RISCV_fnmadd: int  # 98
RISCV_fnmsub: int  # 97
RISCV_frcsr: int  # 156
RISCV_frflags: int  # 160
RISCV_frrm: int  # 158
RISCV_fscsr: int  # 157
RISCV_fsd: int  # 118
RISCV_fsflags: int  # 161
RISCV_fsgnj: int  # 104
RISCV_fsgnjn: int  # 105
RISCV_fsgnjx: int  # 106
RISCV_fsh: int  # 376
RISCV_fsq: int  # 120
RISCV_fsqrt: int  # 103
RISCV_fsrm: int  # 159
RISCV_fsub: int  # 100
RISCV_fsw: int  # 94
RISCV_hfenceb: int  # 46
RISCV_hfenceg: int  # 47
RISCV_hinval: int  # 381
RISCV_hl: int  # 377
RISCV_hs: int  # 378
RISCV_j: int  # 140
RISCV_jal: int  # 3
RISCV_jalr: int  # 4
RISCV_jr: int  # 141
RISCV_jump: int  # 165
RISCV_la: int  # 162
RISCV_last: int  # 528
RISCV_lb: int  # 11
RISCV_lbu: int  # 14
RISCV_ld: int  # 49
RISCV_lh: int  # 12
RISCV_lhu: int  # 15
RISCV_li: int  # 122
RISCV_lr: int  # 81
RISCV_lui: int  # 1
RISCV_lw: int  # 13
RISCV_lwu: int  # 48
RISCV_max: int  # 357
RISCV_maxu: int  # 358
RISCV_min: int  # 359
RISCV_minu: int  # 360
RISCV_mret: int  # 43
RISCV_mul: int  # 68
RISCV_mulh: int  # 69
RISCV_mulhsu: int  # 70
RISCV_mulhu: int  # 71
RISCV_mulw: int  # 76
RISCV_mv: int  # 123
RISCV_neg: int  # 125
RISCV_negw: int  # 126
RISCV_nop: int  # 121
RISCV_not: int  # 124
RISCV_null: int  # 0
RISCV_or: int  # 36
RISCV_orc: int  # 361
RISCV_ori: int  # 23
RISCV_orn: int  # 362
RISCV_pack: int  # 391
RISCV_packh: int  # 392
RISCV_packw: int  # 393
RISCV_pause: int  # 382
RISCV_prefetch: int  # 384
RISCV_rdcycle: int  # 144
RISCV_rdcycleh: int  # 147
RISCV_rdinstret: int  # 143
RISCV_rdinstreth: int  # 146
RISCV_rdtime: int  # 145
RISCV_rdtimeh: int  # 148
RISCV_rem: int  # 74
RISCV_remu: int  # 75
RISCV_remuw: int  # 80
RISCV_remw: int  # 79
RISCV_ret: int  # 142
RISCV_rev8: int  # 363
RISCV_rol: int  # 364
RISCV_rolw: int  # 365
RISCV_ror: int  # 366
RISCV_rori: int  # 367
RISCV_roriw: int  # 368
RISCV_rorw: int  # 369
RISCV_sb: int  # 16
RISCV_sc: int  # 82
RISCV_sd: int  # 50
RISCV_seqz: int  # 128
RISCV_sext: int  # 127
RISCV_sfence: int  # 45
RISCV_sfencefg: int  # 380
RISCV_sfencevm: int  # 385
RISCV_sgtz: int  # 131
RISCV_sh: int  # 17
RISCV_sh1add: int  # 370
RISCV_sh2add: int  # 371
RISCV_sh3add: int  # 372
RISCV_sha256: int  # 394
RISCV_sha512: int  # 395
RISCV_sinval: int  # 379
RISCV_sll: int  # 30
RISCV_slli: int  # 25
RISCV_slliw: int  # 52
RISCV_sllw: int  # 57
RISCV_slt: int  # 31
RISCV_slti: int  # 20
RISCV_sltiu: int  # 21
RISCV_sltu: int  # 32
RISCV_sltw: int  # 58
RISCV_sltz: int  # 130
RISCV_sm3: int  # 396
RISCV_sm4: int  # 397
RISCV_snez: int  # 129
RISCV_sra: int  # 35
RISCV_srai: int  # 27
RISCV_sraiw: int  # 54
RISCV_sraw: int  # 60
RISCV_sret: int  # 42
RISCV_srl: int  # 34
RISCV_srli: int  # 26
RISCV_srliw: int  # 53
RISCV_srlw: int  # 59
RISCV_sub: int  # 29
RISCV_subw: int  # 56
RISCV_sw: int  # 18
RISCV_tail: int  # 164
RISCV_thaddsl: int  # 430
RISCV_thandn: int  # 509
RISCV_thdcachecall: int  # 404
RISCV_thdcacheciall: int  # 405
RISCV_thdcachecipa: int  # 408
RISCV_thdcachecisw: int  # 414
RISCV_thdcacheciva: int  # 411
RISCV_thdcachecpa: int  # 407
RISCV_thdcachecpal1: int  # 416
RISCV_thdcachecsw: int  # 413
RISCV_thdcachecva: int  # 410
RISCV_thdcachecval1: int  # 417
RISCV_thdcacheiall: int  # 406
RISCV_thdcacheipa: int  # 409
RISCV_thdcacheisw: int  # 415
RISCV_thdcacheiva: int  # 412
RISCV_thext: int  # 433
RISCV_thextu: int  # 434
RISCV_thff0: int  # 435
RISCV_thff1: int  # 436
RISCV_thflrd: int  # 492
RISCV_thflrw: int  # 493
RISCV_thflurd: int  # 494
RISCV_thflurw: int  # 495
RISCV_thfmv: int  # 506
RISCV_thfsrd: int  # 496
RISCV_thfsrw: int  # 497
RISCV_thfsurd: int  # 498
RISCV_thfsurw: int  # 499
RISCV_thicacheiall: int  # 418
RISCV_thicacheialls: int  # 419
RISCV_thicacheipa: int  # 420
RISCV_thicacheiva: int  # 421
RISCV_thipop: int  # 508
RISCV_thipush: int  # 507
RISCV_thl2cachecall: int  # 422
RISCV_thl2cacheciall: int  # 423
RISCV_thl2cacheiall: int  # 424
RISCV_thlbia: int  # 443
RISCV_thlbib: int  # 444
RISCV_thlbuia: int  # 445
RISCV_thlbuib: int  # 446
RISCV_thldd: int  # 487
RISCV_thldia: int  # 455
RISCV_thldib: int  # 456
RISCV_thlhia: int  # 447
RISCV_thlhib: int  # 448
RISCV_thlhuia: int  # 449
RISCV_thlhuib: int  # 450
RISCV_thlrb: int  # 465
RISCV_thlrbu: int  # 466
RISCV_thlrd: int  # 471
RISCV_thlrh: int  # 467
RISCV_thlrhu: int  # 468
RISCV_thlrw: int  # 469
RISCV_thlrwu: int  # 470
RISCV_thlurb: int  # 476
RISCV_thlurbu: int  # 477
RISCV_thlurd: int  # 482
RISCV_thlurh: int  # 478
RISCV_thlurhu: int  # 479
RISCV_thlurw: int  # 480
RISCV_thlurwu: int  # 481
RISCV_thlwd: int  # 488
RISCV_thlwia: int  # 451
RISCV_thlwib: int  # 452
RISCV_thlwud: int  # 489
RISCV_thlwuia: int  # 453
RISCV_thlwuib: int  # 454
RISCV_thmula: int  # 500
RISCV_thmulah: int  # 501
RISCV_thmulaw: int  # 502
RISCV_thmuls: int  # 503
RISCV_thmulsh: int  # 504
RISCV_thmulsw: int  # 505
RISCV_thmveqz: int  # 441
RISCV_thmvnez: int  # 442
RISCV_thorn: int  # 510
RISCV_thpackh: int  # 513
RISCV_thpackhl: int  # 514
RISCV_thpackl: int  # 512
RISCV_threv: int  # 437
RISCV_threvw: int  # 438
RISCV_thsbia: int  # 457
RISCV_thsbib: int  # 458
RISCV_thsdd: int  # 490
RISCV_thsdia: int  # 463
RISCV_thsdib: int  # 464
RISCV_thsfencevmas: int  # 425
RISCV_thshia: int  # 459
RISCV_thshib: int  # 460
RISCV_thsrb: int  # 472
RISCV_thsrd: int  # 475
RISCV_thsrh: int  # 473
RISCV_thsrri: int  # 431
RISCV_thsrriw: int  # 432
RISCV_thsrw: int  # 474
RISCV_thsurb: int  # 483
RISCV_thsurd: int  # 486
RISCV_thsurh: int  # 484
RISCV_thsurw: int  # 485
RISCV_thswd: int  # 491
RISCV_thswia: int  # 461
RISCV_thswib: int  # 462
RISCV_thsync: int  # 426
RISCV_thsynci: int  # 428
RISCV_thsyncis: int  # 429
RISCV_thsyncs: int  # 427
RISCV_thtst: int  # 440
RISCV_thtstnbz: int  # 439
RISCV_thvmaqa: int  # 515
RISCV_thvmaqasu: int  # 517
RISCV_thvmaqau: int  # 516
RISCV_thvmaqaus: int  # 518
RISCV_thvpmaqa: int  # 519
RISCV_thvpmaqasu: int  # 522
RISCV_thvpmaqau: int  # 520
RISCV_thvpmaqaus: int  # 521
RISCV_thvpnclip: int  # 523
RISCV_thvpnclipu: int  # 524
RISCV_thvpwadd: int  # 525
RISCV_thvpwaddu: int  # 526
RISCV_thxorn: int  # 511
RISCV_unk: int  # 527
RISCV_unzip: int  # 398
RISCV_uret: int  # 41
RISCV_vaadd: int  # 225
RISCV_vaaddu: int  # 224
RISCV_vadc: int  # 185
RISCV_vadd: int  # 171
RISCV_vand: int  # 178
RISCV_vasub: int  # 227
RISCV_vasubu: int  # 226
RISCV_vcompress: int  # 240
RISCV_vcpop: int  # 230
RISCV_vdiv: int  # 250
RISCV_vdivu: int  # 249
RISCV_vfabs: int  # 334
RISCV_vfadd: int  # 276
RISCV_vfclass: int  # 296
RISCV_vfcvt: int  # 290
RISCV_vfdiv: int  # 305
RISCV_vfirst: int  # 231
RISCV_vfmacc: int  # 313
RISCV_vfmadd: int  # 309
RISCV_vfmax: int  # 282
RISCV_vfmerge: int  # 297
RISCV_vfmin: int  # 280
RISCV_vfmov: int  # 289
RISCV_vfmsac: int  # 315
RISCV_vfmsub: int  # 311
RISCV_vfmul: int  # 307
RISCV_vfmv: int  # 298
RISCV_vfncvt: int  # 292
RISCV_vfneg: int  # 333
RISCV_vfnmacc: int  # 314
RISCV_vfnmadd: int  # 310
RISCV_vfnmsac: int  # 316
RISCV_vfnmsub: int  # 312
RISCV_vfrdiv: int  # 306
RISCV_vfrec7: int  # 295
RISCV_vfredmax: int  # 283
RISCV_vfredmin: int  # 281
RISCV_vfredosum: int  # 279
RISCV_vfredusum: int  # 277
RISCV_vfrsqrt7: int  # 294
RISCV_vfrsub: int  # 308
RISCV_vfsgnj: int  # 284
RISCV_vfsgnjn: int  # 285
RISCV_vfsgnjx: int  # 286
RISCV_vfslide1down: int  # 288
RISCV_vfslide1up: int  # 287
RISCV_vfsqrt: int  # 293
RISCV_vfsub: int  # 278
RISCV_vfwadd: int  # 317
RISCV_vfwaddw: int  # 321
RISCV_vfwcvt: int  # 291
RISCV_vfwmacc: int  # 324
RISCV_vfwmsac: int  # 326
RISCV_vfwmul: int  # 323
RISCV_vfwnmacc: int  # 325
RISCV_vfwnmsac: int  # 327
RISCV_vfwredosum: int  # 320
RISCV_vfwredusum: int  # 318
RISCV_vfwsub: int  # 319
RISCV_vfwsubw: int  # 322
RISCV_vid: int  # 239
RISCV_viota: int  # 238
RISCV_vl: int  # 169
RISCV_vmacc: int  # 259
RISCV_vmadc: int  # 186
RISCV_vmadd: int  # 257
RISCV_vmand: int  # 242
RISCV_vmandn: int  # 241
RISCV_vmax: int  # 177
RISCV_vmaxu: int  # 176
RISCV_vmclr: int  # 336
RISCV_vmerge: int  # 189
RISCV_vmfeq: int  # 299
RISCV_vmfge: int  # 304
RISCV_vmfgt: int  # 303
RISCV_vmfle: int  # 300
RISCV_vmflt: int  # 301
RISCV_vmfne: int  # 302
RISCV_vmin: int  # 175
RISCV_vminu: int  # 174
RISCV_vmmv: int  # 335
RISCV_vmnand: int  # 246
RISCV_vmnor: int  # 247
RISCV_vmnot: int  # 338
RISCV_vmor: int  # 243
RISCV_vmorn: int  # 245
RISCV_vmsbc: int  # 188
RISCV_vmsbf: int  # 235
RISCV_vmseq: int  # 191
RISCV_vmset: int  # 337
RISCV_vmsgt: int  # 198
RISCV_vmsgtu: int  # 197
RISCV_vmsif: int  # 237
RISCV_vmsle: int  # 196
RISCV_vmsleu: int  # 195
RISCV_vmslt: int  # 194
RISCV_vmsltu: int  # 193
RISCV_vmsne: int  # 192
RISCV_vmsof: int  # 236
RISCV_vmul: int  # 254
RISCV_vmulh: int  # 256
RISCV_vmulhsu: int  # 255
RISCV_vmulhu: int  # 253
RISCV_vmv: int  # 190
RISCV_vmvi: int  # 232
RISCV_vmvr: int  # 205
RISCV_vmxnor: int  # 248
RISCV_vmxor: int  # 244
RISCV_vnclip: int  # 213
RISCV_vnclipu: int  # 212
RISCV_vncvt: int  # 332
RISCV_vneg: int  # 328
RISCV_vnmsac: int  # 260
RISCV_vnmsub: int  # 258
RISCV_vnot: int  # 331
RISCV_vnsra: int  # 211
RISCV_vnsrl: int  # 210
RISCV_vor: int  # 179
RISCV_vredand: int  # 217
RISCV_vredmax: int  # 223
RISCV_vredmaxu: int  # 222
RISCV_vredmin: int  # 221
RISCV_vredminu: int  # 220
RISCV_vredor: int  # 218
RISCV_vredsum: int  # 216
RISCV_vredxor: int  # 219
RISCV_vrem: int  # 252
RISCV_vremu: int  # 251
RISCV_vrgather: int  # 181
RISCV_vrgatherei16: int  # 183
RISCV_vrsub: int  # 173
RISCV_vs: int  # 170
RISCV_vsadd: int  # 200
RISCV_vsaddu: int  # 199
RISCV_vsbc: int  # 187
RISCV_vsetivli: int  # 168
RISCV_vsetvl: int  # 166
RISCV_vsetvli: int  # 167
RISCV_vsext: int  # 234
RISCV_vslide1down: int  # 229
RISCV_vslide1up: int  # 228
RISCV_vslidedown: int  # 184
RISCV_vslideup: int  # 182
RISCV_vsll: int  # 203
RISCV_vsmul: int  # 204
RISCV_vsra: int  # 207
RISCV_vsrl: int  # 206
RISCV_vssra: int  # 209
RISCV_vssrl: int  # 208
RISCV_vssub: int  # 202
RISCV_vssubu: int  # 201
RISCV_vsub: int  # 172
RISCV_vwadd: int  # 262
RISCV_vwaddu: int  # 261
RISCV_vwadduw: int  # 265
RISCV_vwaddw: int  # 266
RISCV_vwcvt: int  # 329
RISCV_vwcvtu: int  # 330
RISCV_vwmacc: int  # 273
RISCV_vwmaccsu: int  # 275
RISCV_vwmaccu: int  # 272
RISCV_vwmaccus: int  # 274
RISCV_vwmul: int  # 271
RISCV_vwmulsu: int  # 270
RISCV_vwmulu: int  # 269
RISCV_vwredsum: int  # 215
RISCV_vwredsumu: int  # 214
RISCV_vwsub: int  # 264
RISCV_vwsubu: int  # 263
RISCV_vwsubuw: int  # 267
RISCV_vwsubw: int  # 268
RISCV_vxor: int  # 180
RISCV_vzext: int  # 233
RISCV_wfi: int  # 44
RISCV_wrsnto: int  # 402
RISCV_wrssto: int  # 403
RISCV_xnor: int  # 373
RISCV_xor: int  # 33
RISCV_xori: int  # 22
RISCV_xperm4: int  # 399
RISCV_xperm8: int  # 400
RISCV_zext: int  # 374
RISCV_zip: int  # 401
RL78_add: int  # 49
RL78_addc: int  # 50
RL78_addw: int  # 5
RL78_and: int  # 14
RL78_and1: int  # 27
RL78_bc: int  # 45
RL78_bf: int  # 38
RL78_bh: int  # 47
RL78_bnc: int  # 46
RL78_bnh: int  # 48
RL78_bnz: int  # 12
RL78_br: int  # 16
RL78_brk: int  # 68
RL78_bt: int  # 37
RL78_btclr: int  # 36
RL78_bz: int  # 21
RL78_call: int  # 3
RL78_callt: int  # 73
RL78_clr1: int  # 29
RL78_clrb: int  # 13
RL78_clrw: int  # 4
RL78_cmp: int  # 18
RL78_cmp0: int  # 61
RL78_cmps: int  # 58
RL78_cmpw: int  # 11
RL78_dec: int  # 55
RL78_decw: int  # 19
RL78_divhu: int  # 76
RL78_divwu: int  # 77
RL78_halt: int  # 60
RL78_inc: int  # 20
RL78_incw: int  # 10
RL78_last: int  # 80
RL78_mach: int  # 79
RL78_machu: int  # 78
RL78_mov: int  # 35
RL78_mov1: int  # 28
RL78_movs: int  # 59
RL78_movw: int  # 2
RL78_mulh: int  # 75
RL78_mulhu: int  # 74
RL78_mulu: int  # 62
RL78_nop: int  # 72
RL78_not1: int  # 31
RL78_null: int  # 0
RL78_oneb: int  # 63
RL78_onew: int  # 9
RL78_or: int  # 15
RL78_or1: int  # 26
RL78_pop: int  # 17
RL78_push: int  # 8
RL78_ret: int  # 6
RL78_retb: int  # 69
RL78_reti: int  # 70
RL78_rol: int  # 65
RL78_rolc: int  # 67
RL78_rolwc: int  # 56
RL78_ror: int  # 64
RL78_rorc: int  # 66
RL78_sar: int  # 41
RL78_sarw: int  # 44
RL78_sel: int  # 7
RL78_set1: int  # 30
RL78_shl: int  # 39
RL78_shlw: int  # 42
RL78_shr: int  # 40
RL78_shrw: int  # 43
RL78_skc: int  # 32
RL78_skh: int  # 24
RL78_sknc: int  # 33
RL78_sknh: int  # 23
RL78_sknz: int  # 22
RL78_skz: int  # 34
RL78_stop: int  # 71
RL78_sub: int  # 51
RL78_subc: int  # 52
RL78_subw: int  # 1
RL78_xch: int  # 54
RL78_xchw: int  # 57
RL78_xor: int  # 53
RL78_xor1: int  # 25
ROLE_3WAYCMP0: int  # 32
ROLE_3WAYCMP1: int  # 33
ROLE_ABS: int  # 31
ROLE_ALLOCA: int  # 11
ROLE_BITTEST: int  # 19
ROLE_BITTESTANDCOMPLEMENT: int  # 22
ROLE_BITTESTANDRESET: int  # 21
ROLE_BITTESTANDSET: int  # 20
ROLE_BSWAP: int  # 12
ROLE_BUG: int  # 10
ROLE_CFSUB3: int  # 29
ROLE_CONTAINING_RECORD: int  # 14
ROLE_EMPTY: int  # 1
ROLE_FASTFAIL: int  # 15
ROLE_IS_MUL_OK: int  # 17
ROLE_MEMCPY: int  # 5
ROLE_MEMSET: int  # 2
ROLE_MEMSET32: int  # 3
ROLE_MEMSET64: int  # 4
ROLE_OFSUB3: int  # 30
ROLE_PRESENT: int  # 13
ROLE_READFLAGS: int  # 16
ROLE_ROL: int  # 27
ROLE_ROR: int  # 28
ROLE_SATURATED_MUL: int  # 18
ROLE_SSE_CMP4: int  # 39
ROLE_SSE_CMP8: int  # 40
ROLE_STRCAT: int  # 8
ROLE_STRCPY: int  # 6
ROLE_STRLEN: int  # 7
ROLE_TAIL: int  # 9
ROLE_UNK: int  # 0
ROLE_VA_ARG: int  # 23
ROLE_VA_COPY: int  # 24
ROLE_VA_END: int  # 26
ROLE_VA_START: int  # 25
ROLE_WCSCAT: int  # 38
ROLE_WCSCPY: int  # 36
ROLE_WCSLEN: int  # 37
ROLE_WMEMCPY: int  # 34
ROLE_WMEMSET: int  # 35
ROOT_KEY_NAME: str  # Software\Hex-Rays\IDA
RQ_IDAIDLE: int  # 128
RQ_IGNWERR: int  # 4
RQ_MASKING: int  # 1
RQ_NOSUSP: int  # 0
RQ_PROCEXIT: int  # 64
RQ_RESMOD: int  # 61440
RQ_RESMOD_SHIFT: int  # 12
RQ_RESUME: int  # 512
RQ_SILENT: int  # 8
RQ_SUSPEND: int  # 2
RQ_SUSPRUN: int  # 256
RQ_SWSCREEN: int  # 16
RQ_VERBOSE: int  # 0
RQ__NOTHRRF: int  # 32
RVT_FLOAT: int  # -1
RVT_INT: int  # -2
RVT_UNAVAILABLE: int  # -3
RW_ACCESS: int  # 3
RX_abs: int  # 1
RX_adc: int  # 2
RX_add: int  # 3
RX_and: int  # 4
RX_bclr: int  # 7
RX_beq: int  # 10
RX_bfmov: int  # 8
RX_bfmovz: int  # 9
RX_bge: int  # 18
RX_bgeu: int  # 12
RX_bgt: int  # 20
RX_bgtu: int  # 14
RX_ble: int  # 21
RX_bleu: int  # 15
RX_blt: int  # 19
RX_bltu: int  # 13
RX_bmeq: int  # 24
RX_bmge: int  # 32
RX_bmgeu: int  # 26
RX_bmgt: int  # 34
RX_bmgtu: int  # 28
RX_bmle: int  # 35
RX_bmleu: int  # 29
RX_bmlt: int  # 33
RX_bmltu: int  # 27
RX_bmn: int  # 31
RX_bmne: int  # 25
RX_bmno: int  # 37
RX_bmo: int  # 36
RX_bmpz: int  # 30
RX_bn: int  # 17
RX_bne: int  # 11
RX_bno: int  # 23
RX_bnot: int  # 38
RX_bo: int  # 22
RX_bpz: int  # 16
RX_bra: int  # 5
RX_brk: int  # 6
RX_bset: int  # 39
RX_bsr: int  # 40
RX_btst: int  # 41
RX_clrpsw: int  # 42
RX_cmp: int  # 43
RX_dabs: int  # 153
RX_dadd: int  # 154
RX_dcmpeq: int  # 156
RX_dcmple: int  # 158
RX_dcmplt: int  # 157
RX_dcmpun: int  # 155
RX_ddiv: int  # 159
RX_div: int  # 44
RX_divu: int  # 45
RX_dmov: int  # 160
RX_dmul: int  # 161
RX_dneg: int  # 162
RX_dpopm: int  # 163
RX_dpushm: int  # 164
RX_dround: int  # 165
RX_dsqrt: int  # 166
RX_dsub: int  # 167
RX_dtof: int  # 168
RX_dtoi: int  # 169
RX_dtou: int  # 170
RX_emaca: int  # 46
RX_emsba: int  # 47
RX_emul: int  # 49
RX_emula: int  # 48
RX_emulu: int  # 50
RX_fadd: int  # 51
RX_fcmp: int  # 52
RX_fdiv: int  # 53
RX_fmul: int  # 54
RX_fsqrt: int  # 55
RX_fsub: int  # 56
RX_ftod: int  # 171
RX_ftoi: int  # 57
RX_ftou: int  # 58
RX_int: int  # 59
RX_itod: int  # 172
RX_itof: int  # 60
RX_jmp: int  # 61
RX_jsr: int  # 62
RX_last: int  # 177
RX_machi: int  # 63
RX_maclh: int  # 65
RX_maclo: int  # 64
RX_max: int  # 66
RX_min: int  # 67
RX_mov: int  # 68
RX_movco: int  # 69
RX_movli: int  # 70
RX_movu: int  # 71
RX_msbhi: int  # 72
RX_msblh: int  # 74
RX_msblo: int  # 73
RX_mul: int  # 75
RX_mulhi: int  # 76
RX_mullh: int  # 78
RX_mullo: int  # 77
RX_mvfacgu: int  # 82
RX_mvfachi: int  # 79
RX_mvfaclo: int  # 80
RX_mvfacmi: int  # 81
RX_mvfc: int  # 83
RX_mvfdc: int  # 173
RX_mvfdr: int  # 174
RX_mvtacgu: int  # 84
RX_mvtachi: int  # 85
RX_mvtaclo: int  # 86
RX_mvtc: int  # 87
RX_mvtdc: int  # 175
RX_mvtipl: int  # 88
RX_neg: int  # 89
RX_nop: int  # 90
RX_not: int  # 91
RX_null: int  # 0
RX_or: int  # 92
RX_pop: int  # 93
RX_popc: int  # 94
RX_popm: int  # 95
RX_push: int  # 96
RX_pushc: int  # 97
RX_pushm: int  # 98
RX_racl: int  # 99
RX_racw: int  # 101
RX_rdacl: int  # 100
RX_rdacw: int  # 102
RX_revl: int  # 103
RX_revw: int  # 104
RX_rmpa: int  # 105
RX_rolc: int  # 106
RX_rorc: int  # 107
RX_rotl: int  # 108
RX_rotr: int  # 109
RX_round: int  # 110
RX_rstr: int  # 111
RX_rte: int  # 112
RX_rtfi: int  # 113
RX_rts: int  # 114
RX_rtsd: int  # 115
RX_sat: int  # 116
RX_satr: int  # 117
RX_save: int  # 118
RX_sbb: int  # 119
RX_sceq: int  # 120
RX_scge: int  # 128
RX_scgeu: int  # 122
RX_scgt: int  # 130
RX_scgtu: int  # 124
RX_scle: int  # 131
RX_scleu: int  # 125
RX_sclt: int  # 129
RX_scltu: int  # 123
RX_scmpu: int  # 134
RX_scn: int  # 127
RX_scne: int  # 121
RX_scno: int  # 133
RX_sco: int  # 132
RX_scpz: int  # 126
RX_setpsw: int  # 135
RX_shar: int  # 136
RX_shll: int  # 137
RX_shlr: int  # 138
RX_smovb: int  # 139
RX_smovf: int  # 140
RX_smovu: int  # 141
RX_sstr: int  # 142
RX_stnz: int  # 143
RX_stz: int  # 144
RX_sub: int  # 145
RX_suntil: int  # 146
RX_swhile: int  # 147
RX_tst: int  # 148
RX_utod: int  # 176
RX_utof: int  # 149
RX_wait: int  # 150
RX_xchg: int  # 151
RX_xor: int  # 152
R_cs: int  # 30
R_ds: int  # 32
R_es: int  # 29
R_fs: int  # 33
R_gs: int  # 34
R_ss: int  # 31
S2EAOPT_NOCALC: int  # 1
SAVE_ALL_VALUES: int  # 0
SAVE_DIFF: int  # 1
SAVE_NONE: int  # 2
SCF_ALLCMT: int  # 2
SCF_LINNUM: int  # 8
SCF_NOCMT: int  # 4
SCF_RPTCMT: int  # 1
SCF_SHHID_FUNC: int  # 64
SCF_SHHID_ITEM: int  # 32
SCF_SHHID_SEGM: int  # 128
SCF_TESTMODE: int  # 16
SCOLOR_ADDR: str  # (
SCOLOR_ALTOP: str  # 
SCOLOR_ASMDIR: str  # 
SCOLOR_AUTOCMT: str  # 
SCOLOR_BINPREF: str  # 
SCOLOR_CHAR: str  # 

SCOLOR_CNAME: str  # %
SCOLOR_CODNAME: str  # 
SCOLOR_COLLAPSED: str  # '
SCOLOR_CREF: str  # 
SCOLOR_CREFTAIL: str  # 
SCOLOR_DATNAME: str  # 
SCOLOR_DCHAR: str  # 
SCOLOR_DEFAULT: str  # 
SCOLOR_DEMNAME: str  # 
SCOLOR_DNAME: str  # 
SCOLOR_DNUM: str  # 
SCOLOR_DREF: str  # 
SCOLOR_DREFTAIL: str  # 
SCOLOR_DSTR: str  # 
SCOLOR_ERROR: str  # 
SCOLOR_ESC: str  # 
SCOLOR_EXTRA: str  # 
SCOLOR_FG_MAX: str  # (
SCOLOR_HIDNAME: str  # 
SCOLOR_IMPNAME: str  # "
SCOLOR_INSN: str  # 
SCOLOR_INV: str  # 
SCOLOR_KEYWORD: str  #  
SCOLOR_LIBNAME: str  # 
SCOLOR_LOCNAME: str  # 
SCOLOR_MACRO: str  # 
SCOLOR_NUMBER: str  # 
SCOLOR_OFF: str  # 
SCOLOR_ON: str  # 
SCOLOR_OPND1: str  # )
SCOLOR_OPND2: str  # *
SCOLOR_OPND3: str  # +
SCOLOR_OPND4: str  # ,
SCOLOR_OPND5: str  # -
SCOLOR_OPND6: str  # .
SCOLOR_PREFIX: str  # 
SCOLOR_REG: str  # !
SCOLOR_REGCMT: str  # 
SCOLOR_RPTCMT: str  # 
SCOLOR_SEGNAME: str  # #
SCOLOR_STRING: str  # 
SCOLOR_SYMBOL: str  # 	
SCOLOR_UNAME: str  # &
SCOLOR_UNKNAME: str  # $
SCOLOR_UTF8: str  # 2
SCOLOR_VOIDOP: str  # 
SC_AUTO: int  # 5
SC_EXT: int  # 2
SC_FRIEND: int  # 6
SC_REG: int  # 4
SC_STAT: int  # 3
SC_TYPE: int  # 1
SC_UNK: int  # 0
SC_VIRT: int  # 7
SEARCH_BRK: int  # 256
SEARCH_CASE: int  # 4
SEARCH_DEF: int  # 1024
SEARCH_DOWN: int  # 1
SEARCH_IDENT: int  # 128
SEARCH_NEXT: int  # 2
SEARCH_NOBRK: int  # 16
SEARCH_NOSHOW: int  # 32
SEARCH_REGEX: int  # 8
SEARCH_UP: int  # 0
SEARCH_USE: int  # 512
SEARCH_USESEL: int  # 2048
SEEK_CUR: int  # 1
SEEK_END: int  # 2
SEEK_SET: int  # 0
SEGMOD_KEEP: int  # 2
SEGMOD_KEEP0: int  # 8
SEGMOD_KEEPSEL: int  # 16
SEGMOD_KILL: int  # 1
SEGMOD_NOMOVE: int  # 32
SEGMOD_SILENT: int  # 4
SEGMOD_SPARSE: int  # 64
SEGPERM_EXEC: int  # 1
SEGPERM_MAXVAL: int  # 7
SEGPERM_READ: int  # 4
SEGPERM_WRITE: int  # 2
SEG_ABSSYM: int  # 10
SEG_BSS: int  # 9
SEG_CODE: int  # 2
SEG_COMM: int  # 11
SEG_DATA: int  # 3
SEG_GRP: int  # 6
SEG_IMEM: int  # 12
SEG_IMP: int  # 4
SEG_MAX_BITNESS_CODE: int  # 2
SEG_MAX_SEGTYPE_CODE: int  # 12
SEG_NORM: int  # 0
SEG_NULL: int  # 7
SEG_UNDF: int  # 8
SEG_XTRN: int  # 1
SETCOMP_BY_USER: int  # 8
SETCOMP_ONLY_ABI: int  # 4
SETCOMP_ONLY_ID: int  # 2
SETCOMP_OVERRIDE: int  # 1
SETMENU_APP: int  # 1
SETMENU_ENSURE_SEP: int  # 8
SETMENU_FIRST: int  # 2
SETMENU_IF_ENABLED: int  # 4
SETMENU_INS: int  # 0
SETMENU_POSMASK: int  # 3
SETPROC_IDB: int  # 0
SETPROC_LOADER: int  # 1
SETPROC_LOADER_NON_FATAL: int  # 2
SETPROC_USER: int  # 3
SFL_COMORG: int  # 1
SFL_DEBUG: int  # 8
SFL_HEADER: int  # 64
SFL_HIDDEN: int  # 4
SFL_HIDETYPE: int  # 32
SFL_LOADER: int  # 16
SFL_OBOK: int  # 2
SH2a_band_b: int  # 137
SH2a_bandnot_b: int  # 138
SH2a_bclr: int  # 139
SH2a_bclr_b: int  # 140
SH2a_bld: int  # 141
SH2a_bld_b: int  # 142
SH2a_bldnot_b: int  # 143
SH2a_bor_b: int  # 144
SH2a_bornot_b: int  # 145
SH2a_bset: int  # 146
SH2a_bset_b: int  # 147
SH2a_bst: int  # 148
SH2a_bst_b: int  # 149
SH2a_bxor_b: int  # 150
SH2a_clips_b: int  # 151
SH2a_clips_w: int  # 152
SH2a_clipu_b: int  # 153
SH2a_clipu_w: int  # 154
SH2a_divs: int  # 155
SH2a_divu: int  # 156
SH2a_jsr_n: int  # 157
SH2a_ldbank: int  # 158
SH2a_movi20: int  # 159
SH2a_movi20s: int  # 160
SH2a_movml_l: int  # 161
SH2a_movmu_l: int  # 162
SH2a_movrt: int  # 163
SH2a_movu_b: int  # 164
SH2a_movu_w: int  # 165
SH2a_mulr: int  # 166
SH2a_nott: int  # 167
SH2a_resbank: int  # 168
SH2a_rts_n: int  # 169
SH2a_rtv_n: int  # 170
SH2a_stbank: int  # 171
SH3_add: int  # 1
SH3_addc: int  # 2
SH3_addv: int  # 3
SH3_and: int  # 4
SH3_and_b: int  # 5
SH3_bf: int  # 6
SH3_bf_s: int  # 7
SH3_bra: int  # 8
SH3_braf: int  # 9
SH3_bsr: int  # 10
SH3_bsrf: int  # 11
SH3_bt: int  # 12
SH3_bt_s: int  # 13
SH3_clrmac: int  # 14
SH3_clrs: int  # 15
SH3_clrt: int  # 16
SH3_cmp_eq: int  # 17
SH3_cmp_ge: int  # 18
SH3_cmp_gt: int  # 19
SH3_cmp_hi: int  # 20
SH3_cmp_hs: int  # 21
SH3_cmp_pl: int  # 22
SH3_cmp_pz: int  # 23
SH3_cmp_str: int  # 24
SH3_div0s: int  # 25
SH3_div0u: int  # 26
SH3_div1: int  # 27
SH3_dmuls_l: int  # 28
SH3_dmulu_l: int  # 29
SH3_dt: int  # 30
SH3_exts_b: int  # 31
SH3_exts_w: int  # 32
SH3_extu_b: int  # 33
SH3_extu_w: int  # 34
SH3_jmp: int  # 35
SH3_jsr: int  # 36
SH3_ldc: int  # 37
SH3_ldc_l: int  # 38
SH3_lds: int  # 39
SH3_lds_l: int  # 40
SH3_ldtlb: int  # 41
SH3_mac_l: int  # 43
SH3_mac_w: int  # 42
SH3_mov: int  # 44
SH3_mov_b: int  # 45
SH3_mov_l: int  # 47
SH3_mov_w: int  # 46
SH3_mova: int  # 57
SH3_movi: int  # 48
SH3_movi_l: int  # 50
SH3_movi_w: int  # 49
SH3_movp_b: int  # 51
SH3_movp_l: int  # 53
SH3_movp_w: int  # 52
SH3_movs_b: int  # 54
SH3_movs_l: int  # 56
SH3_movs_w: int  # 55
SH3_movt: int  # 58
SH3_mul: int  # 59
SH3_muls: int  # 60
SH3_mulu: int  # 61
SH3_neg: int  # 62
SH3_negc: int  # 63
SH3_nop: int  # 64
SH3_not: int  # 65
SH3_null: int  # 0
SH3_or: int  # 66
SH3_or_b: int  # 67
SH3_pref: int  # 68
SH3_rotcl: int  # 69
SH3_rotcr: int  # 70
SH3_rotl: int  # 71
SH3_rotr: int  # 72
SH3_rte: int  # 73
SH3_rts: int  # 74
SH3_sets: int  # 75
SH3_sett: int  # 76
SH3_shad: int  # 77
SH3_shal: int  # 78
SH3_shar: int  # 79
SH3_shld: int  # 80
SH3_shll: int  # 81
SH3_shll16: int  # 84
SH3_shll2: int  # 82
SH3_shll8: int  # 83
SH3_shlr: int  # 85
SH3_shlr16: int  # 88
SH3_shlr2: int  # 86
SH3_shlr8: int  # 87
SH3_sleep: int  # 89
SH3_stc: int  # 90
SH3_stc_l: int  # 91
SH3_sts: int  # 92
SH3_sts_l: int  # 93
SH3_sub: int  # 94
SH3_subc: int  # 95
SH3_subv: int  # 96
SH3_swap_b: int  # 97
SH3_swap_w: int  # 98
SH3_tas_b: int  # 99
SH3_trapa: int  # 100
SH3_tst: int  # 101
SH3_tst_b: int  # 102
SH3_xor: int  # 103
SH3_xor_b: int  # 104
SH3_xtrct: int  # 105
SH4_fabs: int  # 106
SH4_fadd: int  # 107
SH4_fcmp_eq: int  # 108
SH4_fcmp_gt: int  # 109
SH4_fcnvds: int  # 110
SH4_fcnvsd: int  # 111
SH4_fdiv: int  # 112
SH4_fipr: int  # 113
SH4_fldi0: int  # 114
SH4_fldi1: int  # 115
SH4_flds: int  # 116
SH4_float: int  # 117
SH4_fmac: int  # 118
SH4_fmov: int  # 119
SH4_fmov_s: int  # 120
SH4_fmovex: int  # 121
SH4_fmul: int  # 122
SH4_fneg: int  # 123
SH4_frchg: int  # 124
SH4_fsca: int  # 136
SH4_fschg: int  # 125
SH4_fsqrt: int  # 126
SH4_fsts: int  # 127
SH4_fsub: int  # 128
SH4_ftrc: int  # 129
SH4_ftrv: int  # 130
SH4_ftstn: int  # 131
SH4_last: int  # 180
SH4_movca_l: int  # 132
SH4_ocbi: int  # 133
SH4_ocbp: int  # 134
SH4_ocbwb: int  # 135
SH4a_fpchg: int  # 179
SH4a_fsrra: int  # 178
SH4a_icbi: int  # 175
SH4a_movco_l: int  # 172
SH4a_movli_l: int  # 173
SH4a_movua_l: int  # 174
SH4a_prefi: int  # 176
SH4a_synco: int  # 177
SHINS_LDXEA: int  # 8
SHINS_NUMADDR: int  # 1
SHINS_SHORT: int  # 4
SHINS_VALNUM: int  # 2
SIGN_HEADER_MAGIC: str  # IDASGN
SIGN_HEADER_VERSION: int  # 10
SIG_SUBDIR: str  # sig
SIZEOF_BLOCK_CHAINS: int  # 56
SIZEOF_nodeidx_t: int  # 8
SIZE_MAX: int  # 18446744073709551615
SNAP_ALL_SEG: int  # 0
SNAP_CUR_SEG: int  # 2
SNAP_LOAD_SEG: int  # 1
SN_AUTO: int  # 32
SN_CHECK: int  # 0
SN_DELTAIL: int  # 8192
SN_FORCE: int  # 2048
SN_IDBENC: int  # 1024
SN_LOCAL: int  # 512
SN_MULTI: int  # 16384
SN_MULTI_FORCE: int  # 32768
SN_NOCHECK: int  # 1
SN_NODUMMY: int  # 4096
SN_NOLIST: int  # 128
SN_NON_AUTO: int  # 64
SN_NON_PUBLIC: int  # 4
SN_NON_WEAK: int  # 16
SN_NOWARN: int  # 256
SN_PUBLIC: int  # 2
SN_WEAK: int  # 8
SPARC_add: int  # 1
SPARC_addc: int  # 3
SPARC_addcc: int  # 2
SPARC_addccc: int  # 4
SPARC_alignaddress: int  # 187
SPARC_and: int  # 5
SPARC_andcc: int  # 6
SPARC_andn: int  # 7
SPARC_andncc: int  # 8
SPARC_array: int  # 188
SPARC_b: int  # 9
SPARC_bclr: int  # 179
SPARC_bmask: int  # 227
SPARC_bp: int  # 10
SPARC_bpr: int  # 11
SPARC_bset: int  # 178
SPARC_bshuffle: int  # 228
SPARC_btog: int  # 180
SPARC_btst: int  # 177
SPARC_call: int  # 12
SPARC_cas: int  # 169
SPARC_casa: int  # 13
SPARC_casl: int  # 170
SPARC_casx: int  # 171
SPARC_casxa: int  # 14
SPARC_casxl: int  # 172
SPARC_clr: int  # 181
SPARC_clrb: int  # 182
SPARC_clrh: int  # 183
SPARC_clruw: int  # 185
SPARC_clrx: int  # 184
SPARC_cmp: int  # 157
SPARC_dec: int  # 175
SPARC_deccc: int  # 176
SPARC_done: int  # 15
SPARC_edge: int  # 189
SPARC_edgen: int  # 229
SPARC_fabs: int  # 16
SPARC_fadd: int  # 17
SPARC_faligndata: int  # 190
SPARC_fand: int  # 193
SPARC_fandnot1: int  # 191
SPARC_fandnot2: int  # 192
SPARC_fb: int  # 19
SPARC_fbp: int  # 18
SPARC_fcmp: int  # 20
SPARC_fcmpe: int  # 21
SPARC_fcmpeq: int  # 194
SPARC_fcmpgt: int  # 195
SPARC_fcmple: int  # 196
SPARC_fcmpne: int  # 197
SPARC_fdiv: int  # 22
SPARC_fdmulq: int  # 23
SPARC_fdtoi: int  # 50
SPARC_fdtoq: int  # 48
SPARC_fdtos: int  # 41
SPARC_fdtox: int  # 35
SPARC_fexpand: int  # 198
SPARC_fitod: int  # 43
SPARC_fitoq: int  # 46
SPARC_fitos: int  # 40
SPARC_flush: int  # 24
SPARC_flushw: int  # 25
SPARC_fmov: int  # 26
SPARC_fmovcc: int  # 27
SPARC_fmovr: int  # 28
SPARC_fmul: int  # 29
SPARC_fmul8sux16: int  # 199
SPARC_fmul8ulx16: int  # 200
SPARC_fmul8x16: int  # 201
SPARC_fmul8x16al: int  # 202
SPARC_fmul8x16au: int  # 203
SPARC_fmuld8sux16: int  # 204
SPARC_fmuld8ulx16: int  # 205
SPARC_fnand: int  # 206
SPARC_fneg: int  # 30
SPARC_fnor: int  # 207
SPARC_fnot1: int  # 208
SPARC_fnot2: int  # 209
SPARC_fone: int  # 210
SPARC_for: int  # 213
SPARC_fornot1: int  # 211
SPARC_fornot2: int  # 212
SPARC_fpack: int  # 215
SPARC_fpackfix: int  # 214
SPARC_fpadd: int  # 216
SPARC_fpmerge: int  # 217
SPARC_fpsub: int  # 218
SPARC_fqtod: int  # 45
SPARC_fqtoi: int  # 51
SPARC_fqtos: int  # 42
SPARC_fqtox: int  # 36
SPARC_fsmuld: int  # 31
SPARC_fsqrt: int  # 32
SPARC_fsrc1: int  # 219
SPARC_fsrc2: int  # 220
SPARC_fstod: int  # 44
SPARC_fstoi: int  # 49
SPARC_fstoq: int  # 47
SPARC_fstox: int  # 34
SPARC_fsub: int  # 33
SPARC_fxnor: int  # 221
SPARC_fxor: int  # 222
SPARC_fxtod: int  # 38
SPARC_fxtoq: int  # 39
SPARC_fxtos: int  # 37
SPARC_fzero: int  # 223
SPARC_illtrap: int  # 52
SPARC_impdep1: int  # 53
SPARC_impdep2: int  # 54
SPARC_inc: int  # 173
SPARC_inccc: int  # 174
SPARC_iprefetch: int  # 159
SPARC_jmp: int  # 158
SPARC_jmpl: int  # 55
SPARC_last: int  # 233
SPARC_ldd: int  # 56
SPARC_ldda: int  # 57
SPARC_lddf: int  # 58
SPARC_lddfa: int  # 59
SPARC_ldf: int  # 60
SPARC_ldfa: int  # 61
SPARC_ldfsr: int  # 62
SPARC_ldqf: int  # 63
SPARC_ldqfa: int  # 64
SPARC_ldsb: int  # 65
SPARC_ldsba: int  # 66
SPARC_ldsh: int  # 67
SPARC_ldsha: int  # 68
SPARC_ldstub: int  # 69
SPARC_ldstuba: int  # 70
SPARC_ldsw: int  # 71
SPARC_ldswa: int  # 72
SPARC_ldub: int  # 73
SPARC_lduba: int  # 74
SPARC_lduh: int  # 75
SPARC_lduha: int  # 76
SPARC_lduw: int  # 77
SPARC_lduwa: int  # 78
SPARC_ldx: int  # 79
SPARC_ldxa: int  # 80
SPARC_ldxfsr: int  # 81
SPARC_membar: int  # 82
SPARC_mov: int  # 83
SPARC_movr: int  # 84
SPARC_mulscc: int  # 85
SPARC_mulx: int  # 86
SPARC_neg: int  # 168
SPARC_nop: int  # 87
SPARC_not: int  # 167
SPARC_null: int  # 0
SPARC_or: int  # 88
SPARC_orcc: int  # 89
SPARC_orn: int  # 90
SPARC_orncc: int  # 91
SPARC_pdist: int  # 224
SPARC_popc: int  # 92
SPARC_prefetch: int  # 93
SPARC_prefetcha: int  # 94
SPARC_pseudo_mov: int  # 186
SPARC_rd: int  # 95
SPARC_rdhpr: int  # 230
SPARC_rdpr: int  # 96
SPARC_restore: int  # 97
SPARC_restored: int  # 98
SPARC_ret: int  # 161
SPARC_retl: int  # 162
SPARC_retry: int  # 99
SPARC_rett: int  # 226
SPARC_return: int  # 100
SPARC_save: int  # 101
SPARC_saved: int  # 102
SPARC_sdiv: int  # 103
SPARC_sdivcc: int  # 104
SPARC_sdivx: int  # 105
SPARC_sethi: int  # 106
SPARC_setsw: int  # 164
SPARC_setuw: int  # 163
SPARC_setx: int  # 165
SPARC_shutdown: int  # 225
SPARC_siam: int  # 232
SPARC_signx: int  # 166
SPARC_sir: int  # 107
SPARC_sll: int  # 108
SPARC_sllx: int  # 109
SPARC_smul: int  # 110
SPARC_smulcc: int  # 111
SPARC_sra: int  # 112
SPARC_srax: int  # 113
SPARC_srl: int  # 114
SPARC_srlx: int  # 115
SPARC_stb: int  # 116
SPARC_stba: int  # 117
SPARC_stbar: int  # 118
SPARC_std: int  # 119
SPARC_stda: int  # 120
SPARC_stdf: int  # 121
SPARC_stdfa: int  # 122
SPARC_stf: int  # 123
SPARC_stfa: int  # 124
SPARC_stfsr: int  # 125
SPARC_sth: int  # 126
SPARC_stha: int  # 127
SPARC_stqf: int  # 128
SPARC_stqfa: int  # 129
SPARC_stw: int  # 130
SPARC_stwa: int  # 131
SPARC_stx: int  # 132
SPARC_stxa: int  # 133
SPARC_stxfsr: int  # 134
SPARC_sub: int  # 135
SPARC_subc: int  # 137
SPARC_subcc: int  # 136
SPARC_subccc: int  # 138
SPARC_swap: int  # 139
SPARC_swapa: int  # 140
SPARC_t: int  # 145
SPARC_taddcc: int  # 141
SPARC_taddcctv: int  # 142
SPARC_tst: int  # 160
SPARC_tsubcc: int  # 143
SPARC_tsubcctv: int  # 144
SPARC_udiv: int  # 146
SPARC_udivcc: int  # 147
SPARC_udivx: int  # 148
SPARC_umul: int  # 149
SPARC_umulcc: int  # 150
SPARC_wr: int  # 151
SPARC_wrhpr: int  # 231
SPARC_wrpr: int  # 152
SPARC_xnor: int  # 153
SPARC_xnorcc: int  # 154
SPARC_xor: int  # 155
SPARC_xorcc: int  # 156
SRCDBG_HINTS_MARKER: str  # ~
SRCDBG_HINTS_MARKER_LEN: int  # 2
SRCDBG_PROV_VERSION: int  # 4
SRCIT_EXPR: int  # 4
SRCIT_FUNC: int  # 2
SRCIT_LOCVAR: int  # 6
SRCIT_MODULE: int  # 1
SRCIT_NONE: int  # 0
SRCIT_STMT: int  # 3
SRCIT_STTVAR: int  # 5
SRCLANG_C: int  # 1
SRCLANG_CPP: int  # 2
SRCLANG_GO: int  # 16
SRCLANG_OBJC: int  # 4
SRCLANG_SWIFT: int  # 8
SREG_NUM: int  # 16
SR_auto: int  # 3
SR_autostart: int  # 4
SR_inherit: int  # 1
SR_user: int  # 2
SSF_AUTOMATIC: int  # 1
SSUF_DESC: int  # 1
SSUF_FLAGS: int  # 4
SSUF_PATH: int  # 2
ST10_CoABS: int  # 85
ST10_CoADD: int  # 86
ST10_CoASHR: int  # 87
ST10_CoCMP: int  # 88
ST10_CoLOAD: int  # 89
ST10_CoMAC: int  # 90
ST10_CoMACM: int  # 91
ST10_CoMAX: int  # 92
ST10_CoMIN: int  # 93
ST10_CoMOV: int  # 94
ST10_CoMUL: int  # 95
ST10_CoNEG: int  # 96
ST10_CoNOP: int  # 97
ST10_CoRND: int  # 98
ST10_CoSHL: int  # 99
ST10_CoSHR: int  # 100
ST10_CoSTORE: int  # 101
ST10_CoSUB: int  # 102
ST20_adc: int  # 1
ST20_add: int  # 2
ST20_addc: int  # 3
ST20_ajw: int  # 4
ST20_alt: int  # 81
ST20_altend: int  # 82
ST20_altwt: int  # 83
ST20_and: int  # 5
ST20_arot: int  # 6
ST20_ashr: int  # 7
ST20_bcnt: int  # 84
ST20_biquad: int  # 8
ST20_bitcnt: int  # 85
ST20_bitld: int  # 9
ST20_bitmask: int  # 10
ST20_bitrevnbits: int  # 86
ST20_bitrevword: int  # 87
ST20_bitst: int  # 11
ST20_breakpoint: int  # 12
ST20_bsub: int  # 88
ST20_call: int  # 89
ST20_causeerror: int  # 90
ST20_cb: int  # 91
ST20_cbu: int  # 92
ST20_ccnt1: int  # 93
ST20_cflerr: int  # 94
ST20_cir: int  # 95
ST20_ciru: int  # 96
ST20_cj: int  # 13
ST20_clockdis: int  # 97
ST20_clockenb: int  # 98
ST20_clrhalterr: int  # 99
ST20_crcbyte: int  # 100
ST20_crcword: int  # 101
ST20_cs: int  # 102
ST20_csngl: int  # 103
ST20_csu: int  # 104
ST20_csub0: int  # 105
ST20_cword: int  # 106
ST20_dequeue: int  # 14
ST20_devlb: int  # 107
ST20_devls: int  # 108
ST20_devlw: int  # 109
ST20_devmove: int  # 110
ST20_devsb: int  # 111
ST20_devss: int  # 112
ST20_devsw: int  # 113
ST20_diff: int  # 114
ST20_disc: int  # 115
ST20_diss: int  # 116
ST20_dist: int  # 117
ST20_div: int  # 118
ST20_divstep: int  # 15
ST20_dup: int  # 16
ST20_ecall: int  # 17
ST20_enbc: int  # 119
ST20_enbs: int  # 120
ST20_enbt: int  # 121
ST20_endp: int  # 122
ST20_enqueue: int  # 18
ST20_eqc: int  # 19
ST20_eret: int  # 20
ST20_fcall: int  # 21
ST20_fmul: int  # 123
ST20_fptesterr: int  # 124
ST20_gajw: int  # 22
ST20_gcall: int  # 125
ST20_gintdis: int  # 126
ST20_gintenb: int  # 127
ST20_gt: int  # 23
ST20_gtu: int  # 24
ST20_in: int  # 128
ST20_insertqueue: int  # 129
ST20_intdis: int  # 130
ST20_intenb: int  # 131
ST20_io: int  # 25
ST20_iret: int  # 132
ST20_j: int  # 26
ST20_jab: int  # 27
ST20_ladd: int  # 133
ST20_last: int  # 217
ST20_lb: int  # 134
ST20_lbinc: int  # 28
ST20_lbx: int  # 135
ST20_ldc: int  # 29
ST20_ldclock: int  # 136
ST20_lddevid: int  # 137
ST20_ldiff: int  # 138
ST20_ldinf: int  # 139
ST20_ldiv: int  # 140
ST20_ldl: int  # 30
ST20_ldlp: int  # 31
ST20_ldmemstartval: int  # 141
ST20_ldnl: int  # 32
ST20_ldnlp: int  # 33
ST20_ldpi: int  # 34
ST20_ldpri: int  # 142
ST20_ldprodid: int  # 35
ST20_ldshadow: int  # 143
ST20_ldtdesc: int  # 36
ST20_ldtimer: int  # 144
ST20_ldtraph: int  # 145
ST20_ldtrapped: int  # 146
ST20_lend: int  # 147
ST20_lmul: int  # 148
ST20_ls: int  # 149
ST20_lshl: int  # 150
ST20_lshr: int  # 151
ST20_lsinc: int  # 37
ST20_lsub: int  # 152
ST20_lsum: int  # 153
ST20_lsx: int  # 154
ST20_lsxinc: int  # 38
ST20_lwinc: int  # 39
ST20_mac: int  # 40
ST20_mint: int  # 155
ST20_move: int  # 156
ST20_move2dall: int  # 157
ST20_move2dinit: int  # 158
ST20_move2dnonzero: int  # 159
ST20_move2dzero: int  # 160
ST20_mul: int  # 41
ST20_nfix: int  # 42
ST20_nop: int  # 43
ST20_norm: int  # 161
ST20_not: int  # 44
ST20_null: int  # 0
ST20_opr: int  # 45
ST20_or: int  # 46
ST20_order: int  # 47
ST20_orderu: int  # 48
ST20_out: int  # 162
ST20_outbyte: int  # 163
ST20_outword: int  # 164
ST20_pfix: int  # 49
ST20_pop: int  # 165
ST20_postnormsn: int  # 166
ST20_prod: int  # 167
ST20_reboot: int  # 168
ST20_rem: int  # 169
ST20_resetch: int  # 170
ST20_restart: int  # 171
ST20_ret: int  # 172
ST20_rev: int  # 50
ST20_rmw: int  # 51
ST20_rot: int  # 52
ST20_roundsn: int  # 173
ST20_run: int  # 53
ST20_runp: int  # 174
ST20_satadd: int  # 175
ST20_satmul: int  # 176
ST20_satsub: int  # 177
ST20_saturate: int  # 54
ST20_saveh: int  # 178
ST20_savel: int  # 179
ST20_sb: int  # 180
ST20_sbinc: int  # 55
ST20_seterr: int  # 181
ST20_sethalterr: int  # 182
ST20_settimeslice: int  # 183
ST20_shl: int  # 56
ST20_shr: int  # 57
ST20_signal: int  # 58
ST20_slmul: int  # 184
ST20_smacinit: int  # 59
ST20_smacloop: int  # 60
ST20_smul: int  # 61
ST20_ss: int  # 185
ST20_ssinc: int  # 62
ST20_ssub: int  # 186
ST20_startp: int  # 187
ST20_statusclr: int  # 63
ST20_statusset: int  # 64
ST20_statustst: int  # 65
ST20_stclock: int  # 188
ST20_sthb: int  # 189
ST20_sthf: int  # 190
ST20_stl: int  # 66
ST20_stlb: int  # 191
ST20_stlf: int  # 192
ST20_stnl: int  # 67
ST20_stop: int  # 68
ST20_stoperr: int  # 193
ST20_stopp: int  # 194
ST20_stshadow: int  # 195
ST20_sttimer: int  # 196
ST20_sttraph: int  # 197
ST20_sttrapped: int  # 198
ST20_sub: int  # 69
ST20_subc: int  # 70
ST20_sulmul: int  # 199
ST20_sum: int  # 200
ST20_swap32: int  # 71
ST20_swapqueue: int  # 201
ST20_swaptimer: int  # 202
ST20_swinc: int  # 72
ST20_talt: int  # 203
ST20_taltwt: int  # 204
ST20_testerr: int  # 205
ST20_testhalterr: int  # 206
ST20_testpranal: int  # 207
ST20_timeslice: int  # 73
ST20_tin: int  # 208
ST20_trapdis: int  # 209
ST20_trapenb: int  # 210
ST20_tret: int  # 211
ST20_umac: int  # 74
ST20_unpacksn: int  # 212
ST20_unsign: int  # 75
ST20_wait: int  # 76
ST20_wcnt: int  # 213
ST20_wsub: int  # 77
ST20_wsubdb: int  # 214
ST20_xbword: int  # 78
ST20_xdble: int  # 215
ST20_xor: int  # 79
ST20_xsword: int  # 80
ST20_xword: int  # 216
ST7_adc: int  # 1
ST7_add: int  # 2
ST7_and: int  # 3
ST7_bcp: int  # 4
ST7_bres: int  # 5
ST7_bset: int  # 6
ST7_btjf: int  # 7
ST7_btjt: int  # 8
ST7_call: int  # 9
ST7_callr: int  # 10
ST7_clr: int  # 11
ST7_cp: int  # 12
ST7_cpl: int  # 13
ST7_dec: int  # 14
ST7_halt: int  # 15
ST7_inc: int  # 17
ST7_iret: int  # 16
ST7_jp: int  # 18
ST7_jra: int  # 19
ST7_jrc: int  # 32
ST7_jreq: int  # 30
ST7_jrf: int  # 21
ST7_jrh: int  # 24
ST7_jrih: int  # 22
ST7_jril: int  # 23
ST7_jrm: int  # 26
ST7_jrmi: int  # 28
ST7_jrnc: int  # 33
ST7_jrne: int  # 31
ST7_jrnh: int  # 25
ST7_jrnm: int  # 27
ST7_jrpl: int  # 29
ST7_jrt: int  # 20
ST7_jruge: int  # 35
ST7_jrugt: int  # 36
ST7_jrule: int  # 37
ST7_jrult: int  # 34
ST7_last: int  # 64
ST7_ld: int  # 38
ST7_mul: int  # 39
ST7_neg: int  # 40
ST7_nop: int  # 41
ST7_null: int  # 0
ST7_or: int  # 42
ST7_pop: int  # 43
ST7_push: int  # 44
ST7_rcf: int  # 45
ST7_ret: int  # 46
ST7_rim: int  # 47
ST7_rlc: int  # 48
ST7_rrc: int  # 49
ST7_rsp: int  # 50
ST7_sbc: int  # 51
ST7_scf: int  # 52
ST7_sim: int  # 53
ST7_sla: int  # 54
ST7_sll: int  # 55
ST7_sra: int  # 57
ST7_srl: int  # 56
ST7_sub: int  # 58
ST7_swap: int  # 59
ST7_tnz: int  # 60
ST7_trap: int  # 61
ST7_wfi: int  # 62
ST7_xor: int  # 63
STATUS_MASK: int  # -268435456
STEP: int  # 6
STEP_TRACE: int  # 1
STI_ACCHAR: int  # 12
STI_ACHAR: int  # 10
STI_ACUCHAR: int  # 13
STI_AEABI_LCMP: int  # 17
STI_AEABI_MEMCLR: int  # 24
STI_AEABI_MEMCPY: int  # 22
STI_AEABI_MEMSET: int  # 23
STI_AEABI_ULCMP: int  # 18
STI_AUCHAR: int  # 11
STI_COMPLEX128: int  # 29
STI_COMPLEX64: int  # 28
STI_DONT_USE: int  # 19
STI_FDELOP: int  # 15
STI_FPURGING: int  # 14
STI_LAST: int  # 31
STI_MSGSEND: int  # 16
STI_PBYTE: int  # 4
STI_PCCHAR: int  # 2
STI_PCHAR: int  # 0
STI_PCUCHAR: int  # 3
STI_PCVOID: int  # 9
STI_PINT: int  # 5
STI_PPVOID: int  # 8
STI_PUCHAR: int  # 1
STI_PUINT: int  # 6
STI_PUNKNOWN: int  # 30
STI_PVOID: int  # 7
STI_RTC_CHECK_2: int  # 25
STI_RTC_CHECK_4: int  # 26
STI_RTC_CHECK_8: int  # 27
STI_SIZE_T: int  # 20
STI_SSIZE_T: int  # 21
STKVAR_KEEP_EXISTING: int  # 2
STKVAR_VALID_SIZE: int  # 1
STRCONV_ESCAPE: int  # 1
STRCONV_INCLLEN: int  # 4
STRCONV_REPLCHAR: int  # 2
STRENC_DEFAULT: int  # 0
STRENC_NONE: int  # 255
STRF_AUTO: int  # 2
STRF_COMMENT: int  # 16
STRF_GEN: int  # 1
STRF_SAVECASE: int  # 32
STRF_SERIAL: int  # 4
STRF_UNICODE: int  # 8
STRLYT_MASK: int  # 252
STRLYT_PASCAL1: int  # 1
STRLYT_PASCAL2: int  # 2
STRLYT_PASCAL4: int  # 3
STRLYT_SHIFT: int  # 2
STRLYT_TERMCHR: int  # 0
STRMEM_ANON: int  # -2147483648
STRMEM_AUTO: int  # 2
STRMEM_CASTABLE_TO: int  # 1073741824
STRMEM_INDEX: int  # 1
STRMEM_LOWBND: int  # 8
STRMEM_MASK: int  # 15
STRMEM_MAXS: int  # 7
STRMEM_MINS: int  # 6
STRMEM_NAME: int  # 3
STRMEM_NEXT: int  # 9
STRMEM_OFFSET: int  # 0
STRMEM_SIZE: int  # 5
STRMEM_SKIP_EMPTY: int  # 536870912
STRMEM_SKIP_GAPS: int  # 16777216
STRMEM_TYPE: int  # 4
STRMEM_VFTABLE: int  # 268435456
STRTYPE_C: int  # 0
STRTYPE_C_16: int  # 1
STRTYPE_C_32: int  # 2
STRTYPE_LEN2: int  # 8
STRTYPE_LEN2_16: int  # 9
STRTYPE_LEN2_32: int  # 10
STRTYPE_LEN4: int  # 12
STRTYPE_LEN4_16: int  # 13
STRTYPE_LEN4_32: int  # 14
STRTYPE_PASCAL: int  # 4
STRTYPE_PASCAL_16: int  # 5
STRTYPE_PASCAL_32: int  # 6
STRTYPE_TERMCHR: int  # 0
STRUC_SEPARATOR: str  # .
STRWIDTH_1B: int  # 0
STRWIDTH_2B: int  # 1
STRWIDTH_4B: int  # 2
STRWIDTH_MASK: int  # 3
STT_CUR: int  # -1
STT_DBG: int  # 2
STT_MM: int  # 1
STT_VA: int  # 0
ST_ALREADY_LOGGED: int  # 4
ST_DIFFERENTIAL: int  # 16
ST_OPTIONS_DEFAULT: int  # 3
ST_OPTIONS_MASK: int  # 31
ST_OVER_DEBUG_SEG: int  # 1
ST_OVER_LIB_FUNC: int  # 2
ST_SKIP_LOOPS: int  # 8
SUBSTCHAR: str  # _
SUDT_ALIGN: int  # 2
SUDT_CONST: int  # 64
SUDT_FAST: int  # 16
SUDT_GAPS: int  # 4
SUDT_SERDEF: int  # 512
SUDT_SORT: int  # 1
SUDT_TRUNC: int  # 256
SUDT_UNEX: int  # 8
SUDT_VOLATILE: int  # 128
SVF_COPY_LINES: int  # 0
SVF_LINES_BYPTR: int  # 1
SVW_FLOAT: int  # 1
SVW_INT: int  # 0
SVW_SOFT: int  # 2
SWIG_PYTHON_LEGACY_BOOL: int  # 1
SWI_CUSTOM: int  # 16384
SWI_DEFRET: int  # 1048576
SWI_DEF_IN_TBL: int  # 32
SWI_ELBASE: int  # 512
SWI_HXNOLOWCASE: int  # 262144
SWI_INDIRECT: int  # 65536
SWI_J32: int  # 4
SWI_JMPINSN: int  # 4194304
SWI_JMP_INV: int  # 64
SWI_JSIZE: int  # 1024
SWI_SELFREL: int  # 2097152
SWI_SEPARATE: int  # 4096
SWI_SHIFT_MASK: int  # 384
SWI_SIGNED: int  # 8192
SWI_SPARSE: int  # 1
SWI_STDTBL: int  # 524288
SWI_SUBTRACT: int  # 131072
SWI_USER: int  # 16
SWI_V32: int  # 2
SWI_VERSION: int  # 8388608
SWI_VSIZE: int  # 2048
SWI_VSPLIT: int  # 8
SW_SEGXRF: int  # 1
SW_XRFFNC: int  # 4
SW_XRFMRK: int  # 2
SW_XRFVAL: int  # 8
T900_adc: int  # 25
T900_adcw: int  # 26
T900_add: int  # 23
T900_addw: int  # 24
T900_and: int  # 54
T900_andcf: int  # 62
T900_andw: int  # 55
T900_bit: int  # 69
T900_bs1b: int  # 75
T900_bs1f: int  # 74
T900_call: int  # 121
T900_calr: int  # 122
T900_ccf: int  # 67
T900_chg: int  # 72
T900_cp: int  # 31
T900_cpd: int  # 21
T900_cpdr: int  # 22
T900_cpi: int  # 19
T900_cpir: int  # 20
T900_cpl: int  # 42
T900_cpw: int  # 32
T900_daa: int  # 40
T900_dec: int  # 35
T900_decf: int  # 87
T900_decw: int  # 36
T900_di: int  # 78
T900_div: int  # 45
T900_divs: int  # 46
T900_djnz: int  # 123
T900_ei: int  # 77
T900_ex: int  # 9
T900_exts: int  # 39
T900_extz: int  # 38
T900_halt: int  # 80
T900_inc: int  # 33
T900_incf: int  # 86
T900_incw: int  # 34
T900_jp: int  # 115
T900_jp_cond: int  # 116
T900_jr: int  # 117
T900_jr_cond: int  # 118
T900_jrl: int  # 119
T900_jrl_cond: int  # 120
T900_last: int  # 130
T900_ld: int  # 1
T900_lda: int  # 7
T900_ldar: int  # 8
T900_ldc: int  # 81
T900_ldcf: int  # 60
T900_ldd: int  # 15
T900_lddr: int  # 17
T900_lddrw: int  # 18
T900_lddw: int  # 16
T900_ldf: int  # 85
T900_ldi: int  # 11
T900_ldir: int  # 13
T900_ldirw: int  # 14
T900_ldiw: int  # 12
T900_ldw: int  # 2
T900_ldx: int  # 82
T900_link: int  # 83
T900_max: int  # 128
T900_mdec1: int  # 51
T900_mdec2: int  # 52
T900_mdec4: int  # 53
T900_minc1: int  # 48
T900_minc2: int  # 49
T900_minc4: int  # 50
T900_mirr: int  # 10
T900_mul: int  # 43
T900_mula: int  # 47
T900_muls: int  # 44
T900_neg: int  # 37
T900_nop: int  # 76
T900_normal: int  # 129
T900_null: int  # 0
T900_or: int  # 56
T900_orcf: int  # 63
T900_orw: int  # 57
T900_paa: int  # 41
T900_pop: int  # 5
T900_popw: int  # 6
T900_push: int  # 3
T900_pushw: int  # 4
T900_rcf: int  # 65
T900_res: int  # 70
T900_ret: int  # 124
T900_ret_cond: int  # 125
T900_retd: int  # 126
T900_reti: int  # 127
T900_rl: int  # 95
T900_rl_mem: int  # 96
T900_rlc: int  # 89
T900_rlc_mem: int  # 90
T900_rlcw_mem: int  # 91
T900_rld: int  # 113
T900_rlw_mem: int  # 97
T900_rr: int  # 98
T900_rr_mem: int  # 99
T900_rrc: int  # 92
T900_rrc_mem: int  # 93
T900_rrcw_mem: int  # 94
T900_rrd: int  # 114
T900_rrw_mem: int  # 100
T900_sbc: int  # 29
T900_sbcw: int  # 30
T900_scc: int  # 88
T900_scf: int  # 66
T900_set: int  # 71
T900_sla: int  # 101
T900_sla_mem: int  # 102
T900_slaw_mem: int  # 103
T900_sll: int  # 107
T900_sll_mem: int  # 108
T900_sllw_mem: int  # 109
T900_sra: int  # 104
T900_sra_mem: int  # 105
T900_sraw_mem: int  # 106
T900_srl: int  # 110
T900_srl_mem: int  # 111
T900_srlw_mem: int  # 112
T900_stcf: int  # 61
T900_sub: int  # 27
T900_subw: int  # 28
T900_swi: int  # 79
T900_tset: int  # 73
T900_unlk: int  # 84
T900_xor: int  # 58
T900_xorcf: int  # 64
T900_xorw: int  # 59
T900_zcf: int  # 68
TAENUM_64BIT: int  # 32
TAENUM_BIN: int  # 512
TAENUM_LZERO: int  # 2048
TAENUM_NUMSIGN: int  # 1024
TAENUM_OCT: int  # 256
TAENUM_SIGNED: int  # 128
TAENUM_UNSIGNED: int  # 64
TAFLD_BASECLASS: int  # 32
TAFLD_BYTIL: int  # 16384
TAFLD_FRAME_R: int  # 4096
TAFLD_FRAME_S: int  # 8192
TAFLD_GAP: int  # 1024
TAFLD_METHOD: int  # 512
TAFLD_REGCMT: int  # 2048
TAFLD_UNALIGNED: int  # 64
TAFLD_VFTABLE: int  # 256
TAFLD_VIRTBASE: int  # 128
TAH_ALL: int  # 32752
TAH_BYTE: int  # 254
TAH_HASATTRS: int  # 16
TAPTR_PTR32: int  # 32
TAPTR_PTR64: int  # 64
TAPTR_RESTRICT: int  # 96
TAPTR_SHIFTED: int  # 128
TAUDT_CPPOBJ: int  # 128
TAUDT_FIXED: int  # 1024
TAUDT_MSSTRUCT: int  # 32
TAUDT_TUPLE: int  # 2048
TAUDT_UNALIGNED: int  # 64
TAUDT_VFTABLE: int  # 256
TA_FORMAT: str  # format
TA_ORG_ARRDIM: str  # __org_arrdim
TA_ORG_TYPEDEF: str  # __org_typedef
TA_VALUE_REPR: str  # 
TBEA_ANY: int  # 31
TBEA_CATCH: int  # 2
TBEA_FALLTHRU: int  # 32
TBEA_SEHFILT: int  # 16
TBEA_SEHLPAD: int  # 8
TBEA_SEHTRY: int  # 4
TBEA_TRY: int  # 1
TBERR_EMPTY: int  # 4
TBERR_END: int  # 2
TBERR_INTERSECT: int  # 7
TBERR_KIND: int  # 5
TBERR_NO_CATCHES: int  # 6
TBERR_OK: int  # 0
TBERR_ORDER: int  # 3
TBERR_START: int  # 1
TCCPT_IDAPLACE: int  # 3
TCCPT_INVALID: int  # 0
TCCPT_PLACE: int  # 1
TCCPT_SIMPLELINE_PLACE: int  # 2
TCCPT_TIPLACE: int  # 4
TCCRT_FLAT: int  # 1
TCCRT_GRAPH: int  # 2
TCCRT_INVALID: int  # 0
TCCRT_PROXIMITY: int  # 3
TCMP_ANYBASE: int  # 64
TCMP_AUTOCAST: int  # 2
TCMP_CALL: int  # 8
TCMP_DECL: int  # 32
TCMP_DEEP_UDT: int  # 256
TCMP_DELPTR: int  # 16
TCMP_EQUAL: int  # 0
TCMP_IGNMODS: int  # 1
TCMP_MANCAST: int  # 4
TCMP_SKIPTHIS: int  # 128
TCT_NOT_OWNER: int  # 2
TCT_OWNER: int  # 1
TCT_UNKNOWN: int  # 0
TERR_ALIEN_NAME: int  # -31
TERR_BAD_ARG: int  # -4
TERR_BAD_ARRAY: int  # -8
TERR_BAD_BASE: int  # -24
TERR_BAD_BF: int  # -9
TERR_BAD_BMASK: int  # -17
TERR_BAD_FX_SIZE: int  # -36
TERR_BAD_GAP: int  # -25
TERR_BAD_GROUPS: int  # -29
TERR_BAD_INDEX: int  # -7
TERR_BAD_LAYOUT: int  # -28
TERR_BAD_MSKVAL: int  # -18
TERR_BAD_NAME: int  # -3
TERR_BAD_OFFSET: int  # -10
TERR_BAD_REPR: int  # -19
TERR_BAD_SERIAL: int  # -30
TERR_BAD_SIZE: int  # -6
TERR_BAD_SUBTYPE: int  # -14
TERR_BAD_TAH: int  # -23
TERR_BAD_TYPE: int  # -5
TERR_BAD_UNIVAR: int  # -11
TERR_BAD_VALUE: int  # -15
TERR_BAD_VARLAST: int  # -12
TERR_COUNT: int  # 39
TERR_DUPNAME: int  # -21
TERR_ENUM_SIZE: int  # -33
TERR_GRP_NOEMPTY: int  # -20
TERR_NESTED: int  # -26
TERR_NOT_COMPAT: int  # -27
TERR_NOT_FOUND: int  # -38
TERR_NOT_IMPL: int  # -34
TERR_NO_BMASK: int  # -16
TERR_OK: int  # 0
TERR_OVERLAP: int  # -13
TERR_SAVE: int  # -1
TERR_SAVE_ERROR: int  # -1
TERR_SERIALIZE: int  # -2
TERR_STOCK: int  # -32
TERR_STRUCT_SIZE: int  # -37
TERR_TYPE_WORSE: int  # -35
TERR_UNION_BF: int  # -22
TERR_WRONGNAME: int  # -3
THM_SUBDIR: str  # themes
THREAD_EXITED: int  # 4
THREAD_STARTED: int  # 3
TIL_ADD_ALREADY: int  # 2
TIL_ADD_FAILED: int  # 0
TIL_ADD_OK: int  # 1
TIL_ALI: int  # 32
TIL_ECC: int  # 512
TIL_ESI: int  # 4
TIL_MAC: int  # 2
TIL_MOD: int  # 64
TIL_ORD: int  # 16
TIL_SLD: int  # 256
TIL_STM: int  # 128
TIL_SUBDIR: str  # til
TIL_UNI: int  # 8
TIL_ZIP: int  # 1
TINFO_DEFINITE: int  # 1
TINFO_DELAYFUNC: int  # 2
TINFO_GUESSED: int  # 0
TINFO_STRICT: int  # 4
TMS28_aborti: int  # 1
TMS28_abs: int  # 2
TMS28_absf32: int  # 162
TMS28_absf64: int  # 222
TMS28_absi32div32: int  # 324
TMS28_absi32div32u: int  # 325
TMS28_absi64div32: int  # 326
TMS28_absi64div32u: int  # 327
TMS28_absi64div64: int  # 328
TMS28_absi64div64u: int  # 329
TMS28_abstc: int  # 3
TMS28_add: int  # 4
TMS28_addb: int  # 5
TMS28_addcl: int  # 6
TMS28_addcu: int  # 7
TMS28_addf32: int  # 163
TMS28_addf64: int  # 205
TMS28_addl: int  # 8
TMS28_addu: int  # 9
TMS28_addul: int  # 10
TMS28_adrk: int  # 11
TMS28_and: int  # 12
TMS28_andb: int  # 13
TMS28_asp: int  # 14
TMS28_asr: int  # 15
TMS28_asr64: int  # 16
TMS28_asrl: int  # 17
TMS28_atanpuf32: int  # 347
TMS28_b: int  # 18
TMS28_banz: int  # 19
TMS28_bar: int  # 20
TMS28_bf: int  # 21
TMS28_c27map: int  # 22
TMS28_c27obj: int  # 23
TMS28_c28addr: int  # 24
TMS28_c28map: int  # 25
TMS28_c28obj: int  # 26
TMS28_clrc: int  # 27
TMS28_cmp: int  # 28
TMS28_cmp64: int  # 29
TMS28_cmpb: int  # 30
TMS28_cmpf32: int  # 164
TMS28_cmpf64: int  # 207
TMS28_cmpl: int  # 31
TMS28_cmpr: int  # 32
TMS28_cospuf32: int  # 346
TMS28_csb: int  # 33
TMS28_dec: int  # 34
TMS28_dint: int  # 35
TMS28_div2pif32: int  # 342
TMS28_divf32: int  # 343
TMS28_dmac: int  # 36
TMS28_dmov: int  # 37
TMS28_eallow: int  # 38
TMS28_edis: int  # 39
TMS28_eint: int  # 40
TMS28_einvf32: int  # 165
TMS28_einvf64: int  # 226
TMS28_eisqrtf32: int  # 166
TMS28_eisqrtf64: int  # 225
TMS28_enegi32div32: int  # 333
TMS28_enegi64div32: int  # 336
TMS28_enegi64div64: int  # 339
TMS28_estop0: int  # 41
TMS28_estop1: int  # 42
TMS28_f32dtof64: int  # 221
TMS28_f32tof64: int  # 220
TMS28_f32toi16: int  # 167
TMS28_f32toi16r: int  # 168
TMS28_f32toi32: int  # 169
TMS28_f32toui16: int  # 170
TMS28_f32toui16r: int  # 171
TMS28_f32toui32: int  # 172
TMS28_f64tof32: int  # 219
TMS28_f64toi32: int  # 210
TMS28_f64toi64: int  # 214
TMS28_f64toui32: int  # 211
TMS28_f64toui64: int  # 215
TMS28_ffc: int  # 43
TMS28_flip: int  # 44
TMS28_fracf32: int  # 173
TMS28_fracf64: int  # 218
TMS28_i16tof32: int  # 174
TMS28_i32tof32: int  # 175
TMS28_i32tof64: int  # 212
TMS28_i64tof64: int  # 216
TMS28_iack: int  # 45
TMS28_idle: int  # 46
TMS28_iexp2f32: int  # 349
TMS28_imacl: int  # 47
TMS28_impyal: int  # 48
TMS28_impyl: int  # 49
TMS28_impysl: int  # 50
TMS28_impyxul: int  # 51
TMS28_in: int  # 52
TMS28_inc: int  # 53
TMS28_intr: int  # 54
TMS28_iret: int  # 55
TMS28_last: int  # 351
TMS28_lb: int  # 56
TMS28_lc: int  # 57
TMS28_lcr: int  # 58
TMS28_log2f32: int  # 350
TMS28_loopnz: int  # 59
TMS28_loopz: int  # 60
TMS28_lpaddr: int  # 61
TMS28_lret: int  # 62
TMS28_lrete: int  # 63
TMS28_lretr: int  # 64
TMS28_lsl: int  # 65
TMS28_lsl64: int  # 66
TMS28_lsll: int  # 67
TMS28_lsr: int  # 68
TMS28_lsr64: int  # 69
TMS28_lsrl: int  # 70
TMS28_mac: int  # 71
TMS28_macf32: int  # 176
TMS28_macf64: int  # 203
TMS28_max: int  # 72
TMS28_maxcul: int  # 73
TMS28_maxf32: int  # 177
TMS28_maxf64: int  # 208
TMS28_maxl: int  # 74
TMS28_min: int  # 75
TMS28_mincul: int  # 76
TMS28_minf32: int  # 178
TMS28_minf64: int  # 209
TMS28_minl: int  # 77
TMS28_mnegi32div32: int  # 334
TMS28_mnegi64div32: int  # 337
TMS28_mnegi64div64: int  # 340
TMS28_mov: int  # 78
TMS28_mov16: int  # 179
TMS28_mov32: int  # 180
TMS28_mov64: int  # 224
TMS28_mova: int  # 79
TMS28_movad: int  # 80
TMS28_movb: int  # 81
TMS28_movd32: int  # 181
TMS28_movdd32: int  # 201
TMS28_movdl: int  # 82
TMS28_movf32: int  # 182
TMS28_movh: int  # 83
TMS28_movix: int  # 202
TMS28_moviz: int  # 183
TMS28_movl: int  # 84
TMS28_movp: int  # 85
TMS28_movs: int  # 86
TMS28_movst0: int  # 184
TMS28_movu: int  # 87
TMS28_movw: int  # 88
TMS28_movx: int  # 89
TMS28_movxi: int  # 185
TMS28_movz: int  # 90
TMS28_mpy: int  # 91
TMS28_mpy2pif32: int  # 341
TMS28_mpya: int  # 92
TMS28_mpyb: int  # 93
TMS28_mpyf32: int  # 186
TMS28_mpyf64: int  # 204
TMS28_mpys: int  # 94
TMS28_mpyu: int  # 95
TMS28_mpyxu: int  # 96
TMS28_nasp: int  # 97
TMS28_neg: int  # 98
TMS28_neg64: int  # 99
TMS28_negf32: int  # 187
TMS28_negf64: int  # 223
TMS28_negi32div32: int  # 332
TMS28_negi64div32: int  # 335
TMS28_negi64div64: int  # 338
TMS28_negtc: int  # 100
TMS28_nop: int  # 101
TMS28_norm: int  # 102
TMS28_not: int  # 103
TMS28_null: int  # 0
TMS28_or: int  # 104
TMS28_orb: int  # 105
TMS28_out: int  # 106
TMS28_pop: int  # 107
TMS28_poprb: int  # 188
TMS28_pread: int  # 108
TMS28_push: int  # 109
TMS28_pushrb: int  # 189
TMS28_pwrite: int  # 110
TMS28_qmacl: int  # 111
TMS28_qmpyal: int  # 112
TMS28_qmpyl: int  # 113
TMS28_qmpysl: int  # 114
TMS28_qmpyul: int  # 115
TMS28_qmpyxul: int  # 116
TMS28_quadf32: int  # 348
TMS28_restore: int  # 190
TMS28_rol: int  # 117
TMS28_ror: int  # 118
TMS28_rpt: int  # 119
TMS28_rptb: int  # 191
TMS28_sat: int  # 120
TMS28_sat64: int  # 121
TMS28_save: int  # 192
TMS28_sb: int  # 122
TMS28_sbbu: int  # 123
TMS28_sbf: int  # 124
TMS28_sbrk: int  # 125
TMS28_setc: int  # 126
TMS28_setflg: int  # 193
TMS28_sfr: int  # 127
TMS28_sinpuf32: int  # 345
TMS28_spm: int  # 128
TMS28_sqra: int  # 129
TMS28_sqrs: int  # 130
TMS28_sqrtf32: int  # 344
TMS28_sub: int  # 131
TMS28_subb: int  # 132
TMS28_subbl: int  # 133
TMS28_subc2ui64: int  # 331
TMS28_subc4ui32: int  # 330
TMS28_subcu: int  # 134
TMS28_subcul: int  # 135
TMS28_subf32: int  # 194
TMS28_subf64: int  # 206
TMS28_subl: int  # 136
TMS28_subr: int  # 137
TMS28_subrl: int  # 138
TMS28_subu: int  # 139
TMS28_subul: int  # 140
TMS28_swapf: int  # 195
TMS28_sxtb: int  # 141
TMS28_tbit: int  # 142
TMS28_tclr: int  # 143
TMS28_test: int  # 144
TMS28_testtf: int  # 196
TMS28_trap: int  # 145
TMS28_tset: int  # 146
TMS28_ui16tof32: int  # 197
TMS28_ui32tof32: int  # 198
TMS28_ui32tof64: int  # 213
TMS28_ui64tof64: int  # 217
TMS28_uout: int  # 147
TMS28_vashl32: int  # 286
TMS28_vashr32: int  # 287
TMS28_vbitflip: int  # 288
TMS28_vcadd: int  # 243
TMS28_vccmac: int  # 291
TMS28_vccmpy: int  # 292
TMS28_vccon: int  # 293
TMS28_vcdadd16: int  # 244
TMS28_vcdsub16: int  # 245
TMS28_vcfft1: int  # 303
TMS28_vcfft10: int  # 312
TMS28_vcfft2: int  # 304
TMS28_vcfft3: int  # 305
TMS28_vcfft4: int  # 306
TMS28_vcfft5: int  # 307
TMS28_vcfft6: int  # 308
TMS28_vcfft7: int  # 309
TMS28_vcfft8: int  # 310
TMS28_vcfft9: int  # 311
TMS28_vcflip: int  # 294
TMS28_vclear: int  # 227
TMS28_vclearall: int  # 228
TMS28_vclrcpack: int  # 280
TMS28_vclrcrcmsgflip: int  # 271
TMS28_vclrdive: int  # 298
TMS28_vclropack: int  # 281
TMS28_vclrovfi: int  # 229
TMS28_vclrovfr: int  # 230
TMS28_vcmac: int  # 246
TMS28_vcmag: int  # 295
TMS28_vcmpy: int  # 247
TMS28_vcrc16p1h_1: int  # 252
TMS28_vcrc16p1l_1: int  # 253
TMS28_vcrc16p2h_1: int  # 254
TMS28_vcrc16p2l_1: int  # 255
TMS28_vcrc24h_1: int  # 275
TMS28_vcrc24l_1: int  # 274
TMS28_vcrc32h_1: int  # 256
TMS28_vcrc32l_1: int  # 257
TMS28_vcrc32p2h_1: int  # 273
TMS28_vcrc32p2l_1: int  # 272
TMS28_vcrc8h_1: int  # 250
TMS28_vcrc8l_1: int  # 251
TMS28_vcrcclr: int  # 258
TMS28_vcrch: int  # 278
TMS28_vcrcl: int  # 277
TMS28_vcshl16: int  # 296
TMS28_vcshr16: int  # 297
TMS28_vcsub: int  # 249
TMS28_vdec: int  # 299
TMS28_vgfacc: int  # 313
TMS28_vgfadd4: int  # 314
TMS28_vgfinit: int  # 315
TMS28_vgfmac4: int  # 316
TMS28_vgfmpy4: int  # 317
TMS28_vinc: int  # 300
TMS28_vitbm2: int  # 259
TMS28_vitbm3: int  # 260
TMS28_vitdhaddsub: int  # 261
TMS28_vitdhsubadd: int  # 262
TMS28_vitdladdsub: int  # 263
TMS28_vitdlsubadd: int  # 264
TMS28_vithsel: int  # 265
TMS28_vitlsel: int  # 266
TMS28_vitstage: int  # 321
TMS28_vlshl32: int  # 289
TMS28_vlshr32: int  # 290
TMS28_vmod32: int  # 301
TMS28_vmov16: int  # 231
TMS28_vmov32: int  # 232
TMS28_vmovd32: int  # 233
TMS28_vmovix: int  # 234
TMS28_vmovxi: int  # 236
TMS28_vmovzi: int  # 235
TMS28_vmpyadd: int  # 302
TMS28_vneg: int  # 248
TMS28_vnop: int  # 269
TMS28_vpack4: int  # 318
TMS28_vrevb: int  # 319
TMS28_vrndoff: int  # 237
TMS28_vrndon: int  # 238
TMS28_vsatoff: int  # 239
TMS28_vsaton: int  # 240
TMS28_vsetcpack: int  # 282
TMS28_vsetcrcmsgflip: int  # 270
TMS28_vsetcrcsize: int  # 276
TMS28_vsetk: int  # 322
TMS28_vsetopack: int  # 283
TMS28_vsetshl: int  # 241
TMS28_vsetshr: int  # 242
TMS28_vshlmb: int  # 320
TMS28_vsminit: int  # 323
TMS28_vswap32: int  # 284
TMS28_vswapcrc: int  # 279
TMS28_vtclear: int  # 267
TMS28_vtrace: int  # 268
TMS28_vxormov32: int  # 285
TMS28_xb: int  # 148
TMS28_xbanz: int  # 149
TMS28_xcall: int  # 150
TMS28_xmac: int  # 151
TMS28_xmacd: int  # 152
TMS28_xor: int  # 153
TMS28_xorb: int  # 154
TMS28_xpread: int  # 155
TMS28_xpwrite: int  # 156
TMS28_xret: int  # 157
TMS28_xretc: int  # 158
TMS28_zalr: int  # 159
TMS28_zap: int  # 160
TMS28_zapa: int  # 161
TMS28_zero: int  # 199
TMS28_zeroa: int  # 200
TMS2_abs: int  # 139
TMS2_add: int  # 140
TMS2_addc: int  # 141
TMS2_addh: int  # 142
TMS2_addk: int  # 143
TMS2_adds: int  # 144
TMS2_addt: int  # 145
TMS2_adlk: int  # 146
TMS2_adrk: int  # 147
TMS2_and: int  # 148
TMS2_andk: int  # 149
TMS2_apac: int  # 150
TMS2_b: int  # 151
TMS2_bacc: int  # 152
TMS2_banz: int  # 153
TMS2_bbnz: int  # 154
TMS2_bbz: int  # 155
TMS2_bc: int  # 156
TMS2_bgez: int  # 157
TMS2_bgz: int  # 158
TMS2_bioz: int  # 159
TMS2_bit: int  # 160
TMS2_bitt: int  # 161
TMS2_blez: int  # 162
TMS2_blkd: int  # 163
TMS2_blkp: int  # 164
TMS2_blz: int  # 165
TMS2_bnc: int  # 166
TMS2_bnv: int  # 167
TMS2_bnz: int  # 168
TMS2_bv: int  # 169
TMS2_bz: int  # 170
TMS2_cala: int  # 171
TMS2_call: int  # 172
TMS2_cmpl: int  # 173
TMS2_cmpr: int  # 174
TMS2_cnfd: int  # 175
TMS2_cnfp: int  # 176
TMS2_conf: int  # 177
TMS2_dint: int  # 178
TMS2_dmov: int  # 179
TMS2_eint: int  # 180
TMS2_fort: int  # 181
TMS2_idle: int  # 182
TMS2_in: int  # 183
TMS2_lac: int  # 184
TMS2_lack: int  # 185
TMS2_lact: int  # 186
TMS2_lalk: int  # 187
TMS2_lar: int  # 188
TMS2_lark: int  # 189
TMS2_larp: int  # 190
TMS2_ldp: int  # 191
TMS2_ldpk: int  # 192
TMS2_lph: int  # 193
TMS2_lrlk: int  # 194
TMS2_lst: int  # 195
TMS2_lst1: int  # 196
TMS2_lt: int  # 197
TMS2_lta: int  # 198
TMS2_ltd: int  # 199
TMS2_ltp: int  # 200
TMS2_lts: int  # 201
TMS2_mac: int  # 202
TMS2_macd: int  # 203
TMS2_mar: int  # 204
TMS2_mpy: int  # 205
TMS2_mpya: int  # 206
TMS2_mpyk: int  # 207
TMS2_mpys: int  # 208
TMS2_mpyu: int  # 209
TMS2_neg: int  # 210
TMS2_nop: int  # 211
TMS2_norm: int  # 212
TMS2_or: int  # 213
TMS2_ork: int  # 214
TMS2_out: int  # 215
TMS2_pac: int  # 216
TMS2_pop: int  # 217
TMS2_popd: int  # 218
TMS2_pshd: int  # 219
TMS2_push: int  # 220
TMS2_rc: int  # 221
TMS2_ret: int  # 222
TMS2_rfsm: int  # 223
TMS2_rhm: int  # 224
TMS2_rol: int  # 225
TMS2_ror: int  # 226
TMS2_rovm: int  # 227
TMS2_rpt: int  # 228
TMS2_rptk: int  # 229
TMS2_rsxm: int  # 230
TMS2_rtc: int  # 231
TMS2_rtxm: int  # 232
TMS2_rxf: int  # 233
TMS2_sach: int  # 234
TMS2_sacl: int  # 235
TMS2_sar: int  # 236
TMS2_sblk: int  # 237
TMS2_sbrk: int  # 238
TMS2_sc: int  # 239
TMS2_sfl: int  # 240
TMS2_sfr: int  # 241
TMS2_sfsm: int  # 242
TMS2_shm: int  # 243
TMS2_sovm: int  # 244
TMS2_spac: int  # 245
TMS2_sph: int  # 246
TMS2_spl: int  # 247
TMS2_spm: int  # 248
TMS2_sqra: int  # 249
TMS2_sqrs: int  # 250
TMS2_sst: int  # 251
TMS2_sst1: int  # 252
TMS2_ssxm: int  # 253
TMS2_stc: int  # 254
TMS2_stxm: int  # 255
TMS2_sub: int  # 256
TMS2_subb: int  # 257
TMS2_subc: int  # 258
TMS2_subh: int  # 259
TMS2_subk: int  # 260
TMS2_subs: int  # 261
TMS2_subt: int  # 262
TMS2_sxf: int  # 263
TMS2_tblr: int  # 264
TMS2_tblw: int  # 265
TMS2_trap: int  # 266
TMS2_xor: int  # 267
TMS2_xork: int  # 268
TMS2_zac: int  # 269
TMS2_zalh: int  # 270
TMS2_zalr: int  # 271
TMS2_zals: int  # 272
TMS320C3X_ABSF: int  # 1
TMS320C3X_ABSI: int  # 2
TMS320C3X_ADDC: int  # 3
TMS320C3X_ADDC3: int  # 58
TMS320C3X_ADDF: int  # 4
TMS320C3X_ADDF3: int  # 59
TMS320C3X_ADDI: int  # 5
TMS320C3X_ADDI3: int  # 60
TMS320C3X_AND: int  # 6
TMS320C3X_AND3: int  # 61
TMS320C3X_ANDN: int  # 7
TMS320C3X_ANDN3: int  # 62
TMS320C3X_ASH: int  # 8
TMS320C3X_ASH3: int  # 63
TMS320C3X_BR: int  # 77
TMS320C3X_BRD: int  # 78
TMS320C3X_Bcond: int  # 82
TMS320C3X_CALL: int  # 79
TMS320C3X_CALLcond: int  # 84
TMS320C3X_CMPF: int  # 9
TMS320C3X_CMPF3: int  # 64
TMS320C3X_CMPI: int  # 10
TMS320C3X_CMPI3: int  # 65
TMS320C3X_DBcond: int  # 83
TMS320C3X_FIX: int  # 11
TMS320C3X_FLOAT: int  # 12
TMS320C3X_IACK: int  # 57
TMS320C3X_IDLE: int  # 13
TMS320C3X_IDLE2: int  # 14
TMS320C3X_LDE: int  # 15
TMS320C3X_LDF: int  # 16
TMS320C3X_LDFI: int  # 17
TMS320C3X_LDFcond: int  # 75
TMS320C3X_LDI: int  # 18
TMS320C3X_LDII: int  # 19
TMS320C3X_LDIcond: int  # 76
TMS320C3X_LDM: int  # 20
TMS320C3X_LOPOWER: int  # 35
TMS320C3X_LSH: int  # 21
TMS320C3X_LSH3: int  # 66
TMS320C3X_MAXSPEED: int  # 36
TMS320C3X_MPYF: int  # 22
TMS320C3X_MPYF3: int  # 67
TMS320C3X_MPYI: int  # 23
TMS320C3X_MPYI3: int  # 68
TMS320C3X_MV_IDX: int  # 91
TMS320C3X_NEGB: int  # 24
TMS320C3X_NEGF: int  # 25
TMS320C3X_NEGI: int  # 26
TMS320C3X_NONE: int  # 90
TMS320C3X_NOP: int  # 27
TMS320C3X_NORM: int  # 28
TMS320C3X_NOT: int  # 29
TMS320C3X_OR: int  # 34
TMS320C3X_OR3: int  # 69
TMS320C3X_POP: int  # 30
TMS320C3X_POPF: int  # 31
TMS320C3X_PUSH: int  # 32
TMS320C3X_PUSHF: int  # 33
TMS320C3X_RETIU: int  # 88
TMS320C3X_RETIcond: int  # 86
TMS320C3X_RETSU: int  # 89
TMS320C3X_RETScond: int  # 87
TMS320C3X_RND: int  # 37
TMS320C3X_ROL: int  # 38
TMS320C3X_ROLC: int  # 39
TMS320C3X_ROR: int  # 40
TMS320C3X_RORC: int  # 41
TMS320C3X_RPTB: int  # 80
TMS320C3X_RPTS: int  # 42
TMS320C3X_SIGI: int  # 47
TMS320C3X_STF: int  # 43
TMS320C3X_STFI: int  # 44
TMS320C3X_STI: int  # 45
TMS320C3X_STII: int  # 46
TMS320C3X_SUBB: int  # 48
TMS320C3X_SUBB3: int  # 70
TMS320C3X_SUBC: int  # 49
TMS320C3X_SUBF: int  # 50
TMS320C3X_SUBF3: int  # 71
TMS320C3X_SUBI: int  # 51
TMS320C3X_SUBI3: int  # 72
TMS320C3X_SUBRB: int  # 52
TMS320C3X_SUBRF: int  # 53
TMS320C3X_SUBRI: int  # 54
TMS320C3X_SWI: int  # 81
TMS320C3X_TRAPcond: int  # 85
TMS320C3X_TSTB: int  # 55
TMS320C3X_TSTB3: int  # 73
TMS320C3X_XOR: int  # 56
TMS320C3X_XOR3: int  # 74
TMS320C3X_last: int  # 92
TMS320C3X_null: int  # 0
TMS320C54_abdst: int  # 51
TMS320C54_abs1: int  # 52
TMS320C54_abs2: int  # 53
TMS320C54_add1: int  # 1
TMS320C54_add2: int  # 2
TMS320C54_add3: int  # 3
TMS320C54_addc: int  # 4
TMS320C54_addm: int  # 5
TMS320C54_adds: int  # 6
TMS320C54_and1: int  # 71
TMS320C54_and2: int  # 72
TMS320C54_and3: int  # 73
TMS320C54_andm: int  # 74
TMS320C54_b: int  # 96
TMS320C54_bacc: int  # 98
TMS320C54_baccd: int  # 99
TMS320C54_banz: int  # 100
TMS320C54_banzd: int  # 101
TMS320C54_bc2: int  # 102
TMS320C54_bc3: int  # 103
TMS320C54_bcd2: int  # 104
TMS320C54_bcd3: int  # 105
TMS320C54_bd: int  # 97
TMS320C54_bit: int  # 91
TMS320C54_bitf: int  # 92
TMS320C54_bitt: int  # 93
TMS320C54_cala: int  # 110
TMS320C54_calad: int  # 111
TMS320C54_call: int  # 112
TMS320C54_calld: int  # 113
TMS320C54_cc2: int  # 114
TMS320C54_cc3: int  # 115
TMS320C54_ccd2: int  # 116
TMS320C54_ccd3: int  # 117
TMS320C54_cmpl1: int  # 54
TMS320C54_cmpl2: int  # 55
TMS320C54_cmpm: int  # 94
TMS320C54_cmpr: int  # 95
TMS320C54_cmps: int  # 175
TMS320C54_dadd2: int  # 44
TMS320C54_dadd3: int  # 45
TMS320C54_dadst: int  # 46
TMS320C54_delay: int  # 56
TMS320C54_dld: int  # 159
TMS320C54_drsub: int  # 47
TMS320C54_dsadt: int  # 48
TMS320C54_dst: int  # 167
TMS320C54_dsub: int  # 49
TMS320C54_dsubt: int  # 50
TMS320C54_exp: int  # 57
TMS320C54_fb: int  # 106
TMS320C54_fbacc: int  # 108
TMS320C54_fbaccd: int  # 109
TMS320C54_fbd: int  # 107
TMS320C54_fcala: int  # 118
TMS320C54_fcalad: int  # 119
TMS320C54_fcall: int  # 120
TMS320C54_fcalld: int  # 121
TMS320C54_firs: int  # 58
TMS320C54_frame: int  # 144
TMS320C54_fret: int  # 124
TMS320C54_fretd: int  # 125
TMS320C54_frete: int  # 126
TMS320C54_freted: int  # 127
TMS320C54_idle: int  # 149
TMS320C54_intr: int  # 122
TMS320C54_last: int  # 203
TMS320C54_ld1: int  # 160
TMS320C54_ld2: int  # 161
TMS320C54_ld3: int  # 162
TMS320C54_ld_mac: int  # 180
TMS320C54_ld_macr: int  # 181
TMS320C54_ld_mas: int  # 182
TMS320C54_ld_masr: int  # 183
TMS320C54_ldm: int  # 163
TMS320C54_ldr: int  # 164
TMS320C54_ldu: int  # 165
TMS320C54_lms: int  # 59
TMS320C54_ltd: int  # 166
TMS320C54_mac2: int  # 19
TMS320C54_mac3: int  # 20
TMS320C54_maca1: int  # 23
TMS320C54_maca2: int  # 24
TMS320C54_maca3: int  # 25
TMS320C54_macar1: int  # 26
TMS320C54_macar2: int  # 27
TMS320C54_macar3: int  # 28
TMS320C54_macd: int  # 29
TMS320C54_macp: int  # 30
TMS320C54_macr2: int  # 21
TMS320C54_macr3: int  # 22
TMS320C54_macsu: int  # 31
TMS320C54_mar: int  # 150
TMS320C54_mas2: int  # 32
TMS320C54_mas3: int  # 33
TMS320C54_masa1: int  # 36
TMS320C54_masa2: int  # 37
TMS320C54_masa3: int  # 38
TMS320C54_masar1: int  # 39
TMS320C54_masar2: int  # 40
TMS320C54_masar3: int  # 41
TMS320C54_masr2: int  # 34
TMS320C54_masr3: int  # 35
TMS320C54_max: int  # 60
TMS320C54_min: int  # 61
TMS320C54_mpy2: int  # 13
TMS320C54_mpy3: int  # 14
TMS320C54_mpya: int  # 16
TMS320C54_mpyr2: int  # 15
TMS320C54_mpyu: int  # 17
TMS320C54_mvdd: int  # 191
TMS320C54_mvdk: int  # 192
TMS320C54_mvdm: int  # 193
TMS320C54_mvdp: int  # 194
TMS320C54_mvkd: int  # 195
TMS320C54_mvmd: int  # 196
TMS320C54_mvmm: int  # 197
TMS320C54_mvpd: int  # 198
TMS320C54_neg1: int  # 62
TMS320C54_neg2: int  # 63
TMS320C54_nop: int  # 151
TMS320C54_norm1: int  # 64
TMS320C54_norm2: int  # 65
TMS320C54_null: int  # 0
TMS320C54_or1: int  # 75
TMS320C54_or2: int  # 76
TMS320C54_or3: int  # 77
TMS320C54_orm: int  # 78
TMS320C54_poly: int  # 66
TMS320C54_popd: int  # 145
TMS320C54_popm: int  # 146
TMS320C54_portr: int  # 199
TMS320C54_portw: int  # 200
TMS320C54_pshd: int  # 147
TMS320C54_pshm: int  # 148
TMS320C54_rc1: int  # 128
TMS320C54_rc2: int  # 129
TMS320C54_rc3: int  # 130
TMS320C54_rcd1: int  # 131
TMS320C54_rcd2: int  # 132
TMS320C54_rcd3: int  # 133
TMS320C54_reada: int  # 201
TMS320C54_reset: int  # 152
TMS320C54_ret: int  # 134
TMS320C54_retd: int  # 135
TMS320C54_rete: int  # 136
TMS320C54_reted: int  # 137
TMS320C54_retf: int  # 138
TMS320C54_retfd: int  # 139
TMS320C54_rnd1: int  # 67
TMS320C54_rnd2: int  # 68
TMS320C54_rol: int  # 83
TMS320C54_roltc: int  # 84
TMS320C54_ror: int  # 85
TMS320C54_rpt: int  # 140
TMS320C54_rptb: int  # 141
TMS320C54_rptbd: int  # 142
TMS320C54_rptz: int  # 143
TMS320C54_rsbx1: int  # 153
TMS320C54_rsbx2: int  # 154
TMS320C54_saccd: int  # 176
TMS320C54_sat: int  # 69
TMS320C54_sfta2: int  # 86
TMS320C54_sfta3: int  # 87
TMS320C54_sftc: int  # 88
TMS320C54_sftl2: int  # 89
TMS320C54_sftl3: int  # 90
TMS320C54_sqdst: int  # 70
TMS320C54_squr: int  # 18
TMS320C54_squra: int  # 42
TMS320C54_squrs: int  # 43
TMS320C54_srccd: int  # 177
TMS320C54_ssbx1: int  # 155
TMS320C54_ssbx2: int  # 156
TMS320C54_st: int  # 168
TMS320C54_st_add: int  # 184
TMS320C54_st_ld: int  # 179
TMS320C54_st_mac: int  # 186
TMS320C54_st_macr: int  # 187
TMS320C54_st_mas: int  # 188
TMS320C54_st_masr: int  # 189
TMS320C54_st_mpy: int  # 190
TMS320C54_st_sub: int  # 185
TMS320C54_sth2: int  # 169
TMS320C54_sth3: int  # 170
TMS320C54_stl2: int  # 171
TMS320C54_stl3: int  # 172
TMS320C54_stlm: int  # 173
TMS320C54_stm: int  # 174
TMS320C54_strcd: int  # 178
TMS320C54_sub1: int  # 7
TMS320C54_sub2: int  # 8
TMS320C54_sub3: int  # 9
TMS320C54_subb: int  # 10
TMS320C54_subc: int  # 11
TMS320C54_subs: int  # 12
TMS320C54_trap: int  # 123
TMS320C54_writa: int  # 202
TMS320C54_xc2: int  # 157
TMS320C54_xc3: int  # 158
TMS320C54_xor1: int  # 79
TMS320C54_xor2: int  # 80
TMS320C54_xor3: int  # 81
TMS320C54_xorm: int  # 82
TMS320C55_aadd: int  # 89
TMS320C55_abdst: int  # 1
TMS320C55_abs1: int  # 2
TMS320C55_abs2: int  # 3
TMS320C55_add1: int  # 4
TMS320C55_add2: int  # 5
TMS320C55_add3: int  # 6
TMS320C55_add4: int  # 7
TMS320C55_add_asub: int  # 79
TMS320C55_add_mov: int  # 73
TMS320C55_addrv1: int  # 10
TMS320C55_addrv2: int  # 11
TMS320C55_addsub: int  # 22
TMS320C55_addsub2cc: int  # 18
TMS320C55_addsubcc4: int  # 16
TMS320C55_addsubcc5: int  # 17
TMS320C55_addv1: int  # 8
TMS320C55_addv2: int  # 9
TMS320C55_amar1: int  # 92
TMS320C55_amar2: int  # 209
TMS320C55_amar3: int  # 64
TMS320C55_amar_amar: int  # 78
TMS320C55_amar_mac: int  # 48
TMS320C55_amar_mac40: int  # 50
TMS320C55_amar_macr: int  # 49
TMS320C55_amar_macr40: int  # 51
TMS320C55_amar_mas: int  # 56
TMS320C55_amar_mas40: int  # 58
TMS320C55_amar_masr: int  # 57
TMS320C55_amar_masr40: int  # 59
TMS320C55_amar_mpy: int  # 36
TMS320C55_amar_mpy40: int  # 38
TMS320C55_amar_mpyr: int  # 37
TMS320C55_amar_mpyr40: int  # 39
TMS320C55_amov: int  # 91
TMS320C55_and1: int  # 215
TMS320C55_and2: int  # 216
TMS320C55_and3: int  # 217
TMS320C55_asub: int  # 90
TMS320C55_b: int  # 241
TMS320C55_band: int  # 196
TMS320C55_bcc: int  # 239
TMS320C55_bccu: int  # 240
TMS320C55_bclr1: int  # 207
TMS320C55_bclr2: int  # 201
TMS320C55_bcnt: int  # 212
TMS320C55_bfxpa: int  # 197
TMS320C55_bfxtr: int  # 198
TMS320C55_bnot: int  # 200
TMS320C55_bset1: int  # 208
TMS320C55_bset2: int  # 202
TMS320C55_btst: int  # 199
TMS320C55_btst_mov: int  # 80
TMS320C55_btstclr: int  # 204
TMS320C55_btstnot: int  # 205
TMS320C55_btstp: int  # 206
TMS320C55_btstset: int  # 203
TMS320C55_call: int  # 243
TMS320C55_callcc: int  # 242
TMS320C55_cmp: int  # 87
TMS320C55_cmpand: int  # 177
TMS320C55_cmpandu: int  # 178
TMS320C55_cmpor: int  # 179
TMS320C55_cmporu: int  # 180
TMS320C55_cmpu: int  # 88
TMS320C55_delay: int  # 234
TMS320C55_dmaxdiff: int  # 13
TMS320C55_dmindiff: int  # 15
TMS320C55_exp: int  # 176
TMS320C55_firsadd: int  # 65
TMS320C55_firssub: int  # 66
TMS320C55_idle: int  # 246
TMS320C55_intr: int  # 258
TMS320C55_last: int  # 261
TMS320C55_lms: int  # 82
TMS320C55_mac3: int  # 123
TMS320C55_mac4: int  # 124
TMS320C55_mac40_mac40: int  # 42
TMS320C55_mac40_mpy40: int  # 30
TMS320C55_mac_mac: int  # 40
TMS320C55_mac_mpy: int  # 28
TMS320C55_mack3: int  # 127
TMS320C55_mack4: int  # 128
TMS320C55_mackr3: int  # 129
TMS320C55_mackr4: int  # 130
TMS320C55_macm2: int  # 131
TMS320C55_macm3: int  # 132
TMS320C55_macm4: int  # 133
TMS320C55_macm403: int  # 137
TMS320C55_macm404: int  # 138
TMS320C55_macm_mov: int  # 69
TMS320C55_macmk3: int  # 147
TMS320C55_macmk4: int  # 148
TMS320C55_macmkr3: int  # 149
TMS320C55_macmkr4: int  # 150
TMS320C55_macmr2: int  # 134
TMS320C55_macmr3: int  # 135
TMS320C55_macmr4: int  # 136
TMS320C55_macmr403: int  # 139
TMS320C55_macmr404: int  # 140
TMS320C55_macmr_mov: int  # 70
TMS320C55_macmrz: int  # 142
TMS320C55_macmz: int  # 141
TMS320C55_macr3: int  # 125
TMS320C55_macr4: int  # 126
TMS320C55_macr40_macr40: int  # 43
TMS320C55_macr40_mpyr40: int  # 31
TMS320C55_macr_macr: int  # 41
TMS320C55_macr_mpyr: int  # 29
TMS320C55_mant_nexp: int  # 175
TMS320C55_mas2: int  # 155
TMS320C55_mas3: int  # 156
TMS320C55_mas40_mac40: int  # 46
TMS320C55_mas40_mas40: int  # 54
TMS320C55_mas40_mpy40: int  # 34
TMS320C55_mas_mac: int  # 44
TMS320C55_mas_mas: int  # 52
TMS320C55_mas_mpy: int  # 32
TMS320C55_masm2: int  # 159
TMS320C55_masm3: int  # 160
TMS320C55_masm4: int  # 161
TMS320C55_masm403: int  # 165
TMS320C55_masm404: int  # 166
TMS320C55_masm_mov: int  # 71
TMS320C55_masmr2: int  # 162
TMS320C55_masmr3: int  # 163
TMS320C55_masmr4: int  # 164
TMS320C55_masmr403: int  # 167
TMS320C55_masmr404: int  # 168
TMS320C55_masmr_mov: int  # 72
TMS320C55_masr2: int  # 157
TMS320C55_masr3: int  # 158
TMS320C55_masr40_macr40: int  # 47
TMS320C55_masr40_masr40: int  # 55
TMS320C55_masr40_mpyr40: int  # 35
TMS320C55_masr_macr: int  # 45
TMS320C55_masr_masr: int  # 53
TMS320C55_masr_mpyr: int  # 33
TMS320C55_max1: int  # 83
TMS320C55_max2: int  # 84
TMS320C55_maxdiff: int  # 12
TMS320C55_min1: int  # 85
TMS320C55_min2: int  # 86
TMS320C55_mindiff: int  # 14
TMS320C55_mov2: int  # 231
TMS320C55_mov3: int  # 232
TMS320C55_mov402: int  # 233
TMS320C55_mov_aadd: int  # 76
TMS320C55_mov_add: int  # 77
TMS320C55_mov_asub: int  # 81
TMS320C55_mov_mov: int  # 75
TMS320C55_mpy1: int  # 97
TMS320C55_mpy2: int  # 98
TMS320C55_mpy3: int  # 99
TMS320C55_mpy40_mac40: int  # 62
TMS320C55_mpy_mac: int  # 60
TMS320C55_mpy_mpy: int  # 24
TMS320C55_mpy_mpy40: int  # 26
TMS320C55_mpy_mpyr: int  # 25
TMS320C55_mpy_mpyr40: int  # 27
TMS320C55_mpyk2: int  # 103
TMS320C55_mpyk3: int  # 104
TMS320C55_mpykr2: int  # 105
TMS320C55_mpykr3: int  # 106
TMS320C55_mpym2: int  # 107
TMS320C55_mpym3: int  # 108
TMS320C55_mpym403: int  # 111
TMS320C55_mpym_mov: int  # 67
TMS320C55_mpymk: int  # 117
TMS320C55_mpymkr: int  # 118
TMS320C55_mpymr2: int  # 109
TMS320C55_mpymr3: int  # 110
TMS320C55_mpymr403: int  # 112
TMS320C55_mpymr_mov: int  # 68
TMS320C55_mpymru3: int  # 114
TMS320C55_mpymu3: int  # 113
TMS320C55_mpyr1: int  # 100
TMS320C55_mpyr2: int  # 101
TMS320C55_mpyr3: int  # 102
TMS320C55_mpyr40_macr40: int  # 63
TMS320C55_mpyr_macr: int  # 61
TMS320C55_neg1: int  # 173
TMS320C55_neg2: int  # 174
TMS320C55_nop: int  # 247
TMS320C55_nop_16: int  # 248
TMS320C55_not1: int  # 213
TMS320C55_not2: int  # 214
TMS320C55_null: int  # 0
TMS320C55_or1: int  # 218
TMS320C55_or2: int  # 219
TMS320C55_or3: int  # 220
TMS320C55_pop1: int  # 235
TMS320C55_pop2: int  # 236
TMS320C55_popboth: int  # 210
TMS320C55_psh1: int  # 237
TMS320C55_psh2: int  # 238
TMS320C55_pshboth: int  # 211
TMS320C55_reset: int  # 259
TMS320C55_ret: int  # 256
TMS320C55_retcc: int  # 255
TMS320C55_reti: int  # 257
TMS320C55_rol: int  # 226
TMS320C55_ror: int  # 227
TMS320C55_round1: int  # 181
TMS320C55_round2: int  # 182
TMS320C55_rpt: int  # 252
TMS320C55_rptadd: int  # 253
TMS320C55_rptb: int  # 250
TMS320C55_rptblocal: int  # 249
TMS320C55_rptcc: int  # 251
TMS320C55_rptsub: int  # 254
TMS320C55_sat1: int  # 183
TMS320C55_sat2: int  # 184
TMS320C55_satr1: int  # 185
TMS320C55_satr2: int  # 186
TMS320C55_sftcc: int  # 19
TMS320C55_sftl2: int  # 224
TMS320C55_sftl3: int  # 225
TMS320C55_sfts2: int  # 187
TMS320C55_sfts3: int  # 188
TMS320C55_sftsc2: int  # 189
TMS320C55_sftsc3: int  # 190
TMS320C55_sqa1: int  # 119
TMS320C55_sqa2: int  # 120
TMS320C55_sqam2: int  # 143
TMS320C55_sqam3: int  # 144
TMS320C55_sqamr2: int  # 145
TMS320C55_sqamr3: int  # 146
TMS320C55_sqar1: int  # 121
TMS320C55_sqar2: int  # 122
TMS320C55_sqdst: int  # 191
TMS320C55_sqr1: int  # 93
TMS320C55_sqr2: int  # 94
TMS320C55_sqrm: int  # 115
TMS320C55_sqrmr: int  # 116
TMS320C55_sqrr1: int  # 95
TMS320C55_sqrr2: int  # 96
TMS320C55_sqs1: int  # 151
TMS320C55_sqs2: int  # 152
TMS320C55_sqsm2: int  # 169
TMS320C55_sqsm3: int  # 170
TMS320C55_sqsmr2: int  # 171
TMS320C55_sqsmr3: int  # 172
TMS320C55_sqsr1: int  # 153
TMS320C55_sqsr2: int  # 154
TMS320C55_sub1: int  # 192
TMS320C55_sub2: int  # 193
TMS320C55_sub3: int  # 194
TMS320C55_sub4: int  # 195
TMS320C55_sub_mov: int  # 74
TMS320C55_subadd: int  # 23
TMS320C55_subc2: int  # 20
TMS320C55_subc3: int  # 21
TMS320C55_swap: int  # 228
TMS320C55_swap4: int  # 230
TMS320C55_swapp: int  # 229
TMS320C55_trap: int  # 260
TMS320C55_xcc: int  # 244
TMS320C55_xccpart: int  # 245
TMS320C55_xor1: int  # 221
TMS320C55_xor2: int  # 222
TMS320C55_xor3: int  # 223
TMS6_abs: int  # 1
TMS6_abs2: int  # 78
TMS6_absdp: int  # 79
TMS6_abssp: int  # 80
TMS6_add: int  # 2
TMS6_add2: int  # 8
TMS6_add4: int  # 81
TMS6_addab: int  # 4
TMS6_addad: int  # 82
TMS6_addah: int  # 5
TMS6_addaw: int  # 6
TMS6_adddp: int  # 83
TMS6_addk: int  # 7
TMS6_addkpc: int  # 84
TMS6_addsp: int  # 85
TMS6_addsub: int  # 86
TMS6_addsub2: int  # 87
TMS6_addu: int  # 3
TMS6_and: int  # 9
TMS6_andn: int  # 88
TMS6_avg2: int  # 89
TMS6_avgu4: int  # 90
TMS6_b: int  # 10
TMS6_bdec: int  # 91
TMS6_bitc4: int  # 92
TMS6_bitr: int  # 93
TMS6_bnop: int  # 94
TMS6_bpos: int  # 95
TMS6_callp: int  # 96
TMS6_ccmatmpy: int  # 233
TMS6_ccmatmpyr1: int  # 231
TMS6_ccmpy32r1: int  # 232
TMS6_clr: int  # 11
TMS6_cmatmpy: int  # 230
TMS6_cmatmpyr1: int  # 234
TMS6_cmpeq: int  # 12
TMS6_cmpeq2: int  # 97
TMS6_cmpeq4: int  # 98
TMS6_cmpeqdp: int  # 99
TMS6_cmpeqsp: int  # 100
TMS6_cmpgt: int  # 13
TMS6_cmpgt2: int  # 101
TMS6_cmpgtdp: int  # 102
TMS6_cmpgtsp: int  # 103
TMS6_cmpgtu: int  # 14
TMS6_cmpgtu4: int  # 104
TMS6_cmplt: int  # 15
TMS6_cmplt2: int  # 105
TMS6_cmpltdp: int  # 106
TMS6_cmpltsp: int  # 107
TMS6_cmpltu: int  # 16
TMS6_cmpltu4: int  # 108
TMS6_cmpy: int  # 109
TMS6_cmpyr: int  # 110
TMS6_cmpyr1: int  # 111
TMS6_cmpysp: int  # 235
TMS6_crot270: int  # 237
TMS6_crot90: int  # 236
TMS6_dadd: int  # 238
TMS6_dadd2: int  # 239
TMS6_daddsp: int  # 240
TMS6_dapys2: int  # 241
TMS6_davg2: int  # 242
TMS6_davgnr2: int  # 243
TMS6_davgnru4: int  # 244
TMS6_davgu4: int  # 245
TMS6_dccmpy: int  # 246
TMS6_dccmpyr1: int  # 247
TMS6_dcmpeq2: int  # 248
TMS6_dcmpeq4: int  # 249
TMS6_dcmpgt2: int  # 250
TMS6_dcmpgtu4: int  # 251
TMS6_dcmpy: int  # 252
TMS6_dcmpyr1: int  # 253
TMS6_dcrot270: int  # 254
TMS6_dcrot90: int  # 255
TMS6_ddotp4: int  # 112
TMS6_ddotph2: int  # 113
TMS6_ddotph2r: int  # 114
TMS6_ddotpl2: int  # 115
TMS6_ddotpl2r: int  # 116
TMS6_deal: int  # 117
TMS6_dint: int  # 118
TMS6_dinthspu: int  # 256
TMS6_dintspu: int  # 257
TMS6_dmax2: int  # 258
TMS6_dmaxu4: int  # 259
TMS6_dmin2: int  # 260
TMS6_dminu4: int  # 261
TMS6_dmpy2: int  # 262
TMS6_dmpysp: int  # 263
TMS6_dmpysu4: int  # 264
TMS6_dmpyu2: int  # 265
TMS6_dmpyu4: int  # 266
TMS6_dmv: int  # 119
TMS6_dmvd: int  # 267
TMS6_dotp2: int  # 120
TMS6_dotpn2: int  # 121
TMS6_dotpnrsu2: int  # 122
TMS6_dotpnrus2: int  # 123
TMS6_dotprsu2: int  # 124
TMS6_dotprus2: int  # 125
TMS6_dotpsu4: int  # 126
TMS6_dotpu4: int  # 127
TMS6_dotpus4: int  # 128
TMS6_dpack2: int  # 129
TMS6_dpackh2: int  # 268
TMS6_dpackh4: int  # 269
TMS6_dpackhl2: int  # 270
TMS6_dpackl2: int  # 271
TMS6_dpackl4: int  # 272
TMS6_dpacklh2: int  # 273
TMS6_dpackx2: int  # 130
TMS6_dpint: int  # 131
TMS6_dpsp: int  # 132
TMS6_dptrunc: int  # 133
TMS6_dsadd: int  # 274
TMS6_dsadd2: int  # 275
TMS6_dshl: int  # 276
TMS6_dshl2: int  # 277
TMS6_dshr: int  # 278
TMS6_dshr2: int  # 279
TMS6_dshru: int  # 280
TMS6_dshru2: int  # 281
TMS6_dsmpy2: int  # 282
TMS6_dspacku4: int  # 283
TMS6_dspint: int  # 284
TMS6_dspinth: int  # 285
TMS6_dssub: int  # 286
TMS6_dssub2: int  # 287
TMS6_dsub: int  # 288
TMS6_dsub2: int  # 289
TMS6_dsubsp: int  # 290
TMS6_dxpnd2: int  # 291
TMS6_dxpnd4: int  # 292
TMS6_ext: int  # 17
TMS6_extu: int  # 18
TMS6_fadddp: int  # 293
TMS6_faddsp: int  # 294
TMS6_fmpydp: int  # 295
TMS6_fphead: int  # 310
TMS6_fsubdp: int  # 296
TMS6_fsubsp: int  # 297
TMS6_gmpy: int  # 134
TMS6_gmpy4: int  # 135
TMS6_idle: int  # 19
TMS6_intdp: int  # 136
TMS6_intdpu: int  # 137
TMS6_intsp: int  # 138
TMS6_intspu: int  # 139
TMS6_land: int  # 298
TMS6_landn: int  # 299
TMS6_last: int  # 311
TMS6_ldb: int  # 20
TMS6_ldbu: int  # 21
TMS6_lddw: int  # 140
TMS6_ldh: int  # 22
TMS6_ldhu: int  # 23
TMS6_ldndw: int  # 141
TMS6_ldnw: int  # 142
TMS6_ldw: int  # 24
TMS6_lmbd: int  # 25
TMS6_lor: int  # 300
TMS6_max2: int  # 143
TMS6_maxu4: int  # 144
TMS6_mfence: int  # 301
TMS6_min2: int  # 145
TMS6_minu4: int  # 146
TMS6_mpy: int  # 26
TMS6_mpy2: int  # 147
TMS6_mpy2ir: int  # 148
TMS6_mpy32: int  # 149
TMS6_mpy32su: int  # 150
TMS6_mpy32u: int  # 151
TMS6_mpy32us: int  # 152
TMS6_mpydp: int  # 153
TMS6_mpyh: int  # 30
TMS6_mpyhi: int  # 154
TMS6_mpyhir: int  # 155
TMS6_mpyhl: int  # 34
TMS6_mpyhlu: int  # 35
TMS6_mpyhslu: int  # 37
TMS6_mpyhsu: int  # 33
TMS6_mpyhu: int  # 31
TMS6_mpyhuls: int  # 36
TMS6_mpyhus: int  # 32
TMS6_mpyi: int  # 156
TMS6_mpyid: int  # 157
TMS6_mpyih: int  # 158
TMS6_mpyihr: int  # 159
TMS6_mpyil: int  # 160
TMS6_mpyilr: int  # 161
TMS6_mpylh: int  # 38
TMS6_mpylhu: int  # 39
TMS6_mpyli: int  # 162
TMS6_mpylir: int  # 163
TMS6_mpylshu: int  # 41
TMS6_mpyluhs: int  # 40
TMS6_mpysp: int  # 164
TMS6_mpysp2dp: int  # 165
TMS6_mpyspdp: int  # 166
TMS6_mpysu: int  # 29
TMS6_mpysu4: int  # 167
TMS6_mpyu: int  # 27
TMS6_mpyu2: int  # 302
TMS6_mpyu4: int  # 168
TMS6_mpyus: int  # 28
TMS6_mpyus4: int  # 169
TMS6_mv: int  # 42
TMS6_mvc: int  # 43
TMS6_mvd: int  # 170
TMS6_mvk: int  # 44
TMS6_mvkh: int  # 45
TMS6_mvkl: int  # 171
TMS6_mvklh: int  # 46
TMS6_neg: int  # 47
TMS6_nop: int  # 48
TMS6_norm: int  # 49
TMS6_not: int  # 50
TMS6_null: int  # 0
TMS6_or: int  # 51
TMS6_pack2: int  # 172
TMS6_packh2: int  # 173
TMS6_packh4: int  # 174
TMS6_packhl2: int  # 175
TMS6_packl4: int  # 176
TMS6_packlh2: int  # 177
TMS6_qmpy32: int  # 303
TMS6_qmpysp: int  # 304
TMS6_qsmpy32r1: int  # 305
TMS6_rcpdp: int  # 178
TMS6_rcpsp: int  # 179
TMS6_rint: int  # 180
TMS6_rotl: int  # 181
TMS6_rpack2: int  # 182
TMS6_rsqrdp: int  # 183
TMS6_rsqrsp: int  # 184
TMS6_sadd: int  # 52
TMS6_sadd2: int  # 185
TMS6_saddsu2: int  # 186
TMS6_saddsub: int  # 187
TMS6_saddsub2: int  # 188
TMS6_saddu4: int  # 189
TMS6_saddus2: int  # 190
TMS6_sat: int  # 53
TMS6_set: int  # 54
TMS6_shfl: int  # 191
TMS6_shfl3: int  # 192
TMS6_shl: int  # 55
TMS6_shl2: int  # 306
TMS6_shlmb: int  # 193
TMS6_shr: int  # 56
TMS6_shr2: int  # 194
TMS6_shrmb: int  # 195
TMS6_shru: int  # 57
TMS6_shru2: int  # 196
TMS6_smpy: int  # 58
TMS6_smpy2: int  # 197
TMS6_smpy32: int  # 198
TMS6_smpyh: int  # 61
TMS6_smpyhl: int  # 59
TMS6_smpylh: int  # 60
TMS6_spack2: int  # 199
TMS6_spacku4: int  # 200
TMS6_spdp: int  # 201
TMS6_spint: int  # 202
TMS6_spkernel: int  # 203
TMS6_spkernelr: int  # 204
TMS6_sploop: int  # 205
TMS6_sploopd: int  # 206
TMS6_sploopw: int  # 207
TMS6_spmask: int  # 208
TMS6_spmaskr: int  # 209
TMS6_sptrunc: int  # 210
TMS6_sshl: int  # 62
TMS6_sshvl: int  # 211
TMS6_sshvr: int  # 212
TMS6_ssub: int  # 63
TMS6_ssub2: int  # 213
TMS6_stb: int  # 64
TMS6_stbu: int  # 65
TMS6_stdw: int  # 214
TMS6_sth: int  # 66
TMS6_sthu: int  # 67
TMS6_stndw: int  # 215
TMS6_stnw: int  # 216
TMS6_stw: int  # 68
TMS6_sub: int  # 69
TMS6_sub2: int  # 75
TMS6_sub4: int  # 217
TMS6_subab: int  # 71
TMS6_subabs4: int  # 218
TMS6_subah: int  # 72
TMS6_subaw: int  # 73
TMS6_subc: int  # 74
TMS6_subdp: int  # 219
TMS6_subsp: int  # 220
TMS6_subu: int  # 70
TMS6_swap2: int  # 221
TMS6_swap4: int  # 222
TMS6_swe: int  # 223
TMS6_swenr: int  # 224
TMS6_unpkbu4: int  # 307
TMS6_unpkh2: int  # 308
TMS6_unpkhu2: int  # 309
TMS6_unpkhu4: int  # 225
TMS6_unpklu4: int  # 226
TMS6_xor: int  # 76
TMS6_xormpy: int  # 227
TMS6_xpnd2: int  # 228
TMS6_xpnd4: int  # 229
TMS6_zero: int  # 77
TMS_abs: int  # 1
TMS_adcb: int  # 2
TMS_add: int  # 3
TMS_addb: int  # 4
TMS_addc: int  # 5
TMS_adds: int  # 6
TMS_addt: int  # 7
TMS_adrk: int  # 8
TMS_and: int  # 9
TMS_andb: int  # 10
TMS_apac: int  # 11
TMS_apl: int  # 12
TMS_apl2: int  # 13
TMS_b: int  # 14
TMS_bacc: int  # 15
TMS_baccd: int  # 16
TMS_banz: int  # 17
TMS_banzd: int  # 18
TMS_bcnd: int  # 19
TMS_bcndd: int  # 20
TMS_bd: int  # 21
TMS_bit: int  # 22
TMS_bitt: int  # 23
TMS_bldd: int  # 24
TMS_bldp: int  # 25
TMS_blpd: int  # 26
TMS_bsar: int  # 27
TMS_cala: int  # 28
TMS_calad: int  # 29
TMS_call: int  # 30
TMS_calld: int  # 31
TMS_cc: int  # 32
TMS_ccd: int  # 33
TMS_clrc: int  # 34
TMS_cmpl: int  # 35
TMS_cmpr: int  # 36
TMS_cpl: int  # 37
TMS_cpl2: int  # 38
TMS_crgt: int  # 39
TMS_crlt: int  # 40
TMS_dmov: int  # 41
TMS_estop: int  # 42
TMS_exar: int  # 43
TMS_idle: int  # 44
TMS_idle2: int  # 45
TMS_in: int  # 46
TMS_intr: int  # 47
TMS_lacb: int  # 48
TMS_lacc: int  # 49
TMS_lacl: int  # 50
TMS_lact: int  # 51
TMS_lamm: int  # 52
TMS_lar: int  # 53
TMS_last: int  # 273
TMS_ldp: int  # 54
TMS_lmmr: int  # 55
TMS_lph: int  # 56
TMS_lst: int  # 57
TMS_lt: int  # 58
TMS_lta: int  # 59
TMS_ltd: int  # 60
TMS_ltp: int  # 61
TMS_lts: int  # 62
TMS_mac: int  # 63
TMS_macd: int  # 64
TMS_madd: int  # 65
TMS_mads: int  # 66
TMS_mar: int  # 67
TMS_mpy: int  # 68
TMS_mpya: int  # 69
TMS_mpys: int  # 70
TMS_mpyu: int  # 71
TMS_neg: int  # 72
TMS_nmi: int  # 73
TMS_nop: int  # 74
TMS_norm: int  # 75
TMS_null: int  # 0
TMS_opl: int  # 76
TMS_opl2: int  # 77
TMS_or: int  # 78
TMS_orb: int  # 79
TMS_out: int  # 80
TMS_pac: int  # 81
TMS_pop: int  # 82
TMS_popd: int  # 83
TMS_pshd: int  # 84
TMS_push: int  # 85
TMS_ret: int  # 86
TMS_retc: int  # 87
TMS_retcd: int  # 88
TMS_retd: int  # 89
TMS_rete: int  # 90
TMS_reti: int  # 91
TMS_rol: int  # 92
TMS_rolb: int  # 93
TMS_ror: int  # 94
TMS_rorb: int  # 95
TMS_rpt: int  # 96
TMS_rptb: int  # 97
TMS_rptz: int  # 98
TMS_sacb: int  # 99
TMS_sach: int  # 100
TMS_sacl: int  # 101
TMS_samm: int  # 102
TMS_sar: int  # 103
TMS_sath: int  # 104
TMS_satl: int  # 105
TMS_sbb: int  # 106
TMS_sbbb: int  # 107
TMS_sbrk: int  # 108
TMS_setc: int  # 109
TMS_sfl: int  # 110
TMS_sflb: int  # 111
TMS_sfr: int  # 112
TMS_sfrb: int  # 113
TMS_smmr: int  # 114
TMS_spac: int  # 115
TMS_sph: int  # 116
TMS_spl: int  # 117
TMS_splk: int  # 118
TMS_spm: int  # 119
TMS_sqra: int  # 120
TMS_sqrs: int  # 121
TMS_sst: int  # 122
TMS_sub: int  # 123
TMS_subb: int  # 124
TMS_subc: int  # 125
TMS_subs: int  # 126
TMS_subt: int  # 127
TMS_tblr: int  # 128
TMS_tblw: int  # 129
TMS_trap: int  # 130
TMS_xc: int  # 131
TMS_xor: int  # 132
TMS_xorb: int  # 133
TMS_xpl: int  # 134
TMS_xpl2: int  # 135
TMS_zalr: int  # 136
TMS_zap: int  # 137
TMS_zpr: int  # 138
TPOS_LNNUM: str  # 
TPOS_REGCMT: str  # 
TRACE_FULL: int  # 14
TRICORE_abs: int  # 1
TRICORE_abs_b: int  # 2
TRICORE_abs_df: int  # 439
TRICORE_abs_f: int  # 449
TRICORE_abs_h: int  # 3
TRICORE_absdif: int  # 4
TRICORE_absdif_b: int  # 5
TRICORE_absdif_h: int  # 6
TRICORE_absdifs: int  # 7
TRICORE_absdifs_h: int  # 8
TRICORE_abss: int  # 9
TRICORE_abss_h: int  # 10
TRICORE_add16: int  # 14
TRICORE_add16_a: int  # 15
TRICORE_add32: int  # 16
TRICORE_add32_a: int  # 17
TRICORE_add_b: int  # 11
TRICORE_add_df: int  # 441
TRICORE_add_f: int  # 12
TRICORE_add_h: int  # 13
TRICORE_addc: int  # 18
TRICORE_addi: int  # 19
TRICORE_addih: int  # 20
TRICORE_addih_a: int  # 21
TRICORE_adds: int  # 22
TRICORE_adds16: int  # 26
TRICORE_adds_h: int  # 23
TRICORE_adds_hu: int  # 24
TRICORE_adds_u: int  # 25
TRICORE_addsc16_a: int  # 28
TRICORE_addsc32_a: int  # 29
TRICORE_addsc_at: int  # 27
TRICORE_addx: int  # 30
TRICORE_and16: int  # 42
TRICORE_and32: int  # 43
TRICORE_and_and_t: int  # 31
TRICORE_and_andn_t: int  # 32
TRICORE_and_eq: int  # 33
TRICORE_and_ge: int  # 34
TRICORE_and_ge_u: int  # 35
TRICORE_and_lt: int  # 36
TRICORE_and_lt_u: int  # 37
TRICORE_and_ne: int  # 38
TRICORE_and_nor_t: int  # 39
TRICORE_and_or_t: int  # 40
TRICORE_and_t: int  # 41
TRICORE_andn: int  # 44
TRICORE_andn_t: int  # 45
TRICORE_bisr16: int  # 46
TRICORE_bisr32: int  # 47
TRICORE_bmerge: int  # 48
TRICORE_bsplit: int  # 49
TRICORE_cachea_i: int  # 50
TRICORE_cachea_i_vm: int  # 428
TRICORE_cachea_w: int  # 51
TRICORE_cachea_w_vm: int  # 429
TRICORE_cachea_wi: int  # 52
TRICORE_cachea_wi_vm: int  # 430
TRICORE_cachei_i: int  # 382
TRICORE_cachei_i_vm: int  # 431
TRICORE_cachei_w: int  # 383
TRICORE_cachei_w_vm: int  # 432
TRICORE_cachei_wi: int  # 384
TRICORE_cachei_wi_vm: int  # 433
TRICORE_cadd16: int  # 53
TRICORE_cadd32: int  # 54
TRICORE_caddn16: int  # 55
TRICORE_caddn32: int  # 56
TRICORE_call16: int  # 57
TRICORE_call32: int  # 58
TRICORE_calla: int  # 59
TRICORE_calli: int  # 60
TRICORE_calli16: int  # 460
TRICORE_clo: int  # 61
TRICORE_clo_h: int  # 62
TRICORE_cls: int  # 63
TRICORE_cls_h: int  # 64
TRICORE_clz: int  # 65
TRICORE_clz_h: int  # 66
TRICORE_cmov16: int  # 67
TRICORE_cmovn16: int  # 68
TRICORE_cmp_df: int  # 436
TRICORE_cmp_f: int  # 69
TRICORE_cmpswap_w: int  # 398
TRICORE_crc32: int  # 396
TRICORE_crc32_b: int  # 400
TRICORE_crc32l_w: int  # 401
TRICORE_crcn: int  # 402
TRICORE_csub: int  # 70
TRICORE_csubn: int  # 71
TRICORE_debug16: int  # 72
TRICORE_debug32: int  # 73
TRICORE_dextr: int  # 74
TRICORE_dftof: int  # 421
TRICORE_dftoi: int  # 418
TRICORE_dftoin: int  # 417
TRICORE_dftoiz: int  # 426
TRICORE_dftol: int  # 420
TRICORE_dftolz: int  # 423
TRICORE_dftou: int  # 422
TRICORE_dftoul: int  # 419
TRICORE_dftoulz: int  # 425
TRICORE_dftouz: int  # 424
TRICORE_disable: int  # 75
TRICORE_div: int  # 385
TRICORE_div64: int  # 454
TRICORE_div64_u: int  # 453
TRICORE_div_df: int  # 437
TRICORE_div_f: int  # 76
TRICORE_div_u: int  # 386
TRICORE_dsync: int  # 77
TRICORE_dvadj: int  # 78
TRICORE_dvinit: int  # 79
TRICORE_dvinit_b: int  # 80
TRICORE_dvinit_bu: int  # 81
TRICORE_dvinit_h: int  # 82
TRICORE_dvinit_hu: int  # 83
TRICORE_dvinit_u: int  # 84
TRICORE_dvstep: int  # 85
TRICORE_dvstep_u: int  # 86
TRICORE_enable: int  # 87
TRICORE_eq16: int  # 92
TRICORE_eq32: int  # 93
TRICORE_eq_a: int  # 88
TRICORE_eq_b: int  # 89
TRICORE_eq_h: int  # 90
TRICORE_eq_w: int  # 91
TRICORE_eqany_b: int  # 94
TRICORE_eqany_h: int  # 95
TRICORE_eqz_a: int  # 96
TRICORE_extr: int  # 97
TRICORE_extr_u: int  # 98
TRICORE_fcall: int  # 387
TRICORE_fcalla: int  # 388
TRICORE_fcalli: int  # 389
TRICORE_fret16: int  # 390
TRICORE_fret32: int  # 391
TRICORE_ftodf: int  # 413
TRICORE_ftohp: int  # 406
TRICORE_ftoi: int  # 99
TRICORE_ftoin: int  # 427
TRICORE_ftoiz: int  # 392
TRICORE_ftoq31: int  # 100
TRICORE_ftoq31z: int  # 393
TRICORE_ftou: int  # 101
TRICORE_ftouz: int  # 394
TRICORE_ge: int  # 102
TRICORE_ge_a: int  # 103
TRICORE_ge_u: int  # 104
TRICORE_hptof: int  # 407
TRICORE_hvcall: int  # 411
TRICORE_imask: int  # 105
TRICORE_ins_t: int  # 106
TRICORE_insert: int  # 107
TRICORE_insn_t: int  # 108
TRICORE_isync: int  # 109
TRICORE_itodf: int  # 416
TRICORE_itof: int  # 110
TRICORE_ixmax: int  # 111
TRICORE_ixmax_u: int  # 112
TRICORE_ixmin: int  # 113
TRICORE_ixmin_u: int  # 114
TRICORE_j16: int  # 115
TRICORE_j32: int  # 116
TRICORE_ja: int  # 117
TRICORE_jeq16: int  # 119
TRICORE_jeq32: int  # 120
TRICORE_jeq_a: int  # 118
TRICORE_jge: int  # 121
TRICORE_jge_u: int  # 122
TRICORE_jgez16: int  # 123
TRICORE_jgtz16: int  # 124
TRICORE_ji16: int  # 125
TRICORE_ji32: int  # 126
TRICORE_jl: int  # 127
TRICORE_jla: int  # 128
TRICORE_jlez16: int  # 129
TRICORE_jli: int  # 130
TRICORE_jlt: int  # 131
TRICORE_jlt_u: int  # 132
TRICORE_jltz16: int  # 133
TRICORE_jne16: int  # 135
TRICORE_jne32: int  # 136
TRICORE_jne_a: int  # 134
TRICORE_jned: int  # 137
TRICORE_jnei: int  # 138
TRICORE_jnz16: int  # 139
TRICORE_jnz16_a: int  # 140
TRICORE_jnz16_t: int  # 141
TRICORE_jnz32_a: int  # 142
TRICORE_jnz32_t: int  # 143
TRICORE_jri: int  # 459
TRICORE_jz16: int  # 144
TRICORE_jz16_a: int  # 145
TRICORE_jz16_t: int  # 146
TRICORE_jz32_a: int  # 147
TRICORE_jz32_t: int  # 148
TRICORE_last: int  # 461
TRICORE_ld16_a: int  # 154
TRICORE_ld16_bu: int  # 155
TRICORE_ld16_h: int  # 156
TRICORE_ld16_w: int  # 157
TRICORE_ld32_a: int  # 158
TRICORE_ld32_bu: int  # 159
TRICORE_ld32_h: int  # 160
TRICORE_ld32_w: int  # 161
TRICORE_ld_b: int  # 149
TRICORE_ld_d: int  # 150
TRICORE_ld_da: int  # 151
TRICORE_ld_dd: int  # 451
TRICORE_ld_hu: int  # 152
TRICORE_ld_q: int  # 153
TRICORE_ldlcx: int  # 162
TRICORE_ldmst: int  # 163
TRICORE_lducx: int  # 164
TRICORE_lea: int  # 165
TRICORE_lha: int  # 405
TRICORE_loop16: int  # 166
TRICORE_loop32: int  # 167
TRICORE_loopu: int  # 168
TRICORE_lsync: int  # 409
TRICORE_lt16: int  # 177
TRICORE_lt32: int  # 178
TRICORE_lt_a: int  # 169
TRICORE_lt_b: int  # 170
TRICORE_lt_bu: int  # 171
TRICORE_lt_h: int  # 172
TRICORE_lt_hu: int  # 173
TRICORE_lt_u: int  # 174
TRICORE_lt_w: int  # 175
TRICORE_lt_wu: int  # 176
TRICORE_ltodf: int  # 412
TRICORE_madd: int  # 179
TRICORE_madd_df: int  # 443
TRICORE_madd_f: int  # 180
TRICORE_madd_h: int  # 181
TRICORE_madd_q: int  # 182
TRICORE_madd_u: int  # 183
TRICORE_maddm_h: int  # 184
TRICORE_maddms_h: int  # 185
TRICORE_maddr_h: int  # 186
TRICORE_maddr_q: int  # 187
TRICORE_maddrs_h: int  # 188
TRICORE_maddrs_q: int  # 189
TRICORE_madds: int  # 190
TRICORE_madds_h: int  # 191
TRICORE_madds_q: int  # 192
TRICORE_madds_u: int  # 193
TRICORE_maddsu_h: int  # 194
TRICORE_maddsum_h: int  # 195
TRICORE_maddsums_h: int  # 196
TRICORE_maddsur_h: int  # 197
TRICORE_maddsurs_h: int  # 198
TRICORE_maddsus_h: int  # 199
TRICORE_max: int  # 200
TRICORE_max_b: int  # 201
TRICORE_max_bu: int  # 202
TRICORE_max_df: int  # 442
TRICORE_max_f: int  # 447
TRICORE_max_h: int  # 203
TRICORE_max_hu: int  # 204
TRICORE_max_u: int  # 205
TRICORE_mfcr: int  # 206
TRICORE_mfdcr: int  # 434
TRICORE_min: int  # 207
TRICORE_min_b: int  # 208
TRICORE_min_bu: int  # 209
TRICORE_min_df: int  # 445
TRICORE_min_f: int  # 450
TRICORE_min_h: int  # 210
TRICORE_min_hu: int  # 211
TRICORE_min_u: int  # 212
TRICORE_mov16: int  # 214
TRICORE_mov16_a: int  # 215
TRICORE_mov16_aa: int  # 216
TRICORE_mov16_d: int  # 217
TRICORE_mov32: int  # 218
TRICORE_mov32_a: int  # 219
TRICORE_mov32_aa: int  # 220
TRICORE_mov32_d: int  # 221
TRICORE_mov_u: int  # 213
TRICORE_movh: int  # 222
TRICORE_movh_a: int  # 223
TRICORE_msub: int  # 224
TRICORE_msub_df: int  # 444
TRICORE_msub_f: int  # 225
TRICORE_msub_h: int  # 226
TRICORE_msub_q: int  # 227
TRICORE_msub_u: int  # 228
TRICORE_msubad_h: int  # 229
TRICORE_msubadm_h: int  # 230
TRICORE_msubadms_h: int  # 231
TRICORE_msubadr_h: int  # 232
TRICORE_msubadrs_h: int  # 233
TRICORE_msubads_h: int  # 234
TRICORE_msubm_h: int  # 235
TRICORE_msubms_h: int  # 236
TRICORE_msubr_h: int  # 237
TRICORE_msubr_q: int  # 238
TRICORE_msubrs_h: int  # 239
TRICORE_msubrs_q: int  # 240
TRICORE_msubs: int  # 241
TRICORE_msubs_h: int  # 242
TRICORE_msubs_q: int  # 243
TRICORE_msubs_u: int  # 244
TRICORE_mtcr: int  # 245
TRICORE_mtdcr: int  # 435
TRICORE_mul16: int  # 250
TRICORE_mul32: int  # 251
TRICORE_mul_df: int  # 438
TRICORE_mul_f: int  # 246
TRICORE_mul_h: int  # 247
TRICORE_mul_q: int  # 248
TRICORE_mul_u: int  # 249
TRICORE_mulm_h: int  # 252
TRICORE_mulms_h: int  # 253
TRICORE_mulp_b: int  # 457
TRICORE_mulr_h: int  # 254
TRICORE_mulr_q: int  # 255
TRICORE_muls: int  # 256
TRICORE_muls_u: int  # 257
TRICORE_nand: int  # 258
TRICORE_nand_t: int  # 259
TRICORE_ne: int  # 260
TRICORE_ne_a: int  # 261
TRICORE_neg_df: int  # 446
TRICORE_neg_f: int  # 448
TRICORE_nez_a: int  # 262
TRICORE_nop16: int  # 263
TRICORE_nop32: int  # 264
TRICORE_nor32: int  # 267
TRICORE_nor_t: int  # 265
TRICORE_not16: int  # 266
TRICORE_null: int  # 0
TRICORE_or16: int  # 279
TRICORE_or32: int  # 280
TRICORE_or_and_t: int  # 268
TRICORE_or_andn_t: int  # 269
TRICORE_or_eq: int  # 270
TRICORE_or_ge: int  # 271
TRICORE_or_ge_u: int  # 272
TRICORE_or_lt: int  # 273
TRICORE_or_lt_u: int  # 274
TRICORE_or_ne: int  # 275
TRICORE_or_nor_t: int  # 276
TRICORE_or_or_t: int  # 277
TRICORE_or_t: int  # 278
TRICORE_orn: int  # 281
TRICORE_orn_t: int  # 282
TRICORE_pack: int  # 283
TRICORE_parity: int  # 284
TRICORE_popcnt_w: int  # 404
TRICORE_q31tof: int  # 285
TRICORE_qseed_df: int  # 458
TRICORE_qseed_f: int  # 286
TRICORE_rem64: int  # 455
TRICORE_rem64_u: int  # 456
TRICORE_restore: int  # 395
TRICORE_ret16: int  # 287
TRICORE_ret32: int  # 288
TRICORE_rfe16: int  # 289
TRICORE_rfe32: int  # 290
TRICORE_rfh: int  # 408
TRICORE_rfm: int  # 291
TRICORE_rslcx: int  # 292
TRICORE_rstv: int  # 293
TRICORE_rsub16: int  # 294
TRICORE_rsub32: int  # 295
TRICORE_rsubs: int  # 296
TRICORE_rsubs_u: int  # 297
TRICORE_sat16_b: int  # 298
TRICORE_sat16_bu: int  # 299
TRICORE_sat16_h: int  # 300
TRICORE_sat16_hu: int  # 301
TRICORE_sat32_b: int  # 302
TRICORE_sat32_bu: int  # 303
TRICORE_sat32_h: int  # 304
TRICORE_sat32_hu: int  # 305
TRICORE_sel: int  # 306
TRICORE_seln: int  # 307
TRICORE_sh16: int  # 323
TRICORE_sh32: int  # 324
TRICORE_sh_and_t: int  # 308
TRICORE_sh_andn_t: int  # 309
TRICORE_sh_eq: int  # 310
TRICORE_sh_ge: int  # 311
TRICORE_sh_ge_u: int  # 312
TRICORE_sh_h: int  # 313
TRICORE_sh_lt: int  # 314
TRICORE_sh_lt_u: int  # 315
TRICORE_sh_nand_t: int  # 316
TRICORE_sh_ne: int  # 317
TRICORE_sh_nor_t: int  # 318
TRICORE_sh_or_t: int  # 319
TRICORE_sh_orn_t: int  # 320
TRICORE_sh_xnor_t: int  # 321
TRICORE_sh_xor_t: int  # 322
TRICORE_sha16: int  # 326
TRICORE_sha32: int  # 327
TRICORE_sha_h: int  # 325
TRICORE_shas: int  # 328
TRICORE_shuffle: int  # 403
TRICORE_st16_a: int  # 333
TRICORE_st16_b: int  # 334
TRICORE_st16_h: int  # 335
TRICORE_st16_w: int  # 336
TRICORE_st32_a: int  # 337
TRICORE_st32_b: int  # 338
TRICORE_st32_h: int  # 339
TRICORE_st32_w: int  # 340
TRICORE_st_d: int  # 329
TRICORE_st_da: int  # 330
TRICORE_st_dd: int  # 452
TRICORE_st_q: int  # 331
TRICORE_st_t: int  # 332
TRICORE_stlcx: int  # 341
TRICORE_stucx: int  # 342
TRICORE_sub16: int  # 346
TRICORE_sub16_a: int  # 347
TRICORE_sub32: int  # 348
TRICORE_sub32_a: int  # 349
TRICORE_sub_b: int  # 343
TRICORE_sub_df: int  # 440
TRICORE_sub_f: int  # 344
TRICORE_sub_h: int  # 345
TRICORE_subc: int  # 350
TRICORE_subs16: int  # 354
TRICORE_subs32: int  # 355
TRICORE_subs_h: int  # 351
TRICORE_subs_hu: int  # 352
TRICORE_subs_u: int  # 353
TRICORE_subx: int  # 356
TRICORE_svlcx: int  # 357
TRICORE_swap_w: int  # 358
TRICORE_swapmsk_w: int  # 399
TRICORE_syscall: int  # 359
TRICORE_tlbdemap: int  # 360
TRICORE_tlbflush_a: int  # 361
TRICORE_tlbflush_b: int  # 362
TRICORE_tlbmap: int  # 363
TRICORE_tlbprobe_a: int  # 364
TRICORE_tlbprobe_i: int  # 365
TRICORE_trapinv: int  # 410
TRICORE_trapsv: int  # 366
TRICORE_trapv: int  # 367
TRICORE_ultodf: int  # 415
TRICORE_unpack: int  # 368
TRICORE_updfl: int  # 369
TRICORE_utodf: int  # 414
TRICORE_utof: int  # 370
TRICORE_wait: int  # 397
TRICORE_xnor: int  # 371
TRICORE_xnor_t: int  # 372
TRICORE_xor16: int  # 380
TRICORE_xor32: int  # 381
TRICORE_xor_eq: int  # 373
TRICORE_xor_ge: int  # 374
TRICORE_xor_ge_u: int  # 375
TRICORE_xor_lt: int  # 376
TRICORE_xor_lt_u: int  # 377
TRICORE_xor_ne: int  # 378
TRICORE_xor_t: int  # 379
TRIMEDIA_alloc: int  # 172
TRIMEDIA_allocd: int  # 168
TRIMEDIA_allocr: int  # 169
TRIMEDIA_allocx: int  # 170
TRIMEDIA_asl: int  # 20
TRIMEDIA_asli: int  # 12
TRIMEDIA_asr: int  # 19
TRIMEDIA_asri: int  # 11
TRIMEDIA_bitand: int  # 17
TRIMEDIA_bitandinv: int  # 50
TRIMEDIA_bitinv: int  # 51
TRIMEDIA_bitor: int  # 18
TRIMEDIA_bitxor: int  # 49
TRIMEDIA_borrow: int  # 203
TRIMEDIA_carry: int  # 46
TRIMEDIA_curcycles: int  # 141
TRIMEDIA_cycles: int  # 133
TRIMEDIA_dcb: int  # 162
TRIMEDIA_dinvalid: int  # 163
TRIMEDIA_dspiabs: int  # 173
TRIMEDIA_dspiadd: int  # 62
TRIMEDIA_dspidualabs: int  # 174
TRIMEDIA_dspidualadd: int  # 66
TRIMEDIA_dspidualmul: int  # 85
TRIMEDIA_dspidualsub: int  # 67
TRIMEDIA_dspimul: int  # 120
TRIMEDIA_dspisub: int  # 64
TRIMEDIA_dspuadd: int  # 63
TRIMEDIA_dspumul: int  # 121
TRIMEDIA_dspuquadaddui: int  # 74
TRIMEDIA_dspusub: int  # 65
TRIMEDIA_dualasr: int  # 92
TRIMEDIA_dualiclipi: int  # 77
TRIMEDIA_dualuclipi: int  # 78
TRIMEDIA_fabsval: int  # 101
TRIMEDIA_fabsvalflags: int  # 102
TRIMEDIA_fadd: int  # 23
TRIMEDIA_faddflags: int  # 98
TRIMEDIA_fdiv: int  # 94
TRIMEDIA_fdivflags: int  # 95
TRIMEDIA_feql: int  # 127
TRIMEDIA_feqlflags: int  # 128
TRIMEDIA_fgeq: int  # 125
TRIMEDIA_fgeqflags: int  # 126
TRIMEDIA_fgtr: int  # 123
TRIMEDIA_fgtrflags: int  # 124
TRIMEDIA_fleq: int  # 198
TRIMEDIA_fleqflags: int  # 202
TRIMEDIA_fles: int  # 197
TRIMEDIA_flesflags: int  # 201
TRIMEDIA_fmul: int  # 29
TRIMEDIA_fmulflags: int  # 122
TRIMEDIA_fneq: int  # 129
TRIMEDIA_fneqflags: int  # 130
TRIMEDIA_fsign: int  # 131
TRIMEDIA_fsignflags: int  # 132
TRIMEDIA_fsqrt: int  # 96
TRIMEDIA_fsqrtflags: int  # 97
TRIMEDIA_fsub: int  # 99
TRIMEDIA_fsubflags: int  # 100
TRIMEDIA_funshift1: int  # 89
TRIMEDIA_funshift2: int  # 90
TRIMEDIA_funshift3: int  # 91
TRIMEDIA_h_dspiabs: int  # 61
TRIMEDIA_h_dspidualabs: int  # 68
TRIMEDIA_h_iabs: int  # 45
TRIMEDIA_h_st16d: int  # 31
TRIMEDIA_h_st32d: int  # 32
TRIMEDIA_h_st8d: int  # 30
TRIMEDIA_hicycles: int  # 134
TRIMEDIA_iabs: int  # 175
TRIMEDIA_iadd: int  # 13
TRIMEDIA_iaddi: int  # 6
TRIMEDIA_iavgonep: int  # 26
TRIMEDIA_ibytesel: int  # 57
TRIMEDIA_iclipi: int  # 70
TRIMEDIA_iclr: int  # 148
TRIMEDIA_ident: int  # 192
TRIMEDIA_ieql: int  # 38
TRIMEDIA_ieqli: int  # 5
TRIMEDIA_ifir16: int  # 83
TRIMEDIA_ifir8ii: int  # 82
TRIMEDIA_ifir8ui: int  # 81
TRIMEDIA_ifixieee: int  # 107
TRIMEDIA_ifixieeeflags: int  # 108
TRIMEDIA_ifixrz: int  # 22
TRIMEDIA_ifixrzflags: int  # 115
TRIMEDIA_iflip: int  # 73
TRIMEDIA_ifloat: int  # 21
TRIMEDIA_ifloatflags: int  # 116
TRIMEDIA_ifloatrz: int  # 103
TRIMEDIA_ifloatrzflags: int  # 104
TRIMEDIA_igeq: int  # 15
TRIMEDIA_igeqi: int  # 2
TRIMEDIA_igtr: int  # 16
TRIMEDIA_igtri: int  # 1
TRIMEDIA_ijmpf: int  # 147
TRIMEDIA_ijmpi: int  # 145
TRIMEDIA_ijmpt: int  # 143
TRIMEDIA_ild16: int  # 176
TRIMEDIA_ild16d: int  # 7
TRIMEDIA_ild16r: int  # 153
TRIMEDIA_ild16x: int  # 154
TRIMEDIA_ild8: int  # 177
TRIMEDIA_ild8d: int  # 150
TRIMEDIA_ild8r: int  # 151
TRIMEDIA_ileq: int  # 194
TRIMEDIA_ileqi: int  # 43
TRIMEDIA_iles: int  # 193
TRIMEDIA_ilesi: int  # 3
TRIMEDIA_imax: int  # 25
TRIMEDIA_imin: int  # 24
TRIMEDIA_imul: int  # 28
TRIMEDIA_imulm: int  # 118
TRIMEDIA_ineg: int  # 178
TRIMEDIA_ineq: int  # 40
TRIMEDIA_ineqi: int  # 4
TRIMEDIA_inonzero: int  # 48
TRIMEDIA_isub: int  # 14
TRIMEDIA_isubi: int  # 33
TRIMEDIA_izero: int  # 47
TRIMEDIA_jmpf: int  # 146
TRIMEDIA_jmpi: int  # 144
TRIMEDIA_jmpt: int  # 142
TRIMEDIA_last: int  # 207
TRIMEDIA_ld32: int  # 179
TRIMEDIA_ld32d: int  # 8
TRIMEDIA_ld32r: int  # 158
TRIMEDIA_ld32x: int  # 159
TRIMEDIA_lsl: int  # 205
TRIMEDIA_lsli: int  # 206
TRIMEDIA_lsr: int  # 86
TRIMEDIA_lsri: int  # 10
TRIMEDIA_mergedual16lsb: int  # 93
TRIMEDIA_mergelsb: int  # 58
TRIMEDIA_mergemsb: int  # 59
TRIMEDIA_nop: int  # 171
TRIMEDIA_null: int  # 0
TRIMEDIA_pack16lsb: int  # 54
TRIMEDIA_pack16msb: int  # 55
TRIMEDIA_packbytes: int  # 53
TRIMEDIA_pref: int  # 180
TRIMEDIA_pref16x: int  # 166
TRIMEDIA_pref32x: int  # 167
TRIMEDIA_prefd: int  # 164
TRIMEDIA_prefr: int  # 165
TRIMEDIA_quadavg: int  # 69
TRIMEDIA_quadumax: int  # 76
TRIMEDIA_quadumin: int  # 75
TRIMEDIA_quadumulmsb: int  # 79
TRIMEDIA_rdstatus: int  # 161
TRIMEDIA_rdtag: int  # 160
TRIMEDIA_readdpc: int  # 135
TRIMEDIA_readpcsw: int  # 137
TRIMEDIA_readspc: int  # 136
TRIMEDIA_rol: int  # 87
TRIMEDIA_roli: int  # 88
TRIMEDIA_sex16: int  # 52
TRIMEDIA_sex8: int  # 181
TRIMEDIA_st16: int  # 182
TRIMEDIA_st16d: int  # 183
TRIMEDIA_st32: int  # 184
TRIMEDIA_st32d: int  # 185
TRIMEDIA_st8: int  # 186
TRIMEDIA_st8d: int  # 187
TRIMEDIA_ubytesel: int  # 56
TRIMEDIA_uclipi: int  # 71
TRIMEDIA_uclipu: int  # 72
TRIMEDIA_ueql: int  # 199
TRIMEDIA_ueqli: int  # 39
TRIMEDIA_ufir16: int  # 84
TRIMEDIA_ufir8uu: int  # 80
TRIMEDIA_ufixieee: int  # 109
TRIMEDIA_ufixieeeflags: int  # 110
TRIMEDIA_ufixrz: int  # 111
TRIMEDIA_ufixrzflags: int  # 112
TRIMEDIA_ufloat: int  # 113
TRIMEDIA_ufloatflags: int  # 114
TRIMEDIA_ufloatrz: int  # 105
TRIMEDIA_ufloatrzflags: int  # 106
TRIMEDIA_ugeq: int  # 36
TRIMEDIA_ugeqi: int  # 37
TRIMEDIA_ugtr: int  # 34
TRIMEDIA_ugtri: int  # 35
TRIMEDIA_uimm: int  # 149
TRIMEDIA_uld16: int  # 188
TRIMEDIA_uld16d: int  # 155
TRIMEDIA_uld16r: int  # 156
TRIMEDIA_uld16x: int  # 157
TRIMEDIA_uld8: int  # 189
TRIMEDIA_uld8d: int  # 9
TRIMEDIA_uld8r: int  # 152
TRIMEDIA_uleq: int  # 196
TRIMEDIA_uleqi: int  # 44
TRIMEDIA_ules: int  # 195
TRIMEDIA_ulesi: int  # 42
TRIMEDIA_ume8ii: int  # 60
TRIMEDIA_ume8uu: int  # 27
TRIMEDIA_umin: int  # 204
TRIMEDIA_umul: int  # 117
TRIMEDIA_umulm: int  # 119
TRIMEDIA_uneq: int  # 200
TRIMEDIA_uneqi: int  # 41
TRIMEDIA_writedpc: int  # 139
TRIMEDIA_writepcsw: int  # 140
TRIMEDIA_writespc: int  # 138
TRIMEDIA_zex16: int  # 190
TRIMEDIA_zex8: int  # 191
TS_DONTREF: int  # 33554432
TS_MASK: int  # 234881024
TS_NOELL: int  # 134217728
TS_SHRINK: int  # 67108864
TVIS_CMT: int  # 4
TVIS_NAME: int  # 2
TVIS_RPTCMT: int  # 8
TVIS_TYPE: int  # 1
TVST_DEF: int  # 2
TVST_LEVEL: int  # 4
TVST_PRUNE: int  # 1
TYPE_BASE_MASK: int  # 15
TYPE_FLAGS_MASK: int  # 48
TYPE_FULL_MASK: int  # 63
TYPE_MODIF_MASK: int  # 192
TYPID_ISREF: int  # 256
TYPID_SHIFT: int  # 9
UA_MAXOP: int  # 8
UCDR_MANGLED: int  # 4
UCDR_NAME: int  # 2
UCDR_STRLIT: int  # 1
UCDR_TYPE: int  # 8
UIJMP_ACTIVATE: int  # 1
UIJMP_ANYVIEW: int  # 0
UIJMP_DONTPUSH: int  # 2
UIJMP_IDAVIEW: int  # 4
UIJMP_IDAVIEW_NEW: int  # 8
UIJMP_VIEWMASK: int  # 12
ULV_PRECISE_DEFEA: int  # 1
UNHID_FUNC: int  # 2
UNHID_RANGE: int  # 4
UNHID_SEGM: int  # 1
UNSP_adc: int  # 2
UNSP_adc_s: int  # 16
UNSP_add: int  # 1
UNSP_add_s: int  # 15
UNSP_and: int  # 12
UNSP_and_s: int  # 26
UNSP_asr: int  # 66
UNSP_asror: int  # 67
UNSP_break: int  # 65
UNSP_call: int  # 33
UNSP_clrb: int  # 76
UNSP_cmp: int  # 5
UNSP_cmp_s: int  # 19
UNSP_cmpc: int  # 6
UNSP_cmpc_s: int  # 20
UNSP_divq: int  # 56
UNSP_divs: int  # 55
UNSP_exp: int  # 36
UNSP_fiq: int  # 63
UNSP_fir_mov: int  # 59
UNSP_fraction: int  # 60
UNSP_goto: int  # 34
UNSP_int1: int  # 57
UNSP_int2: int  # 58
UNSP_invb: int  # 77
UNSP_irq: int  # 61
UNSP_irqnest: int  # 64
UNSP_ja: int  # 46
UNSP_jae: int  # 38
UNSP_jb: int  # 37
UNSP_jbe: int  # 45
UNSP_je: int  # 42
UNSP_jg: int  # 48
UNSP_jge: int  # 39
UNSP_jl: int  # 40
UNSP_jle: int  # 47
UNSP_jmi: int  # 44
UNSP_jmp: int  # 51
UNSP_jne: int  # 41
UNSP_jpl: int  # 43
UNSP_jvc: int  # 49
UNSP_jvs: int  # 50
UNSP_last: int  # 78
UNSP_load: int  # 10
UNSP_load_s: int  # 24
UNSP_lsl: int  # 68
UNSP_lslor: int  # 69
UNSP_lsr: int  # 70
UNSP_lsror: int  # 71
UNSP_mulss: int  # 52
UNSP_mulus: int  # 53
UNSP_muluu: int  # 54
UNSP_neg: int  # 7
UNSP_neg_s: int  # 21
UNSP_negc: int  # 8
UNSP_negc_s: int  # 22
UNSP_nop: int  # 35
UNSP_null: int  # 0
UNSP_or: int  # 11
UNSP_or_s: int  # 25
UNSP_pop: int  # 31
UNSP_push: int  # 32
UNSP_retf: int  # 29
UNSP_reti: int  # 30
UNSP_rol: int  # 72
UNSP_ror: int  # 73
UNSP_sbc: int  # 4
UNSP_sbc_s: int  # 18
UNSP_secbank: int  # 62
UNSP_setb: int  # 75
UNSP_store: int  # 14
UNSP_store_s: int  # 28
UNSP_sub: int  # 3
UNSP_sub_s: int  # 17
UNSP_test: int  # 13
UNSP_test_s: int  # 27
UNSP_tstb: int  # 74
UNSP_xor: int  # 9
UNSP_xor_s: int  # 23
USE_CURLY_BRACES: int  # 2
USE_KEYBOARD: int  # 0
USE_MOUSE: int  # 1
UTF16BE_BOM: str  # ??
UTF16LE_BOM: str  # ??
UTF32BE_BOM: str  # 
UTF32LE_BOM: str  # ??
UTF8_BOM: str  # ﻿
UTF8_ELLIPSIS: str  # …
UTF8_REPLCHAR: str  # �
UTP_ENUM: int  # 0
UTP_STRUCT: int  # 1
V695_FIXUP_VHIGH: int  # 10
V695_FIXUP_VLOW: int  # 11
V695_REF_OFF8: int  # 0
V695_REF_VHIGH: int  # 7
V695_REF_VLOW: int  # 8
VALSTR_OPEN: int  # 1
VARSLICE_SINGLE: int  # 1
VAULT_CACHE_FNAME: str  # .vault_cache
VAULT_CACHE_SUBDIR: str  # .vault
VDI_EXPR: int  # 1
VDI_FUNC: int  # 3
VDI_LVAR: int  # 2
VDI_NONE: int  # 0
VDI_TAIL: int  # 4
VDRUN_APPEND: int  # 1
VDRUN_CMDLINE: int  # 32
VDRUN_LUMINA: int  # 128
VDRUN_MAYSTOP: int  # 16
VDRUN_NEWFILE: int  # 0
VDRUN_ONLYNEW: int  # 2
VDRUN_PERF: int  # 2097152
VDRUN_SENDIDB: int  # 8
VDRUN_SILENT: int  # 4
VDRUN_STATS: int  # 64
VDUI_VALID: int  # 2
VDUI_VISIBLE: int  # 1
VEL_CMT: int  # 2
VEL_POST: int  # 1
VES_ALT: int  # 2
VES_CTRL: int  # 4
VES_META: int  # 128
VES_MOUSE_LEFT: int  # 8
VES_MOUSE_MIDDLE: int  # 32
VES_MOUSE_RIGHT: int  # 16
VES_SHIFT: int  # 1
VLD_AUTO_REPAIR: int  # 1
VLD_DIALOG: int  # 2
VLD_SILENT: int  # 4
VME_LEFT_BUTTON: int  # 1
VME_MID_BUTTON: int  # 3
VME_RIGHT_BUTTON: int  # 2
VME_UNKNOWN: int  # 0
VNT_IDENT: int  # 6
VNT_STRLIT: int  # 1
VNT_TYPE: int  # 8
VNT_UDTMEM: int  # 2
VNT_VISIBLE: int  # 2
VREF_COPY: int  # 2
VREF_LOOP: int  # 0
VREF_ONCE: int  # 1
VR_AT_END: int  # 1
VR_AT_START: int  # 0
VR_EXACT: int  # 2
VTBL_MEMNAME: str  # __vftable
VTBL_SUFFIX: str  # _vtbl
VT_FLOAT: int  # 3
VT_FUNC: int  # 6
VT_INT64: int  # 9
VT_LONG: int  # 2
VT_OBJ: int  # 5
VT_PVOID: int  # 8
VT_REF: int  # 10
VT_STR: int  # 7
VT_WILD: int  # 4
WARN_ADDR_OUTARGS: int  # 6
WARN_ARRAY_INARG: int  # 21
WARN_BAD_CALL_SP: int  # 38
WARN_BAD_FIELD_TYPE: int  # 23
WARN_BAD_INSN: int  # 49
WARN_BAD_MAPDST: int  # 48
WARN_BAD_PURGED: int  # 12
WARN_BAD_RETVAR: int  # 25
WARN_BAD_SHADOW: int  # 45
WARN_BAD_SP: int  # 40
WARN_BAD_STD_TYPE: int  # 37
WARN_BAD_STKPNT: int  # 41
WARN_BAD_STROFF: int  # 33
WARN_BAD_VALRNG: int  # 44
WARN_BAD_VARSIZE: int  # 34
WARN_CBUILD_LOOPS: int  # 13
WARN_CR_BADOFF: int  # 32
WARN_CR_NOFIELD: int  # 31
WARN_DEP_UNK_CALLS: int  # 7
WARN_EXP_LINVAR: int  # 10
WARN_FIXED_INSN: int  # 29
WARN_FRAG_LVAR: int  # 26
WARN_GUESSED_TYPE: int  # 9
WARN_HUGE_STKOFF: int  # 27
WARN_ILL_ELLIPSIS: int  # 8
WARN_ILL_FPU_STACK: int  # 18
WARN_ILL_FUNCTYPE: int  # 2
WARN_ILL_PURGED: int  # 1
WARN_JUMPOUT: int  # 43
WARN_MAX: int  # 57
WARN_MAX_ARGS: int  # 22
WARN_MISSED_SWITCH: int  # 39
WARN_MUST_RET_FP: int  # 17
WARN_NO_SAVE_REST: int  # 14
WARN_ODD_ABI: int  # 50
WARN_ODD_ADDR_USE: int  # 16
WARN_ODD_INPUT_REG: int  # 15
WARN_OPT_USELESS_JCND: int  # 54
WARN_OPT_VALRNG: int  # 46
WARN_OPT_VALRNG2: int  # 52
WARN_OPT_VALRNG3: int  # 53
WARN_OPT_VALRNG4: int  # 56
WARN_RET_LOCREF: int  # 47
WARN_SELFREF_PROP: int  # 19
WARN_SUBFRAME_OVERFLOW: int  # 55
WARN_UNALIGNED_ARG: int  # 36
WARN_UNBALANCED_STACK: int  # 51
WARN_UNDEF_LVAR: int  # 42
WARN_UNINITED_REG: int  # 28
WARN_UNSUPP_REG: int  # 35
WARN_VARARG_MANY: int  # 5
WARN_VARARG_NOSTK: int  # 4
WARN_VARARG_REGS: int  # 0
WARN_VARARG_TCAL: int  # 3
WARN_WIDEN_CHAINS: int  # 11
WARN_WOULD_OVERLAP: int  # 20
WARN_WRITE_CONST: int  # 24
WARN_WRONG_VA_OFF: int  # 30
WCLS_CLOSE_LATER: int  # 8
WCLS_DELETE_LATER: int  # 8
WCLS_DONT_SAVE_SIZE: int  # 4
WCLS_NO_CONTEXT: int  # 2
WCLS_SAVE: int  # 1
WFNE_ANY: int  # 1
WFNE_CONT: int  # 8
WFNE_NOWAIT: int  # 16
WFNE_SILENT: int  # 4
WFNE_SUSP: int  # 2
WFNE_USEC: int  # 32
WITH_ASSERTS: int  # 512
WITH_SIDEFF: int  # 1
WOPN_CLOSED_BY_ESC: int  # 128
WOPN_DP_BEFORE: int  # 2097152
WOPN_DP_BOTTOM: int  # 524288
WOPN_DP_FLOATING: int  # 8388608
WOPN_DP_INSIDE: int  # 1048576
WOPN_DP_INSIDE_BEFORE: int  # 3145728
WOPN_DP_LEFT: int  # 65536
WOPN_DP_MASK: int  # 268369920
WOPN_DP_RIGHT: int  # 262144
WOPN_DP_SHIFT: int  # 16
WOPN_DP_SZHINT: int  # 16777216
WOPN_DP_TAB: int  # 4194304
WOPN_DP_TAB_BEFORE: int  # 6291456
WOPN_DP_TOP: int  # 131072
WOPN_NOT_CLOSED_BY_ESC: int  # 256
WOPN_PERSIST: int  # 64
WOPN_RESTORE: int  # 4
WRITE_ACCESS: int  # 1
XREFSTATE_DONE: int  # 64
XREFSTATE_GO: int  # 32
XREFSTATE_NONE: int  # 0
XREF_ALL: int  # 0
XREF_BASE: int  # 128
XREF_CODE: int  # 4
XREF_DATA: int  # 2
XREF_EA: int  # 8
XREF_FAR: int  # 1
XREF_FLOW: int  # 0
XREF_MASK: int  # 31
XREF_NOFLOW: int  # 1
XREF_PASTEND: int  # 256
XREF_TAIL: int  # 64
XREF_TID: int  # 16
XREF_USER: int  # 32
XTENSA_abs: int  # 1
XTENSA_abs_d: int  # 181
XTENSA_abs_s: int  # 182
XTENSA_add: int  # 2
XTENSA_add_d: int  # 183
XTENSA_add_s: int  # 184
XTENSA_addexp_d: int  # 185
XTENSA_addexp_s: int  # 186
XTENSA_addexpm_d: int  # 187
XTENSA_addexpm_s: int  # 188
XTENSA_addi: int  # 3
XTENSA_addmi: int  # 4
XTENSA_addx2: int  # 5
XTENSA_addx4: int  # 6
XTENSA_addx8: int  # 7
XTENSA_ae2_rur: int  # 343
XTENSA_ae2_wur: int  # 344
XTENSA_ae_rur: int  # 345
XTENSA_ae_wur: int  # 346
XTENSA_all4: int  # 134
XTENSA_all8: int  # 135
XTENSA_and: int  # 8
XTENSA_andb: int  # 136
XTENSA_andbc: int  # 137
XTENSA_andi: int  # 115
XTENSA_any4: int  # 138
XTENSA_any8: int  # 139
XTENSA_ball: int  # 9
XTENSA_bany: int  # 10
XTENSA_bbc: int  # 11
XTENSA_bbci: int  # 13
XTENSA_bbs: int  # 12
XTENSA_bbsi: int  # 14
XTENSA_beq: int  # 15
XTENSA_beqi: int  # 16
XTENSA_beqz: int  # 17
XTENSA_bf: int  # 140
XTENSA_bge: int  # 18
XTENSA_bgei: int  # 19
XTENSA_bgeu: int  # 20
XTENSA_bgeui: int  # 21
XTENSA_bgez: int  # 22
XTENSA_blt: int  # 23
XTENSA_blti: int  # 24
XTENSA_bltu: int  # 25
XTENSA_bltui: int  # 26
XTENSA_bltz: int  # 27
XTENSA_bnall: int  # 28
XTENSA_bne: int  # 30
XTENSA_bnei: int  # 31
XTENSA_bnez: int  # 32
XTENSA_bnone: int  # 29
XTENSA_break: int  # 33
XTENSA_bt: int  # 141
XTENSA_call0: int  # 34
XTENSA_call12: int  # 37
XTENSA_call4: int  # 35
XTENSA_call8: int  # 36
XTENSA_callx0: int  # 38
XTENSA_callx12: int  # 41
XTENSA_callx4: int  # 39
XTENSA_callx8: int  # 40
XTENSA_ceil_d: int  # 189
XTENSA_ceil_s: int  # 190
XTENSA_clamps: int  # 315
XTENSA_clrb_expstate: int  # 336
XTENSA_clrex: int  # 177
XTENSA_const_d: int  # 191
XTENSA_const_s: int  # 192
XTENSA_cvtd_s: int  # 193
XTENSA_cvts_d: int  # 194
XTENSA_dci: int  # 148
XTENSA_dcwb: int  # 149
XTENSA_dcwbi: int  # 150
XTENSA_depbits: int  # 173
XTENSA_dhi: int  # 151
XTENSA_dhi_b: int  # 125
XTENSA_dhu: int  # 152
XTENSA_dhwb: int  # 153
XTENSA_dhwb_b: int  # 126
XTENSA_dhwbi: int  # 154
XTENSA_dhwbi_b: int  # 127
XTENSA_dii: int  # 155
XTENSA_diu: int  # 156
XTENSA_div0_d: int  # 195
XTENSA_div0_s: int  # 196
XTENSA_divn_d: int  # 197
XTENSA_divn_s: int  # 198
XTENSA_diwb: int  # 157
XTENSA_diwbi: int  # 158
XTENSA_diwbui_p: int  # 159
XTENSA_dpfl: int  # 160
XTENSA_dpfm_b: int  # 128
XTENSA_dpfm_bf: int  # 129
XTENSA_dpfr: int  # 161
XTENSA_dpfr_b: int  # 130
XTENSA_dpfr_bf: int  # 131
XTENSA_dpfro: int  # 162
XTENSA_dpfw: int  # 163
XTENSA_dpfw_b: int  # 132
XTENSA_dpfw_bf: int  # 133
XTENSA_dpfwo: int  # 164
XTENSA_dsync: int  # 42
XTENSA_entry: int  # 43
XTENSA_esync: int  # 44
XTENSA_excw: int  # 45
XTENSA_extui: int  # 46
XTENSA_extw: int  # 47
XTENSA_float_d: int  # 199
XTENSA_float_s: int  # 200
XTENSA_floor_d: int  # 201
XTENSA_floor_s: int  # 202
XTENSA_fsync: int  # 119
XTENSA_getex: int  # 178
XTENSA_hwwdtlba: int  # 337
XTENSA_hwwitlba: int  # 338
XTENSA_idtlb: int  # 317
XTENSA_ihi: int  # 279
XTENSA_ihu: int  # 280
XTENSA_iii: int  # 281
XTENSA_iitlb: int  # 318
XTENSA_iiu: int  # 282
XTENSA_ill: int  # 114
XTENSA_ipf: int  # 283
XTENSA_ipfl: int  # 284
XTENSA_isync: int  # 48
XTENSA_j: int  # 49
XTENSA_jx: int  # 50
XTENSA_l16si: int  # 57
XTENSA_l16ui: int  # 58
XTENSA_l32ai: int  # 316
XTENSA_l32e: int  # 330
XTENSA_l32ex: int  # 179
XTENSA_l32i: int  # 59
XTENSA_l32r: int  # 60
XTENSA_l8ui: int  # 56
XTENSA_last: int  # 347
XTENSA_ldct: int  # 165
XTENSA_ldcw: int  # 166
XTENSA_lddec: int  # 295
XTENSA_lddr32_p: int  # 169
XTENSA_ldi: int  # 203
XTENSA_ldinc: int  # 296
XTENSA_ldip: int  # 204
XTENSA_ldpte: int  # 339
XTENSA_ldx: int  # 205
XTENSA_ldxp: int  # 206
XTENSA_lict: int  # 285
XTENSA_licw: int  # 286
XTENSA_loop: int  # 51
XTENSA_loopgtz: int  # 52
XTENSA_loopnez: int  # 53
XTENSA_lsi: int  # 54
XTENSA_lsip: int  # 207
XTENSA_lsiu: int  # 208
XTENSA_lsx: int  # 55
XTENSA_lsxp: int  # 209
XTENSA_lsxu: int  # 210
XTENSA_madd_d: int  # 211
XTENSA_madd_s: int  # 212
XTENSA_maddn_d: int  # 213
XTENSA_maddn_s: int  # 214
XTENSA_max: int  # 61
XTENSA_maxu: int  # 62
XTENSA_memw: int  # 63
XTENSA_min: int  # 64
XTENSA_minu: int  # 65
XTENSA_mkdadj_d: int  # 215
XTENSA_mkdadj_s: int  # 216
XTENSA_mksadj_d: int  # 217
XTENSA_mksadj_s: int  # 218
XTENSA_mov: int  # 66
XTENSA_mov_d: int  # 219
XTENSA_mov_s: int  # 220
XTENSA_moveqz: int  # 67
XTENSA_moveqz_s: int  # 221
XTENSA_movf: int  # 142
XTENSA_movf_s: int  # 222
XTENSA_movgez: int  # 68
XTENSA_movgez_s: int  # 223
XTENSA_movi: int  # 69
XTENSA_movltz: int  # 70
XTENSA_movltz_s: int  # 224
XTENSA_movnez: int  # 71
XTENSA_movnez_s: int  # 225
XTENSA_movsp: int  # 331
XTENSA_movt: int  # 143
XTENSA_movt_s: int  # 226
XTENSA_msub_d: int  # 227
XTENSA_msub_s: int  # 228
XTENSA_mul16s: int  # 72
XTENSA_mul16u: int  # 73
XTENSA_mul_aa: int  # 297
XTENSA_mul_ad: int  # 298
XTENSA_mul_d: int  # 229
XTENSA_mul_da: int  # 299
XTENSA_mul_dd: int  # 300
XTENSA_mul_s: int  # 230
XTENSA_mula_aa: int  # 301
XTENSA_mula_ad: int  # 302
XTENSA_mula_da: int  # 303
XTENSA_mula_da_lddec: int  # 304
XTENSA_mula_da_ldinc: int  # 305
XTENSA_mula_dd: int  # 306
XTENSA_mula_dd_lddec: int  # 307
XTENSA_mula_dd_ldinc: int  # 308
XTENSA_mull: int  # 74
XTENSA_muls_aa: int  # 309
XTENSA_muls_ad: int  # 310
XTENSA_muls_da: int  # 311
XTENSA_muls_dd: int  # 312
XTENSA_mulsh: int  # 289
XTENSA_muluh: int  # 290
XTENSA_neg: int  # 75
XTENSA_neg_d: int  # 231
XTENSA_neg_s: int  # 232
XTENSA_nexp01_d: int  # 233
XTENSA_nexp01_s: int  # 234
XTENSA_nop: int  # 78
XTENSA_nsa: int  # 76
XTENSA_nsau: int  # 77
XTENSA_null: int  # 0
XTENSA_oeq_d: int  # 235
XTENSA_oeq_s: int  # 236
XTENSA_ole_d: int  # 237
XTENSA_ole_s: int  # 238
XTENSA_olt_d: int  # 239
XTENSA_olt_s: int  # 240
XTENSA_or: int  # 79
XTENSA_orb: int  # 144
XTENSA_orbc: int  # 145
XTENSA_ori: int  # 116
XTENSA_pdtlb: int  # 319
XTENSA_pitlb: int  # 320
XTENSA_pptlb: int  # 321
XTENSA_quos: int  # 291
XTENSA_quou: int  # 292
XTENSA_rdtlb0: int  # 322
XTENSA_rdtlb1: int  # 323
XTENSA_read_impwire: int  # 340
XTENSA_recip0_d: int  # 241
XTENSA_recip0_s: int  # 242
XTENSA_rems: int  # 293
XTENSA_remu: int  # 294
XTENSA_rer: int  # 120
XTENSA_ret: int  # 80
XTENSA_retw: int  # 81
XTENSA_rfdd: int  # 170
XTENSA_rfde: int  # 174
XTENSA_rfdo: int  # 171
XTENSA_rfe: int  # 82
XTENSA_rfi: int  # 83
XTENSA_rfme: int  # 314
XTENSA_rfr: int  # 243
XTENSA_rfrd: int  # 244
XTENSA_rfue: int  # 175
XTENSA_rfwo: int  # 332
XTENSA_rfwu: int  # 333
XTENSA_ritlb0: int  # 324
XTENSA_ritlb1: int  # 325
XTENSA_rotw: int  # 334
XTENSA_round_d: int  # 245
XTENSA_round_s: int  # 246
XTENSA_rptlb0: int  # 326
XTENSA_rptlb1: int  # 327
XTENSA_rsil: int  # 84
XTENSA_rsqrt0_d: int  # 247
XTENSA_rsqrt0_s: int  # 248
XTENSA_rsr: int  # 85
XTENSA_rsync: int  # 86
XTENSA_rur: int  # 117
XTENSA_s16i: int  # 88
XTENSA_s32c1i: int  # 147
XTENSA_s32e: int  # 335
XTENSA_s32ex: int  # 180
XTENSA_s32i: int  # 89
XTENSA_s32nb: int  # 121
XTENSA_s32ri: int  # 90
XTENSA_s8i: int  # 87
XTENSA_salt: int  # 122
XTENSA_saltu: int  # 123
XTENSA_sdct: int  # 167
XTENSA_sdcw: int  # 168
XTENSA_sddr32_p: int  # 172
XTENSA_sdi: int  # 249
XTENSA_sdip: int  # 250
XTENSA_sdx: int  # 251
XTENSA_sdxp: int  # 252
XTENSA_setb_expstate: int  # 341
XTENSA_sext: int  # 91
XTENSA_sict: int  # 287
XTENSA_sicw: int  # 288
XTENSA_simcall: int  # 329
XTENSA_sll: int  # 92
XTENSA_slli: int  # 93
XTENSA_sqrt0_d: int  # 253
XTENSA_sqrt0_s: int  # 254
XTENSA_sra: int  # 94
XTENSA_srai: int  # 95
XTENSA_src: int  # 96
XTENSA_srl: int  # 97
XTENSA_srli: int  # 98
XTENSA_ssa8b: int  # 99
XTENSA_ssa8l: int  # 100
XTENSA_ssai: int  # 101
XTENSA_ssi: int  # 255
XTENSA_ssip: int  # 256
XTENSA_ssiu: int  # 257
XTENSA_ssl: int  # 102
XTENSA_ssr: int  # 103
XTENSA_ssx: int  # 258
XTENSA_ssxp: int  # 259
XTENSA_ssxu: int  # 260
XTENSA_sub: int  # 104
XTENSA_sub_d: int  # 261
XTENSA_sub_s: int  # 262
XTENSA_subx2: int  # 105
XTENSA_subx4: int  # 106
XTENSA_subx8: int  # 107
XTENSA_syscall: int  # 176
XTENSA_trunc_d: int  # 263
XTENSA_trunc_s: int  # 264
XTENSA_ueq_d: int  # 265
XTENSA_ueq_s: int  # 266
XTENSA_ufloat_d: int  # 267
XTENSA_ufloat_s: int  # 268
XTENSA_ule_d: int  # 269
XTENSA_ule_s: int  # 270
XTENSA_ult_d: int  # 271
XTENSA_ult_s: int  # 272
XTENSA_umul_aa: int  # 313
XTENSA_un_d: int  # 273
XTENSA_un_s: int  # 274
XTENSA_utrunc_d: int  # 275
XTENSA_utrunc_s: int  # 276
XTENSA_waiti: int  # 108
XTENSA_wdtlb: int  # 109
XTENSA_wer: int  # 124
XTENSA_wfr: int  # 277
XTENSA_wfrd: int  # 278
XTENSA_witlb: int  # 110
XTENSA_wptlb: int  # 328
XTENSA_wrmsk_expstate: int  # 342
XTENSA_wsr: int  # 111
XTENSA_wur: int  # 118
XTENSA_xor: int  # 112
XTENSA_xorb: int  # 146
XTENSA_xsr: int  # 113
Z80_adc: int  # 2
Z80_adcw: int  # 205
Z80_add: int  # 3
Z80_addw: int  # 203
Z80_and: int  # 81
Z80_andw: int  # 207
Z80_bit: int  # 82
Z80_btest: int  # 237
Z80_call: int  # 83
Z80_calr: int  # 212
Z80_ccf: int  # 84
Z80_cp: int  # 85
Z80_cpd: int  # 86
Z80_cpdr: int  # 87
Z80_cpi: int  # 88
Z80_cpir: int  # 89
Z80_cpl: int  # 90
Z80_cplw: int  # 198
Z80_cpw: int  # 210
Z80_ddir: int  # 211
Z80_dec: int  # 91
Z80_di: int  # 24
Z80_divuw: int  # 229
Z80_djnz: int  # 92
Z80_ei: int  # 25
Z80_ex: int  # 93
Z80_exall: int  # 217
Z80_exts: int  # 235
Z80_extsw: int  # 236
Z80_exx: int  # 94
Z80_exxx: int  # 215
Z80_exxy: int  # 216
Z80_halt: int  # 95
Z80_im: int  # 96
Z80_in: int  # 27
Z80_in0: int  # 139
Z80_ina: int  # 233
Z80_inaw: int  # 231
Z80_inc: int  # 97
Z80_ind: int  # 98
Z80_indr: int  # 99
Z80_indrw: int  # 245
Z80_indw: int  # 244
Z80_ini: int  # 100
Z80_inir: int  # 101
Z80_inirw: int  # 243
Z80_iniw: int  # 242
Z80_inp: int  # 136
Z80_inw: int  # 200
Z80_jp: int  # 102
Z80_jr: int  # 103
Z80_ld: int  # 104
Z80_ldctl: int  # 213
Z80_ldd: int  # 105
Z80_lddr: int  # 106
Z80_lddrw: int  # 241
Z80_lddw: int  # 240
Z80_ldi: int  # 107
Z80_ldir: int  # 108
Z80_ldirw: int  # 239
Z80_ldiw: int  # 238
Z80_ldw: int  # 202
Z80_mlt: int  # 140
Z80_mtest: int  # 214
Z80_multuw: int  # 228
Z80_multw: int  # 227
Z80_neg: int  # 109
Z80_negw: int  # 234
Z80_or: int  # 110
Z80_orw: int  # 209
Z80_otdm: int  # 143
Z80_otdmr: int  # 144
Z80_otdr: int  # 111
Z80_otdrw: int  # 249
Z80_otim: int  # 141
Z80_otimr: int  # 142
Z80_otir: int  # 112
Z80_otirw: int  # 247
Z80_out: int  # 48
Z80_out0: int  # 145
Z80_outa: int  # 232
Z80_outaw: int  # 230
Z80_outd: int  # 113
Z80_outdw: int  # 248
Z80_outi: int  # 114
Z80_outiw: int  # 246
Z80_outp: int  # 137
Z80_outw: int  # 201
Z80_pop: int  # 50
Z80_push: int  # 51
Z80_res: int  # 115
Z80_resc: int  # 219
Z80_ret: int  # 116
Z80_reti: int  # 117
Z80_retn: int  # 118
Z80_rl: int  # 119
Z80_rla: int  # 120
Z80_rlc: int  # 121
Z80_rlca: int  # 122
Z80_rlcw: int  # 220
Z80_rld: int  # 123
Z80_rlw: int  # 222
Z80_rr: int  # 124
Z80_rra: int  # 125
Z80_rrc: int  # 126
Z80_rrca: int  # 127
Z80_rrcw: int  # 221
Z80_rrd: int  # 128
Z80_rrw: int  # 223
Z80_sbc: int  # 130
Z80_sbcw: int  # 206
Z80_scf: int  # 129
Z80_set: int  # 131
Z80_setc: int  # 218
Z80_sla: int  # 132
Z80_slaw: int  # 224
Z80_slp: int  # 146
Z80_sra: int  # 133
Z80_sraw: int  # 225
Z80_srl: int  # 134
Z80_srlw: int  # 226
Z80_srr: int  # 138
Z80_sub: int  # 74
Z80_subw: int  # 204
Z80_swap: int  # 199
Z80_tst: int  # 147
Z80_tstio: int  # 148
Z80_xor: int  # 135
Z80_xorw: int  # 208
Z8_adc: int  # 1
Z8_add: int  # 2
Z8_and: int  # 3
Z8_call: int  # 4
Z8_ccf: int  # 5
Z8_clr: int  # 6
Z8_com: int  # 7
Z8_cp: int  # 8
Z8_da: int  # 9
Z8_dec: int  # 10
Z8_decw: int  # 11
Z8_di: int  # 12
Z8_djnz: int  # 13
Z8_ei: int  # 14
Z8_halt: int  # 15
Z8_inc: int  # 16
Z8_incw: int  # 17
Z8_iret: int  # 18
Z8_jp: int  # 19
Z8_jpcond: int  # 20
Z8_jr: int  # 21
Z8_jrcond: int  # 22
Z8_last: int  # 50
Z8_ld: int  # 23
Z8_ldc: int  # 24
Z8_ldci: int  # 25
Z8_lde: int  # 26
Z8_ldei: int  # 27
Z8_nop: int  # 28
Z8_null: int  # 0
Z8_or: int  # 29
Z8_pop: int  # 30
Z8_push: int  # 31
Z8_rcf: int  # 32
Z8_ret: int  # 33
Z8_rl: int  # 34
Z8_rlc: int  # 35
Z8_rr: int  # 36
Z8_rrc: int  # 37
Z8_sbc: int  # 38
Z8_scf: int  # 39
Z8_sra: int  # 40
Z8_srp: int  # 41
Z8_stop: int  # 42
Z8_sub: int  # 43
Z8_swap: int  # 44
Z8_tcm: int  # 46
Z8_tm: int  # 45
Z8_wdh: int  # 48
Z8_wdt: int  # 49
Z8_xor: int  # 47
adding_segm: int  # 63
allsegs_moved: int  # 31
annotations: _Feature  # _Feature((3, 7, 0, 'beta', 1), None, 16777216)
arrow_height: int  # 10
arrow_width: int  # 8
atag: int  # 65
auto_empty: int  # 3
auto_empty_finally: int  # 4
beep_default: int  # 0
bisect: module
bitset_align: int  # 63
bitset_shift: int  # 6
bitset_width: int  # 64
bookmark_changed: int  # 61
builtins: module  # <module 'builtins' (built-in)>
byte_patched: int  # 53
callee_addr_changed: int  # 60
cc_count: int  # 5
changing_cmt: int  # 54
changing_op_ti: int  # 14
changing_op_type: int  # 16
changing_range_cmt: int  # 56
changing_segm_class: int  # 27
changing_segm_end: int  # 23
changing_segm_name: int  # 25
changing_segm_start: int  # 21
changing_ti: int  # 12
chtype_entry: int  # 2
chtype_enum: int  # 12
chtype_enum_by_value_and_size: int  # 13
chtype_func: int  # 6
chtype_generic: int  # 0
chtype_idasgn: int  # 1
chtype_idatil: int  # 9
chtype_name: int  # 3
chtype_segm: int  # 7
chtype_srcp: int  # 10
chtype_stkvar_xref: int  # 4
chtype_strpath: int  # 8
chtype_struct: int  # 11
chtype_xref: int  # 5
cik_filename: int  # 1
cik_path: int  # 2
cik_string: int  # 0
cit_asm: int  # 82
cit_block: int  # 71
cit_break: int  # 78
cit_continue: int  # 79
cit_do: int  # 76
cit_empty: int  # 70
cit_end: int  # 85
cit_expr: int  # 72
cit_for: int  # 74
cit_goto: int  # 81
cit_if: int  # 73
cit_return: int  # 80
cit_switch: int  # 77
cit_throw: int  # 84
cit_try: int  # 83
cit_while: int  # 75
closebase: int  # 0
cmt_changed: int  # 55
compiler_changed: int  # 11
cot_add: int  # 35
cot_asg: int  # 2
cot_asgadd: int  # 6
cot_asgband: int  # 5
cot_asgbor: int  # 3
cot_asgmul: int  # 8
cot_asgsdiv: int  # 12
cot_asgshl: int  # 11
cot_asgsmod: int  # 14
cot_asgsshr: int  # 9
cot_asgsub: int  # 7
cot_asgudiv: int  # 13
cot_asgumod: int  # 15
cot_asgushr: int  # 10
cot_asgxor: int  # 4
cot_band: int  # 21
cot_bnot: int  # 50
cot_bor: int  # 19
cot_call: int  # 57
cot_cast: int  # 48
cot_comma: int  # 1
cot_empty: int  # 0
cot_eq: int  # 22
cot_fadd: int  # 42
cot_fdiv: int  # 45
cot_fmul: int  # 44
cot_fneg: int  # 46
cot_fnum: int  # 62
cot_fsub: int  # 43
cot_helper: int  # 68
cot_idx: int  # 58
cot_insn: int  # 66
cot_land: int  # 18
cot_last: int  # 69
cot_lnot: int  # 49
cot_lor: int  # 17
cot_memptr: int  # 60
cot_memref: int  # 59
cot_mul: int  # 37
cot_ne: int  # 23
cot_neg: int  # 47
cot_num: int  # 61
cot_obj: int  # 64
cot_postdec: int  # 54
cot_postinc: int  # 53
cot_predec: int  # 56
cot_preinc: int  # 55
cot_ptr: int  # 51
cot_ref: int  # 52
cot_sdiv: int  # 38
cot_sge: int  # 24
cot_sgt: int  # 28
cot_shl: int  # 34
cot_sizeof: int  # 67
cot_sle: int  # 26
cot_slt: int  # 30
cot_smod: int  # 40
cot_sshr: int  # 32
cot_str: int  # 63
cot_sub: int  # 36
cot_tern: int  # 16
cot_type: int  # 69
cot_udiv: int  # 39
cot_uge: int  # 25
cot_ugt: int  # 29
cot_ule: int  # 27
cot_ult: int  # 31
cot_umod: int  # 41
cot_ushr: int  # 33
cot_var: int  # 65
cot_xor: int  # 20
ctypes: module
cvar: idaapi_Cvar  # <idaapi.idaapi_Cvar object at 0x7acfb4290980>
dbg_bpt: int  # 12
dbg_bpt_changed: int  # 19
dbg_exception: int  # 10
dbg_finished_loading_bpts: int  # 21
dbg_information: int  # 9
dbg_last: int  # 22
dbg_library_load: int  # 7
dbg_library_unload: int  # 8
dbg_null: int  # 0
dbg_process_attach: int  # 3
dbg_process_detach: int  # 4
dbg_process_exit: int  # 2
dbg_process_start: int  # 1
dbg_request_error: int  # 14
dbg_run_to: int  # 17
dbg_started_loading_bpts: int  # 20
dbg_step_into: int  # 15
dbg_step_over: int  # 16
dbg_step_until_ret: int  # 18
dbg_suspend_process: int  # 11
dbg_thread_exit: int  # 6
dbg_thread_start: int  # 5
dbg_trace: int  # 13
deleting_func: int  # 36
deleting_func_tail: int  # 40
deleting_segm: int  # 19
deleting_tryblks: int  # 47
destroyed_items: int  # 51
determined_main: int  # 5
dirtree_link: int  # 67
dirtree_mkdir: int  # 65
dirtree_move: int  # 68
dirtree_rank: int  # 69
dirtree_rmdir: int  # 66
dirtree_rminode: int  # 70
dirtree_segm_moved: int  # 71
dr_I: int  # 5
dr_O: int  # 1
dr_R: int  # 3
dr_S: int  # 6
dr_T: int  # 4
dr_U: int  # 0
dr_W: int  # 2
dt_bitfild: int  # 12
dt_byte: int  # 0
dt_byte16: int  # 8
dt_byte32: int  # 16
dt_byte64: int  # 17
dt_code: int  # 9
dt_double: int  # 4
dt_dword: int  # 2
dt_float: int  # 3
dt_fword: int  # 11
dt_half: int  # 18
dt_ldbl: int  # 15
dt_packreal: int  # 6
dt_qword: int  # 7
dt_string: int  # 13
dt_tbyte: int  # 5
dt_unicode: int  # 14
dt_void: int  # 10
dt_word: int  # 1
eExecThrow: int  # 90
extlang_changed: int  # 6
extra_cmt_changed: int  # 58
f_AIXAR: int  # 24
f_AOUT: int  # 20
f_AR: int  # 16
f_BIN: int  # 2
f_COFF: int  # 10
f_COM: int  # 23
f_COM_old: int  # 1
f_DRV: int  # 3
f_ELF: int  # 18
f_EXE: int  # 22
f_EXE_old: int  # 0
f_HEX: int  # 5
f_LE: int  # 8
f_LOADER: int  # 17
f_LX: int  # 7
f_MACHO: int  # 25
f_MD1IMG: int  # 27
f_MEX: int  # 6
f_NLM: int  # 9
f_OMF: int  # 12
f_OMFLIB: int  # 15
f_PE: int  # 11
f_PRC: int  # 21
f_PSXOBJ: int  # 26
f_SREC: int  # 13
f_W32RUN: int  # 19
f_WIN: int  # 4
f_ZIP: int  # 14
fcb_cndret: int  # 3
fcb_enoret: int  # 5
fcb_error: int  # 7
fcb_extern: int  # 6
fcb_indjump: int  # 1
fcb_noret: int  # 4
fcb_normal: int  # 0
fcb_ret: int  # 2
fl_CF: int  # 16
fl_CN: int  # 17
fl_F: int  # 21
fl_JF: int  # 18
fl_JN: int  # 19
fl_U: int  # 0
fl_USobsolete: int  # 20
flow_chart_created: int  # 10
fr_add: int  # 1
fr_add2: int  # 2
fr_addc: int  # 3
fr_addn: int  # 4
fr_addn2: int  # 5
fr_addsp: int  # 89
fr_and: int  # 11
fr_andb: int  # 13
fr_andccr: int  # 86
fr_andh: int  # 12
fr_asr: int  # 42
fr_asr2: int  # 43
fr_bandh: int  # 21
fr_bandl: int  # 20
fr_bc: int  # 64
fr_beorh: int  # 25
fr_beorl: int  # 24
fr_beq: int  # 62
fr_bge: int  # 71
fr_bgt: int  # 73
fr_bhi: int  # 75
fr_ble: int  # 72
fr_bls: int  # 74
fr_blt: int  # 70
fr_bn: int  # 66
fr_bnc: int  # 65
fr_bne: int  # 63
fr_bno: int  # 61
fr_bnv: int  # 69
fr_borh: int  # 23
fr_borl: int  # 22
fr_bp: int  # 67
fr_bra: int  # 60
fr_btsth: int  # 27
fr_btstl: int  # 26
fr_bv: int  # 68
fr_call: int  # 55
fr_cmp: int  # 9
fr_cmp2: int  # 10
fr_copld: int  # 82
fr_copop: int  # 81
fr_copst: int  # 83
fr_copsv: int  # 84
fr_div0s: int  # 32
fr_div0u: int  # 33
fr_div1: int  # 34
fr_div2: int  # 35
fr_div3: int  # 36
fr_div4s: int  # 37
fr_dmov: int  # 76
fr_dmovb: int  # 78
fr_dmovh: int  # 77
fr_enter: int  # 98
fr_eor: int  # 17
fr_eorb: int  # 19
fr_eorh: int  # 18
fr_extsb: int  # 90
fr_extsh: int  # 92
fr_extub: int  # 91
fr_extuh: int  # 93
fr_int: int  # 57
fr_inte: int  # 58
fr_jmp: int  # 54
fr_last: int  # 101
fr_ld: int  # 47
fr_ldi_20: int  # 45
fr_ldi_32: int  # 44
fr_ldi_8: int  # 46
fr_ldm0: int  # 94
fr_ldm1: int  # 95
fr_ldres: int  # 79
fr_ldub: int  # 49
fr_lduh: int  # 48
fr_leave: int  # 99
fr_lsl: int  # 38
fr_lsl2: int  # 39
fr_lsr: int  # 40
fr_lsr2: int  # 41
fr_mov: int  # 53
fr_mul: int  # 28
fr_mulh: int  # 30
fr_mulu: int  # 29
fr_muluh: int  # 31
fr_nop: int  # 85
fr_null: int  # 0
fr_or: int  # 14
fr_orb: int  # 16
fr_orccr: int  # 87
fr_orh: int  # 15
fr_ret: int  # 56
fr_reti: int  # 59
fr_st: int  # 50
fr_stb: int  # 52
fr_sth: int  # 51
fr_stilm: int  # 88
fr_stm0: int  # 96
fr_stm1: int  # 97
fr_stres: int  # 80
fr_sub: int  # 6
fr_subc: int  # 7
fr_subn: int  # 8
fr_xchb: int  # 100
frame_created: int  # 78
frame_deleted: int  # 37
frame_expanded: int  # 83
frame_udm_changed: int  # 82
frame_udm_created: int  # 79
frame_udm_deleted: int  # 80
frame_udm_renamed: int  # 81
func_added: int  # 32
func_deleted: int  # 64
func_noret_changed: int  # 43
func_tail_appended: int  # 39
func_tail_deleted: int  # 41
func_updated: int  # 33
git_edge: int  # 1
git_elp: int  # 5
git_node: int  # 2
git_none: int  # 0
git_text: int  # 4
git_tool: int  # 3
grcode_attach_menu_item: int  # 301
grcode_calculating_layout: int  # 0
grcode_center_on: int  # 264
grcode_change_group_visibility: int  # 281
grcode_changed_graph: int  # 2
grcode_clear: int  # 269
grcode_clicked: int  # 4
grcode_create_circle_layout: int  # 272
grcode_create_digraph_layout: int  # 270
grcode_create_disasm_graph1: int  # 287
grcode_create_disasm_graph2: int  # 288
grcode_create_graph_viewer: int  # 256
grcode_create_group: int  # 275
grcode_create_interactive_graph: int  # 259
grcode_create_mutable_graph: int  # 259
grcode_create_tree_layout: int  # 271
grcode_create_user_graph_place: int  # 286
grcode_creating_group: int  # 6
grcode_dblclicked: int  # 5
grcode_del_custom_layout: int  # 266
grcode_del_node_info: int  # 291
grcode_delete_group: int  # 280
grcode_delete_interactive_graph: int  # 298
grcode_deleting_group: int  # 7
grcode_destroyed: int  # 18
grcode_edge_infos_wrapper_clear: int  # 300
grcode_edge_infos_wrapper_copy: int  # 299
grcode_empty: int  # 278
grcode_find_subgraph_node: int  # 274
grcode_fit_window: int  # 262
grcode_get_curnode: int  # 263
grcode_get_custom_layout: int  # 276
grcode_get_gli: int  # 303
grcode_get_graph_groups: int  # 277
grcode_get_graph_viewer: int  # 257
grcode_get_node_info: int  # 290
grcode_get_node_representative: int  # 273
grcode_get_selection: int  # 265
grcode_get_viewer_graph: int  # 258
grcode_gotfocus: int  # 9
grcode_group_visibility: int  # 8
grcode_is_visible_node: int  # 279
grcode_layout_calculated: int  # 1
grcode_lostfocus: int  # 10
grcode_node_qty: int  # 283
grcode_nrect: int  # 284
grcode_refresh_viewer: int  # 261
grcode_reserved: int  # 3
grcode_reserved2: int  # 12
grcode_set_custom_layout: int  # 267
grcode_set_edge: int  # 282
grcode_set_gli: int  # 302
grcode_set_graph_groups: int  # 268
grcode_set_node_info: int  # 289
grcode_set_titlebar_height: int  # 285
grcode_set_viewer_graph: int  # 260
grcode_user_draw: int  # 16
grcode_user_hint: int  # 17
grcode_user_refresh: int  # 11
grcode_user_size: int  # 14
grcode_user_text: int  # 13
grcode_user_title: int  # 15
grcode_viewer_create_groups: int  # 292
grcode_viewer_create_groups_vec: int  # 295
grcode_viewer_delete_groups: int  # 293
grcode_viewer_delete_groups_vec: int  # 296
grcode_viewer_groups_visibility: int  # 294
grcode_viewer_groups_visibility_vec: int  # 297
htag: int  # 72
hx_arglocs_overlap: int  # 177
hx_asgop: int  # 448
hx_asgop_revert: int  # 449
hx_bitset_t_add: int  # 205
hx_bitset_t_add_: int  # 206
hx_bitset_t_add__: int  # 207
hx_bitset_t_bitset_t: int  # 203
hx_bitset_t_compare: int  # 226
hx_bitset_t_copy: int  # 204
hx_bitset_t_count: int  # 218
hx_bitset_t_count_: int  # 219
hx_bitset_t_cut_at: int  # 211
hx_bitset_t_dstr: int  # 216
hx_bitset_t_empty: int  # 217
hx_bitset_t_fill_gaps: int  # 222
hx_bitset_t_fill_with_ones: int  # 221
hx_bitset_t_goup: int  # 227
hx_bitset_t_has: int  # 213
hx_bitset_t_has_all: int  # 214
hx_bitset_t_has_any: int  # 215
hx_bitset_t_has_common: int  # 223
hx_bitset_t_intersect: int  # 224
hx_bitset_t_is_subset_of: int  # 225
hx_bitset_t_last: int  # 220
hx_bitset_t_shift_down: int  # 212
hx_bitset_t_sub: int  # 208
hx_bitset_t_sub_: int  # 209
hx_bitset_t_sub__: int  # 210
hx_block_chains_begin: int  # 117
hx_block_chains_clear: int  # 125
hx_block_chains_end: int  # 118
hx_block_chains_erase: int  # 124
hx_block_chains_find: int  # 122
hx_block_chains_free: int  # 127
hx_block_chains_get: int  # 121
hx_block_chains_insert: int  # 123
hx_block_chains_new: int  # 128
hx_block_chains_next: int  # 119
hx_block_chains_prev: int  # 120
hx_block_chains_size: int  # 126
hx_block_chains_t_dstr: int  # 330
hx_block_chains_t_get_chain: int  # 328
hx_block_chains_t_print: int  # 329
hx_boundaries_begin: int  # 104
hx_boundaries_clear: int  # 113
hx_boundaries_end: int  # 105
hx_boundaries_erase: int  # 112
hx_boundaries_find: int  # 110
hx_boundaries_first: int  # 108
hx_boundaries_free: int  # 115
hx_boundaries_insert: int  # 111
hx_boundaries_new: int  # 116
hx_boundaries_next: int  # 106
hx_boundaries_prev: int  # 107
hx_boundaries_second: int  # 109
hx_boundaries_size: int  # 114
hx_carglist_t_compare: int  # 504
hx_casm_t_compare: int  # 489
hx_catchexpr_t_compare: int  # 616
hx_cblock_t_compare: int  # 503
hx_ccase_t_compare: int  # 505
hx_ccases_t_compare: int  # 506
hx_ccatch_t_compare: int  # 508
hx_cdg_insn_iterator_t_next: int  # 430
hx_cdo_t_compare: int  # 485
hx_cexpr_t_assign: int  # 464
hx_cexpr_t_calc_type: int  # 470
hx_cexpr_t_cleanup: int  # 467
hx_cexpr_t_compare: int  # 465
hx_cexpr_t_contains_operator: int  # 473
hx_cexpr_t_dstr: int  # 479
hx_cexpr_t_equal_effect: int  # 471
hx_cexpr_t_get_high_nbit_bound: int  # 474
hx_cexpr_t_get_low_nbit_bound: int  # 475
hx_cexpr_t_has_side_effects: int  # 477
hx_cexpr_t_is_child_of: int  # 472
hx_cexpr_t_maybe_ptr: int  # 478
hx_cexpr_t_print1: int  # 469
hx_cexpr_t_put_number: int  # 468
hx_cexpr_t_replace_by: int  # 466
hx_cexpr_t_requires_lvalue: int  # 476
hx_cfor_t_compare: int  # 483
hx_cfunc_parentee_t_calc_rvalue_type: int  # 458
hx_cfunc_t_build_c_tree: int  # 534
hx_cfunc_t_cleanup: int  # 564
hx_cfunc_t_del_orphan_cmts: int  # 548
hx_cfunc_t_find_item_coords: int  # 563
hx_cfunc_t_find_label: int  # 541
hx_cfunc_t_gather_derefs: int  # 562
hx_cfunc_t_get_boundaries: int  # 559
hx_cfunc_t_get_eamap: int  # 558
hx_cfunc_t_get_func_type: int  # 538
hx_cfunc_t_get_line_item: int  # 556
hx_cfunc_t_get_lvars: int  # 539
hx_cfunc_t_get_pseudocode: int  # 560
hx_cfunc_t_get_stkoff_delta: int  # 540
hx_cfunc_t_get_user_cmt: int  # 543
hx_cfunc_t_get_user_iflags: int  # 545
hx_cfunc_t_get_user_union_selection: int  # 549
hx_cfunc_t_get_warnings: int  # 557
hx_cfunc_t_has_orphan_cmts: int  # 547
hx_cfunc_t_print_dcl: int  # 536
hx_cfunc_t_print_func: int  # 537
hx_cfunc_t_recalc_item_addresses: int  # 619
hx_cfunc_t_refresh_func_ctext: int  # 561
hx_cfunc_t_remove_unused_labels: int  # 542
hx_cfunc_t_save_user_cmts: int  # 552
hx_cfunc_t_save_user_iflags: int  # 554
hx_cfunc_t_save_user_labels: int  # 551
hx_cfunc_t_save_user_numforms: int  # 553
hx_cfunc_t_save_user_unions: int  # 555
hx_cfunc_t_set_user_cmt: int  # 544
hx_cfunc_t_set_user_iflags: int  # 546
hx_cfunc_t_set_user_union_selection: int  # 550
hx_cfunc_t_verify: int  # 535
hx_cgoto_t_compare: int  # 488
hx_chain_t_append_list: int  # 326
hx_chain_t_append_list_: int  # 327
hx_chain_t_dstr: int  # 325
hx_chain_t_print: int  # 324
hx_change_hexrays_config: int  # 434
hx_cif_t_assign: int  # 480
hx_cif_t_compare: int  # 481
hx_cinsn_t_assign: int  # 490
hx_cinsn_t_cleanup: int  # 493
hx_cinsn_t_collect_free_breaks: int  # 500
hx_cinsn_t_collect_free_continues: int  # 501
hx_cinsn_t_compare: int  # 491
hx_cinsn_t_contains_insn: int  # 499
hx_cinsn_t_create_if: int  # 495
hx_cinsn_t_dstr: int  # 502
hx_cinsn_t_is_ordinary_flow: int  # 498
hx_cinsn_t_new_insn: int  # 494
hx_cinsn_t_print: int  # 496
hx_cinsn_t_print1: int  # 497
hx_cinsn_t_replace_by: int  # 492
hx_citem_locator_t_compare: int  # 459
hx_citem_t_contains_expr: int  # 460
hx_citem_t_contains_label: int  # 461
hx_citem_t_find_closest_addr: int  # 463
hx_citem_t_find_parent_of: int  # 462
hx_clear_cached_cfuncs: int  # 570
hx_cloop_t_assign: int  # 482
hx_close_hexrays_waitbox: int  # 565
hx_close_pseudocode: int  # 437
hx_cnumber_t_assign: int  # 452
hx_cnumber_t_compare: int  # 453
hx_cnumber_t_print: int  # 450
hx_cnumber_t_value: int  # 451
hx_codegen_t_clear: int  # 431
hx_codegen_t_emit: int  # 432
hx_codegen_t_emit_: int  # 433
hx_convert_to_user_call: int  # 198
hx_create_cfunc: int  # 568
hx_create_field_name: int  # 573
hx_create_typedef: int  # 170
hx_creturn_t_compare: int  # 486
hx_cswitch_t_compare: int  # 507
hx_cthrow_t_compare: int  # 487
hx_ctree_item_t_dstr: int  # 516
hx_ctree_item_t_get_ea: int  # 513
hx_ctree_item_t_get_edm: int  # 511
hx_ctree_item_t_get_label_num: int  # 514
hx_ctree_item_t_get_lvar: int  # 512
hx_ctree_item_t_get_udm: int  # 510
hx_ctree_item_t_print: int  # 515
hx_ctree_parentee_t_recalc_parent_types: int  # 457
hx_ctree_visitor_t_apply_to: int  # 455
hx_ctree_visitor_t_apply_to_exprs: int  # 456
hx_ctry_t_compare: int  # 509
hx_cwhile_t_compare: int  # 484
hx_decompile: int  # 566
hx_decompile_many: int  # 439
hx_dereference: int  # 523
hx_dstr: int  # 158
hx_dummy_ptrtype: int  # 167
hx_eamap_begin: int  # 91
hx_eamap_clear: int  # 100
hx_eamap_end: int  # 92
hx_eamap_erase: int  # 99
hx_eamap_find: int  # 97
hx_eamap_first: int  # 95
hx_eamap_free: int  # 102
hx_eamap_insert: int  # 98
hx_eamap_new: int  # 103
hx_eamap_next: int  # 93
hx_eamap_prev: int  # 94
hx_eamap_second: int  # 96
hx_eamap_size: int  # 101
hx_file_printer_t_print: int  # 156
hx_fnumber_t_dstr: int  # 272
hx_fnumber_t_print: int  # 271
hx_gco_info_t_append_to_list: int  # 442
hx_gen_microcode: int  # 567
hx_get_ctype_name: int  # 572
hx_get_current_operand: int  # 443
hx_get_float_type: int  # 164
hx_get_hexrays_version: int  # 435
hx_get_int_type_by_width_and_sign: int  # 165
hx_get_member_type: int  # 168
hx_get_merror_desc: int  # 146
hx_get_mreg_name: int  # 254
hx_get_op_signness: int  # 447
hx_get_signed_mcode: int  # 151
hx_get_temp_regs: int  # 250
hx_get_type: int  # 171
hx_get_unk_type: int  # 166
hx_get_unsigned_mcode: int  # 152
hx_get_widget_vdui: int  # 438
hx_getb_reginsn: int  # 359
hx_getf_reginsn: int  # 358
hx_graph_chains_t_for_all_chains: int  # 331
hx_graph_chains_t_release: int  # 332
hx_has_cached_cfunc: int  # 571
hx_hexrays_alloc: int  # 129
hx_hexrays_failure_t_desc: int  # 440
hx_hexrays_free: int  # 130
hx_install_hexrays_callback: int  # 574
hx_install_microcode_filter: int  # 199
hx_install_optblock_handler: int  # 257
hx_install_optinsn_handler: int  # 255
hx_int64_emulator_t_minsn_value: int  # 621
hx_int64_emulator_t_mop_value: int  # 620
hx_is_bool_type: int  # 162
hx_is_kreg: int  # 251
hx_is_mcode_propagatable: int  # 148
hx_is_nonbool_type: int  # 161
hx_is_small_udt: int  # 160
hx_is_type_correct: int  # 159
hx_ivl_t_compare: int  # 229
hx_ivl_t_dstr: int  # 228
hx_ivlset_t_add: int  # 230
hx_ivlset_t_add_: int  # 231
hx_ivlset_t_addmasked: int  # 232
hx_ivlset_t_compare: int  # 243
hx_ivlset_t_contains: int  # 240
hx_ivlset_t_count: int  # 238
hx_ivlset_t_dstr: int  # 237
hx_ivlset_t_has_common: int  # 235
hx_ivlset_t_has_common_: int  # 239
hx_ivlset_t_includes: int  # 241
hx_ivlset_t_intersect: int  # 242
hx_ivlset_t_print: int  # 236
hx_ivlset_t_sub: int  # 233
hx_ivlset_t_sub_: int  # 234
hx_lnot: int  # 517
hx_locate_lvar: int  # 194
hx_lvar_locator_t_compare: int  # 178
hx_lvar_locator_t_dstr: int  # 179
hx_lvar_mapping_begin: int  # 13
hx_lvar_mapping_clear: int  # 22
hx_lvar_mapping_end: int  # 14
hx_lvar_mapping_erase: int  # 21
hx_lvar_mapping_find: int  # 19
hx_lvar_mapping_first: int  # 17
hx_lvar_mapping_free: int  # 24
hx_lvar_mapping_insert: int  # 20
hx_lvar_mapping_new: int  # 25
hx_lvar_mapping_next: int  # 15
hx_lvar_mapping_prev: int  # 16
hx_lvar_mapping_second: int  # 18
hx_lvar_mapping_size: int  # 23
hx_lvar_ref_t_compare: int  # 267
hx_lvar_ref_t_var: int  # 268
hx_lvar_t_accepts_type: int  # 182
hx_lvar_t_append_list: int  # 185
hx_lvar_t_append_list_: int  # 186
hx_lvar_t_dstr: int  # 180
hx_lvar_t_is_promoted_arg: int  # 181
hx_lvar_t_set_lvar_type: int  # 183
hx_lvar_t_set_width: int  # 184
hx_lvars_t_find: int  # 188
hx_lvars_t_find_lvar: int  # 189
hx_lvars_t_find_stkvar: int  # 187
hx_make_num: int  # 521
hx_make_pointer: int  # 169
hx_make_ref: int  # 522
hx_mark_cfunc_dirty: int  # 569
hx_mba_ranges_t_range_contains: int  # 384
hx_mba_t_alloc_fict_ea: int  # 417
hx_mba_t_alloc_kreg: int  # 422
hx_mba_t_alloc_lvars: int  # 399
hx_mba_t_analyze_calls: int  # 397
hx_mba_t_arg: int  # 416
hx_mba_t_build_graph: int  # 395
hx_mba_t_copy_block: int  # 407
hx_mba_t_create_helper_call: int  # 414
hx_mba_t_deserialize: int  # 420
hx_mba_t_dump: int  # 400
hx_mba_t_find_mop: int  # 413
hx_mba_t_for_all_insns: int  # 411
hx_mba_t_for_all_ops: int  # 410
hx_mba_t_for_all_topinsns: int  # 412
hx_mba_t_free_kreg: int  # 423
hx_mba_t_get_curfunc: int  # 392
hx_mba_t_get_func_output_lists: int  # 415
hx_mba_t_get_graph: int  # 396
hx_mba_t_idaloc2vd: int  # 387
hx_mba_t_idaloc2vd_: int  # 388
hx_mba_t_inline_func: int  # 424
hx_mba_t_insert_block: int  # 405
hx_mba_t_locate_stkpnt: int  # 425
hx_mba_t_map_fict_ea: int  # 418
hx_mba_t_mark_chains_dirty: int  # 404
hx_mba_t_merge_blocks: int  # 409
hx_mba_t_optimize_global: int  # 398
hx_mba_t_optimize_local: int  # 394
hx_mba_t_print: int  # 402
hx_mba_t_remove_block: int  # 406
hx_mba_t_remove_blocks: int  # 618
hx_mba_t_remove_empty_and_unreachable_blocks: int  # 408
hx_mba_t_save_snapshot: int  # 421
hx_mba_t_serialize: int  # 419
hx_mba_t_set_lvar_name: int  # 426
hx_mba_t_set_maturity: int  # 393
hx_mba_t_split_block: int  # 617
hx_mba_t_stkoff_ida2vd: int  # 386
hx_mba_t_stkoff_vd2ida: int  # 385
hx_mba_t_term: int  # 391
hx_mba_t_vd2idaloc: int  # 389
hx_mba_t_vd2idaloc_: int  # 390
hx_mba_t_vdump_mba: int  # 401
hx_mba_t_verify: int  # 403
hx_mbl_graph_t_get_du: int  # 429
hx_mbl_graph_t_get_ud: int  # 428
hx_mbl_graph_t_is_accessed_globally: int  # 427
hx_mblock_t_append_def_list: int  # 374
hx_mblock_t_append_use_list: int  # 373
hx_mblock_t_build_def_list: int  # 376
hx_mblock_t_build_lists: int  # 371
hx_mblock_t_build_use_list: int  # 375
hx_mblock_t_dump: int  # 362
hx_mblock_t_find_access: int  # 380
hx_mblock_t_find_first_use: int  # 377
hx_mblock_t_find_redefinition: int  # 378
hx_mblock_t_for_all_insns: int  # 366
hx_mblock_t_for_all_ops: int  # 367
hx_mblock_t_for_all_uses: int  # 368
hx_mblock_t_get_reginsn_qty: int  # 383
hx_mblock_t_get_valranges: int  # 381
hx_mblock_t_get_valranges_: int  # 382
hx_mblock_t_init: int  # 360
hx_mblock_t_insert_into_block: int  # 364
hx_mblock_t_is_rhs_redefined: int  # 379
hx_mblock_t_optimize_block: int  # 370
hx_mblock_t_optimize_insn: int  # 369
hx_mblock_t_optimize_useless_jump: int  # 372
hx_mblock_t_print: int  # 361
hx_mblock_t_remove_from_block: int  # 365
hx_mblock_t_vdump_block: int  # 363
hx_mcallarg_t_dstr: int  # 310
hx_mcallarg_t_print: int  # 309
hx_mcallarg_t_set_regarg: int  # 311
hx_mcallinfo_t_dstr: int  # 316
hx_mcallinfo_t_get_type: int  # 314
hx_mcallinfo_t_lexcompare: int  # 312
hx_mcallinfo_t_print: int  # 315
hx_mcallinfo_t_set_type: int  # 313
hx_mcases_t_compare: int  # 317
hx_mcases_t_dstr: int  # 319
hx_mcases_t_print: int  # 318
hx_mcode_modifies_d: int  # 153
hx_minsn_t__make_nop: int  # 343
hx_minsn_t_copy: int  # 334
hx_minsn_t_deserialize: int  # 357
hx_minsn_t_dstr: int  # 338
hx_minsn_t_equal_insns: int  # 344
hx_minsn_t_find_call: int  # 348
hx_minsn_t_find_ins_op: int  # 351
hx_minsn_t_find_num_op: int  # 352
hx_minsn_t_find_opcode: int  # 350
hx_minsn_t_for_all_insns: int  # 342
hx_minsn_t_for_all_ops: int  # 341
hx_minsn_t_has_side_effects: int  # 349
hx_minsn_t_init: int  # 333
hx_minsn_t_is_between: int  # 354
hx_minsn_t_is_helper: int  # 347
hx_minsn_t_is_noret_call: int  # 346
hx_minsn_t_lexcompare: int  # 345
hx_minsn_t_may_use_aliased_memory: int  # 355
hx_minsn_t_modifies_d: int  # 353
hx_minsn_t_optimize_subtree: int  # 340
hx_minsn_t_print: int  # 337
hx_minsn_t_serialize: int  # 356
hx_minsn_t_set_combined: int  # 335
hx_minsn_t_setaddr: int  # 339
hx_minsn_t_swap: int  # 336
hx_mlist_t_addmem: int  # 246
hx_mlist_t_compare: int  # 249
hx_mlist_t_dstr: int  # 248
hx_mlist_t_print: int  # 247
hx_modify_user_lvar_info: int  # 193
hx_modify_user_lvars: int  # 192
hx_mop_t__make_gvar: int  # 286
hx_mop_t_apply_ld_mcode: int  # 308
hx_mop_t_assign: int  # 274
hx_mop_t_change_size: int  # 306
hx_mop_t_copy: int  # 273
hx_mop_t_create_from_insn: int  # 283
hx_mop_t_create_from_ivlset: int  # 280
hx_mop_t_create_from_mlist: int  # 279
hx_mop_t_create_from_scattered_vdloc: int  # 282
hx_mop_t_create_from_vdloc: int  # 281
hx_mop_t_dstr: int  # 278
hx_mop_t_equal_mops: int  # 295
hx_mop_t_erase: int  # 276
hx_mop_t_for_all_ops: int  # 297
hx_mop_t_for_all_scattered_submops: int  # 298
hx_mop_t_get_stkoff: int  # 300
hx_mop_t_is01: int  # 292
hx_mop_t_is_bit_reg: int  # 290
hx_mop_t_is_constant: int  # 299
hx_mop_t_is_sign_extended_from: int  # 293
hx_mop_t_is_zero_extended_from: int  # 294
hx_mop_t_lexcompare: int  # 296
hx_mop_t_make_first_half: int  # 303
hx_mop_t_make_fpnum: int  # 285
hx_mop_t_make_gvar: int  # 287
hx_mop_t_make_helper: int  # 289
hx_mop_t_make_high_half: int  # 302
hx_mop_t_make_low_half: int  # 301
hx_mop_t_make_number: int  # 284
hx_mop_t_make_reg_pair: int  # 288
hx_mop_t_make_second_half: int  # 304
hx_mop_t_may_use_aliased_memory: int  # 291
hx_mop_t_preserve_side_effects: int  # 307
hx_mop_t_print: int  # 277
hx_mop_t_shift_mop: int  # 305
hx_mop_t_swap: int  # 275
hx_mreg2reg: int  # 253
hx_must_mcode_close_block: int  # 147
hx_mutable_graph_t_del_edge: int  # 266
hx_mutable_graph_t_goup: int  # 265
hx_mutable_graph_t_resize: int  # 264
hx_negate_mcode_relation: int  # 149
hx_negated_relation: int  # 445
hx_new_block: int  # 518
hx_open_pseudocode: int  # 436
hx_operand_locator_t_compare: int  # 154
hx_parse_user_call: int  # 197
hx_partial_type_num: int  # 163
hx_print_vdloc: int  # 176
hx_qstring_printer_t_print: int  # 157
hx_reg2mreg: int  # 252
hx_remitem: int  # 444
hx_remove_hexrays_callback: int  # 575
hx_remove_optblock_handler: int  # 258
hx_remove_optinsn_handler: int  # 256
hx_restore_user_cmts: int  # 530
hx_restore_user_defined_calls: int  # 195
hx_restore_user_iflags: int  # 532
hx_restore_user_labels: int  # 529
hx_restore_user_lvar_settings: int  # 190
hx_restore_user_numforms: int  # 531
hx_restore_user_unions: int  # 533
hx_rlist_t_dstr: int  # 245
hx_rlist_t_print: int  # 244
hx_save_user_cmts: int  # 525
hx_save_user_defined_calls: int  # 196
hx_save_user_iflags: int  # 527
hx_save_user_labels: int  # 524
hx_save_user_lvar_settings: int  # 191
hx_save_user_numforms: int  # 526
hx_save_user_unions: int  # 528
hx_select_udt_by_offset: int  # 615
hx_send_database: int  # 441
hx_set_type: int  # 172
hx_simple_graph_t_compute_dominators: int  # 259
hx_simple_graph_t_compute_immediate_dominators: int  # 260
hx_simple_graph_t_depth_first_postorder: int  # 262
hx_simple_graph_t_depth_first_preorder: int  # 261
hx_simple_graph_t_goup: int  # 263
hx_stkvar_ref_t_compare: int  # 269
hx_stkvar_ref_t_get_stkvar: int  # 270
hx_swap_mcode_relation: int  # 150
hx_swapped_relation: int  # 446
hx_udc_filter_t_apply: int  # 202
hx_udc_filter_t_cleanup: int  # 200
hx_udc_filter_t_init: int  # 201
hx_udcall_map_begin: int  # 26
hx_udcall_map_clear: int  # 35
hx_udcall_map_end: int  # 27
hx_udcall_map_erase: int  # 34
hx_udcall_map_find: int  # 32
hx_udcall_map_first: int  # 30
hx_udcall_map_free: int  # 37
hx_udcall_map_insert: int  # 33
hx_udcall_map_new: int  # 38
hx_udcall_map_next: int  # 28
hx_udcall_map_prev: int  # 29
hx_udcall_map_second: int  # 31
hx_udcall_map_size: int  # 36
hx_user_cmts_begin: int  # 39
hx_user_cmts_clear: int  # 48
hx_user_cmts_end: int  # 40
hx_user_cmts_erase: int  # 47
hx_user_cmts_find: int  # 45
hx_user_cmts_first: int  # 43
hx_user_cmts_free: int  # 50
hx_user_cmts_insert: int  # 46
hx_user_cmts_new: int  # 51
hx_user_cmts_next: int  # 41
hx_user_cmts_prev: int  # 42
hx_user_cmts_second: int  # 44
hx_user_cmts_size: int  # 49
hx_user_iflags_begin: int  # 52
hx_user_iflags_clear: int  # 61
hx_user_iflags_end: int  # 53
hx_user_iflags_erase: int  # 60
hx_user_iflags_find: int  # 58
hx_user_iflags_first: int  # 56
hx_user_iflags_free: int  # 63
hx_user_iflags_insert: int  # 59
hx_user_iflags_new: int  # 64
hx_user_iflags_next: int  # 54
hx_user_iflags_prev: int  # 55
hx_user_iflags_second: int  # 57
hx_user_iflags_size: int  # 62
hx_user_labels_begin: int  # 78
hx_user_labels_clear: int  # 87
hx_user_labels_end: int  # 79
hx_user_labels_erase: int  # 86
hx_user_labels_find: int  # 84
hx_user_labels_first: int  # 82
hx_user_labels_free: int  # 89
hx_user_labels_insert: int  # 85
hx_user_labels_new: int  # 90
hx_user_labels_next: int  # 80
hx_user_labels_prev: int  # 81
hx_user_labels_second: int  # 83
hx_user_labels_size: int  # 88
hx_user_numforms_begin: int  # 0
hx_user_numforms_clear: int  # 9
hx_user_numforms_end: int  # 1
hx_user_numforms_erase: int  # 8
hx_user_numforms_find: int  # 6
hx_user_numforms_first: int  # 4
hx_user_numforms_free: int  # 11
hx_user_numforms_insert: int  # 7
hx_user_numforms_new: int  # 12
hx_user_numforms_next: int  # 2
hx_user_numforms_prev: int  # 3
hx_user_numforms_second: int  # 5
hx_user_numforms_size: int  # 10
hx_user_unions_begin: int  # 65
hx_user_unions_clear: int  # 74
hx_user_unions_end: int  # 66
hx_user_unions_erase: int  # 73
hx_user_unions_find: int  # 71
hx_user_unions_first: int  # 69
hx_user_unions_free: int  # 76
hx_user_unions_insert: int  # 72
hx_user_unions_new: int  # 77
hx_user_unions_next: int  # 67
hx_user_unions_prev: int  # 68
hx_user_unions_second: int  # 70
hx_user_unions_size: int  # 75
hx_valrng_t_assign: int  # 133
hx_valrng_t_clear: int  # 131
hx_valrng_t_compare: int  # 134
hx_valrng_t_copy: int  # 132
hx_valrng_t_cvt_to_cmp: int  # 145
hx_valrng_t_cvt_to_single_value: int  # 144
hx_valrng_t_dstr: int  # 143
hx_valrng_t_has: int  # 141
hx_valrng_t_intersect_with: int  # 138
hx_valrng_t_inverse: int  # 140
hx_valrng_t_print: int  # 142
hx_valrng_t_reduce_size: int  # 137
hx_valrng_t_set_cmp: int  # 136
hx_valrng_t_set_eq: int  # 135
hx_valrng_t_unite_with: int  # 139
hx_var_ref_t_compare: int  # 454
hx_vcall_helper: int  # 520
hx_vcreate_helper: int  # 519
hx_vd_printer_t_print: int  # 155
hx_vdloc_t_compare: int  # 174
hx_vdloc_t_dstr: int  # 173
hx_vdloc_t_is_aliasable: int  # 175
hx_vdui_t_calc_cmt_type: int  # 603
hx_vdui_t_clear: int  # 582
hx_vdui_t_collapse_item: int  # 612
hx_vdui_t_collapse_lvars: int  # 613
hx_vdui_t_ctree_to_disasm: int  # 602
hx_vdui_t_del_orphan_cmts: int  # 606
hx_vdui_t_edit_cmt: int  # 604
hx_vdui_t_edit_func_cmt: int  # 605
hx_vdui_t_get_current_item: int  # 584
hx_vdui_t_get_current_label: int  # 581
hx_vdui_t_get_number: int  # 580
hx_vdui_t_invert_bits: int  # 611
hx_vdui_t_invert_sign: int  # 610
hx_vdui_t_jump_enter: int  # 601
hx_vdui_t_map_lvar: int  # 595
hx_vdui_t_refresh_cpos: int  # 583
hx_vdui_t_refresh_ctext: int  # 578
hx_vdui_t_refresh_view: int  # 577
hx_vdui_t_rename_global: int  # 599
hx_vdui_t_rename_label: int  # 600
hx_vdui_t_rename_lvar: int  # 586
hx_vdui_t_rename_udm: int  # 597
hx_vdui_t_set_global_type: int  # 598
hx_vdui_t_set_locked: int  # 576
hx_vdui_t_set_lvar_cmt: int  # 592
hx_vdui_t_set_lvar_type: int  # 589
hx_vdui_t_set_noptr_lvar: int  # 590
hx_vdui_t_set_num_enum: int  # 608
hx_vdui_t_set_num_radix: int  # 607
hx_vdui_t_set_num_stroff: int  # 609
hx_vdui_t_set_udm_type: int  # 596
hx_vdui_t_split_item: int  # 614
hx_vdui_t_switch_to: int  # 579
hx_vdui_t_ui_edit_lvar_cmt: int  # 591
hx_vdui_t_ui_map_lvar: int  # 593
hx_vdui_t_ui_rename_lvar: int  # 585
hx_vdui_t_ui_set_call_type: int  # 587
hx_vdui_t_ui_set_lvar_type: int  # 588
hx_vdui_t_ui_unmap_lvar: int  # 594
hx_vivl_t_dstr: int  # 323
hx_vivl_t_extend_to_cover: int  # 320
hx_vivl_t_intersect: int  # 321
hx_vivl_t_print: int  # 322
hxe_begin_inlining: int  # 19
hxe_build_callinfo: int  # 16
hxe_callinfo_built: int  # 17
hxe_calls_done: int  # 18
hxe_close_pseudocode: int  # 103
hxe_cmt_changed: int  # 115
hxe_collect_warnings: int  # 22
hxe_combine: int  # 12
hxe_create_hint: int  # 108
hxe_curpos: int  # 107
hxe_double_click: int  # 106
hxe_flowchart: int  # 0
hxe_func_printed: int  # 14
hxe_glbopt: int  # 7
hxe_inlined_func: int  # 21
hxe_inlining_func: int  # 20
hxe_interr: int  # 11
hxe_keyboard: int  # 104
hxe_locopt: int  # 5
hxe_maturity: int  # 10
hxe_mba_maturity: int  # 116
hxe_microcode: int  # 3
hxe_open_pseudocode: int  # 100
hxe_populating_popup: int  # 110
hxe_pre_structural: int  # 8
hxe_prealloc: int  # 6
hxe_preoptimized: int  # 4
hxe_print_func: int  # 13
hxe_prolog: int  # 2
hxe_refresh_pseudocode: int  # 102
hxe_resolve_stkaddrs: int  # 15
hxe_right_click: int  # 105
hxe_stkpnts: int  # 1
hxe_structural: int  # 9
hxe_switch_pseudocode: int  # 101
hxe_text_ready: int  # 109
ida_expr: module
ida_funcs: module
ida_gdl: module
ida_ida: _module_wrapper_t
ida_idaapi: module
ida_idd: module
ida_idp: module
ida_kernwin: module
ida_nalt: module
ida_pro: module
ida_range: module
ida_segment: module
ida_typeinf: module
ida_ua: module
ida_xref: module
idasgn_loaded: int  # 7
idasgn_matched_ea: int  # 84
iek_key_press: int  # 2
iek_key_release: int  # 3
iek_mouse_button_press: int  # 4
iek_mouse_button_release: int  # 5
iek_mouse_wheel: int  # 6
iek_shortcut: int  # 1
iek_unknown: int  # 0
ignore_glabel: int  # 4
ignore_llabel: int  # 2
ignore_none: int  # 0
ignore_regvar: int  # 1
ignore_stkvar: int  # 3
inspect: module
integer_types: tuple  # (<class 'int'>,)
item_color_changed: int  # 59
j_a_hardware: int  # 207
j_a_invokeignored: int  # 205
j_a_invokesuper: int  # 203
j_a_invokevirtualobject: int  # 204
j_a_software: int  # 206
j_aaload: int  # 50
j_aastore: int  # 83
j_aconst_null: int  # 1
j_aload: int  # 25
j_aload_0: int  # 42
j_aload_1: int  # 43
j_aload_2: int  # 44
j_aload_3: int  # 45
j_anewarray: int  # 189
j_anewarray_quick: int  # 222
j_areturn: int  # 176
j_arraylength: int  # 190
j_astore: int  # 58
j_astore_0: int  # 75
j_astore_1: int  # 76
j_astore_2: int  # 77
j_astore_3: int  # 78
j_athrow: int  # 191
j_baload: int  # 51
j_bastore: int  # 84
j_bipush: int  # 16
j_breakpoint: int  # 202
j_caload: int  # 52
j_castore: int  # 85
j_checkcast: int  # 192
j_checkcast_quick: int  # 224
j_d2f: int  # 144
j_d2i: int  # 142
j_d2l: int  # 143
j_dadd: int  # 99
j_daload: int  # 49
j_dastore: int  # 82
j_dcmpg: int  # 152
j_dcmpl: int  # 151
j_dconst_0: int  # 14
j_dconst_1: int  # 15
j_ddiv: int  # 111
j_dload: int  # 24
j_dload_0: int  # 38
j_dload_1: int  # 39
j_dload_2: int  # 40
j_dload_3: int  # 41
j_dmul: int  # 107
j_dneg: int  # 119
j_drem: int  # 115
j_dreturn: int  # 175
j_dstore: int  # 57
j_dstore_0: int  # 71
j_dstore_1: int  # 72
j_dstore_2: int  # 73
j_dstore_3: int  # 74
j_dsub: int  # 103
j_dup: int  # 89
j_dup2: int  # 92
j_dup2_x1: int  # 93
j_dup2_x2: int  # 94
j_dup_x1: int  # 90
j_dup_x2: int  # 91
j_f2d: int  # 141
j_f2i: int  # 139
j_f2l: int  # 140
j_fadd: int  # 98
j_faload: int  # 48
j_fastore: int  # 81
j_fcmpg: int  # 150
j_fcmpl: int  # 149
j_fconst_0: int  # 11
j_fconst_1: int  # 12
j_fconst_2: int  # 13
j_fdiv: int  # 110
j_fload: int  # 23
j_fload_0: int  # 34
j_fload_1: int  # 35
j_fload_2: int  # 36
j_fload_3: int  # 37
j_fmul: int  # 106
j_fneg: int  # 118
j_frem: int  # 114
j_freturn: int  # 174
j_fstore: int  # 56
j_fstore_0: int  # 67
j_fstore_1: int  # 68
j_fstore_2: int  # 69
j_fstore_3: int  # 70
j_fsub: int  # 102
j_getfield: int  # 180
j_getfield2_quick: int  # 208
j_getfield_quick: int  # 206
j_getfield_quick_w: int  # 227
j_getstatic: int  # 178
j_getstatic2_quick: int  # 212
j_getstatic_quick: int  # 210
j_goto: int  # 167
j_goto_w: int  # 200
j_i2b: int  # 145
j_i2c: int  # 146
j_i2d: int  # 135
j_i2f: int  # 134
j_i2l: int  # 133
j_i2s: int  # 147
j_iadd: int  # 96
j_iaload: int  # 46
j_iand: int  # 126
j_iastore: int  # 79
j_iconst_0: int  # 3
j_iconst_1: int  # 4
j_iconst_2: int  # 5
j_iconst_3: int  # 6
j_iconst_4: int  # 7
j_iconst_5: int  # 8
j_iconst_m1: int  # 2
j_idiv: int  # 108
j_if_acmpeq: int  # 165
j_if_acmpne: int  # 166
j_if_icmpeq: int  # 159
j_if_icmpge: int  # 162
j_if_icmpgt: int  # 163
j_if_icmple: int  # 164
j_if_icmplt: int  # 161
j_if_icmpne: int  # 160
j_ifeq: int  # 153
j_ifge: int  # 156
j_ifgt: int  # 157
j_ifle: int  # 158
j_iflt: int  # 155
j_ifne: int  # 154
j_ifnonnull: int  # 199
j_ifnull: int  # 198
j_iinc: int  # 132
j_iload: int  # 21
j_iload_0: int  # 26
j_iload_1: int  # 27
j_iload_2: int  # 28
j_iload_3: int  # 29
j_imul: int  # 104
j_ineg: int  # 116
j_instanceof: int  # 193
j_instanceof_quick: int  # 225
j_invokedynamic: int  # 186
j_invokeignored_quick: int  # 220
j_invokeinterface: int  # 185
j_invokeinterface_quick: int  # 218
j_invokenonvirtual_quick: int  # 215
j_invokespecial: int  # 183
j_invokestatic: int  # 184
j_invokestatic_quick: int  # 217
j_invokesuper_quick: int  # 216
j_invokevirtual: int  # 182
j_invokevirtual_quick: int  # 214
j_invokevirtual_quick_w: int  # 226
j_invokevirtualobject_quick: int  # 219
j_ior: int  # 128
j_irem: int  # 112
j_ireturn: int  # 172
j_ishl: int  # 120
j_ishr: int  # 122
j_istore: int  # 54
j_istore_0: int  # 59
j_istore_1: int  # 60
j_istore_2: int  # 61
j_istore_3: int  # 62
j_isub: int  # 100
j_iushr: int  # 124
j_ixor: int  # 130
j_jsr: int  # 168
j_jsr_w: int  # 201
j_l2d: int  # 138
j_l2f: int  # 137
j_l2i: int  # 136
j_ladd: int  # 97
j_laload: int  # 47
j_land: int  # 127
j_last: int  # 208
j_lastnorm: int  # 203
j_lastore: int  # 80
j_lcmp: int  # 148
j_lconst_0: int  # 9
j_lconst_1: int  # 10
j_ldc: int  # 18
j_ldc2w: int  # 20
j_ldc2w_quick: int  # 205
j_ldc_quick: int  # 203
j_ldcw: int  # 19
j_ldcw_quick: int  # 204
j_ldiv: int  # 109
j_lload: int  # 22
j_lload_0: int  # 30
j_lload_1: int  # 31
j_lload_2: int  # 32
j_lload_3: int  # 33
j_lmul: int  # 105
j_lneg: int  # 117
j_lookupswitch: int  # 171
j_lor: int  # 129
j_lrem: int  # 113
j_lreturn: int  # 173
j_lshl: int  # 121
j_lshr: int  # 123
j_lstore: int  # 55
j_lstore_0: int  # 63
j_lstore_1: int  # 64
j_lstore_2: int  # 65
j_lstore_3: int  # 66
j_lsub: int  # 101
j_lushr: int  # 125
j_lxor: int  # 131
j_monitorenter: int  # 194
j_monitorexit: int  # 195
j_multianewarray: int  # 197
j_multianewarray_quick: int  # 223
j_new: int  # 187
j_new_quick: int  # 221
j_newarray: int  # 188
j_nop: int  # 0
j_pop: int  # 87
j_pop2: int  # 88
j_putfield: int  # 181
j_putfield2_quick: int  # 209
j_putfield_quick: int  # 207
j_putfield_quick_w: int  # 228
j_putstatic: int  # 179
j_putstatic2_quick: int  # 213
j_putstatic_quick: int  # 211
j_quick_last: int  # 229
j_ret: int  # 169
j_return: int  # 177
j_saload: int  # 53
j_sastore: int  # 86
j_sipush: int  # 17
j_swap: int  # 95
j_tableswitch: int  # 170
j_wide: int  # 196
k: str  # voff_t_undef
kernel_config_loaded: int  # 8
layout_circle: int  # 3
layout_digraph: int  # 1
layout_none: int  # 0
layout_orthogonal: int  # 5
layout_polar_tree: int  # 4
layout_radial_tree: int  # 6
layout_tree: int  # 2
loader_finished: int  # 9
local_type_renamed: int  # 89
local_types_changed: int  # 72
lt_edm_changed: int  # 88
lt_edm_created: int  # 85
lt_edm_deleted: int  # 86
lt_edm_renamed: int  # 87
lt_udm_changed: int  # 76
lt_udm_created: int  # 73
lt_udm_deleted: int  # 74
lt_udm_renamed: int  # 75
lt_udt_expanded: int  # 77
ltag: int  # 76
lxe_lvar_cmt_changed: int  # 113
lxe_lvar_mapping_changed: int  # 114
lxe_lvar_name_changed: int  # 111
lxe_lvar_type_changed: int  # 112
m32r_add: int  # 1
m32r_add3: int  # 2
m32r_addi: int  # 3
m32r_addv: int  # 4
m32r_addv3: int  # 5
m32r_addx: int  # 6
m32r_and: int  # 7
m32r_and3: int  # 8
m32r_bc: int  # 9
m32r_bclr: int  # 132
m32r_beq: int  # 10
m32r_beqz: int  # 11
m32r_bgez: int  # 12
m32r_bgtz: int  # 13
m32r_bl: int  # 14
m32r_blez: int  # 15
m32r_bltz: int  # 16
m32r_bnc: int  # 17
m32r_bne: int  # 18
m32r_bnez: int  # 19
m32r_bra: int  # 20
m32r_bset: int  # 131
m32r_btst: int  # 133
m32r_clrpsw: int  # 135
m32r_cmp: int  # 21
m32r_cmpi: int  # 22
m32r_cmpu: int  # 23
m32r_cmpui: int  # 24
m32r_div: int  # 25
m32r_divu: int  # 26
m32r_fadd: int  # 119
m32r_fcmp: int  # 129
m32r_fcmpe: int  # 130
m32r_fdiv: int  # 122
m32r_fmadd: int  # 123
m32r_fmsub: int  # 124
m32r_fmul: int  # 121
m32r_fsub: int  # 120
m32r_ftoi: int  # 127
m32r_ftos: int  # 128
m32r_itof: int  # 125
m32r_jl: int  # 27
m32r_jmp: int  # 28
m32r_last: int  # 136
m32r_ld: int  # 29
m32r_ld24: int  # 30
m32r_ldb: int  # 31
m32r_ldh: int  # 32
m32r_ldi: int  # 33
m32r_ldub: int  # 34
m32r_lduh: int  # 35
m32r_lock: int  # 36
m32r_machi: int  # 37
m32r_maclo: int  # 38
m32r_macwhi: int  # 39
m32r_macwlo: int  # 40
m32r_mul: int  # 41
m32r_mulhi: int  # 42
m32r_mullo: int  # 43
m32r_mulwhi: int  # 44
m32r_mulwlo: int  # 45
m32r_mv: int  # 46
m32r_mvfachi: int  # 47
m32r_mvfaclo: int  # 48
m32r_mvfacmi: int  # 49
m32r_mvfc: int  # 50
m32r_mvtachi: int  # 51
m32r_mvtaclo: int  # 52
m32r_mvtc: int  # 53
m32r_neg: int  # 54
m32r_nop: int  # 55
m32r_not: int  # 56
m32r_null: int  # 0
m32r_or: int  # 57
m32r_or3: int  # 58
m32r_pop: int  # 60
m32r_push: int  # 59
m32r_rac: int  # 61
m32r_rach: int  # 62
m32r_rem: int  # 63
m32r_remu: int  # 64
m32r_rte: int  # 65
m32r_seth: int  # 66
m32r_setpsw: int  # 134
m32r_sll: int  # 67
m32r_sll3: int  # 68
m32r_slli: int  # 69
m32r_sra: int  # 70
m32r_sra3: int  # 71
m32r_srai: int  # 72
m32r_srl: int  # 73
m32r_srl3: int  # 74
m32r_srli: int  # 75
m32r_st: int  # 76
m32r_stb: int  # 77
m32r_sth: int  # 78
m32r_sub: int  # 79
m32r_subv: int  # 80
m32r_subx: int  # 81
m32r_trap: int  # 82
m32r_unlock: int  # 83
m32r_utof: int  # 126
m32r_xor: int  # 84
m32r_xor3: int  # 85
m32rx_bcl: int  # 86
m32rx_bncl: int  # 87
m32rx_cmpeq: int  # 88
m32rx_cmpz: int  # 89
m32rx_divh: int  # 90
m32rx_jc: int  # 91
m32rx_jnc: int  # 92
m32rx_machi: int  # 93
m32rx_maclh1: int  # 116
m32rx_maclo: int  # 94
m32rx_macwhi: int  # 95
m32rx_macwlo: int  # 96
m32rx_macwu1: int  # 113
m32rx_msblo: int  # 114
m32rx_mulhi: int  # 97
m32rx_mullo: int  # 98
m32rx_mulwhi: int  # 99
m32rx_mulwlo: int  # 100
m32rx_mulwu1: int  # 115
m32rx_mvfachi: int  # 101
m32rx_mvfaclo: int  # 102
m32rx_mvfacmi: int  # 103
m32rx_mvtachi: int  # 104
m32rx_mvtaclo: int  # 105
m32rx_pcmpbz: int  # 111
m32rx_rac: int  # 106
m32rx_rach: int  # 107
m32rx_sadd: int  # 112
m32rx_sat: int  # 110
m32rx_satb: int  # 108
m32rx_sath: int  # 109
m32rx_sc: int  # 117
m32rx_snc: int  # 118
m740_adc: int  # 1
m740_and: int  # 2
m740_asl: int  # 3
m740_bbc: int  # 4
m740_bbs: int  # 5
m740_bcc: int  # 6
m740_bcs: int  # 7
m740_beq: int  # 8
m740_bit: int  # 9
m740_bmi: int  # 10
m740_bne: int  # 11
m740_bpl: int  # 12
m740_bra: int  # 13
m740_brk: int  # 14
m740_bvc: int  # 15
m740_bvs: int  # 16
m740_clb: int  # 17
m740_clc: int  # 18
m740_cld: int  # 19
m740_cli: int  # 20
m740_clt: int  # 21
m740_clv: int  # 22
m740_cmp: int  # 23
m740_com: int  # 24
m740_cpx: int  # 25
m740_cpy: int  # 26
m740_dec: int  # 27
m740_dex: int  # 28
m740_dey: int  # 29
m740_div: int  # 30
m740_eor: int  # 31
m740_inc: int  # 32
m740_inx: int  # 33
m740_iny: int  # 34
m740_jmp: int  # 35
m740_jsr: int  # 36
m740_last: int  # 72
m740_lda: int  # 37
m740_ldm: int  # 38
m740_ldx: int  # 39
m740_ldy: int  # 40
m740_lsr: int  # 41
m740_mul: int  # 42
m740_nop: int  # 43
m740_null: int  # 0
m740_ora: int  # 44
m740_pha: int  # 45
m740_php: int  # 46
m740_pla: int  # 47
m740_plp: int  # 48
m740_rol: int  # 49
m740_ror: int  # 50
m740_rrf: int  # 51
m740_rti: int  # 52
m740_rts: int  # 53
m740_sbc: int  # 54
m740_seb: int  # 55
m740_sec: int  # 56
m740_sed: int  # 57
m740_sei: int  # 58
m740_set: int  # 59
m740_sta: int  # 60
m740_stp: int  # 61
m740_stx: int  # 62
m740_sty: int  # 63
m740_tax: int  # 64
m740_tay: int  # 65
m740_tst: int  # 66
m740_tsx: int  # 67
m740_txa: int  # 68
m740_txs: int  # 69
m740_tya: int  # 70
m740_wit: int  # 71
m7700_adc: int  # 1
m7700_and: int  # 2
m7700_asl: int  # 3
m7700_bbc: int  # 4
m7700_bbs: int  # 5
m7700_bcc: int  # 6
m7700_bcs: int  # 7
m7700_beq: int  # 8
m7700_bmi: int  # 9
m7700_bne: int  # 10
m7700_bpl: int  # 11
m7700_bra: int  # 12
m7700_brk: int  # 13
m7700_bvc: int  # 14
m7700_bvs: int  # 15
m7700_clb: int  # 16
m7700_clc: int  # 17
m7700_cli: int  # 18
m7700_clm: int  # 19
m7700_clp: int  # 20
m7700_clv: int  # 21
m7700_cmp: int  # 22
m7700_cpx: int  # 23
m7700_cpy: int  # 24
m7700_dec: int  # 25
m7700_dex: int  # 26
m7700_dey: int  # 27
m7700_div: int  # 28
m7700_eor: int  # 29
m7700_inc: int  # 30
m7700_inx: int  # 31
m7700_iny: int  # 32
m7700_jmp: int  # 33
m7700_jsr: int  # 34
m7700_last: int  # 109
m7700_lda: int  # 35
m7700_ldm: int  # 36
m7700_ldt: int  # 37
m7700_ldx: int  # 38
m7700_ldy: int  # 39
m7700_lsr: int  # 40
m7700_mpy: int  # 41
m7700_mvn: int  # 42
m7700_mvp: int  # 43
m7700_nop: int  # 44
m7700_null: int  # 0
m7700_ora: int  # 45
m7700_pea: int  # 46
m7700_pei: int  # 47
m7700_per: int  # 48
m7700_pha: int  # 49
m7700_phb: int  # 50
m7700_phd: int  # 51
m7700_phg: int  # 52
m7700_php: int  # 53
m7700_pht: int  # 54
m7700_phx: int  # 55
m7700_phy: int  # 56
m7700_pla: int  # 57
m7700_plb: int  # 58
m7700_pld: int  # 59
m7700_plp: int  # 60
m7700_plt: int  # 61
m7700_plx: int  # 62
m7700_ply: int  # 63
m7700_psh: int  # 64
m7700_pul: int  # 65
m7700_rla: int  # 66
m7700_rol: int  # 67
m7700_ror: int  # 68
m7700_rti: int  # 69
m7700_rtl: int  # 70
m7700_rts: int  # 71
m7700_sbc: int  # 72
m7700_seb: int  # 73
m7700_sec: int  # 74
m7700_sei: int  # 75
m7700_sem: int  # 76
m7700_sep: int  # 77
m7700_sta: int  # 78
m7700_stp: int  # 79
m7700_stx: int  # 80
m7700_sty: int  # 81
m7700_tad: int  # 82
m7700_tas: int  # 83
m7700_tax: int  # 84
m7700_tay: int  # 85
m7700_tbd: int  # 86
m7700_tbs: int  # 87
m7700_tbx: int  # 88
m7700_tby: int  # 89
m7700_tda: int  # 90
m7700_tdb: int  # 91
m7700_tsa: int  # 92
m7700_tsb: int  # 93
m7700_tsx: int  # 94
m7700_txa: int  # 95
m7700_txb: int  # 96
m7700_txs: int  # 97
m7700_txy: int  # 98
m7700_tya: int  # 99
m7700_tyb: int  # 100
m7700_tyx: int  # 101
m7700_wit: int  # 102
m7700_xab: int  # 103
m7750_asr: int  # 104
m7750_divs: int  # 105
m7750_exts: int  # 106
m7750_extz: int  # 107
m7750_mpys: int  # 108
m7900_abs: int  # 1
m7900_absd: int  # 2
m7900_adc: int  # 3
m7900_adcb: int  # 4
m7900_adcd: int  # 5
m7900_add: int  # 6
m7900_addb: int  # 7
m7900_addd: int  # 8
m7900_addm: int  # 9
m7900_addmb: int  # 10
m7900_addmd: int  # 11
m7900_adds: int  # 12
m7900_addx: int  # 13
m7900_addy: int  # 14
m7900_and: int  # 15
m7900_andb: int  # 16
m7900_andm: int  # 17
m7900_andmb: int  # 18
m7900_andmd: int  # 19
m7900_asl: int  # 20
m7900_asldn: int  # 22
m7900_asln: int  # 21
m7900_asr: int  # 23
m7900_asrdn: int  # 25
m7900_asrn: int  # 24
m7900_bbc: int  # 26
m7900_bbcb: int  # 27
m7900_bbs: int  # 28
m7900_bbsb: int  # 29
m7900_bcc: int  # 30
m7900_bcs: int  # 31
m7900_beq: int  # 32
m7900_bge: int  # 33
m7900_bgt: int  # 34
m7900_bgtu: int  # 35
m7900_ble: int  # 36
m7900_bleu: int  # 37
m7900_blt: int  # 38
m7900_bmi: int  # 39
m7900_bne: int  # 40
m7900_bpl: int  # 41
m7900_bra: int  # 42
m7900_bral: int  # 43
m7900_brk: int  # 44
m7900_bsc: int  # 45
m7900_bsr: int  # 46
m7900_bss: int  # 47
m7900_bvc: int  # 48
m7900_bvs: int  # 49
m7900_cbeq: int  # 50
m7900_cbeqb: int  # 51
m7900_cbne: int  # 52
m7900_cbneb: int  # 53
m7900_clc: int  # 54
m7900_cli: int  # 55
m7900_clm: int  # 56
m7900_clp: int  # 57
m7900_clr: int  # 58
m7900_clrb: int  # 59
m7900_clrm: int  # 60
m7900_clrmb: int  # 61
m7900_clrx: int  # 62
m7900_clry: int  # 63
m7900_clv: int  # 64
m7900_cmp: int  # 65
m7900_cmpb: int  # 66
m7900_cmpd: int  # 67
m7900_cmpm: int  # 68
m7900_cmpmb: int  # 69
m7900_cmpmd: int  # 70
m7900_cpx: int  # 71
m7900_cpy: int  # 72
m7900_debne: int  # 73
m7900_dec: int  # 74
m7900_dex: int  # 75
m7900_dey: int  # 76
m7900_div: int  # 77
m7900_divs: int  # 78
m7900_dxbne: int  # 79
m7900_dybne: int  # 80
m7900_eor: int  # 81
m7900_eorb: int  # 82
m7900_eorm: int  # 83
m7900_eormb: int  # 84
m7900_eormd: int  # 85
m7900_exts: int  # 86
m7900_extsd: int  # 87
m7900_extz: int  # 88
m7900_extzd: int  # 89
m7900_inc: int  # 90
m7900_inx: int  # 91
m7900_iny: int  # 92
m7900_jmp: int  # 93
m7900_jmpl: int  # 94
m7900_jsr: int  # 95
m7900_jsrl: int  # 96
m7900_last: int  # 207
m7900_lda: int  # 97
m7900_ldab: int  # 98
m7900_ldad: int  # 99
m7900_lddn: int  # 100
m7900_ldt: int  # 101
m7900_ldx: int  # 102
m7900_ldxb: int  # 103
m7900_ldy: int  # 104
m7900_ldyb: int  # 105
m7900_lsr: int  # 106
m7900_lsrdn: int  # 108
m7900_lsrn: int  # 107
m7900_movm: int  # 109
m7900_movmb: int  # 110
m7900_movr: int  # 111
m7900_movrb: int  # 112
m7900_mpy: int  # 113
m7900_mpys: int  # 114
m7900_mvn: int  # 115
m7900_mvp: int  # 116
m7900_neg: int  # 117
m7900_negd: int  # 118
m7900_nop: int  # 119
m7900_null: int  # 0
m7900_ora: int  # 120
m7900_orab: int  # 121
m7900_oram: int  # 122
m7900_oramb: int  # 123
m7900_oramd: int  # 124
m7900_pea: int  # 125
m7900_pei: int  # 126
m7900_per: int  # 127
m7900_pha: int  # 128
m7900_phb: int  # 129
m7900_phd: int  # 130
m7900_phdn: int  # 131
m7900_phg: int  # 132
m7900_phldn: int  # 133
m7900_php: int  # 134
m7900_pht: int  # 135
m7900_phx: int  # 136
m7900_phy: int  # 137
m7900_pla: int  # 138
m7900_plb: int  # 139
m7900_pld: int  # 140
m7900_pldn: int  # 141
m7900_plp: int  # 142
m7900_plt: int  # 143
m7900_plx: int  # 144
m7900_ply: int  # 145
m7900_psh: int  # 146
m7900_pul: int  # 147
m7900_rla: int  # 148
m7900_rmpa: int  # 149
m7900_rol: int  # 150
m7900_roldn: int  # 152
m7900_roln: int  # 151
m7900_ror: int  # 153
m7900_rordn: int  # 155
m7900_rorn: int  # 154
m7900_rti: int  # 156
m7900_rtl: int  # 157
m7900_rtld: int  # 158
m7900_rts: int  # 159
m7900_rtsdn: int  # 160
m7900_sbc: int  # 161
m7900_sbcb: int  # 162
m7900_sbcd: int  # 163
m7900_sec: int  # 164
m7900_sei: int  # 165
m7900_sem: int  # 166
m7900_sep: int  # 167
m7900_sta: int  # 168
m7900_stab: int  # 169
m7900_stad: int  # 170
m7900_stp: int  # 171
m7900_stx: int  # 172
m7900_sty: int  # 173
m7900_sub: int  # 174
m7900_subb: int  # 175
m7900_subd: int  # 176
m7900_subm: int  # 177
m7900_submb: int  # 178
m7900_submd: int  # 179
m7900_subs: int  # 180
m7900_subx: int  # 181
m7900_suby: int  # 182
m7900_tadn: int  # 183
m7900_tas: int  # 184
m7900_tax: int  # 185
m7900_tay: int  # 186
m7900_tbdn: int  # 187
m7900_tbs: int  # 188
m7900_tbx: int  # 189
m7900_tby: int  # 190
m7900_tdan: int  # 191
m7900_tdbn: int  # 192
m7900_tds: int  # 193
m7900_tsa: int  # 194
m7900_tsb: int  # 195
m7900_tsd: int  # 196
m7900_tsx: int  # 197
m7900_txa: int  # 198
m7900_txb: int  # 199
m7900_txs: int  # 200
m7900_txy: int  # 201
m7900_tya: int  # 202
m7900_tyb: int  # 203
m7900_tyx: int  # 204
m7900_wit: int  # 205
m7900_xab: int  # 206
m_add: int  # 12
m_and: int  # 20
m_bnot: int  # 7
m_call: int  # 56
m_cfadd: int  # 25
m_cfshl: int  # 27
m_cfshr: int  # 28
m_ext: int  # 62
m_f2f: int  # 67
m_f2i: int  # 63
m_f2u: int  # 64
m_fadd: int  # 69
m_fdiv: int  # 72
m_fmul: int  # 71
m_fneg: int  # 68
m_fsub: int  # 70
m_goto: int  # 55
m_high: int  # 11
m_i2f: int  # 65
m_icall: int  # 57
m_ijmp: int  # 54
m_ja: int  # 47
m_jae: int  # 45
m_jb: int  # 46
m_jbe: int  # 48
m_jcnd: int  # 42
m_jg: int  # 49
m_jge: int  # 50
m_jl: int  # 51
m_jle: int  # 52
m_jnz: int  # 43
m_jtbl: int  # 53
m_jz: int  # 44
m_ldc: int  # 3
m_ldx: int  # 2
m_lnot: int  # 6
m_low: int  # 10
m_mov: int  # 4
m_mul: int  # 14
m_neg: int  # 5
m_nop: int  # 0
m_ofadd: int  # 26
m_or: int  # 19
m_pop: int  # 60
m_push: int  # 59
m_ret: int  # 58
m_sar: int  # 24
m_sdiv: int  # 16
m_seta: int  # 36
m_setae: int  # 34
m_setb: int  # 35
m_setbe: int  # 37
m_setg: int  # 38
m_setge: int  # 39
m_setl: int  # 40
m_setle: int  # 41
m_setnz: int  # 32
m_seto: int  # 30
m_setp: int  # 31
m_sets: int  # 29
m_setz: int  # 33
m_shl: int  # 22
m_shr: int  # 23
m_smod: int  # 18
m_stx: int  # 1
m_sub: int  # 13
m_u2f: int  # 66
m_udiv: int  # 15
m_umod: int  # 17
m_und: int  # 61
m_xds: int  # 8
m_xdu: int  # 9
m_xor: int  # 21
make_code: int  # 49
make_data: int  # 50
mbox_error: int  # 3
mbox_feedback: int  # 5
mbox_filestruct: int  # 8
mbox_hide: int  # 10
mbox_info: int  # 1
mbox_internal: int  # 0
mbox_nomem: int  # 4
mbox_readerror: int  # 6
mbox_replace: int  # 11
mbox_wait: int  # 9
mbox_warning: int  # 2
mbox_writeerror: int  # 7
mc8_1: int  # 136
mc8_2: int  # 137
mc8_ab: int  # 2
mc8_aba: int  # 1
mc8_adc: int  # 3
mc8_add: int  # 4
mc8_addd: int  # 5
mc8_aim: int  # 139
mc8_ais: int  # 6
mc8_aix: int  # 7
mc8_and: int  # 8
mc8_andcc: int  # 9
mc8_asr: int  # 10
mc8_bcc: int  # 11
mc8_bclr: int  # 12
mc8_bcs: int  # 13
mc8_beq: int  # 14
mc8_bge: int  # 15
mc8_bgnd: int  # 143
mc8_bgt: int  # 16
mc8_bhcc: int  # 17
mc8_bhcs: int  # 18
mc8_bhi: int  # 19
mc8_bhs: int  # 20
mc8_bih: int  # 21
mc8_bil: int  # 22
mc8_bit: int  # 23
mc8_ble: int  # 24
mc8_blo: int  # 25
mc8_bls: int  # 26
mc8_blt: int  # 27
mc8_bmc: int  # 28
mc8_bmi: int  # 29
mc8_bms: int  # 30
mc8_bne: int  # 31
mc8_bpl: int  # 32
mc8_bra: int  # 33
mc8_brclr: int  # 34
mc8_brn: int  # 35
mc8_brset: int  # 36
mc8_bset: int  # 37
mc8_bsr: int  # 38
mc8_bvc: int  # 39
mc8_bvs: int  # 40
mc8_call: int  # 144
mc8_cba: int  # 41
mc8_cbeq: int  # 42
mc8_clc: int  # 43
mc8_cli: int  # 44
mc8_clr: int  # 45
mc8_clv: int  # 46
mc8_cmp: int  # 47
mc8_com: int  # 48
mc8_cp: int  # 49
mc8_cpd: int  # 50
mc8_cphx: int  # 51
mc8_cpx: int  # 52
mc8_cwai: int  # 53
mc8_daa: int  # 54
mc8_dbnz: int  # 55
mc8_de: int  # 56
mc8_dec: int  # 57
mc8_des: int  # 58
mc8_div: int  # 59
mc8_eim: int  # 141
mc8_eor: int  # 60
mc8_exg: int  # 61
mc8_fdiv: int  # 62
mc8_idiv: int  # 63
mc8_in: int  # 64
mc8_inc: int  # 65
mc8_ins: int  # 66
mc8_jmp: int  # 67
mc8_jsr: int  # 68
mc8_last: int  # 148
mc8_ld: int  # 69
mc8_lda: int  # 70
mc8_ldd: int  # 71
mc8_ldhx: int  # 72
mc8_lds: int  # 73
mc8_ldx: int  # 74
mc8_lea: int  # 75
mc8_lsl: int  # 76
mc8_lsld: int  # 77
mc8_lsr: int  # 78
mc8_lsrd: int  # 79
mc8_mov: int  # 80
mc8_mul: int  # 81
mc8_neg: int  # 82
mc8_nop: int  # 83
mc8_nsa: int  # 84
mc8_null: int  # 0
mc8_oim: int  # 140
mc8_ora: int  # 85
mc8_orcc: int  # 86
mc8_os9: int  # 138
mc8_psh: int  # 87
mc8_psha: int  # 88
mc8_pshb: int  # 89
mc8_pshh: int  # 90
mc8_pshx: int  # 91
mc8_pul: int  # 92
mc8_pula: int  # 93
mc8_pulb: int  # 94
mc8_pulh: int  # 95
mc8_pulx: int  # 96
mc8_rol: int  # 97
mc8_ror: int  # 98
mc8_rsp: int  # 99
mc8_rtc: int  # 145
mc8_rti: int  # 100
mc8_rts: int  # 101
mc8_sba: int  # 102
mc8_sbc: int  # 103
mc8_sec: int  # 104
mc8_sei: int  # 105
mc8_sev: int  # 106
mc8_sex: int  # 107
mc8_skip1: int  # 146
mc8_skip2: int  # 147
mc8_slp: int  # 108
mc8_st: int  # 109
mc8_sta: int  # 110
mc8_std: int  # 111
mc8_sthx: int  # 112
mc8_stop: int  # 113
mc8_sts: int  # 114
mc8_stx: int  # 115
mc8_sub: int  # 116
mc8_subd: int  # 117
mc8_swi: int  # 118
mc8_sync: int  # 119
mc8_tab: int  # 120
mc8_tap: int  # 121
mc8_tax: int  # 122
mc8_tba: int  # 123
mc8_test: int  # 124
mc8_tfr: int  # 125
mc8_tim: int  # 142
mc8_tpa: int  # 126
mc8_ts: int  # 127
mc8_tst: int  # 128
mc8_tsx: int  # 129
mc8_txa: int  # 130
mc8_txs: int  # 131
mc8_tys: int  # 132
mc8_wai: int  # 133
mc8_wait: int  # 134
mc8_xgd: int  # 135
mc_abcd: int  # 1
mc_add: int  # 2
mc_adda: int  # 3
mc_addi: int  # 4
mc_addq: int  # 5
mc_addx: int  # 6
mc_and: int  # 7
mc_andi: int  # 8
mc_asl: int  # 9
mc_asr: int  # 10
mc_atrap: int  # 189
mc_b: int  # 11
mc_bchg: int  # 12
mc_bclr: int  # 13
mc_bfchg: int  # 15
mc_bfclr: int  # 16
mc_bfexts: int  # 19
mc_bfextu: int  # 18
mc_bfffo: int  # 20
mc_bfins: int  # 21
mc_bfset: int  # 17
mc_bftst: int  # 14
mc_bgnd: int  # 22
mc_bitrev: int  # 190
mc_bkpt: int  # 23
mc_bra: int  # 24
mc_bset: int  # 25
mc_bsr: int  # 26
mc_btst: int  # 27
mc_byterev: int  # 191
mc_callm: int  # 28
mc_cas: int  # 29
mc_cas2: int  # 30
mc_chk: int  # 31
mc_chk2: int  # 32
mc_cinv: int  # 33
mc_clr: int  # 34
mc_cmp: int  # 35
mc_cmp2: int  # 36
mc_cmpa: int  # 37
mc_cmpi: int  # 38
mc_cmpm: int  # 39
mc_cpush: int  # 40
mc_db: int  # 41
mc_divs: int  # 42
mc_divsl: int  # 43
mc_divu: int  # 44
mc_divul: int  # 45
mc_eor: int  # 46
mc_eori: int  # 47
mc_exg: int  # 48
mc_ext: int  # 49
mc_extb: int  # 50
mc_fabs: int  # 51
mc_facos: int  # 52
mc_fadd: int  # 53
mc_fasin: int  # 54
mc_fatan: int  # 55
mc_fatanh: int  # 56
mc_fb: int  # 57
mc_fcmp: int  # 58
mc_fcos: int  # 59
mc_fcosh: int  # 60
mc_fdabs: int  # 61
mc_fdadd: int  # 62
mc_fdb: int  # 63
mc_fddiv: int  # 64
mc_fdiv: int  # 65
mc_fdmove: int  # 66
mc_fdmul: int  # 67
mc_fdneg: int  # 68
mc_fdsqrt: int  # 69
mc_fdsub: int  # 70
mc_fetox: int  # 71
mc_fetoxm1: int  # 72
mc_ff1: int  # 192
mc_fgetexp: int  # 73
mc_fgetman: int  # 74
mc_fint: int  # 75
mc_fintrz: int  # 76
mc_flog10: int  # 78
mc_flog2: int  # 77
mc_flogn: int  # 79
mc_flognp1: int  # 80
mc_fmod: int  # 81
mc_fmove: int  # 82
mc_fmovecr: int  # 83
mc_fmovem: int  # 84
mc_fmul: int  # 85
mc_fneg: int  # 86
mc_fnop: int  # 87
mc_frem: int  # 88
mc_frestore: int  # 89
mc_fs: int  # 90
mc_fsabs: int  # 91
mc_fsadd: int  # 92
mc_fsave: int  # 93
mc_fscale: int  # 94
mc_fsdiv: int  # 95
mc_fsgldiv: int  # 96
mc_fsglmul: int  # 97
mc_fsin: int  # 98
mc_fsincos: int  # 99
mc_fsinh: int  # 100
mc_fsmove: int  # 101
mc_fsmul: int  # 102
mc_fsneg: int  # 103
mc_fsqrt: int  # 104
mc_fssqrt: int  # 105
mc_fssub: int  # 106
mc_fsub: int  # 107
mc_ftan: int  # 108
mc_ftanh: int  # 109
mc_ftentox: int  # 110
mc_ftrap: int  # 111
mc_ftst: int  # 112
mc_ftwotox: int  # 113
mc_halt: int  # 114
mc_illegal: int  # 115
mc_intouch: int  # 193
mc_jmp: int  # 116
mc_jsr: int  # 117
mc_last: int  # 205
mc_lea: int  # 118
mc_link: int  # 119
mc_lpstop: int  # 120
mc_lsl: int  # 121
mc_lsr: int  # 122
mc_maaac: int  # 199
mc_mac: int  # 123
mc_macl: int  # 124
mc_masac: int  # 200
mc_mov3q: int  # 194
mc_movclr: int  # 198
mc_move: int  # 125
mc_move16: int  # 126
mc_movea: int  # 127
mc_movec: int  # 128
mc_movem: int  # 129
mc_movep: int  # 130
mc_moveq: int  # 131
mc_moves: int  # 132
mc_msaac: int  # 201
mc_msac: int  # 133
mc_msacl: int  # 134
mc_mssac: int  # 202
mc_muls: int  # 135
mc_mulu: int  # 136
mc_mvs: int  # 195
mc_mvz: int  # 196
mc_nbcd: int  # 137
mc_neg: int  # 138
mc_negx: int  # 139
mc_nop: int  # 140
mc_not: int  # 141
mc_null: int  # 0
mc_or: int  # 142
mc_ori: int  # 143
mc_pack: int  # 144
mc_pb: int  # 146
mc_pdb: int  # 147
mc_pea: int  # 145
mc_pflush: int  # 148
mc_pflushr: int  # 149
mc_ploadr: int  # 150
mc_ploadw: int  # 151
mc_pmove: int  # 152
mc_prestore: int  # 153
mc_ps: int  # 155
mc_psave: int  # 154
mc_ptestr: int  # 156
mc_ptestw: int  # 157
mc_ptrap: int  # 158
mc_pulse: int  # 159
mc_pvalid: int  # 160
mc_remsl: int  # 203
mc_remul: int  # 204
mc_reset: int  # 165
mc_rol: int  # 161
mc_ror: int  # 162
mc_roxl: int  # 163
mc_roxr: int  # 164
mc_rtd: int  # 166
mc_rte: int  # 167
mc_rtm: int  # 168
mc_rtr: int  # 169
mc_rts: int  # 170
mc_s: int  # 172
mc_sats: int  # 197
mc_sbcd: int  # 171
mc_stop: int  # 173
mc_sub: int  # 174
mc_suba: int  # 175
mc_subi: int  # 176
mc_subq: int  # 177
mc_subx: int  # 178
mc_swap: int  # 179
mc_tas: int  # 180
mc_tbl: int  # 181
mc_trap: int  # 182
mc_trapv: int  # 183
mc_tst: int  # 184
mc_unlk: int  # 185
mc_unpk: int  # 186
mc_wddata: int  # 187
mc_wdebug: int  # 188
mn102_add: int  # 1
mn102_addc: int  # 2
mn102_addnf: int  # 3
mn102_and: int  # 4
mn102_asr: int  # 5
mn102_bcc: int  # 6
mn102_bccx: int  # 7
mn102_bclr: int  # 8
mn102_bcs: int  # 9
mn102_bcsx: int  # 10
mn102_beq: int  # 11
mn102_beqx: int  # 12
mn102_bge: int  # 13
mn102_bgex: int  # 14
mn102_bgt: int  # 15
mn102_bgtx: int  # 16
mn102_bhi: int  # 17
mn102_bhix: int  # 18
mn102_ble: int  # 19
mn102_blex: int  # 20
mn102_bls: int  # 21
mn102_blsx: int  # 22
mn102_blt: int  # 23
mn102_bltx: int  # 24
mn102_bnc: int  # 25
mn102_bncx: int  # 26
mn102_bne: int  # 27
mn102_bnex: int  # 28
mn102_bns: int  # 29
mn102_bnsx: int  # 30
mn102_bra: int  # 31
mn102_bset: int  # 32
mn102_btst: int  # 33
mn102_bvc: int  # 34
mn102_bvcx: int  # 35
mn102_bvs: int  # 36
mn102_bvsx: int  # 37
mn102_cmp: int  # 38
mn102_divu: int  # 39
mn102_ext: int  # 40
mn102_extx: int  # 41
mn102_extxb: int  # 42
mn102_extxbu: int  # 43
mn102_extxu: int  # 44
mn102_jmp: int  # 45
mn102_jsr: int  # 46
mn102_last: int  # 70
mn102_lsr: int  # 47
mn102_mov: int  # 48
mn102_movb: int  # 49
mn102_movbu: int  # 50
mn102_movx: int  # 51
mn102_mul: int  # 52
mn102_mulq: int  # 53
mn102_mulqh: int  # 54
mn102_mulql: int  # 55
mn102_mulu: int  # 56
mn102_nop: int  # 57
mn102_not: int  # 58
mn102_null: int  # 0
mn102_or: int  # 59
mn102_pxst: int  # 60
mn102_rol: int  # 61
mn102_ror: int  # 62
mn102_rti: int  # 63
mn102_rts: int  # 64
mn102_sub: int  # 65
mn102_subc: int  # 66
mn102_tbnz: int  # 67
mn102_tbz: int  # 68
mn102_xor: int  # 69
mop_S: int  # 5
mop_a: int  # 10
mop_b: int  # 7
mop_c: int  # 12
mop_d: int  # 4
mop_f: int  # 8
mop_fn: int  # 13
mop_h: int  # 11
mop_l: int  # 9
mop_n: int  # 2
mop_p: int  # 14
mop_r: int  # 1
mop_sc: int  # 15
mop_str: int  # 3
mop_v: int  # 6
mop_z: int  # 0
mr_cc: int  # 5
mr_cf: int  # 0
mr_first: int  # 8
mr_none: int  # -1
mr_of: int  # 3
mr_pf: int  # 4
mr_sf: int  # 2
mr_zf: int  # 1
msg_activated: int  # 0
msg_click: int  # 2
msg_closed: int  # 4
msg_dblclick: int  # 3
msg_deactivated: int  # 1
msg_keydown: int  # 5
nat_auto: int  # 9
nat_cod: int  # 2
nat_cur: int  # 8
nat_dat: int  # 3
nat_err: int  # 6
nat_ext: int  # 5
nat_fun: int  # 1
nat_gap: int  # 7
nat_hlo: int  # 11
nat_last: int  # 12
nat_lib: int  # 0
nat_lum: int  # 10
nat_und: int  # 4
no_sign: int  # 0
ntag: int  # 78
o_displ: int  # 4
o_far: int  # 6
o_idpspec0: int  # 8
o_idpspec1: int  # 9
o_idpspec2: int  # 10
o_idpspec3: int  # 11
o_idpspec4: int  # 12
o_idpspec5: int  # 13
o_imm: int  # 5
o_mem: int  # 2
o_near: int  # 7
o_phrase: int  # 3
o_reg: int  # 1
o_void: int  # 0
op_ti_changed: int  # 15
op_type_changed: int  # 17
os: module  # <module 'os' (frozen)>
pdp_absd: int  # 89
pdp_adc: int  # 37
pdp_add: int  # 53
pdp_addd: int  # 93
pdp_ash: int  # 57
pdp_ashc: int  # 58
pdp_asl: int  # 43
pdp_asr: int  # 42
pdp_bcc: int  # 71
pdp_bcs: int  # 72
pdp_beq: int  # 26
pdp_bge: int  # 27
pdp_bgt: int  # 29
pdp_bhi: int  # 67
pdp_bic: int  # 51
pdp_bis: int  # 52
pdp_bit: int  # 50
pdp_ble: int  # 30
pdp_blos: int  # 68
pdp_blt: int  # 28
pdp_bmi: int  # 66
pdp_bne: int  # 25
pdp_bpl: int  # 65
pdp_bpt: int  # 4
pdp_br: int  # 24
pdp_bvc: int  # 69
pdp_bvs: int  # 70
pdp_call: int  # 105
pdp_ccc: int  # 17
pdp_cfcc: int  # 79
pdp_clc: int  # 13
pdp_cln: int  # 16
pdp_clr: int  # 32
pdp_clrd: int  # 87
pdp_clv: int  # 14
pdp_clz: int  # 15
pdp_cmp: int  # 49
pdp_cmpd: int  # 96
pdp_com: int  # 33
pdp_compcc: int  # 107
pdp_dec: int  # 35
pdp_div: int  # 56
pdp_divd: int  # 98
pdp_emt: int  # 73
pdp_fadd: int  # 60
pdp_fdiv: int  # 63
pdp_fmul: int  # 62
pdp_fsub: int  # 61
pdp_halt: int  # 1
pdp_inc: int  # 34
pdp_iot: int  # 5
pdp_jmp: int  # 9
pdp_jsr: int  # 31
pdp_last: int  # 108
pdp_ldcfd: int  # 104
pdp_ldcif: int  # 103
pdp_ldd: int  # 94
pdp_ldexp: int  # 102
pdp_ldfps: int  # 84
pdp_mark: int  # 44
pdp_mfpd: int  # 76
pdp_mfpi: int  # 45
pdp_mfps: int  # 78
pdp_mfpt: int  # 8
pdp_modd: int  # 92
pdp_mov: int  # 48
pdp_mtpd: int  # 77
pdp_mtpi: int  # 46
pdp_mtps: int  # 75
pdp_mul: int  # 55
pdp_muld: int  # 91
pdp_neg: int  # 36
pdp_negd: int  # 90
pdp_nop: int  # 12
pdp_null: int  # 0
pdp_reset: int  # 6
pdp_return: int  # 106
pdp_rol: int  # 41
pdp_ror: int  # 40
pdp_rti: int  # 3
pdp_rts: int  # 10
pdp_rtt: int  # 7
pdp_sbc: int  # 38
pdp_scc: int  # 22
pdp_sec: int  # 18
pdp_sen: int  # 21
pdp_setd: int  # 82
pdp_setf: int  # 80
pdp_seti: int  # 81
pdp_setl: int  # 83
pdp_sev: int  # 19
pdp_sez: int  # 20
pdp_sob: int  # 64
pdp_spl: int  # 11
pdp_stcdf: int  # 101
pdp_stcdi: int  # 100
pdp_std: int  # 97
pdp_stexp: int  # 99
pdp_stfps: int  # 85
pdp_stst: int  # 86
pdp_sub: int  # 54
pdp_subd: int  # 95
pdp_swab: int  # 23
pdp_sxt: int  # 47
pdp_trap: int  # 74
pdp_tst: int  # 39
pdp_tstd: int  # 88
pdp_wait: int  # 2
pdp_xor: int  # 59
ph: __ph  # <ida_idp.__ph object at 0x7acfb6251e80>
range_cmt_changed: int  # 57
re: module
reg_binary: int  # 3
reg_dword: int  # 4
reg_sz: int  # 1
reg_unknown: int  # 0
renamed: int  # 52
s39_a: int  # 1
s39_ad: int  # 2
s39_adb: int  # 3
s39_adbr: int  # 4
s39_adr: int  # 5
s39_adtr: int  # 6
s39_adtra: int  # 7
s39_ae: int  # 8
s39_aeb: int  # 9
s39_aebr: int  # 10
s39_aer: int  # 11
s39_afi: int  # 12
s39_ag: int  # 13
s39_agf: int  # 14
s39_agfi: int  # 15
s39_agfr: int  # 16
s39_agh: int  # 17
s39_aghi: int  # 18
s39_aghik: int  # 19
s39_agr: int  # 20
s39_agrk: int  # 21
s39_agsi: int  # 22
s39_ah: int  # 23
s39_ahhhr: int  # 24
s39_ahhlr: int  # 25
s39_ahi: int  # 26
s39_ahik: int  # 27
s39_ahy: int  # 28
s39_aih: int  # 29
s39_al: int  # 30
s39_alc: int  # 31
s39_alcg: int  # 32
s39_alcgr: int  # 33
s39_alcr: int  # 34
s39_alfi: int  # 35
s39_alg: int  # 36
s39_algf: int  # 37
s39_algfi: int  # 38
s39_algfr: int  # 39
s39_alghsik: int  # 40
s39_algr: int  # 41
s39_algrk: int  # 42
s39_algsi: int  # 43
s39_alhhhr: int  # 44
s39_alhhlr: int  # 45
s39_alhsik: int  # 46
s39_alr: int  # 47
s39_alrk: int  # 48
s39_alsi: int  # 49
s39_alsih: int  # 50
s39_alsihn: int  # 51
s39_aly: int  # 52
s39_ap: int  # 53
s39_ar: int  # 54
s39_ark: int  # 55
s39_asi: int  # 56
s39_au: int  # 57
s39_aur: int  # 58
s39_aw: int  # 59
s39_awr: int  # 60
s39_axbr: int  # 61
s39_axr: int  # 62
s39_axtr: int  # 63
s39_axtra: int  # 64
s39_ay: int  # 65
s39_b: int  # 66
s39_bakr: int  # 95
s39_bal: int  # 96
s39_balr: int  # 97
s39_bas: int  # 98
s39_basr: int  # 99
s39_bassm: int  # 100
s39_bc: int  # 101
s39_bcr: int  # 102
s39_bct: int  # 103
s39_bctg: int  # 104
s39_bctgr: int  # 105
s39_bctr: int  # 106
s39_be: int  # 74
s39_ber: int  # 88
s39_bh: int  # 68
s39_bhe: int  # 76
s39_bher: int  # 90
s39_bhr: int  # 82
s39_bi: int  # 107
s39_bic: int  # 122
s39_bie: int  # 115
s39_bih: int  # 109
s39_bihe: int  # 117
s39_bil: int  # 111
s39_bile: int  # 119
s39_bilh: int  # 113
s39_bine: int  # 114
s39_binh: int  # 120
s39_binhe: int  # 112
s39_binl: int  # 118
s39_binle: int  # 110
s39_binlh: int  # 116
s39_bino: int  # 121
s39_bio: int  # 108
s39_bl: int  # 70
s39_ble: int  # 78
s39_bler: int  # 92
s39_blh: int  # 72
s39_blhr: int  # 86
s39_blr: int  # 84
s39_bne: int  # 73
s39_bner: int  # 87
s39_bnh: int  # 79
s39_bnhe: int  # 71
s39_bnher: int  # 85
s39_bnhr: int  # 93
s39_bnl: int  # 77
s39_bnle: int  # 69
s39_bnler: int  # 83
s39_bnlh: int  # 75
s39_bnlhr: int  # 89
s39_bnlr: int  # 91
s39_bno: int  # 80
s39_bnor: int  # 94
s39_bo: int  # 67
s39_bor: int  # 81
s39_bpp: int  # 123
s39_bprp: int  # 124
s39_br: int  # 125
s39_bras: int  # 126
s39_brasl: int  # 127
s39_brc: int  # 128
s39_brcl: int  # 129
s39_brct: int  # 130
s39_brctg: int  # 131
s39_brcth: int  # 132
s39_brxh: int  # 133
s39_brxhg: int  # 134
s39_brxle: int  # 135
s39_brxlg: int  # 136
s39_bsa: int  # 137
s39_bsg: int  # 138
s39_bsm: int  # 139
s39_bxh: int  # 140
s39_bxhg: int  # 141
s39_bxle: int  # 142
s39_bxleg: int  # 143
s39_c: int  # 144
s39_cd: int  # 145
s39_cdb: int  # 146
s39_cdbr: int  # 147
s39_cdfbr: int  # 148
s39_cdfbra: int  # 149
s39_cdfr: int  # 150
s39_cdftr: int  # 151
s39_cdgbr: int  # 152
s39_cdgbra: int  # 153
s39_cdgr: int  # 154
s39_cdgtr: int  # 155
s39_cdgtra: int  # 156
s39_cdlfbr: int  # 157
s39_cdlftr: int  # 158
s39_cdlgbr: int  # 159
s39_cdlgtr: int  # 160
s39_cdpt: int  # 161
s39_cdr: int  # 162
s39_cds: int  # 163
s39_cdsg: int  # 164
s39_cdstr: int  # 165
s39_cdsy: int  # 166
s39_cdtr: int  # 167
s39_cdutr: int  # 168
s39_cdzt: int  # 169
s39_ce: int  # 170
s39_ceb: int  # 171
s39_cebr: int  # 172
s39_cedtr: int  # 173
s39_cefbr: int  # 174
s39_cefbra: int  # 175
s39_cefr: int  # 176
s39_cegbr: int  # 177
s39_cegbra: int  # 178
s39_cegr: int  # 179
s39_celfbr: int  # 180
s39_celgbr: int  # 181
s39_cer: int  # 182
s39_cextr: int  # 183
s39_cfc: int  # 184
s39_cfdbr: int  # 185
s39_cfdbra: int  # 186
s39_cfdr: int  # 187
s39_cfdtr: int  # 188
s39_cfebr: int  # 189
s39_cfebra: int  # 190
s39_cfer: int  # 191
s39_cfi: int  # 192
s39_cfxbr: int  # 193
s39_cfxbra: int  # 194
s39_cfxr: int  # 195
s39_cfxtr: int  # 196
s39_cg: int  # 197
s39_cgdbr: int  # 198
s39_cgdbra: int  # 199
s39_cgdr: int  # 200
s39_cgdtr: int  # 201
s39_cgdtra: int  # 202
s39_cgebr: int  # 203
s39_cgebra: int  # 204
s39_cger: int  # 205
s39_cgf: int  # 206
s39_cgfi: int  # 207
s39_cgfr: int  # 208
s39_cgfrl: int  # 209
s39_cgh: int  # 210
s39_cghi: int  # 211
s39_cghrl: int  # 212
s39_cghsi: int  # 213
s39_cgib: int  # 214
s39_cgibh: int  # 215
s39_cgible: int  # 220
s39_cgiblh: int  # 217
s39_cgibnhe: int  # 216
s39_cgibnl: int  # 219
s39_cgibnlh: int  # 218
s39_cgij: int  # 221
s39_cgijh: int  # 222
s39_cgijle: int  # 227
s39_cgijlh: int  # 224
s39_cgijnhe: int  # 223
s39_cgijnl: int  # 226
s39_cgijnlh: int  # 225
s39_cgit: int  # 228
s39_cgith: int  # 229
s39_cgitle: int  # 234
s39_cgitlh: int  # 231
s39_cgitnhe: int  # 230
s39_cgitnl: int  # 233
s39_cgitnlh: int  # 232
s39_cgr: int  # 235
s39_cgrb: int  # 236
s39_cgrbh: int  # 237
s39_cgrble: int  # 242
s39_cgrblh: int  # 239
s39_cgrbnhe: int  # 238
s39_cgrbnl: int  # 241
s39_cgrbnlh: int  # 240
s39_cgrj: int  # 243
s39_cgrjh: int  # 244
s39_cgrjle: int  # 249
s39_cgrjlh: int  # 246
s39_cgrjnhe: int  # 245
s39_cgrjnl: int  # 248
s39_cgrjnlh: int  # 247
s39_cgrl: int  # 250
s39_cgrt: int  # 251
s39_cgrth: int  # 252
s39_cgrtle: int  # 257
s39_cgrtlh: int  # 254
s39_cgrtnhe: int  # 253
s39_cgrtnl: int  # 256
s39_cgrtnlh: int  # 255
s39_cgxbr: int  # 258
s39_cgxbra: int  # 259
s39_cgxr: int  # 260
s39_cgxtr: int  # 261
s39_cgxtra: int  # 262
s39_ch: int  # 263
s39_chf: int  # 264
s39_chhr: int  # 265
s39_chhsi: int  # 266
s39_chi: int  # 267
s39_chlr: int  # 268
s39_chrl: int  # 269
s39_chsi: int  # 270
s39_chy: int  # 271
s39_cib: int  # 272
s39_cibh: int  # 273
s39_cible: int  # 278
s39_ciblh: int  # 275
s39_cibnhe: int  # 274
s39_cibnl: int  # 277
s39_cibnlh: int  # 276
s39_cih: int  # 279
s39_cij: int  # 280
s39_cijh: int  # 281
s39_cijle: int  # 286
s39_cijlh: int  # 283
s39_cijnhe: int  # 282
s39_cijnl: int  # 285
s39_cijnlh: int  # 284
s39_cit: int  # 287
s39_cith: int  # 288
s39_citle: int  # 293
s39_citlh: int  # 290
s39_citnhe: int  # 289
s39_citnl: int  # 292
s39_citnlh: int  # 291
s39_cksm: int  # 294
s39_cl: int  # 295
s39_clc: int  # 296
s39_clcl: int  # 297
s39_clcle: int  # 298
s39_clclu: int  # 299
s39_clfdbr: int  # 300
s39_clfdtr: int  # 301
s39_clfebr: int  # 302
s39_clfhsi: int  # 303
s39_clfi: int  # 304
s39_clfit: int  # 305
s39_clfith: int  # 306
s39_clfitle: int  # 311
s39_clfitlh: int  # 308
s39_clfitnhe: int  # 307
s39_clfitnl: int  # 310
s39_clfitnlh: int  # 309
s39_clfxbr: int  # 312
s39_clfxtr: int  # 313
s39_clg: int  # 314
s39_clgdbr: int  # 315
s39_clgdtr: int  # 316
s39_clgebr: int  # 317
s39_clgf: int  # 318
s39_clgfi: int  # 319
s39_clgfr: int  # 320
s39_clgfrl: int  # 321
s39_clghrl: int  # 322
s39_clghsi: int  # 323
s39_clgib: int  # 324
s39_clgibh: int  # 325
s39_clgible: int  # 330
s39_clgiblh: int  # 327
s39_clgibnhe: int  # 326
s39_clgibnl: int  # 329
s39_clgibnlh: int  # 328
s39_clgij: int  # 331
s39_clgijh: int  # 332
s39_clgijle: int  # 337
s39_clgijlh: int  # 334
s39_clgijnhe: int  # 333
s39_clgijnl: int  # 336
s39_clgijnlh: int  # 335
s39_clgit: int  # 338
s39_clgith: int  # 339
s39_clgitle: int  # 344
s39_clgitlh: int  # 341
s39_clgitnhe: int  # 340
s39_clgitnl: int  # 343
s39_clgitnlh: int  # 342
s39_clgr: int  # 345
s39_clgrb: int  # 346
s39_clgrbh: int  # 347
s39_clgrble: int  # 352
s39_clgrblh: int  # 349
s39_clgrbnhe: int  # 348
s39_clgrbnl: int  # 351
s39_clgrbnlh: int  # 350
s39_clgrj: int  # 353
s39_clgrjh: int  # 354
s39_clgrjle: int  # 359
s39_clgrjlh: int  # 356
s39_clgrjnhe: int  # 355
s39_clgrjnl: int  # 358
s39_clgrjnlh: int  # 357
s39_clgrl: int  # 360
s39_clgrt: int  # 361
s39_clgrth: int  # 362
s39_clgrtle: int  # 367
s39_clgrtlh: int  # 364
s39_clgrtnhe: int  # 363
s39_clgrtnl: int  # 366
s39_clgrtnlh: int  # 365
s39_clgt: int  # 368
s39_clgth: int  # 369
s39_clgtle: int  # 374
s39_clgtlh: int  # 371
s39_clgtnhe: int  # 370
s39_clgtnl: int  # 373
s39_clgtnlh: int  # 372
s39_clgxbr: int  # 375
s39_clgxtr: int  # 376
s39_clhf: int  # 377
s39_clhhr: int  # 378
s39_clhhsi: int  # 379
s39_clhlr: int  # 380
s39_clhrl: int  # 381
s39_cli: int  # 382
s39_clib: int  # 383
s39_clibh: int  # 384
s39_clible: int  # 389
s39_cliblh: int  # 386
s39_clibnhe: int  # 385
s39_clibnl: int  # 388
s39_clibnlh: int  # 387
s39_clih: int  # 390
s39_clij: int  # 391
s39_clijh: int  # 392
s39_clijle: int  # 397
s39_clijlh: int  # 394
s39_clijnhe: int  # 393
s39_clijnl: int  # 396
s39_clijnlh: int  # 395
s39_cliy: int  # 398
s39_clm: int  # 399
s39_clmh: int  # 400
s39_clmy: int  # 401
s39_clr: int  # 402
s39_clrb: int  # 403
s39_clrbh: int  # 404
s39_clrble: int  # 409
s39_clrblh: int  # 406
s39_clrbnhe: int  # 405
s39_clrbnl: int  # 408
s39_clrbnlh: int  # 407
s39_clrj: int  # 410
s39_clrjh: int  # 411
s39_clrjle: int  # 416
s39_clrjlh: int  # 413
s39_clrjnhe: int  # 412
s39_clrjnl: int  # 415
s39_clrjnlh: int  # 414
s39_clrl: int  # 417
s39_clrt: int  # 418
s39_clrth: int  # 419
s39_clrtle: int  # 424
s39_clrtlh: int  # 421
s39_clrtnhe: int  # 420
s39_clrtnl: int  # 423
s39_clrtnlh: int  # 422
s39_clst: int  # 425
s39_clt: int  # 426
s39_clth: int  # 427
s39_cltle: int  # 432
s39_cltlh: int  # 429
s39_cltnhe: int  # 428
s39_cltnl: int  # 431
s39_cltnlh: int  # 430
s39_cly: int  # 433
s39_cmpsc: int  # 434
s39_cp: int  # 435
s39_cpdt: int  # 436
s39_cpsdr: int  # 437
s39_cpxt: int  # 438
s39_cpya: int  # 439
s39_cr: int  # 440
s39_crb: int  # 441
s39_crbh: int  # 442
s39_crble: int  # 447
s39_crblh: int  # 444
s39_crbnhe: int  # 443
s39_crbnl: int  # 446
s39_crbnlh: int  # 445
s39_crdte: int  # 448
s39_crj: int  # 449
s39_crjh: int  # 450
s39_crjle: int  # 455
s39_crjlh: int  # 452
s39_crjnhe: int  # 451
s39_crjnl: int  # 454
s39_crjnlh: int  # 453
s39_crl: int  # 456
s39_crt: int  # 457
s39_crth: int  # 458
s39_crtle: int  # 463
s39_crtlh: int  # 460
s39_crtnhe: int  # 459
s39_crtnl: int  # 462
s39_crtnlh: int  # 461
s39_cs: int  # 464
s39_csch: int  # 465
s39_csdtr: int  # 466
s39_csg: int  # 467
s39_csp: int  # 468
s39_cspg: int  # 469
s39_csst: int  # 470
s39_csxtr: int  # 471
s39_csy: int  # 472
s39_cu12: int  # 473
s39_cu14: int  # 474
s39_cu21: int  # 475
s39_cu24: int  # 476
s39_cu41: int  # 477
s39_cu42: int  # 478
s39_cudtr: int  # 479
s39_cuse: int  # 480
s39_cutfu: int  # 481
s39_cuutf: int  # 482
s39_cuxtr: int  # 483
s39_cvb: int  # 484
s39_cvbg: int  # 485
s39_cvby: int  # 486
s39_cvd: int  # 487
s39_cvdg: int  # 488
s39_cvdy: int  # 489
s39_cxbr: int  # 490
s39_cxfbr: int  # 491
s39_cxfbra: int  # 492
s39_cxfr: int  # 493
s39_cxftr: int  # 494
s39_cxgbr: int  # 495
s39_cxgbra: int  # 496
s39_cxgr: int  # 497
s39_cxgtr: int  # 498
s39_cxgtra: int  # 499
s39_cxlfbr: int  # 500
s39_cxlftr: int  # 501
s39_cxlgbr: int  # 502
s39_cxlgtr: int  # 503
s39_cxpt: int  # 504
s39_cxr: int  # 505
s39_cxstr: int  # 506
s39_cxtr: int  # 507
s39_cxutr: int  # 508
s39_cxzt: int  # 509
s39_cy: int  # 510
s39_czdt: int  # 511
s39_czxt: int  # 512
s39_d: int  # 513
s39_dd: int  # 514
s39_ddb: int  # 515
s39_ddbr: int  # 516
s39_ddr: int  # 517
s39_ddtr: int  # 518
s39_ddtra: int  # 519
s39_de: int  # 520
s39_deb: int  # 521
s39_debr: int  # 522
s39_der: int  # 523
s39_dfltcc: int  # 524
s39_diag: int  # 525
s39_didbr: int  # 526
s39_diebr: int  # 527
s39_dl: int  # 528
s39_dlg: int  # 529
s39_dlgr: int  # 530
s39_dlr: int  # 531
s39_dp: int  # 532
s39_dr: int  # 533
s39_dsg: int  # 534
s39_dsgf: int  # 535
s39_dsgfr: int  # 536
s39_dsgr: int  # 537
s39_dxbr: int  # 538
s39_dxr: int  # 539
s39_dxtr: int  # 540
s39_dxtra: int  # 541
s39_ear: int  # 542
s39_ecag: int  # 543
s39_ecctr: int  # 544
s39_ecpga: int  # 545
s39_ectg: int  # 546
s39_ed: int  # 547
s39_edmk: int  # 548
s39_eedtr: int  # 549
s39_eextr: int  # 550
s39_efpc: int  # 551
s39_epair: int  # 552
s39_epar: int  # 553
s39_epctr: int  # 554
s39_epsw: int  # 555
s39_ereg: int  # 556
s39_eregg: int  # 557
s39_esair: int  # 558
s39_esar: int  # 559
s39_esdtr: int  # 560
s39_esea: int  # 561
s39_esta: int  # 562
s39_esxtr: int  # 563
s39_etnd: int  # 564
s39_ex: int  # 565
s39_exrl: int  # 566
s39_fidbr: int  # 567
s39_fidbra: int  # 568
s39_fidr: int  # 569
s39_fidtr: int  # 570
s39_fiebr: int  # 571
s39_fiebra: int  # 572
s39_fier: int  # 573
s39_fixbr: int  # 574
s39_fixbra: int  # 575
s39_fixr: int  # 576
s39_fixtr: int  # 577
s39_flogr: int  # 578
s39_hdr: int  # 579
s39_her: int  # 580
s39_hsch: int  # 581
s39_iac: int  # 582
s39_ic: int  # 583
s39_icm: int  # 584
s39_icmh: int  # 585
s39_icmy: int  # 586
s39_icy: int  # 587
s39_idte: int  # 588
s39_iedtr: int  # 589
s39_iextr: int  # 590
s39_iihf: int  # 591
s39_iihh: int  # 592
s39_iihl: int  # 593
s39_iilf: int  # 594
s39_iilh: int  # 595
s39_iill: int  # 596
s39_ipk: int  # 597
s39_ipm: int  # 598
s39_ipte: int  # 599
s39_irbm: int  # 600
s39_iske: int  # 601
s39_ivsk: int  # 602
s39_j: int  # 603
s39_je: int  # 611
s39_jg: int  # 618
s39_jge: int  # 626
s39_jgh: int  # 620
s39_jghe: int  # 628
s39_jgl: int  # 622
s39_jgle: int  # 630
s39_jglh: int  # 624
s39_jgne: int  # 625
s39_jgnh: int  # 631
s39_jgnhe: int  # 623
s39_jgnl: int  # 629
s39_jgnle: int  # 621
s39_jgnlh: int  # 627
s39_jgno: int  # 632
s39_jgo: int  # 619
s39_jh: int  # 605
s39_jhe: int  # 613
s39_jl: int  # 607
s39_jle: int  # 615
s39_jlh: int  # 609
s39_jne: int  # 610
s39_jnh: int  # 616
s39_jnhe: int  # 608
s39_jnl: int  # 614
s39_jnle: int  # 606
s39_jnlh: int  # 612
s39_jno: int  # 617
s39_jo: int  # 604
s39_kdb: int  # 633
s39_kdbr: int  # 634
s39_kdsa: int  # 635
s39_kdtr: int  # 636
s39_keb: int  # 637
s39_kebr: int  # 638
s39_kimd: int  # 639
s39_klmd: int  # 640
s39_km: int  # 641
s39_kma: int  # 642
s39_kmac: int  # 643
s39_kmc: int  # 644
s39_kmctr: int  # 645
s39_kmf: int  # 646
s39_kmo: int  # 647
s39_kxbr: int  # 648
s39_kxtr: int  # 649
s39_l: int  # 650
s39_la: int  # 651
s39_laa: int  # 652
s39_laag: int  # 653
s39_laal: int  # 654
s39_laalg: int  # 655
s39_lae: int  # 656
s39_laey: int  # 657
s39_lam: int  # 658
s39_lamy: int  # 659
s39_lan: int  # 660
s39_lang: int  # 661
s39_lao: int  # 662
s39_laog: int  # 663
s39_larl: int  # 664
s39_lasp: int  # 665
s39_last: int  # 2209
s39_lat: int  # 666
s39_lax: int  # 667
s39_laxg: int  # 668
s39_lay: int  # 669
s39_lb: int  # 670
s39_lbh: int  # 671
s39_lbr: int  # 672
s39_lcbb: int  # 673
s39_lcctl: int  # 674
s39_lcdbr: int  # 675
s39_lcdfr: int  # 676
s39_lcdr: int  # 677
s39_lcebr: int  # 678
s39_lcer: int  # 679
s39_lcgfr: int  # 680
s39_lcgr: int  # 681
s39_lcr: int  # 682
s39_lctl: int  # 683
s39_lctlg: int  # 684
s39_lcxbr: int  # 685
s39_lcxr: int  # 686
s39_ld: int  # 687
s39_lde: int  # 688
s39_ldeb: int  # 689
s39_ldebr: int  # 690
s39_lder: int  # 691
s39_ldetr: int  # 692
s39_ldgr: int  # 693
s39_ldr: int  # 694
s39_ldrv: int  # 695
s39_ldxbr: int  # 696
s39_ldxbra: int  # 697
s39_ldxr: int  # 698
s39_ldxtr: int  # 699
s39_ldy: int  # 700
s39_le: int  # 701
s39_ledbr: int  # 702
s39_ledbra: int  # 703
s39_ledr: int  # 704
s39_ledtr: int  # 705
s39_ler: int  # 706
s39_lerv: int  # 707
s39_lexbr: int  # 708
s39_lexbra: int  # 709
s39_lexr: int  # 710
s39_ley: int  # 711
s39_lfas: int  # 712
s39_lfh: int  # 713
s39_lfhat: int  # 714
s39_lfpc: int  # 715
s39_lg: int  # 716
s39_lgat: int  # 717
s39_lgb: int  # 718
s39_lgbr: int  # 719
s39_lgdr: int  # 720
s39_lgf: int  # 721
s39_lgfi: int  # 722
s39_lgfr: int  # 723
s39_lgfrl: int  # 724
s39_lgg: int  # 725
s39_lgh: int  # 726
s39_lghi: int  # 727
s39_lghr: int  # 728
s39_lghrl: int  # 729
s39_lgr: int  # 730
s39_lgrl: int  # 731
s39_lgsc: int  # 732
s39_lh: int  # 733
s39_lhh: int  # 734
s39_lhi: int  # 735
s39_lhr: int  # 736
s39_lhrl: int  # 737
s39_lhy: int  # 738
s39_llc: int  # 739
s39_llch: int  # 740
s39_llcr: int  # 741
s39_llgc: int  # 742
s39_llgcr: int  # 743
s39_llgf: int  # 744
s39_llgfat: int  # 745
s39_llgfr: int  # 746
s39_llgfrl: int  # 747
s39_llgfsg: int  # 748
s39_llgh: int  # 749
s39_llghr: int  # 750
s39_llghrl: int  # 751
s39_llgt: int  # 752
s39_llgtat: int  # 753
s39_llgtr: int  # 754
s39_llh: int  # 755
s39_llhh: int  # 756
s39_llhr: int  # 757
s39_llhrl: int  # 758
s39_llihf: int  # 759
s39_llihh: int  # 760
s39_llihl: int  # 761
s39_llilf: int  # 762
s39_llilh: int  # 763
s39_llill: int  # 764
s39_llzrgf: int  # 765
s39_lm: int  # 766
s39_lmd: int  # 767
s39_lmg: int  # 768
s39_lmh: int  # 769
s39_lmy: int  # 770
s39_lndbr: int  # 771
s39_lndfr: int  # 772
s39_lndr: int  # 773
s39_lnebr: int  # 774
s39_lner: int  # 775
s39_lngfr: int  # 776
s39_lngr: int  # 777
s39_lnr: int  # 778
s39_lnxbr: int  # 779
s39_lnxr: int  # 780
s39_loc: int  # 781
s39_loce: int  # 789
s39_locfh: int  # 796
s39_locfhe: int  # 804
s39_locfhh: int  # 798
s39_locfhhe: int  # 806
s39_locfhl: int  # 800
s39_locfhle: int  # 808
s39_locfhlh: int  # 802
s39_locfhne: int  # 803
s39_locfhnh: int  # 809
s39_locfhnhe: int  # 801
s39_locfhnl: int  # 807
s39_locfhnle: int  # 799
s39_locfhnlh: int  # 805
s39_locfhno: int  # 810
s39_locfho: int  # 797
s39_locfhr: int  # 811
s39_locfhre: int  # 819
s39_locfhrh: int  # 813
s39_locfhrhe: int  # 821
s39_locfhrl: int  # 815
s39_locfhrle: int  # 823
s39_locfhrlh: int  # 817
s39_locfhrne: int  # 818
s39_locfhrnh: int  # 824
s39_locfhrnhe: int  # 816
s39_locfhrnl: int  # 822
s39_locfhrnle: int  # 814
s39_locfhrnlh: int  # 820
s39_locfhrno: int  # 825
s39_locfhro: int  # 812
s39_locg: int  # 826
s39_locge: int  # 834
s39_locgh: int  # 828
s39_locghe: int  # 836
s39_locghi: int  # 841
s39_locghie: int  # 849
s39_locghih: int  # 843
s39_locghihe: int  # 851
s39_locghil: int  # 845
s39_locghile: int  # 853
s39_locghilh: int  # 847
s39_locghine: int  # 848
s39_locghinh: int  # 854
s39_locghinhe: int  # 846
s39_locghinl: int  # 852
s39_locghinle: int  # 844
s39_locghinlh: int  # 850
s39_locghino: int  # 855
s39_locghio: int  # 842
s39_locgl: int  # 830
s39_locgle: int  # 838
s39_locglh: int  # 832
s39_locgne: int  # 833
s39_locgnh: int  # 839
s39_locgnhe: int  # 831
s39_locgnl: int  # 837
s39_locgnle: int  # 829
s39_locgnlh: int  # 835
s39_locgno: int  # 840
s39_locgo: int  # 827
s39_locgr: int  # 856
s39_locgre: int  # 864
s39_locgrh: int  # 858
s39_locgrhe: int  # 866
s39_locgrl: int  # 860
s39_locgrle: int  # 868
s39_locgrlh: int  # 862
s39_locgrne: int  # 863
s39_locgrnh: int  # 869
s39_locgrnhe: int  # 861
s39_locgrnl: int  # 867
s39_locgrnle: int  # 859
s39_locgrnlh: int  # 865
s39_locgrno: int  # 870
s39_locgro: int  # 857
s39_loch: int  # 783
s39_loche: int  # 791
s39_lochhi: int  # 871
s39_lochhie: int  # 879
s39_lochhih: int  # 873
s39_lochhihe: int  # 881
s39_lochhil: int  # 875
s39_lochhile: int  # 883
s39_lochhilh: int  # 877
s39_lochhine: int  # 878
s39_lochhinh: int  # 884
s39_lochhinhe: int  # 876
s39_lochhinl: int  # 882
s39_lochhinle: int  # 874
s39_lochhinlh: int  # 880
s39_lochhino: int  # 885
s39_lochhio: int  # 872
s39_lochi: int  # 886
s39_lochie: int  # 894
s39_lochih: int  # 888
s39_lochihe: int  # 896
s39_lochil: int  # 890
s39_lochile: int  # 898
s39_lochilh: int  # 892
s39_lochine: int  # 893
s39_lochinh: int  # 899
s39_lochinhe: int  # 891
s39_lochinl: int  # 897
s39_lochinle: int  # 889
s39_lochinlh: int  # 895
s39_lochino: int  # 900
s39_lochio: int  # 887
s39_locl: int  # 785
s39_locle: int  # 793
s39_loclh: int  # 787
s39_locne: int  # 788
s39_locnh: int  # 794
s39_locnhe: int  # 786
s39_locnl: int  # 792
s39_locnle: int  # 784
s39_locnlh: int  # 790
s39_locno: int  # 795
s39_loco: int  # 782
s39_locr: int  # 901
s39_locre: int  # 909
s39_locrh: int  # 903
s39_locrhe: int  # 911
s39_locrl: int  # 905
s39_locrle: int  # 913
s39_locrlh: int  # 907
s39_locrne: int  # 908
s39_locrnh: int  # 914
s39_locrnhe: int  # 906
s39_locrnl: int  # 912
s39_locrnle: int  # 904
s39_locrnlh: int  # 910
s39_locrno: int  # 915
s39_locro: int  # 902
s39_lpctl: int  # 916
s39_lpd: int  # 917
s39_lpdbr: int  # 918
s39_lpdfr: int  # 919
s39_lpdg: int  # 920
s39_lpdr: int  # 921
s39_lpebr: int  # 922
s39_lper: int  # 923
s39_lpgfr: int  # 924
s39_lpgr: int  # 925
s39_lpp: int  # 926
s39_lpq: int  # 927
s39_lpr: int  # 928
s39_lpsw: int  # 929
s39_lpswe: int  # 930
s39_lptea: int  # 931
s39_lpxbr: int  # 932
s39_lpxr: int  # 933
s39_lr: int  # 934
s39_lra: int  # 935
s39_lrag: int  # 936
s39_lray: int  # 937
s39_lrdr: int  # 938
s39_lrer: int  # 939
s39_lrl: int  # 940
s39_lrv: int  # 941
s39_lrvg: int  # 942
s39_lrvgr: int  # 943
s39_lrvh: int  # 944
s39_lrvr: int  # 945
s39_lsctl: int  # 946
s39_lt: int  # 947
s39_ltdbr: int  # 948
s39_ltdr: int  # 949
s39_ltdtr: int  # 950
s39_ltebr: int  # 951
s39_lter: int  # 952
s39_ltg: int  # 953
s39_ltgf: int  # 954
s39_ltgfr: int  # 955
s39_ltgr: int  # 956
s39_ltr: int  # 957
s39_ltxbr: int  # 958
s39_ltxr: int  # 959
s39_ltxtr: int  # 960
s39_lura: int  # 961
s39_lurag: int  # 962
s39_lxd: int  # 963
s39_lxdb: int  # 964
s39_lxdbr: int  # 965
s39_lxdr: int  # 966
s39_lxdtr: int  # 967
s39_lxe: int  # 968
s39_lxeb: int  # 969
s39_lxebr: int  # 970
s39_lxer: int  # 971
s39_lxr: int  # 972
s39_ly: int  # 973
s39_lzdr: int  # 974
s39_lzer: int  # 975
s39_lzrf: int  # 976
s39_lzrg: int  # 977
s39_lzxr: int  # 978
s39_m: int  # 979
s39_mad: int  # 980
s39_madb: int  # 981
s39_madbr: int  # 982
s39_madr: int  # 983
s39_mae: int  # 984
s39_maeb: int  # 985
s39_maebr: int  # 986
s39_maer: int  # 987
s39_may: int  # 988
s39_mayh: int  # 989
s39_mayhr: int  # 990
s39_mayl: int  # 991
s39_maylr: int  # 992
s39_mayr: int  # 993
s39_mc: int  # 994
s39_md: int  # 995
s39_mdb: int  # 996
s39_mdbr: int  # 997
s39_mde: int  # 998
s39_mdeb: int  # 999
s39_mdebr: int  # 1000
s39_mder: int  # 1001
s39_mdr: int  # 1002
s39_mdtr: int  # 1003
s39_mdtra: int  # 1004
s39_me: int  # 1005
s39_mee: int  # 1006
s39_meeb: int  # 1007
s39_meebr: int  # 1008
s39_meer: int  # 1009
s39_mer: int  # 1010
s39_mfy: int  # 1011
s39_mg: int  # 1012
s39_mgh: int  # 1013
s39_mghi: int  # 1014
s39_mgrk: int  # 1015
s39_mh: int  # 1016
s39_mhi: int  # 1017
s39_mhy: int  # 1018
s39_ml: int  # 1019
s39_mlg: int  # 1020
s39_mlgr: int  # 1021
s39_mlr: int  # 1022
s39_mp: int  # 1023
s39_mr: int  # 1024
s39_ms: int  # 1025
s39_msc: int  # 1026
s39_msch: int  # 1027
s39_msd: int  # 1028
s39_msdb: int  # 1029
s39_msdbr: int  # 1030
s39_msdr: int  # 1031
s39_mse: int  # 1032
s39_mseb: int  # 1033
s39_msebr: int  # 1034
s39_mser: int  # 1035
s39_msfi: int  # 1036
s39_msg: int  # 1037
s39_msgc: int  # 1038
s39_msgf: int  # 1039
s39_msgfi: int  # 1040
s39_msgfr: int  # 1041
s39_msgr: int  # 1042
s39_msgrkc: int  # 1043
s39_msr: int  # 1044
s39_msrkc: int  # 1045
s39_msta: int  # 1046
s39_msy: int  # 1047
s39_mvc: int  # 1048
s39_mvcdk: int  # 1049
s39_mvcin: int  # 1050
s39_mvck: int  # 1051
s39_mvcl: int  # 1052
s39_mvcle: int  # 1053
s39_mvclu: int  # 1054
s39_mvcos: int  # 1055
s39_mvcp: int  # 1056
s39_mvcrl: int  # 1057
s39_mvcs: int  # 1058
s39_mvcsk: int  # 1059
s39_mvghi: int  # 1060
s39_mvhhi: int  # 1061
s39_mvhi: int  # 1062
s39_mvi: int  # 1063
s39_mviy: int  # 1064
s39_mvn: int  # 1065
s39_mvo: int  # 1066
s39_mvpg: int  # 1067
s39_mvst: int  # 1068
s39_mvz: int  # 1069
s39_mxbr: int  # 1070
s39_mxd: int  # 1071
s39_mxdb: int  # 1072
s39_mxdbr: int  # 1073
s39_mxdr: int  # 1074
s39_mxr: int  # 1075
s39_mxtr: int  # 1076
s39_mxtra: int  # 1077
s39_my: int  # 1078
s39_myh: int  # 1079
s39_myhr: int  # 1080
s39_myl: int  # 1081
s39_mylr: int  # 1082
s39_myr: int  # 1083
s39_n: int  # 1084
s39_nc: int  # 1085
s39_ncgrk: int  # 1086
s39_ncrk: int  # 1087
s39_ng: int  # 1088
s39_ngr: int  # 1089
s39_ngrk: int  # 1090
s39_ni: int  # 1091
s39_niai: int  # 1092
s39_nihf: int  # 1093
s39_nihh: int  # 1094
s39_nihl: int  # 1095
s39_nilf: int  # 1096
s39_nilh: int  # 1097
s39_nill: int  # 1098
s39_niy: int  # 1099
s39_nngrk: int  # 1100
s39_nnrk: int  # 1101
s39_nogrk: int  # 1102
s39_nop: int  # 1103
s39_nopr: int  # 1104
s39_nork: int  # 1105
s39_nr: int  # 1106
s39_nrk: int  # 1107
s39_ntstg: int  # 1108
s39_null: int  # 0
s39_nxgrk: int  # 1109
s39_nxrk: int  # 1110
s39_ny: int  # 1111
s39_o: int  # 1112
s39_oc: int  # 1113
s39_ocgrk: int  # 1114
s39_ocrk: int  # 1115
s39_og: int  # 1116
s39_ogr: int  # 1117
s39_ogrk: int  # 1118
s39_oi: int  # 1119
s39_oihf: int  # 1120
s39_oihh: int  # 1121
s39_oihl: int  # 1122
s39_oilf: int  # 1123
s39_oilh: int  # 1124
s39_oill: int  # 1125
s39_oiy: int  # 1126
s39_or: int  # 1127
s39_ork: int  # 1128
s39_oy: int  # 1129
s39_pack: int  # 1130
s39_palb: int  # 1131
s39_pc: int  # 1132
s39_pcc: int  # 1133
s39_pckmo: int  # 1134
s39_pfd: int  # 1135
s39_pfdrl: int  # 1136
s39_pfmf: int  # 1137
s39_pfpo: int  # 1138
s39_pgin: int  # 1139
s39_pgout: int  # 1140
s39_pka: int  # 1141
s39_pku: int  # 1142
s39_plo: int  # 1143
s39_popcnt: int  # 1144
s39_ppa: int  # 1145
s39_ppno: int  # 1146
s39_pr: int  # 1147
s39_prno: int  # 1148
s39_pt: int  # 1149
s39_ptf: int  # 1150
s39_ptff: int  # 1151
s39_pti: int  # 1152
s39_ptlb: int  # 1153
s39_qadtr: int  # 1154
s39_qaxtr: int  # 1155
s39_qctri: int  # 1156
s39_qsi: int  # 1157
s39_rchp: int  # 1158
s39_risbg: int  # 1159
s39_risbgn: int  # 1160
s39_risbhg: int  # 1161
s39_risblg: int  # 1162
s39_rll: int  # 1163
s39_rllg: int  # 1164
s39_rnsbg: int  # 1165
s39_rosbg: int  # 1166
s39_rp: int  # 1167
s39_rrbe: int  # 1168
s39_rrbm: int  # 1169
s39_rrdtr: int  # 1170
s39_rrxtr: int  # 1171
s39_rsch: int  # 1172
s39_rxsbg: int  # 1173
s39_s: int  # 1174
s39_sac: int  # 1175
s39_sacf: int  # 1176
s39_sal: int  # 1177
s39_sam24: int  # 1178
s39_sam31: int  # 1179
s39_sam64: int  # 1180
s39_sar: int  # 1181
s39_scctr: int  # 1182
s39_schm: int  # 1183
s39_sck: int  # 1184
s39_sckc: int  # 1185
s39_sckpf: int  # 1186
s39_sd: int  # 1187
s39_sdb: int  # 1188
s39_sdbr: int  # 1189
s39_sdr: int  # 1190
s39_sdtr: int  # 1191
s39_sdtra: int  # 1192
s39_se: int  # 1193
s39_seb: int  # 1194
s39_sebr: int  # 1195
s39_selgr: int  # 1196
s39_selgre: int  # 1204
s39_selgrh: int  # 1198
s39_selgrhe: int  # 1206
s39_selgrl: int  # 1200
s39_selgrle: int  # 1208
s39_selgrlh: int  # 1202
s39_selgrne: int  # 1203
s39_selgrnh: int  # 1209
s39_selgrnhe: int  # 1201
s39_selgrnl: int  # 1207
s39_selgrnle: int  # 1199
s39_selgrnlh: int  # 1205
s39_selgrno: int  # 1210
s39_selgro: int  # 1197
s39_selhhhr: int  # 1211
s39_selhhhre: int  # 1219
s39_selhhhrh: int  # 1213
s39_selhhhrhe: int  # 1221
s39_selhhhrl: int  # 1215
s39_selhhhrle: int  # 1223
s39_selhhhrlh: int  # 1217
s39_selhhhrne: int  # 1218
s39_selhhhrnh: int  # 1224
s39_selhhhrnhe: int  # 1216
s39_selhhhrnl: int  # 1222
s39_selhhhrnle: int  # 1214
s39_selhhhrnlh: int  # 1220
s39_selhhhrno: int  # 1225
s39_selhhhro: int  # 1212
s39_selr: int  # 1226
s39_selre: int  # 1234
s39_selrh: int  # 1228
s39_selrhe: int  # 1236
s39_selrl: int  # 1230
s39_selrle: int  # 1238
s39_selrlh: int  # 1232
s39_selrne: int  # 1233
s39_selrnh: int  # 1239
s39_selrnhe: int  # 1231
s39_selrnl: int  # 1237
s39_selrnle: int  # 1229
s39_selrnlh: int  # 1235
s39_selrno: int  # 1240
s39_selro: int  # 1227
s39_ser: int  # 1241
s39_sfasr: int  # 1242
s39_sfpc: int  # 1243
s39_sg: int  # 1244
s39_sgf: int  # 1245
s39_sgfr: int  # 1246
s39_sgh: int  # 1247
s39_sgr: int  # 1248
s39_sgrk: int  # 1249
s39_sh: int  # 1250
s39_shhhr: int  # 1251
s39_shhlr: int  # 1252
s39_shy: int  # 1253
s39_sie: int  # 1254
s39_siga: int  # 1255
s39_sigp: int  # 1256
s39_sl: int  # 1257
s39_sla: int  # 1258
s39_slag: int  # 1259
s39_slak: int  # 1260
s39_slb: int  # 1261
s39_slbg: int  # 1262
s39_slbgr: int  # 1263
s39_slbr: int  # 1264
s39_slda: int  # 1265
s39_sldl: int  # 1266
s39_sldt: int  # 1267
s39_slfi: int  # 1268
s39_slg: int  # 1269
s39_slgf: int  # 1270
s39_slgfi: int  # 1271
s39_slgfr: int  # 1272
s39_slgr: int  # 1273
s39_slgrk: int  # 1274
s39_slhhhr: int  # 1275
s39_slhhlr: int  # 1276
s39_sll: int  # 1277
s39_sllg: int  # 1278
s39_sllk: int  # 1279
s39_slr: int  # 1280
s39_slrk: int  # 1281
s39_slxt: int  # 1282
s39_sly: int  # 1283
s39_sortl: int  # 1284
s39_sp: int  # 1285
s39_spctr: int  # 1286
s39_spka: int  # 1287
s39_spm: int  # 1288
s39_spt: int  # 1289
s39_spx: int  # 1290
s39_sqd: int  # 1291
s39_sqdb: int  # 1292
s39_sqdbr: int  # 1293
s39_sqdr: int  # 1294
s39_sqe: int  # 1295
s39_sqeb: int  # 1296
s39_sqebr: int  # 1297
s39_sqer: int  # 1298
s39_sqxbr: int  # 1299
s39_sqxr: int  # 1300
s39_sr: int  # 1301
s39_sra: int  # 1302
s39_srag: int  # 1303
s39_srak: int  # 1304
s39_srda: int  # 1305
s39_srdl: int  # 1306
s39_srdt: int  # 1307
s39_srk: int  # 1308
s39_srl: int  # 1309
s39_srlg: int  # 1310
s39_srlk: int  # 1311
s39_srnm: int  # 1312
s39_srnmb: int  # 1313
s39_srnmt: int  # 1314
s39_srp: int  # 1315
s39_srst: int  # 1316
s39_srstu: int  # 1317
s39_srxt: int  # 1318
s39_ssair: int  # 1319
s39_ssar: int  # 1320
s39_ssch: int  # 1321
s39_sske: int  # 1322
s39_ssm: int  # 1323
s39_st: int  # 1324
s39_stam: int  # 1325
s39_stamy: int  # 1326
s39_stap: int  # 1327
s39_stc: int  # 1328
s39_stch: int  # 1329
s39_stck: int  # 1330
s39_stckc: int  # 1331
s39_stcke: int  # 1332
s39_stckf: int  # 1333
s39_stcm: int  # 1334
s39_stcmh: int  # 1335
s39_stcmy: int  # 1336
s39_stcps: int  # 1337
s39_stcrw: int  # 1338
s39_stctg: int  # 1339
s39_stctl: int  # 1340
s39_stcy: int  # 1341
s39_std: int  # 1342
s39_stdrv: int  # 1343
s39_stdy: int  # 1344
s39_ste: int  # 1345
s39_sterv: int  # 1346
s39_stey: int  # 1347
s39_stfh: int  # 1348
s39_stfl: int  # 1349
s39_stfle: int  # 1350
s39_stfpc: int  # 1351
s39_stg: int  # 1352
s39_stgrl: int  # 1353
s39_stgsc: int  # 1354
s39_sth: int  # 1355
s39_sthh: int  # 1356
s39_sthrl: int  # 1357
s39_sthy: int  # 1358
s39_stidp: int  # 1359
s39_stm: int  # 1360
s39_stmg: int  # 1361
s39_stmh: int  # 1362
s39_stmy: int  # 1363
s39_stnsm: int  # 1364
s39_stoc: int  # 1365
s39_stoce: int  # 1373
s39_stocfh: int  # 1380
s39_stocfhe: int  # 1388
s39_stocfhh: int  # 1382
s39_stocfhhe: int  # 1390
s39_stocfhl: int  # 1384
s39_stocfhle: int  # 1392
s39_stocfhlh: int  # 1386
s39_stocfhne: int  # 1387
s39_stocfhnh: int  # 1393
s39_stocfhnhe: int  # 1385
s39_stocfhnl: int  # 1391
s39_stocfhnle: int  # 1383
s39_stocfhnlh: int  # 1389
s39_stocfhno: int  # 1394
s39_stocfho: int  # 1381
s39_stocg: int  # 1395
s39_stocge: int  # 1403
s39_stocgh: int  # 1397
s39_stocghe: int  # 1405
s39_stocgl: int  # 1399
s39_stocgle: int  # 1407
s39_stocglh: int  # 1401
s39_stocgne: int  # 1402
s39_stocgnh: int  # 1408
s39_stocgnhe: int  # 1400
s39_stocgnl: int  # 1406
s39_stocgnle: int  # 1398
s39_stocgnlh: int  # 1404
s39_stocgno: int  # 1409
s39_stocgo: int  # 1396
s39_stoch: int  # 1367
s39_stoche: int  # 1375
s39_stocl: int  # 1369
s39_stocle: int  # 1377
s39_stoclh: int  # 1371
s39_stocne: int  # 1372
s39_stocnh: int  # 1378
s39_stocnhe: int  # 1370
s39_stocnl: int  # 1376
s39_stocnle: int  # 1368
s39_stocnlh: int  # 1374
s39_stocno: int  # 1379
s39_stoco: int  # 1366
s39_stosm: int  # 1410
s39_stpq: int  # 1411
s39_stpt: int  # 1412
s39_stpx: int  # 1413
s39_strag: int  # 1414
s39_strl: int  # 1415
s39_strv: int  # 1416
s39_strvg: int  # 1417
s39_strvh: int  # 1418
s39_stsch: int  # 1419
s39_stsi: int  # 1420
s39_stura: int  # 1421
s39_sturg: int  # 1422
s39_sty: int  # 1423
s39_su: int  # 1424
s39_sur: int  # 1425
s39_svc: int  # 1426
s39_sw: int  # 1427
s39_swr: int  # 1428
s39_sxbr: int  # 1429
s39_sxr: int  # 1430
s39_sxtr: int  # 1431
s39_sxtra: int  # 1432
s39_sy: int  # 1433
s39_tabort: int  # 1434
s39_tam: int  # 1435
s39_tar: int  # 1436
s39_tb: int  # 1437
s39_tbdr: int  # 1438
s39_tbedr: int  # 1439
s39_tbegin: int  # 1440
s39_tbeginc: int  # 1441
s39_tcdb: int  # 1442
s39_tceb: int  # 1443
s39_tcxb: int  # 1444
s39_tdcdt: int  # 1445
s39_tdcet: int  # 1446
s39_tdcxt: int  # 1447
s39_tdgdt: int  # 1448
s39_tdget: int  # 1449
s39_tdgxt: int  # 1450
s39_tend: int  # 1451
s39_thder: int  # 1452
s39_thdr: int  # 1453
s39_tm: int  # 1454
s39_tmhh: int  # 1455
s39_tmhl: int  # 1456
s39_tmlh: int  # 1457
s39_tmll: int  # 1458
s39_tmy: int  # 1459
s39_tp: int  # 1460
s39_tpei: int  # 1461
s39_tpi: int  # 1462
s39_tprot: int  # 1463
s39_tr: int  # 1464
s39_trace: int  # 1465
s39_tracg: int  # 1466
s39_trap2: int  # 1467
s39_trap4: int  # 1468
s39_tre: int  # 1469
s39_troo: int  # 1470
s39_trot: int  # 1471
s39_trt: int  # 1472
s39_trte: int  # 1473
s39_trto: int  # 1474
s39_trtr: int  # 1475
s39_trtre: int  # 1476
s39_trtt: int  # 1477
s39_ts: int  # 1478
s39_tsch: int  # 1479
s39_unpk: int  # 1480
s39_unpka: int  # 1481
s39_unpku: int  # 1482
s39_upt: int  # 1483
s39_va: int  # 1484
s39_vab: int  # 1485
s39_vac: int  # 1486
s39_vacc: int  # 1487
s39_vaccb: int  # 1488
s39_vaccc: int  # 1489
s39_vacccq: int  # 1490
s39_vaccf: int  # 1491
s39_vaccg: int  # 1492
s39_vacch: int  # 1493
s39_vaccq: int  # 1494
s39_vacq: int  # 1495
s39_vaf: int  # 1496
s39_vag: int  # 1497
s39_vah: int  # 1498
s39_vap: int  # 1499
s39_vaq: int  # 1500
s39_vavg: int  # 1501
s39_vavgb: int  # 1502
s39_vavgf: int  # 1503
s39_vavgg: int  # 1504
s39_vavgh: int  # 1505
s39_vavgl: int  # 1506
s39_vavglb: int  # 1507
s39_vavglf: int  # 1508
s39_vavglg: int  # 1509
s39_vavglh: int  # 1510
s39_vbperm: int  # 1511
s39_vcdg: int  # 1512
s39_vcdgb: int  # 1513
s39_vcdlg: int  # 1514
s39_vcdlgb: int  # 1515
s39_vcefb: int  # 1516
s39_vcelfb: int  # 1517
s39_vceq: int  # 1518
s39_vceqb: int  # 1519
s39_vceqbs: int  # 1520
s39_vceqf: int  # 1521
s39_vceqfs: int  # 1522
s39_vceqg: int  # 1523
s39_vceqgs: int  # 1524
s39_vceqh: int  # 1525
s39_vceqhs: int  # 1526
s39_vcfeb: int  # 1527
s39_vcfpl: int  # 1528
s39_vcfps: int  # 1529
s39_vcgd: int  # 1530
s39_vcgdb: int  # 1531
s39_vch: int  # 1532
s39_vchb: int  # 1533
s39_vchbs: int  # 1534
s39_vchf: int  # 1535
s39_vchfs: int  # 1536
s39_vchg: int  # 1537
s39_vchgs: int  # 1538
s39_vchh: int  # 1539
s39_vchhs: int  # 1540
s39_vchl: int  # 1541
s39_vchlb: int  # 1542
s39_vchlbs: int  # 1543
s39_vchlf: int  # 1544
s39_vchlfs: int  # 1545
s39_vchlg: int  # 1546
s39_vchlgs: int  # 1547
s39_vchlh: int  # 1548
s39_vchlhs: int  # 1549
s39_vcksm: int  # 1550
s39_vclfeb: int  # 1551
s39_vclfp: int  # 1552
s39_vclgd: int  # 1553
s39_vclgdb: int  # 1554
s39_vclz: int  # 1555
s39_vclzb: int  # 1556
s39_vclzf: int  # 1557
s39_vclzg: int  # 1558
s39_vclzh: int  # 1559
s39_vcp: int  # 1560
s39_vcsfp: int  # 1561
s39_vctz: int  # 1562
s39_vctzb: int  # 1563
s39_vctzf: int  # 1564
s39_vctzg: int  # 1565
s39_vctzh: int  # 1566
s39_vcvb: int  # 1567
s39_vcvbg: int  # 1568
s39_vcvd: int  # 1569
s39_vcvdg: int  # 1570
s39_vdp: int  # 1571
s39_vec: int  # 1572
s39_vecb: int  # 1573
s39_vecf: int  # 1574
s39_vecg: int  # 1575
s39_vech: int  # 1576
s39_vecl: int  # 1577
s39_veclb: int  # 1578
s39_veclf: int  # 1579
s39_veclg: int  # 1580
s39_veclh: int  # 1581
s39_verim: int  # 1582
s39_verimb: int  # 1583
s39_verimf: int  # 1584
s39_verimg: int  # 1585
s39_verimh: int  # 1586
s39_verll: int  # 1587
s39_verllb: int  # 1588
s39_verllf: int  # 1589
s39_verllg: int  # 1590
s39_verllh: int  # 1591
s39_verllv: int  # 1592
s39_verllvb: int  # 1593
s39_verllvf: int  # 1594
s39_verllvg: int  # 1595
s39_verllvh: int  # 1596
s39_vesl: int  # 1597
s39_veslb: int  # 1598
s39_veslf: int  # 1599
s39_veslg: int  # 1600
s39_veslh: int  # 1601
s39_veslv: int  # 1602
s39_veslvb: int  # 1603
s39_veslvf: int  # 1604
s39_veslvg: int  # 1605
s39_veslvh: int  # 1606
s39_vesra: int  # 1607
s39_vesrab: int  # 1608
s39_vesraf: int  # 1609
s39_vesrag: int  # 1610
s39_vesrah: int  # 1611
s39_vesrav: int  # 1612
s39_vesravb: int  # 1613
s39_vesravf: int  # 1614
s39_vesravg: int  # 1615
s39_vesravh: int  # 1616
s39_vesrl: int  # 1617
s39_vesrlb: int  # 1618
s39_vesrlf: int  # 1619
s39_vesrlg: int  # 1620
s39_vesrlh: int  # 1621
s39_vesrlv: int  # 1622
s39_vesrlvb: int  # 1623
s39_vesrlvf: int  # 1624
s39_vesrlvg: int  # 1625
s39_vesrlvh: int  # 1626
s39_vfa: int  # 1627
s39_vfadb: int  # 1628
s39_vfae: int  # 1629
s39_vfaeb: int  # 1630
s39_vfaebs: int  # 1631
s39_vfaef: int  # 1632
s39_vfaefs: int  # 1633
s39_vfaeh: int  # 1634
s39_vfaehs: int  # 1635
s39_vfaezb: int  # 1636
s39_vfaezbs: int  # 1637
s39_vfaezf: int  # 1638
s39_vfaezfs: int  # 1639
s39_vfaezh: int  # 1640
s39_vfaezhs: int  # 1641
s39_vfasb: int  # 1642
s39_vfce: int  # 1643
s39_vfcedb: int  # 1644
s39_vfcedbs: int  # 1645
s39_vfcesb: int  # 1646
s39_vfcesbs: int  # 1647
s39_vfch: int  # 1648
s39_vfchdb: int  # 1649
s39_vfchdbs: int  # 1650
s39_vfche: int  # 1651
s39_vfchedb: int  # 1652
s39_vfchedbs: int  # 1653
s39_vfchesb: int  # 1654
s39_vfchesbs: int  # 1655
s39_vfchsb: int  # 1656
s39_vfchsbs: int  # 1657
s39_vfd: int  # 1658
s39_vfddb: int  # 1659
s39_vfdsb: int  # 1660
s39_vfee: int  # 1661
s39_vfeeb: int  # 1662
s39_vfeebs: int  # 1663
s39_vfeef: int  # 1664
s39_vfeefs: int  # 1665
s39_vfeeh: int  # 1666
s39_vfeehs: int  # 1667
s39_vfeezb: int  # 1668
s39_vfeezbs: int  # 1669
s39_vfeezf: int  # 1670
s39_vfeezfs: int  # 1671
s39_vfeezh: int  # 1672
s39_vfeezhs: int  # 1673
s39_vfene: int  # 1674
s39_vfeneb: int  # 1675
s39_vfenebs: int  # 1676
s39_vfenef: int  # 1677
s39_vfenefs: int  # 1678
s39_vfeneh: int  # 1679
s39_vfenehs: int  # 1680
s39_vfenezb: int  # 1681
s39_vfenezbs: int  # 1682
s39_vfenezf: int  # 1683
s39_vfenezfs: int  # 1684
s39_vfenezh: int  # 1685
s39_vfenezhs: int  # 1686
s39_vfi: int  # 1687
s39_vfidb: int  # 1688
s39_vfisb: int  # 1689
s39_vfkedb: int  # 1690
s39_vfkedbs: int  # 1691
s39_vfkesb: int  # 1692
s39_vfkesbs: int  # 1693
s39_vfkhdb: int  # 1694
s39_vfkhdbs: int  # 1695
s39_vfkhedb: int  # 1696
s39_vfkhedbs: int  # 1697
s39_vfkhesb: int  # 1698
s39_vfkhesbs: int  # 1699
s39_vfkhsb: int  # 1700
s39_vfkhsbs: int  # 1701
s39_vflcdb: int  # 1702
s39_vflcsb: int  # 1703
s39_vfll: int  # 1704
s39_vflls: int  # 1705
s39_vflndb: int  # 1706
s39_vflnsb: int  # 1707
s39_vflpdb: int  # 1708
s39_vflpsb: int  # 1709
s39_vflr: int  # 1710
s39_vflrd: int  # 1711
s39_vfm: int  # 1712
s39_vfma: int  # 1713
s39_vfmadb: int  # 1714
s39_vfmasb: int  # 1715
s39_vfmax: int  # 1716
s39_vfmaxdb: int  # 1717
s39_vfmaxsb: int  # 1718
s39_vfmdb: int  # 1719
s39_vfmin: int  # 1720
s39_vfmindb: int  # 1721
s39_vfminsb: int  # 1722
s39_vfms: int  # 1723
s39_vfmsb: int  # 1724
s39_vfmsdb: int  # 1725
s39_vfmssb: int  # 1726
s39_vfnma: int  # 1727
s39_vfnmadb: int  # 1728
s39_vfnmasb: int  # 1729
s39_vfnms: int  # 1730
s39_vfnmsdb: int  # 1731
s39_vfnmssb: int  # 1732
s39_vfpso: int  # 1733
s39_vfpsodb: int  # 1734
s39_vfpsosb: int  # 1735
s39_vfs: int  # 1736
s39_vfsdb: int  # 1737
s39_vfsq: int  # 1738
s39_vfsqdb: int  # 1739
s39_vfsqsb: int  # 1740
s39_vfssb: int  # 1741
s39_vftci: int  # 1742
s39_vftcidb: int  # 1743
s39_vftcisb: int  # 1744
s39_vgbm: int  # 1745
s39_vgef: int  # 1746
s39_vgeg: int  # 1747
s39_vgfm: int  # 1748
s39_vgfma: int  # 1749
s39_vgfmab: int  # 1750
s39_vgfmaf: int  # 1751
s39_vgfmag: int  # 1752
s39_vgfmah: int  # 1753
s39_vgfmb: int  # 1754
s39_vgfmf: int  # 1755
s39_vgfmg: int  # 1756
s39_vgfmh: int  # 1757
s39_vgm: int  # 1758
s39_vgmb: int  # 1759
s39_vgmf: int  # 1760
s39_vgmg: int  # 1761
s39_vgmh: int  # 1762
s39_vistr: int  # 1763
s39_vistrb: int  # 1764
s39_vistrbs: int  # 1765
s39_vistrf: int  # 1766
s39_vistrfs: int  # 1767
s39_vistrh: int  # 1768
s39_vistrhs: int  # 1769
s39_vl: int  # 1770
s39_vlbb: int  # 1771
s39_vlbr: int  # 1772
s39_vlbrf: int  # 1773
s39_vlbrg: int  # 1774
s39_vlbrh: int  # 1775
s39_vlbrq: int  # 1776
s39_vlbrrep: int  # 1777
s39_vlbrrepf: int  # 1778
s39_vlbrrepg: int  # 1779
s39_vlbrreph: int  # 1780
s39_vlc: int  # 1781
s39_vlcb: int  # 1782
s39_vlcf: int  # 1783
s39_vlcg: int  # 1784
s39_vlch: int  # 1785
s39_vlde: int  # 1786
s39_vldeb: int  # 1787
s39_vleb: int  # 1788
s39_vlebrf: int  # 1789
s39_vlebrg: int  # 1790
s39_vlebrh: int  # 1791
s39_vled: int  # 1792
s39_vledb: int  # 1793
s39_vlef: int  # 1794
s39_vleg: int  # 1795
s39_vleh: int  # 1796
s39_vleib: int  # 1797
s39_vleif: int  # 1798
s39_vleig: int  # 1799
s39_vleih: int  # 1800
s39_vler: int  # 1801
s39_vlerf: int  # 1802
s39_vlerg: int  # 1803
s39_vlerh: int  # 1804
s39_vlgv: int  # 1805
s39_vlgvb: int  # 1806
s39_vlgvf: int  # 1807
s39_vlgvg: int  # 1808
s39_vlgvh: int  # 1809
s39_vlip: int  # 1810
s39_vll: int  # 1811
s39_vllebrz: int  # 1812
s39_vllebrze: int  # 1813
s39_vllebrzf: int  # 1814
s39_vllebrzg: int  # 1815
s39_vllebrzh: int  # 1816
s39_vllez: int  # 1817
s39_vllezb: int  # 1818
s39_vllezf: int  # 1819
s39_vllezg: int  # 1820
s39_vllezh: int  # 1821
s39_vllezlf: int  # 1822
s39_vlm: int  # 1823
s39_vlp: int  # 1824
s39_vlpb: int  # 1825
s39_vlpf: int  # 1826
s39_vlpg: int  # 1827
s39_vlph: int  # 1828
s39_vlr: int  # 1829
s39_vlrep: int  # 1830
s39_vlrepb: int  # 1831
s39_vlrepf: int  # 1832
s39_vlrepg: int  # 1833
s39_vlreph: int  # 1834
s39_vlrl: int  # 1835
s39_vlrlr: int  # 1836
s39_vlvg: int  # 1837
s39_vlvgb: int  # 1838
s39_vlvgf: int  # 1839
s39_vlvgg: int  # 1840
s39_vlvgh: int  # 1841
s39_vlvgp: int  # 1842
s39_vmae: int  # 1843
s39_vmaeb: int  # 1844
s39_vmaef: int  # 1845
s39_vmaeh: int  # 1846
s39_vmah: int  # 1847
s39_vmahb: int  # 1848
s39_vmahf: int  # 1849
s39_vmahh: int  # 1850
s39_vmal: int  # 1851
s39_vmalb: int  # 1852
s39_vmale: int  # 1853
s39_vmaleb: int  # 1854
s39_vmalef: int  # 1855
s39_vmaleh: int  # 1856
s39_vmalf: int  # 1857
s39_vmalh: int  # 1858
s39_vmalhb: int  # 1859
s39_vmalhf: int  # 1860
s39_vmalhh: int  # 1861
s39_vmalhw: int  # 1862
s39_vmalo: int  # 1863
s39_vmalob: int  # 1864
s39_vmalof: int  # 1865
s39_vmaloh: int  # 1866
s39_vmao: int  # 1867
s39_vmaob: int  # 1868
s39_vmaof: int  # 1869
s39_vmaoh: int  # 1870
s39_vme: int  # 1871
s39_vmeb: int  # 1872
s39_vmef: int  # 1873
s39_vmeh: int  # 1874
s39_vmh: int  # 1875
s39_vmhb: int  # 1876
s39_vmhf: int  # 1877
s39_vmhh: int  # 1878
s39_vml: int  # 1879
s39_vmlb: int  # 1880
s39_vmle: int  # 1881
s39_vmleb: int  # 1882
s39_vmlef: int  # 1883
s39_vmleh: int  # 1884
s39_vmlf: int  # 1885
s39_vmlh: int  # 1886
s39_vmlhb: int  # 1887
s39_vmlhf: int  # 1888
s39_vmlhh: int  # 1889
s39_vmlhw: int  # 1890
s39_vmlo: int  # 1891
s39_vmlob: int  # 1892
s39_vmlof: int  # 1893
s39_vmloh: int  # 1894
s39_vmn: int  # 1895
s39_vmnb: int  # 1896
s39_vmnf: int  # 1897
s39_vmng: int  # 1898
s39_vmnh: int  # 1899
s39_vmnl: int  # 1900
s39_vmnlb: int  # 1901
s39_vmnlf: int  # 1902
s39_vmnlg: int  # 1903
s39_vmnlh: int  # 1904
s39_vmo: int  # 1905
s39_vmob: int  # 1906
s39_vmof: int  # 1907
s39_vmoh: int  # 1908
s39_vmp: int  # 1909
s39_vmrh: int  # 1910
s39_vmrhb: int  # 1911
s39_vmrhf: int  # 1912
s39_vmrhg: int  # 1913
s39_vmrhh: int  # 1914
s39_vmrl: int  # 1915
s39_vmrlb: int  # 1916
s39_vmrlf: int  # 1917
s39_vmrlg: int  # 1918
s39_vmrlh: int  # 1919
s39_vmsl: int  # 1920
s39_vmslg: int  # 1921
s39_vmsp: int  # 1922
s39_vmx: int  # 1923
s39_vmxb: int  # 1924
s39_vmxf: int  # 1925
s39_vmxg: int  # 1926
s39_vmxh: int  # 1927
s39_vmxl: int  # 1928
s39_vmxlb: int  # 1929
s39_vmxlf: int  # 1930
s39_vmxlg: int  # 1931
s39_vmxlh: int  # 1932
s39_vn: int  # 1933
s39_vnc: int  # 1934
s39_vnn: int  # 1935
s39_vno: int  # 1936
s39_vnot: int  # 1937
s39_vnx: int  # 1938
s39_vo: int  # 1939
s39_voc: int  # 1940
s39_vone: int  # 1941
s39_vpdi: int  # 1942
s39_vperm: int  # 1943
s39_vpk: int  # 1944
s39_vpkf: int  # 1945
s39_vpkg: int  # 1946
s39_vpkh: int  # 1947
s39_vpkls: int  # 1948
s39_vpklsf: int  # 1949
s39_vpklsfs: int  # 1950
s39_vpklsg: int  # 1951
s39_vpklsgs: int  # 1952
s39_vpklsh: int  # 1953
s39_vpklshs: int  # 1954
s39_vpks: int  # 1955
s39_vpksf: int  # 1956
s39_vpksfs: int  # 1957
s39_vpksg: int  # 1958
s39_vpksgs: int  # 1959
s39_vpksh: int  # 1960
s39_vpkshs: int  # 1961
s39_vpkz: int  # 1962
s39_vpopct: int  # 1963
s39_vpopctb: int  # 1964
s39_vpopctf: int  # 1965
s39_vpopctg: int  # 1966
s39_vpopcth: int  # 1967
s39_vpsop: int  # 1968
s39_vrep: int  # 1969
s39_vrepb: int  # 1970
s39_vrepf: int  # 1971
s39_vrepg: int  # 1972
s39_vreph: int  # 1973
s39_vrepi: int  # 1974
s39_vrepib: int  # 1975
s39_vrepif: int  # 1976
s39_vrepig: int  # 1977
s39_vrepih: int  # 1978
s39_vrp: int  # 1979
s39_vs: int  # 1980
s39_vsb: int  # 1981
s39_vsbcbi: int  # 1982
s39_vsbcbiq: int  # 1983
s39_vsbi: int  # 1984
s39_vsbiq: int  # 1985
s39_vscbi: int  # 1986
s39_vscbib: int  # 1987
s39_vscbif: int  # 1988
s39_vscbig: int  # 1989
s39_vscbih: int  # 1990
s39_vscbiq: int  # 1991
s39_vscef: int  # 1992
s39_vsceg: int  # 1993
s39_vsdp: int  # 1994
s39_vseg: int  # 1995
s39_vsegb: int  # 1996
s39_vsegf: int  # 1997
s39_vsegh: int  # 1998
s39_vsel: int  # 1999
s39_vsf: int  # 2000
s39_vsg: int  # 2001
s39_vsh: int  # 2002
s39_vsl: int  # 2003
s39_vslb: int  # 2004
s39_vsld: int  # 2005
s39_vsldb: int  # 2006
s39_vsp: int  # 2007
s39_vsq: int  # 2008
s39_vsra: int  # 2009
s39_vsrab: int  # 2010
s39_vsrd: int  # 2011
s39_vsrl: int  # 2012
s39_vsrlb: int  # 2013
s39_vsrp: int  # 2014
s39_vst: int  # 2015
s39_vstbr: int  # 2016
s39_vstbrf: int  # 2017
s39_vstbrg: int  # 2018
s39_vstbrh: int  # 2019
s39_vstbrq: int  # 2020
s39_vsteb: int  # 2021
s39_vstebrf: int  # 2022
s39_vstebrg: int  # 2023
s39_vstebrh: int  # 2024
s39_vstef: int  # 2025
s39_vsteg: int  # 2026
s39_vsteh: int  # 2027
s39_vster: int  # 2028
s39_vsterf: int  # 2029
s39_vsterg: int  # 2030
s39_vsterh: int  # 2031
s39_vstl: int  # 2032
s39_vstm: int  # 2033
s39_vstrc: int  # 2034
s39_vstrcb: int  # 2035
s39_vstrcbs: int  # 2036
s39_vstrcf: int  # 2037
s39_vstrcfs: int  # 2038
s39_vstrch: int  # 2039
s39_vstrchs: int  # 2040
s39_vstrczb: int  # 2041
s39_vstrczbs: int  # 2042
s39_vstrczf: int  # 2043
s39_vstrczfs: int  # 2044
s39_vstrczh: int  # 2045
s39_vstrczhs: int  # 2046
s39_vstrl: int  # 2047
s39_vstrlr: int  # 2048
s39_vstrs: int  # 2049
s39_vstrsb: int  # 2050
s39_vstrsf: int  # 2051
s39_vstrsh: int  # 2052
s39_vstrszb: int  # 2053
s39_vstrszf: int  # 2054
s39_vstrszh: int  # 2055
s39_vsum: int  # 2056
s39_vsumb: int  # 2057
s39_vsumg: int  # 2058
s39_vsumgf: int  # 2059
s39_vsumgh: int  # 2060
s39_vsumh: int  # 2061
s39_vsumq: int  # 2062
s39_vsumqf: int  # 2063
s39_vsumqg: int  # 2064
s39_vtm: int  # 2065
s39_vtp: int  # 2066
s39_vuph: int  # 2067
s39_vuphb: int  # 2068
s39_vuphf: int  # 2069
s39_vuphh: int  # 2070
s39_vupkz: int  # 2071
s39_vupl: int  # 2072
s39_vuplb: int  # 2073
s39_vuplf: int  # 2074
s39_vuplh: int  # 2075
s39_vuplhb: int  # 2076
s39_vuplhf: int  # 2077
s39_vuplhh: int  # 2078
s39_vuplhw: int  # 2079
s39_vupll: int  # 2080
s39_vupllb: int  # 2081
s39_vupllf: int  # 2082
s39_vupllh: int  # 2083
s39_vx: int  # 2208
s39_vzero: int  # 2084
s39_wcdgb: int  # 2085
s39_wcdlgb: int  # 2086
s39_wcefb: int  # 2087
s39_wcelfb: int  # 2088
s39_wcfeb: int  # 2089
s39_wcgdb: int  # 2090
s39_wclfeb: int  # 2091
s39_wclgdb: int  # 2092
s39_wfadb: int  # 2093
s39_wfasb: int  # 2094
s39_wfaxb: int  # 2095
s39_wfc: int  # 2096
s39_wfcdb: int  # 2097
s39_wfcedb: int  # 2098
s39_wfcedbs: int  # 2099
s39_wfcesb: int  # 2100
s39_wfcesbs: int  # 2101
s39_wfcexb: int  # 2102
s39_wfcexbs: int  # 2103
s39_wfchdb: int  # 2104
s39_wfchdbs: int  # 2105
s39_wfchedb: int  # 2106
s39_wfchedbs: int  # 2107
s39_wfchesb: int  # 2108
s39_wfchesbs: int  # 2109
s39_wfchexb: int  # 2110
s39_wfchexbs: int  # 2111
s39_wfchsb: int  # 2112
s39_wfchsbs: int  # 2113
s39_wfchxb: int  # 2114
s39_wfchxbs: int  # 2115
s39_wfcsb: int  # 2116
s39_wfcxb: int  # 2117
s39_wfddb: int  # 2118
s39_wfdsb: int  # 2119
s39_wfdxb: int  # 2120
s39_wfidb: int  # 2121
s39_wfisb: int  # 2122
s39_wfixb: int  # 2123
s39_wfk: int  # 2124
s39_wfkdb: int  # 2125
s39_wfkedb: int  # 2126
s39_wfkedbs: int  # 2127
s39_wfkesb: int  # 2128
s39_wfkesbs: int  # 2129
s39_wfkexb: int  # 2130
s39_wfkexbs: int  # 2131
s39_wfkhdb: int  # 2132
s39_wfkhdbs: int  # 2133
s39_wfkhedb: int  # 2134
s39_wfkhedbs: int  # 2135
s39_wfkhesb: int  # 2136
s39_wfkhesbs: int  # 2137
s39_wfkhexb: int  # 2138
s39_wfkhexbs: int  # 2139
s39_wfkhsb: int  # 2140
s39_wfkhsbs: int  # 2141
s39_wfkhxb: int  # 2142
s39_wfkhxbs: int  # 2143
s39_wfksb: int  # 2144
s39_wfkxb: int  # 2145
s39_wflcdb: int  # 2146
s39_wflcsb: int  # 2147
s39_wflcxb: int  # 2148
s39_wflld: int  # 2149
s39_wflls: int  # 2150
s39_wflndb: int  # 2151
s39_wflnsb: int  # 2152
s39_wflnxb: int  # 2153
s39_wflpdb: int  # 2154
s39_wflpsb: int  # 2155
s39_wflpxb: int  # 2156
s39_wflrd: int  # 2157
s39_wflrx: int  # 2158
s39_wfmadb: int  # 2159
s39_wfmasb: int  # 2160
s39_wfmaxb: int  # 2161
s39_wfmaxdb: int  # 2162
s39_wfmaxsb: int  # 2163
s39_wfmaxxb: int  # 2164
s39_wfmdb: int  # 2165
s39_wfmindb: int  # 2166
s39_wfminsb: int  # 2167
s39_wfminxb: int  # 2168
s39_wfmsb: int  # 2169
s39_wfmsdb: int  # 2170
s39_wfmssb: int  # 2171
s39_wfmsxb: int  # 2172
s39_wfmxb: int  # 2173
s39_wfnmadb: int  # 2174
s39_wfnmasb: int  # 2175
s39_wfnmaxb: int  # 2176
s39_wfnmsdb: int  # 2177
s39_wfnmssb: int  # 2178
s39_wfnmsxb: int  # 2179
s39_wfpsodb: int  # 2180
s39_wfpsosb: int  # 2181
s39_wfpsoxb: int  # 2182
s39_wfsdb: int  # 2183
s39_wfsqdb: int  # 2184
s39_wfsqsb: int  # 2185
s39_wfsqxb: int  # 2186
s39_wfssb: int  # 2187
s39_wfsxb: int  # 2188
s39_wftcidb: int  # 2189
s39_wftcisb: int  # 2190
s39_wftcixb: int  # 2191
s39_wldeb: int  # 2192
s39_wledb: int  # 2193
s39_x: int  # 2194
s39_xc: int  # 2195
s39_xg: int  # 2196
s39_xgr: int  # 2197
s39_xgrk: int  # 2198
s39_xi: int  # 2199
s39_xihf: int  # 2200
s39_xilf: int  # 2201
s39_xiy: int  # 2202
s39_xr: int  # 2203
s39_xrk: int  # 2204
s39_xsch: int  # 2205
s39_xy: int  # 2206
s39_zap: int  # 2207
saAbs: int  # 0
saGroup: int  # 7
saRel1024Bytes: int  # 13
saRel128Bytes: int  # 11
saRel2048Bytes: int  # 14
saRel32Bytes: int  # 8
saRel4K: int  # 6
saRel512Bytes: int  # 12
saRel64Bytes: int  # 9
saRelByte: int  # 1
saRelDble: int  # 5
saRelPage: int  # 4
saRelPara: int  # 3
saRelQword: int  # 10
saRelWord: int  # 2
saRel_MAX_ALIGN_CODE: int  # 14
savebase: int  # 1
scCommon: int  # 6
scGroup: int  # 1
scPriv: int  # 0
scPub: int  # 2
scPub2: int  # 4
scPub3: int  # 7
scStack: int  # 5
sc_MAX_COMB_CODE: int  # 7
sc_auto: int  # 5
sc_ext: int  # 2
sc_friend: int  # 6
sc_reg: int  # 4
sc_stat: int  # 3
sc_type: int  # 1
sc_unk: int  # 0
sc_virt: int  # 7
segm_added: int  # 18
segm_attrs_updated: int  # 29
segm_class_changed: int  # 28
segm_deleted: int  # 20
segm_end_changed: int  # 24
segm_moved: int  # 30
segm_name_changed: int  # 26
segm_start_changed: int  # 22
sgr_changed: int  # 48
sgr_deleted: int  # 62
st9_adc: int  # 9
st9_adcw: int  # 10
st9_add: int  # 7
st9_addw: int  # 8
st9_ald: int  # 103
st9_aldw: int  # 104
st9_and: int  # 15
st9_andw: int  # 16
st9_band: int  # 67
st9_bcpl: int  # 64
st9_bld: int  # 66
st9_bor: int  # 68
st9_bres: int  # 63
st9_bset: int  # 62
st9_btjf: int  # 79
st9_btjt: int  # 80
st9_btset: int  # 65
st9_bxor: int  # 69
st9_call: int  # 77
st9_calls: int  # 78
st9_ccf: int  # 95
st9_clr: int  # 41
st9_cp: int  # 21
st9_cpjfi: int  # 83
st9_cpjti: int  # 84
st9_cpl: int  # 42
st9_cpw: int  # 22
st9_da: int  # 44
st9_dec: int  # 29
st9_decw: int  # 30
st9_di: int  # 92
st9_div: int  # 60
st9_divws: int  # 61
st9_djnz: int  # 81
st9_dwjnz: int  # 82
st9_ei: int  # 91
st9_eret: int  # 102
st9_etrap: int  # 101
st9_ext: int  # 90
st9_halt: int  # 100
st9_inc: int  # 27
st9_incw: int  # 28
st9_iret: int  # 72
st9_jp: int  # 75
st9_jpcc: int  # 74
st9_jps: int  # 76
st9_jrcc: int  # 73
st9_last: int  # 105
st9_ld: int  # 1
st9_lddd: int  # 6
st9_lddp: int  # 5
st9_ldpd: int  # 4
st9_ldpp: int  # 3
st9_ldw: int  # 2
st9_link: int  # 55
st9_linku: int  # 57
st9_mul: int  # 59
st9_nop: int  # 98
st9_null: int  # 0
st9_or: int  # 17
st9_orw: int  # 18
st9_pea: int  # 47
st9_peau: int  # 52
st9_pop: int  # 48
st9_popu: int  # 53
st9_popuw: int  # 54
st9_popw: int  # 49
st9_push: int  # 45
st9_pushu: int  # 50
st9_pushuw: int  # 51
st9_pushw: int  # 46
st9_rcf: int  # 94
st9_ret: int  # 70
st9_rets: int  # 71
st9_rlc: int  # 37
st9_rlcw: int  # 38
st9_rol: int  # 40
st9_ror: int  # 39
st9_rrc: int  # 35
st9_rrcw: int  # 36
st9_sbc: int  # 13
st9_sbcw: int  # 14
st9_scf: int  # 93
st9_sdm: int  # 97
st9_sla: int  # 31
st9_slaw: int  # 32
st9_spm: int  # 96
st9_spp: int  # 89
st9_sra: int  # 33
st9_sraw: int  # 34
st9_srp: int  # 86
st9_srp0: int  # 87
st9_srp1: int  # 88
st9_sub: int  # 11
st9_subw: int  # 12
st9_swap: int  # 43
st9_tcm: int  # 25
st9_tcmw: int  # 26
st9_tm: int  # 23
st9_tmw: int  # 24
st9_unlink: int  # 56
st9_unlinku: int  # 58
st9_wfi: int  # 99
st9_xch: int  # 85
st9_xor: int  # 19
st9_xorw: int  # 20
st_Ready: int  # 0
st_Think: int  # 1
st_Waiting: int  # 2
st_Work: int  # 3
stag: int  # 83
stkpnts_changed: int  # 44
string_types: tuple  # (<class 'str'>,)
struct: module
sys: module  # <module 'sys' (built-in)>
tail_owner_changed: int  # 42
tev_bpt: int  # 4
tev_call: int  # 2
tev_event: int  # 6
tev_insn: int  # 1
tev_max: int  # 7
tev_mem: int  # 5
tev_none: int  # 0
tev_ret: int  # 3
thunk_func_created: int  # 38
ti_changed: int  # 13
traceback: module
tryblks_updated: int  # 46
type_signed: int  # 1
type_unsigned: int  # 2
types: module
typing: module
updating_tryblks: int  # 45
upgraded: int  # 2
view_activated: int  # 0
view_click: int  # 3
view_close: int  # 7
view_created: int  # 6
view_curpos: int  # 5
view_dblclick: int  # 4
view_deactivated: int  # 1
view_keydown: int  # 2
view_loc_changed: int  # 10
view_mouse_moved: int  # 11
view_mouse_over: int  # 9
view_switched: int  # 8
vtag: int  # 86
weakref: module
xScale_mar: int  # 78
xScale_mia: int  # 72
xScale_miabb: int  # 74
xScale_miabt: int  # 75
xScale_miaph: int  # 73
xScale_miatb: int  # 76
xScale_miatt: int  # 77
xScale_mra: int  # 79
xgap: int  # 10
ygap: int  # 30